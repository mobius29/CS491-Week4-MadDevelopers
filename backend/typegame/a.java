package com.apple.eawt;
import java.awt.*;
import java.lang.reflect.*;
import sun.awt.AWTAccessor;
import sun.lwawt.macosx.*;
import sun.lwawt.macosx.CImage.Creator;
class _AppDockIconHandler {
private static native void nativeSetDockMenu(final long cmenu);
private static native void nativeSetDockIconImage(final long image);
private static native void nativeSetDockIconProgress(final int value);
private static native long nativeGetDockIconImage();
private static native void nativeSetDockIconBadge(final String badge);
PopupMenu fDockMenu = null;
_AppDockIconHandler() { }
public void setDockMenu(final PopupMenu menu) {
fDockMenu = menu;
if (menu == null) {
nativeSetDockMenu(0);
return;
}
final MenuContainer container = menu.getParent();
if (container == null) {
final MenuBar newParent = new MenuBar();
newParent.add(menu);
newParent.addNotify();
}
menu.addNotify();
CMenu peer = AWTAccessor.getMenuComponentAccessor().getPeer(fDockMenu);
nativeSetDockMenu(peer.getNativeMenu());
}
public PopupMenu getDockMenu() {
return fDockMenu;
}
public void setDockIconImage(final Image image) {
try {
final CImage cImage = CImage.createFromImage(image);
cImage.execute(_AppDockIconHandler::nativeSetDockIconImage);
} catch (final Throwable e) {
throw new RuntimeException(e);
}
}
Image getDockIconImage() {
try {
final long dockNSImage = nativeGetDockIconImage();
if (dockNSImage == 0) return null;
final Method getCreatorMethod = CImage.class.getDeclaredMethod(
"getCreator", new Class<?>[]{});
getCreatorMethod.setAccessible(true);
Creator imageCreator = (Creator) getCreatorMethod.invoke(null, new Object[]{});
return imageCreator.createImageUsingNativeSize(dockNSImage);
} catch (final Throwable e) {
throw new RuntimeException(e);
}
}
void setDockIconBadge(final String badge) {
nativeSetDockIconBadge(badge);
}
void setDockIconProgress(int value) {
nativeSetDockIconProgress(value);
}
}
package com.apple.eawt;
import java.awt.EventQueue;
import java.awt.Frame;
import java.awt.desktop.AboutEvent;
import java.awt.desktop.AboutHandler;
import java.awt.desktop.AppForegroundEvent;
import java.awt.desktop.AppForegroundListener;
import java.awt.desktop.AppHiddenEvent;
import java.awt.desktop.AppHiddenListener;
import java.awt.desktop.AppReopenedEvent;
import java.awt.desktop.AppReopenedListener;
import java.awt.desktop.OpenFilesEvent;
import java.awt.desktop.OpenFilesHandler;
import java.awt.desktop.OpenURIEvent;
import java.awt.desktop.OpenURIHandler;
import java.awt.desktop.PreferencesEvent;
import java.awt.desktop.PreferencesHandler;
import java.awt.desktop.PrintFilesEvent;
import java.awt.desktop.PrintFilesHandler;
import java.awt.desktop.QuitEvent;
import java.awt.desktop.QuitHandler;
import java.awt.desktop.QuitStrategy;
import java.awt.desktop.ScreenSleepEvent;
import java.awt.desktop.ScreenSleepListener;
import java.awt.desktop.SystemEventListener;
import java.awt.desktop.SystemSleepEvent;
import java.awt.desktop.SystemSleepListener;
import java.awt.desktop.UserSessionEvent;
import java.awt.desktop.UserSessionEvent.Reason;
import java.awt.desktop.UserSessionListener;
import java.awt.event.WindowEvent;
import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.IdentityHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import sun.awt.AppContext;
import sun.awt.SunToolkit;
class _AppEventHandler {
private static final int NOTIFY_ABOUT = 1;
private static final int NOTIFY_PREFS = 2;
private static final int NOTIFY_OPEN_APP = 3;
private static final int NOTIFY_REOPEN_APP = 4;
private static final int NOTIFY_QUIT = 5;
private static final int NOTIFY_SHUTDOWN = 6;
private static final int NOTIFY_ACTIVE_APP_GAINED = 7;
private static final int NOTIFY_ACTIVE_APP_LOST = 8;
private static final int NOTIFY_APP_HIDDEN = 9;
private static final int NOTIFY_APP_SHOWN = 10;
private static final int NOTIFY_USER_SESSION_ACTIVE = 11;
private static final int NOTIFY_USER_SESSION_INACTIVE = 12;
private static final int NOTIFY_SCREEN_SLEEP = 13;
private static final int NOTIFY_SCREEN_WAKE = 14;
private static final int NOTIFY_SYSTEM_SLEEP = 15;
private static final int NOTIFY_SYSTEM_WAKE = 16;
private static final int REGISTER_USER_SESSION = 1;
private static final int REGISTER_SCREEN_SLEEP = 2;
private static final int REGISTER_SYSTEM_SLEEP = 3;
private static native void nativeOpenCocoaAboutWindow();
private static native void nativeReplyToAppShouldTerminate(final boolean shouldTerminate);
private static native void nativeRegisterForNotification(final int notification);
static final _AppEventHandler instance = new _AppEventHandler();
static _AppEventHandler getInstance() {
return instance;
}
final _AboutDispatcher aboutDispatcher = new _AboutDispatcher();
final _PreferencesDispatcher preferencesDispatcher = new _PreferencesDispatcher();
final _OpenFileDispatcher openFilesDispatcher = new _OpenFileDispatcher();
final _PrintFileDispatcher printFilesDispatcher = new _PrintFileDispatcher();
final _OpenURIDispatcher openURIDispatcher = new _OpenURIDispatcher();
final _QuitDispatcher quitDispatcher = new _QuitDispatcher();
final _OpenAppDispatcher openAppDispatcher = new _OpenAppDispatcher();
final _AppReOpenedDispatcher reOpenAppDispatcher = new _AppReOpenedDispatcher();
final _AppForegroundDispatcher foregroundAppDispatcher = new _AppForegroundDispatcher();
final _HiddenAppDispatcher hiddenAppDispatcher = new _HiddenAppDispatcher();
final _UserSessionDispatcher userSessionDispatcher = new _UserSessionDispatcher();
final _ScreenSleepDispatcher screenSleepDispatcher = new _ScreenSleepDispatcher();
final _SystemSleepDispatcher systemSleepDispatcher = new _SystemSleepDispatcher();
QuitStrategy defaultQuitAction = QuitStrategy.NORMAL_EXIT;
_AppEventHandler() {
final String strategyProp = System.getProperty("apple.eawt.quitStrategy");
if (strategyProp == null) return;
if ("CLOSE_ALL_WINDOWS".equals(strategyProp)) {
setDefaultQuitStrategy(QuitStrategy.CLOSE_ALL_WINDOWS);
} else if ("SYSTEM_EXIT_O".equals(strategyProp)
|| "NORMAL_EXIT".equals(strategyProp)) {
setDefaultQuitStrategy(QuitStrategy.NORMAL_EXIT);
} else {
System.err.println("unrecognized apple.eawt.quitStrategy: " + strategyProp);
}
}
void addListener(final SystemEventListener listener) {
if (listener instanceof AppReopenedListener) reOpenAppDispatcher.addListener((AppReopenedListener)listener);
if (listener instanceof AppForegroundListener) foregroundAppDispatcher.addListener((AppForegroundListener)listener);
if (listener instanceof AppHiddenListener) hiddenAppDispatcher.addListener((AppHiddenListener)listener);
if (listener instanceof UserSessionListener) userSessionDispatcher.addListener((UserSessionListener)listener);
if (listener instanceof ScreenSleepListener) screenSleepDispatcher.addListener((ScreenSleepListener)listener);
if (listener instanceof SystemSleepListener) systemSleepDispatcher.addListener((SystemSleepListener)listener);
}
void removeListener(final SystemEventListener listener) {
if (listener instanceof AppReopenedListener) reOpenAppDispatcher.removeListener((AppReopenedListener)listener);
if (listener instanceof AppForegroundListener) foregroundAppDispatcher.removeListener((AppForegroundListener)listener);
if (listener instanceof AppHiddenListener) hiddenAppDispatcher.removeListener((AppHiddenListener)listener);
if (listener instanceof UserSessionListener) userSessionDispatcher.removeListener((UserSessionListener)listener);
if (listener instanceof ScreenSleepListener) screenSleepDispatcher.removeListener((ScreenSleepListener)listener);
if (listener instanceof SystemSleepListener) systemSleepDispatcher.removeListener((SystemSleepListener)listener);
}
void openCocoaAboutWindow() {
nativeOpenCocoaAboutWindow();
}
void setDefaultQuitStrategy(final QuitStrategy defaultQuitAction) {
this.defaultQuitAction = defaultQuitAction;
}
MacQuitResponse currentQuitResponse;
synchronized MacQuitResponse obtainQuitResponse() {
if (currentQuitResponse != null) return currentQuitResponse;
return currentQuitResponse = new MacQuitResponse(this);
}
synchronized void cancelQuit() {
currentQuitResponse = null;
nativeReplyToAppShouldTerminate(false);
}
synchronized void performQuit() {
currentQuitResponse = null;
try {
if (defaultQuitAction == QuitStrategy.NORMAL_EXIT
|| _AppMiscHandlers.isSuddenTerminationEnbaled()) System.exit(0);
if (defaultQuitAction != QuitStrategy.CLOSE_ALL_WINDOWS) {
throw new RuntimeException("Unknown quit action");
}
EventQueue.invokeLater(new Runnable() {
public void run() {
final Frame[] allFrames = Frame.getFrames();
for (int i = allFrames.length - 1; i >= 0; i--) {
final Frame frame = allFrames[i];
frame.dispatchEvent(new WindowEvent(frame, WindowEvent.WINDOW_CLOSING));
}
}
});
} finally {
nativeReplyToAppShouldTerminate(false);
}
}
private static void handlePrintFiles(final List<String> filenames) {
instance.printFilesDispatcher.dispatch(new _NativeEvent(filenames));
}
private static void handleOpenFiles(final List<String> filenames, final String searchTerm) {
instance.openFilesDispatcher.dispatch(new _NativeEvent(filenames, searchTerm));
}
private static void handleOpenURI(final String uri) {
instance.openURIDispatcher.dispatch(new _NativeEvent(uri));
}
private static void handleNativeNotification(final int code) {
switch (code) {
case NOTIFY_ABOUT:
instance.aboutDispatcher.dispatch(new _NativeEvent());
break;
case NOTIFY_PREFS:
instance.preferencesDispatcher.dispatch(new _NativeEvent());
break;
case NOTIFY_OPEN_APP:
instance.openAppDispatcher.dispatch(new _NativeEvent());
break;
case NOTIFY_REOPEN_APP:
instance.reOpenAppDispatcher.dispatch(new _NativeEvent());
break;
case NOTIFY_QUIT:
instance.quitDispatcher.dispatch(new _NativeEvent());
break;
case NOTIFY_SHUTDOWN:
break;
case NOTIFY_ACTIVE_APP_GAINED:
instance.foregroundAppDispatcher.dispatch(new _NativeEvent(Boolean.TRUE));
break;
case NOTIFY_ACTIVE_APP_LOST:
instance.foregroundAppDispatcher.dispatch(new _NativeEvent(Boolean.FALSE));
break;
case NOTIFY_APP_HIDDEN:
instance.hiddenAppDispatcher.dispatch(new _NativeEvent(Boolean.TRUE));
break;
case NOTIFY_APP_SHOWN:
instance.hiddenAppDispatcher.dispatch(new _NativeEvent(Boolean.FALSE));
break;
case NOTIFY_USER_SESSION_ACTIVE:
instance.userSessionDispatcher.dispatch(new _NativeEvent(Boolean.TRUE));
break;
case NOTIFY_USER_SESSION_INACTIVE:
instance.userSessionDispatcher.dispatch(new _NativeEvent(Boolean.FALSE));
break;
case NOTIFY_SCREEN_SLEEP:
instance.screenSleepDispatcher.dispatch(new _NativeEvent(Boolean.TRUE));
break;
case NOTIFY_SCREEN_WAKE:
instance.screenSleepDispatcher.dispatch(new _NativeEvent(Boolean.FALSE));
break;
case NOTIFY_SYSTEM_SLEEP:
instance.systemSleepDispatcher.dispatch(new _NativeEvent(Boolean.TRUE));
break;
case NOTIFY_SYSTEM_WAKE:
instance.systemSleepDispatcher.dispatch(new _NativeEvent(Boolean.FALSE));
break;
default:
System.err.println("EAWT unknown native notification: " + code);
break;
}
}
class _AboutDispatcher extends _AppEventDispatcher<AboutHandler> {
void performDefaultAction(final _NativeEvent event) {
openCocoaAboutWindow();         }
void performUsing(final AboutHandler handler, final _NativeEvent event) {
handler.handleAbout(new AboutEvent());
}
}
static class _PreferencesDispatcher extends _AppEventDispatcher<PreferencesHandler> {
synchronized void setHandler(final PreferencesHandler handler) {
super.setHandler(handler);
_AppMenuBarHandler.getInstance().setPreferencesMenuItemVisible(handler != null);
_AppMenuBarHandler.getInstance().setPreferencesMenuItemEnabled(handler != null);
}
void performUsing(final PreferencesHandler handler, final _NativeEvent event) {
handler.handlePreferences(new PreferencesEvent());
}
}
static class _OpenAppDispatcher extends _QueuingAppEventDispatcher<com.apple.eawt._OpenAppHandler> {
void performUsing(com.apple.eawt._OpenAppHandler handler, _NativeEvent event) {
handler.handleOpenApp();
}
}
static class _AppReOpenedDispatcher extends _AppEventMultiplexor<AppReopenedListener> {
void performOnListener(AppReopenedListener listener, final _NativeEvent event) {
final AppReopenedEvent e = new AppReopenedEvent();
listener.appReopened(e);
}
}
static class _AppForegroundDispatcher extends _BooleanAppEventMultiplexor<AppForegroundListener, AppForegroundEvent> {
AppForegroundEvent createEvent(final boolean isTrue) { return new AppForegroundEvent(); }
void performFalseEventOn(final AppForegroundListener listener, final AppForegroundEvent e) {
listener.appMovedToBackground(e);
}
void performTrueEventOn(final AppForegroundListener listener, final AppForegroundEvent e) {
listener.appRaisedToForeground(e);
}
}
static class _HiddenAppDispatcher extends _BooleanAppEventMultiplexor<AppHiddenListener, AppHiddenEvent> {
AppHiddenEvent createEvent(final boolean isTrue) { return new AppHiddenEvent(); }
void performFalseEventOn(final AppHiddenListener listener, final AppHiddenEvent e) {
listener.appUnhidden(e);
}
void performTrueEventOn(final AppHiddenListener listener, final AppHiddenEvent e) {
listener.appHidden(e);
}
}
static class _UserSessionDispatcher extends _BooleanAppEventMultiplexor<UserSessionListener, UserSessionEvent> {
UserSessionEvent createEvent(final boolean isTrue) {
return new UserSessionEvent(Reason.UNSPECIFIED);
}
void performFalseEventOn(final UserSessionListener listener, final UserSessionEvent e) {
listener.userSessionDeactivated(e);
}
void performTrueEventOn(final UserSessionListener listener, final UserSessionEvent e) {
listener.userSessionActivated(e);
}
void registerNativeListener() {
nativeRegisterForNotification(REGISTER_USER_SESSION);
}
}
static class _ScreenSleepDispatcher extends _BooleanAppEventMultiplexor<ScreenSleepListener, ScreenSleepEvent> {
ScreenSleepEvent createEvent(final boolean isTrue) { return new ScreenSleepEvent(); }
void performFalseEventOn(final ScreenSleepListener listener, final ScreenSleepEvent e) {
listener.screenAwoke(e);
}
void performTrueEventOn(final ScreenSleepListener listener, final ScreenSleepEvent e) {
listener.screenAboutToSleep(e);
}
void registerNativeListener() {
nativeRegisterForNotification(REGISTER_SCREEN_SLEEP);
}
}
static class _SystemSleepDispatcher extends _BooleanAppEventMultiplexor<SystemSleepListener, SystemSleepEvent> {
SystemSleepEvent createEvent(final boolean isTrue) { return new SystemSleepEvent(); }
void performFalseEventOn(final SystemSleepListener listener, final SystemSleepEvent e) {
listener.systemAwoke(e);
}
void performTrueEventOn(final SystemSleepListener listener, final SystemSleepEvent e) {
listener.systemAboutToSleep(e);
}
void registerNativeListener() {
nativeRegisterForNotification(REGISTER_SYSTEM_SLEEP);
}
}
static class _OpenFileDispatcher extends _QueuingAppEventDispatcher<OpenFilesHandler> {
void performUsing(final OpenFilesHandler handler, final _NativeEvent event) {
final List<String> fileNameList = event.get(0);
final ArrayList<File> files = new ArrayList<File>(fileNameList.size());
for (final String fileName : fileNameList) files.add(new File(fileName));
final String searchTerm = event.get(1);
handler.openFiles(new OpenFilesEvent(files, searchTerm));
}
}
static class _PrintFileDispatcher extends _QueuingAppEventDispatcher<PrintFilesHandler> {
void performUsing(final PrintFilesHandler handler, final _NativeEvent event) {
final List<String> fileNameList = event.get(0);
final ArrayList<File> files = new ArrayList<File>(fileNameList.size());
for (final String fileName : fileNameList) files.add(new File(fileName));
handler.printFiles(new PrintFilesEvent(files));
}
}
static class _OpenURIDispatcher extends _QueuingAppEventDispatcher<OpenURIHandler> {
void performUsing(final OpenURIHandler handler, final _NativeEvent event) {
final String urlString = event.get(0);
try {
handler.openURI(new OpenURIEvent(new URI(urlString)));
} catch (final URISyntaxException e) {
throw new RuntimeException(e);
}
}
}
class _QuitDispatcher extends _AppEventDispatcher<QuitHandler> {
void performDefaultAction(final _NativeEvent event) {
obtainQuitResponse().performQuit();
}
void performUsing(final QuitHandler handler, final _NativeEvent event) {
if (_AppMiscHandlers.isSuddenTerminationEnbaled()) {
performDefaultAction(event);
return;
}
final MacQuitResponse response = obtainQuitResponse();             handler.handleQuitRequestWith(new QuitEvent(), response);
}
}
static class _NativeEvent {
Object[] args;
public _NativeEvent(final Object... args) {
this.args = args;
}
@SuppressWarnings("unchecked")
<T> T get(final int i) {
if (args == null) return null;
return (T)args[i];
}
}
abstract static class _AppEventMultiplexor<L> {
private final Map<L, AppContext> listenerToAppContext =
new IdentityHashMap<L, AppContext>();
boolean nativeListenerRegistered;
void dispatch(final _NativeEvent event, final Object... args) {
final ArrayList<Map.Entry<L, AppContext>> localEntries;
synchronized (this) {
if (listenerToAppContext.size() == 0) {
return;
}
localEntries = new ArrayList<Map.Entry<L, AppContext>>(listenerToAppContext.size());
localEntries.addAll(listenerToAppContext.entrySet());
}
for (final Map.Entry<L, AppContext> e : localEntries) {
final L listener = e.getKey();
final AppContext listenerContext = e.getValue();
SunToolkit.invokeLaterOnAppContext(listenerContext, new Runnable() {
public void run() {
performOnListener(listener, event);
}
});
}
}
synchronized void addListener(final L listener) {
setListenerContext(listener, AppContext.getAppContext());
if (!nativeListenerRegistered) {
registerNativeListener();
nativeListenerRegistered = true;
}
}
synchronized void removeListener(final L listener) {
listenerToAppContext.remove(listener);
}
abstract void performOnListener(L listener, final _NativeEvent event);
void registerNativeListener() { }
private void setListenerContext(L listener, AppContext listenerContext) {
if (listenerContext == null) {
throw new RuntimeException(
"Attempting to add a listener from a thread group without AppContext");
}
listenerToAppContext.put(listener, AppContext.getAppContext());
}
}
abstract static class _BooleanAppEventMultiplexor<L, E> extends _AppEventMultiplexor<L> {
@Override
void performOnListener(L listener, final _NativeEvent event) {
final boolean isTrue = Boolean.TRUE.equals(event.get(0));
final E e = createEvent(isTrue);
if (isTrue) {
performTrueEventOn(listener, e);
} else {
performFalseEventOn(listener, e);
}
}
abstract E createEvent(final boolean isTrue);
abstract void performTrueEventOn(final L listener, final E e);
abstract void performFalseEventOn(final L listener, final E e);
}
abstract static class _AppEventDispatcher<H> {
H _handler;
AppContext handlerContext;
void dispatch(final _NativeEvent event) {
final H localHandler;
final AppContext localHandlerContext;
synchronized (_AppEventDispatcher.this) {
localHandler = _handler;
localHandlerContext = handlerContext;
}
if (localHandler == null) {
performDefaultAction(event);
} else {
SunToolkit.invokeLaterOnAppContext(localHandlerContext, new Runnable() {
public void run() {
performUsing(localHandler, event);
}
});
}
}
synchronized void setHandler(final H handler) {
this._handler = handler;
setHandlerContext(AppContext.getAppContext());
}
void performDefaultAction(final _NativeEvent event) { }         abstract void performUsing(final H handler, final _NativeEvent event);
protected void setHandlerContext(AppContext ctx) {
if (ctx == null) {
throw new RuntimeException(
"Attempting to set a handler from a thread group without AppContext");
}
handlerContext = ctx;
}
}
abstract static class _QueuingAppEventDispatcher<H> extends _AppEventDispatcher<H> {
List<_NativeEvent> queuedEvents = new LinkedList<_NativeEvent>();
@Override
void dispatch(final _NativeEvent event) {
synchronized (this) {
if (queuedEvents != null) {
queuedEvents.add(event);
return;
}
}
super.dispatch(event);
}
synchronized void setHandler(final H handler) {
this._handler = handler;
setHandlerContext(AppContext.getAppContext());
if (queuedEvents != null) {
final java.util.List<_NativeEvent> localQueuedEvents = queuedEvents;
queuedEvents = null;
if (localQueuedEvents.size() != 0) {
for (final _NativeEvent arg : localQueuedEvents) {
dispatch(arg);
}
}
}
}
}
}
package com.apple.eawt;
import java.awt.Container;
import java.awt.Frame;
import javax.swing.JFrame;
import javax.swing.JLayeredPane;
import javax.swing.JMenuBar;
import javax.swing.plaf.MenuBarUI;
import com.apple.laf.ScreenMenuBar;
import sun.awt.AWTAccessor;
import sun.lwawt.macosx.CMenuBar;
import com.apple.laf.AquaMenuBarUI;
class _AppMenuBarHandler {
private static final int MENU_ABOUT = 1;
private static final int MENU_PREFS = 2;
private static native void nativeSetMenuState(final int menu, final boolean visible, final boolean enabled);
private static native void nativeSetDefaultMenuBar(final long menuBarPeer);
private static native void nativeActivateDefaultMenuBar(final long menuBarPeer);
static final _AppMenuBarHandler instance = new _AppMenuBarHandler();
static _AppMenuBarHandler getInstance() {
return instance;
}
private static ScreenMenuBar defaultMenuBar;
private static void initMenuStates(final boolean aboutMenuItemVisible,
final boolean aboutMenuItemEnabled,
final boolean prefsMenuItemVisible,
final boolean prefsMenuItemEnabled) {
synchronized (instance) {
instance.aboutMenuItemVisible = aboutMenuItemVisible;
instance.aboutMenuItemEnabled = aboutMenuItemEnabled;
instance.prefsMenuItemVisible = prefsMenuItemVisible;
instance.prefsMenuItemEnabled = prefsMenuItemEnabled;
}
}
_AppMenuBarHandler() { }
boolean aboutMenuItemVisible;
boolean aboutMenuItemEnabled;
boolean prefsMenuItemVisible;
boolean prefsMenuItemEnabled;
boolean prefsMenuItemExplicitlySet;
void setDefaultMenuBar(final JMenuBar menuBar) {
installDefaultMenuBar(menuBar);
}
static boolean isMenuBarActivationNeeded() {
final Frame[] frames = Frame.getFrames();
for (final Frame frame : frames) {
if (frame.isVisible() && !isFrameMinimized(frame)) {
return false;
}
}
return true;
}
static boolean isFrameMinimized(final Frame frame) {
return (frame.getExtendedState() & Frame.ICONIFIED) != 0;
}
static void installDefaultMenuBar(final JMenuBar menuBar) {
if (menuBar == null) {
if (defaultMenuBar != null) {
defaultMenuBar.removeNotify();
defaultMenuBar = null;
}
nativeSetDefaultMenuBar(0);
return;
}
Container parent = menuBar.getParent();
if (parent instanceof JLayeredPane) {
((JLayeredPane) parent).remove(menuBar);
}
MenuBarUI ui = menuBar.getUI();
if (!(ui instanceof AquaMenuBarUI)) {
ui = new AquaMenuBarUI();
menuBar.setUI(ui);
}
final AquaMenuBarUI aquaUI = (AquaMenuBarUI)ui;
final ScreenMenuBar screenMenuBar = aquaUI.getScreenMenuBar();
if (screenMenuBar == null) {
throw new IllegalStateException("Application.setDefaultMenuBar() only works if apple.laf.useScreenMenuBar=true");
}
if (screenMenuBar != defaultMenuBar) {
if (defaultMenuBar != null) {
defaultMenuBar.removeNotify();
}
defaultMenuBar = screenMenuBar;
screenMenuBar.addNotify();
}
final Object peer = AWTAccessor.getMenuComponentAccessor().getPeer(screenMenuBar);
if (!(peer instanceof CMenuBar)) {
throw new IllegalStateException("Unable to determine native menu bar from provided JMenuBar");
}
((CMenuBar) peer).execute(_AppMenuBarHandler::nativeSetDefaultMenuBar);
if (isMenuBarActivationNeeded()) {
((CMenuBar) peer).execute(_AppMenuBarHandler::nativeActivateDefaultMenuBar);
}
}
void setAboutMenuItemVisible(final boolean present) {
synchronized (this) {
if (aboutMenuItemVisible == present) return;
aboutMenuItemVisible = present;
}
nativeSetMenuState(MENU_ABOUT, aboutMenuItemVisible, aboutMenuItemEnabled);
}
void setPreferencesMenuItemVisible(final boolean present) {
synchronized (this) {
prefsMenuItemExplicitlySet = true;
if (prefsMenuItemVisible == present) return;
prefsMenuItemVisible = present;
}
nativeSetMenuState(MENU_PREFS, prefsMenuItemVisible, prefsMenuItemEnabled);
}
void setAboutMenuItemEnabled(final boolean enable) {
synchronized (this) {
if (aboutMenuItemEnabled == enable) return;
aboutMenuItemEnabled = enable;
}
nativeSetMenuState(MENU_ABOUT, aboutMenuItemVisible, aboutMenuItemEnabled);
}
void setPreferencesMenuItemEnabled(final boolean enable) {
synchronized (this) {
prefsMenuItemExplicitlySet = true;
if (prefsMenuItemEnabled == enable) return;
prefsMenuItemEnabled = enable;
}
nativeSetMenuState(MENU_PREFS, prefsMenuItemVisible, prefsMenuItemEnabled);
}
boolean isAboutMenuItemVisible() {
return aboutMenuItemVisible;
}
boolean isPreferencesMenuItemVisible() {
return prefsMenuItemVisible;
}
boolean isAboutMenuItemEnabled() {
return aboutMenuItemEnabled;
}
boolean isPreferencesMenuItemEnabled() {
return prefsMenuItemEnabled;
}
}
package com.apple.eawt;
class _AppMiscHandlers {
private static boolean isSuddenTerminationEnabled;
private static native void nativeOpenHelpViewer();
private static native void nativeRequestActivation(final boolean allWindows);
private static native void nativeRequestUserAttention(final boolean critical);
private static native void nativeEnableSuddenTermination();
private static native void nativeDisableSuddenTermination();
static void openHelpViewer() {
nativeOpenHelpViewer();
}
static void requestActivation(final boolean allWindows) {
nativeRequestActivation(allWindows);
}
static void requestUserAttention(final boolean critical) {
nativeRequestUserAttention(critical);
}
static void enableSuddenTermination() {
isSuddenTerminationEnabled = true;
nativeEnableSuddenTermination();
}
static void disableSuddenTermination() {
isSuddenTerminationEnabled = false;
nativeDisableSuddenTermination();
}
public static boolean isSuddenTerminationEnbaled() {
return isSuddenTerminationEnabled;
}
}
package com.apple.eawt;
interface _OpenAppHandler {
void handleOpenApp();
}
package com.apple.eawt;
import java.awt.*;
import java.lang.reflect.*;
import sun.awt.AWTAccessor;
import sun.lwawt.macosx.*;
import sun.lwawt.macosx.CImage.Creator;
class _AppDockIconHandler {
private static native void nativeSetDockMenu(final long cmenu);
private static native void nativeSetDockIconImage(final long image);
private static native void nativeSetDockIconProgress(final int value);
private static native long nativeGetDockIconImage();
private static native void nativeSetDockIconBadge(final String badge);
PopupMenu fDockMenu = null;
_AppDockIconHandler() { }
public void setDockMenu(final PopupMenu menu) {
fDockMenu = menu;
if (menu == null) {
nativeSetDockMenu(0);
return;
}
final MenuContainer container = menu.getParent();
if (container == null) {
final MenuBar newParent = new MenuBar();
newParent.add(menu);
newParent.addNotify();
}
menu.addNotify();
CMenu peer = AWTAccessor.getMenuComponentAccessor().getPeer(fDockMenu);
nativeSetDockMenu(peer.getNativeMenu());
}
public PopupMenu getDockMenu() {
return fDockMenu;
}
public void setDockIconImage(final Image image) {
try {
final CImage cImage = CImage.createFromImage(image);
cImage.execute(_AppDockIconHandler::nativeSetDockIconImage);
} catch (final Throwable e) {
throw new RuntimeException(e);
}
}
Image getDockIconImage() {
try {
final long dockNSImage = nativeGetDockIconImage();
if (dockNSImage == 0) return null;
final Method getCreatorMethod = CImage.class.getDeclaredMethod(
"getCreator", new Class<?>[]{});
getCreatorMethod.setAccessible(true);
Creator imageCreator = (Creator) getCreatorMethod.invoke(null, new Object[]{});
return imageCreator.createImageUsingNativeSize(dockNSImage);
} catch (final Throwable e) {
throw new RuntimeException(e);
}
}
void setDockIconBadge(final String badge) {
nativeSetDockIconBadge(badge);
}
void setDockIconProgress(int value) {
nativeSetDockIconProgress(value);
}
}
package com.apple.eawt;
import java.awt.EventQueue;
import java.awt.Frame;
import java.awt.desktop.AboutEvent;
import java.awt.desktop.AboutHandler;
import java.awt.desktop.AppForegroundEvent;
import java.awt.desktop.AppForegroundListener;
import java.awt.desktop.AppHiddenEvent;
import java.awt.desktop.AppHiddenListener;
import java.awt.desktop.AppReopenedEvent;
import java.awt.desktop.AppReopenedListener;
import java.awt.desktop.OpenFilesEvent;
import java.awt.desktop.OpenFilesHandler;
import java.awt.desktop.OpenURIEvent;
import java.awt.desktop.OpenURIHandler;
import java.awt.desktop.PreferencesEvent;
import java.awt.desktop.PreferencesHandler;
import java.awt.desktop.PrintFilesEvent;
import java.awt.desktop.PrintFilesHandler;
import java.awt.desktop.QuitEvent;
import java.awt.desktop.QuitHandler;
import java.awt.desktop.QuitStrategy;
import java.awt.desktop.ScreenSleepEvent;
import java.awt.desktop.ScreenSleepListener;
import java.awt.desktop.SystemEventListener;
import java.awt.desktop.SystemSleepEvent;
import java.awt.desktop.SystemSleepListener;
import java.awt.desktop.UserSessionEvent;
import java.awt.desktop.UserSessionEvent.Reason;
import java.awt.desktop.UserSessionListener;
import java.awt.event.WindowEvent;
import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.IdentityHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import sun.awt.AppContext;
import sun.awt.SunToolkit;
class _AppEventHandler {
private static final int NOTIFY_ABOUT = 1;
private static final int NOTIFY_PREFS = 2;
private static final int NOTIFY_OPEN_APP = 3;
private static final int NOTIFY_REOPEN_APP = 4;
private static final int NOTIFY_QUIT = 5;
private static final int NOTIFY_SHUTDOWN = 6;
private static final int NOTIFY_ACTIVE_APP_GAINED = 7;
private static final int NOTIFY_ACTIVE_APP_LOST = 8;
private static final int NOTIFY_APP_HIDDEN = 9;
private static final int NOTIFY_APP_SHOWN = 10;
private static final int NOTIFY_USER_SESSION_ACTIVE = 11;
private static final int NOTIFY_USER_SESSION_INACTIVE = 12;
private static final int NOTIFY_SCREEN_SLEEP = 13;
private static final int NOTIFY_SCREEN_WAKE = 14;
private static final int NOTIFY_SYSTEM_SLEEP = 15;
private static final int NOTIFY_SYSTEM_WAKE = 16;
private static final int REGISTER_USER_SESSION = 1;
private static final int REGISTER_SCREEN_SLEEP = 2;
private static final int REGISTER_SYSTEM_SLEEP = 3;
private static native void nativeOpenCocoaAboutWindow();
private static native void nativeReplyToAppShouldTerminate(final boolean shouldTerminate);
private static native void nativeRegisterForNotification(final int notification);
static final _AppEventHandler instance = new _AppEventHandler();
static _AppEventHandler getInstance() {
return instance;
}
final _AboutDispatcher aboutDispatcher = new _AboutDispatcher();
final _PreferencesDispatcher preferencesDispatcher = new _PreferencesDispatcher();
final _OpenFileDispatcher openFilesDispatcher = new _OpenFileDispatcher();
final _PrintFileDispatcher printFilesDispatcher = new _PrintFileDispatcher();
final _OpenURIDispatcher openURIDispatcher = new _OpenURIDispatcher();
final _QuitDispatcher quitDispatcher = new _QuitDispatcher();
final _OpenAppDispatcher openAppDispatcher = new _OpenAppDispatcher();
final _AppReOpenedDispatcher reOpenAppDispatcher = new _AppReOpenedDispatcher();
final _AppForegroundDispatcher foregroundAppDispatcher = new _AppForegroundDispatcher();
final _HiddenAppDispatcher hiddenAppDispatcher = new _HiddenAppDispatcher();
final _UserSessionDispatcher userSessionDispatcher = new _UserSessionDispatcher();
final _ScreenSleepDispatcher screenSleepDispatcher = new _ScreenSleepDispatcher();
final _SystemSleepDispatcher systemSleepDispatcher = new _SystemSleepDispatcher();
QuitStrategy defaultQuitAction = QuitStrategy.NORMAL_EXIT;
_AppEventHandler() {
final String strategyProp = System.getProperty("apple.eawt.quitStrategy");
if (strategyProp == null) return;
if ("CLOSE_ALL_WINDOWS".equals(strategyProp)) {
setDefaultQuitStrategy(QuitStrategy.CLOSE_ALL_WINDOWS);
} else if ("SYSTEM_EXIT_O".equals(strategyProp)
|| "NORMAL_EXIT".equals(strategyProp)) {
setDefaultQuitStrategy(QuitStrategy.NORMAL_EXIT);
} else {
System.err.println("unrecognized apple.eawt.quitStrategy: " + strategyProp);
}
}
void addListener(final SystemEventListener listener) {
if (listener instanceof AppReopenedListener) reOpenAppDispatcher.addListener((AppReopenedListener)listener);
if (listener instanceof AppForegroundListener) foregroundAppDispatcher.addListener((AppForegroundListener)listener);
if (listener instanceof AppHiddenListener) hiddenAppDispatcher.addListener((AppHiddenListener)listener);
if (listener instanceof UserSessionListener) userSessionDispatcher.addListener((UserSessionListener)listener);
if (listener instanceof ScreenSleepListener) screenSleepDispatcher.addListener((ScreenSleepListener)listener);
if (listener instanceof SystemSleepListener) systemSleepDispatcher.addListener((SystemSleepListener)listener);
}
void removeListener(final SystemEventListener listener) {
if (listener instanceof AppReopenedListener) reOpenAppDispatcher.removeListener((AppReopenedListener)listener);
if (listener instanceof AppForegroundListener) foregroundAppDispatcher.removeListener((AppForegroundListener)listener);
if (listener instanceof AppHiddenListener) hiddenAppDispatcher.removeListener((AppHiddenListener)listener);
if (listener instanceof UserSessionListener) userSessionDispatcher.removeListener((UserSessionListener)listener);
if (listener instanceof ScreenSleepListener) screenSleepDispatcher.removeListener((ScreenSleepListener)listener);
if (listener instanceof SystemSleepListener) systemSleepDispatcher.removeListener((SystemSleepListener)listener);
}
void openCocoaAboutWindow() {
nativeOpenCocoaAboutWindow();
}
void setDefaultQuitStrategy(final QuitStrategy defaultQuitAction) {
this.defaultQuitAction = defaultQuitAction;
}
MacQuitResponse currentQuitResponse;
synchronized MacQuitResponse obtainQuitResponse() {
if (currentQuitResponse != null) return currentQuitResponse;
return currentQuitResponse = new MacQuitResponse(this);
}
synchronized void cancelQuit() {
currentQuitResponse = null;
nativeReplyToAppShouldTerminate(false);
}
synchronized void performQuit() {
currentQuitResponse = null;
try {
if (defaultQuitAction == QuitStrategy.NORMAL_EXIT
|| _AppMiscHandlers.isSuddenTerminationEnbaled()) System.exit(0);
if (defaultQuitAction != QuitStrategy.CLOSE_ALL_WINDOWS) {
throw new RuntimeException("Unknown quit action");
}
EventQueue.invokeLater(new Runnable() {
public void run() {
final Frame[] allFrames = Frame.getFrames();
for (int i = allFrames.length - 1; i >= 0; i--) {
final Frame frame = allFrames[i];
frame.dispatchEvent(new WindowEvent(frame, WindowEvent.WINDOW_CLOSING));
}
}
});
} finally {
nativeReplyToAppShouldTerminate(false);
}
}
private static void handlePrintFiles(final List<String> filenames) {
instance.printFilesDispatcher.dispatch(new _NativeEvent(filenames));
}
private static void handleOpenFiles(final List<String> filenames, final String searchTerm) {
instance.openFilesDispatcher.dispatch(new _NativeEvent(filenames, searchTerm));
}
private static void handleOpenURI(final String uri) {
instance.openURIDispatcher.dispatch(new _NativeEvent(uri));
}
private static void handleNativeNotification(final int code) {
switch (code) {
case NOTIFY_ABOUT:
instance.aboutDispatcher.dispatch(new _NativeEvent());
break;
case NOTIFY_PREFS:
instance.preferencesDispatcher.dispatch(new _NativeEvent());
break;
case NOTIFY_OPEN_APP:
instance.openAppDispatcher.dispatch(new _NativeEvent());
break;
case NOTIFY_REOPEN_APP:
instance.reOpenAppDispatcher.dispatch(new _NativeEvent());
break;
case NOTIFY_QUIT:
instance.quitDispatcher.dispatch(new _NativeEvent());
break;
case NOTIFY_SHUTDOWN:
break;
case NOTIFY_ACTIVE_APP_GAINED:
instance.foregroundAppDispatcher.dispatch(new _NativeEvent(Boolean.TRUE));
break;
case NOTIFY_ACTIVE_APP_LOST:
instance.foregroundAppDispatcher.dispatch(new _NativeEvent(Boolean.FALSE));
break;
case NOTIFY_APP_HIDDEN:
instance.hiddenAppDispatcher.dispatch(new _NativeEvent(Boolean.TRUE));
break;
case NOTIFY_APP_SHOWN:
instance.hiddenAppDispatcher.dispatch(new _NativeEvent(Boolean.FALSE));
break;
case NOTIFY_USER_SESSION_ACTIVE:
instance.userSessionDispatcher.dispatch(new _NativeEvent(Boolean.TRUE));
break;
case NOTIFY_USER_SESSION_INACTIVE:
instance.userSessionDispatcher.dispatch(new _NativeEvent(Boolean.FALSE));
break;
case NOTIFY_SCREEN_SLEEP:
instance.screenSleepDispatcher.dispatch(new _NativeEvent(Boolean.TRUE));
break;
case NOTIFY_SCREEN_WAKE:
instance.screenSleepDispatcher.dispatch(new _NativeEvent(Boolean.FALSE));
break;
case NOTIFY_SYSTEM_SLEEP:
instance.systemSleepDispatcher.dispatch(new _NativeEvent(Boolean.TRUE));
break;
case NOTIFY_SYSTEM_WAKE:
instance.systemSleepDispatcher.dispatch(new _NativeEvent(Boolean.FALSE));
break;
default:
System.err.println("EAWT unknown native notification: " + code);
break;
}
}
class _AboutDispatcher extends _AppEventDispatcher<AboutHandler> {
void performDefaultAction(final _NativeEvent event) {
openCocoaAboutWindow();         }
void performUsing(final AboutHandler handler, final _NativeEvent event) {
handler.handleAbout(new AboutEvent());
}
}
static class _PreferencesDispatcher extends _AppEventDispatcher<PreferencesHandler> {
synchronized void setHandler(final PreferencesHandler handler) {
super.setHandler(handler);
_AppMenuBarHandler.getInstance().setPreferencesMenuItemVisible(handler != null);
_AppMenuBarHandler.getInstance().setPreferencesMenuItemEnabled(handler != null);
}
void performUsing(final PreferencesHandler handler, final _NativeEvent event) {
handler.handlePreferences(new PreferencesEvent());
}
}
static class _OpenAppDispatcher extends _QueuingAppEventDispatcher<com.apple.eawt._OpenAppHandler> {
void performUsing(com.apple.eawt._OpenAppHandler handler, _NativeEvent event) {
handler.handleOpenApp();
}
}
static class _AppReOpenedDispatcher extends _AppEventMultiplexor<AppReopenedListener> {
void performOnListener(AppReopenedListener listener, final _NativeEvent event) {
final AppReopenedEvent e = new AppReopenedEvent();
listener.appReopened(e);
}
}
static class _AppForegroundDispatcher extends _BooleanAppEventMultiplexor<AppForegroundListener, AppForegroundEvent> {
AppForegroundEvent createEvent(final boolean isTrue) { return new AppForegroundEvent(); }
void performFalseEventOn(final AppForegroundListener listener, final AppForegroundEvent e) {
listener.appMovedToBackground(e);
}
void performTrueEventOn(final AppForegroundListener listener, final AppForegroundEvent e) {
listener.appRaisedToForeground(e);
}
}
static class _HiddenAppDispatcher extends _BooleanAppEventMultiplexor<AppHiddenListener, AppHiddenEvent> {
AppHiddenEvent createEvent(final boolean isTrue) { return new AppHiddenEvent(); }
void performFalseEventOn(final AppHiddenListener listener, final AppHiddenEvent e) {
listener.appUnhidden(e);
}
void performTrueEventOn(final AppHiddenListener listener, final AppHiddenEvent e) {
listener.appHidden(e);
}
}
static class _UserSessionDispatcher extends _BooleanAppEventMultiplexor<UserSessionListener, UserSessionEvent> {
UserSessionEvent createEvent(final boolean isTrue) {
return new UserSessionEvent(Reason.UNSPECIFIED);
}
void performFalseEventOn(final UserSessionListener listener, final UserSessionEvent e) {
listener.userSessionDeactivated(e);
}
void performTrueEventOn(final UserSessionListener listener, final UserSessionEvent e) {
listener.userSessionActivated(e);
}
void registerNativeListener() {
nativeRegisterForNotification(REGISTER_USER_SESSION);
}
}
static class _ScreenSleepDispatcher extends _BooleanAppEventMultiplexor<ScreenSleepListener, ScreenSleepEvent> {
ScreenSleepEvent createEvent(final boolean isTrue) { return new ScreenSleepEvent(); }
void performFalseEventOn(final ScreenSleepListener listener, final ScreenSleepEvent e) {
listener.screenAwoke(e);
}
void performTrueEventOn(final ScreenSleepListener listener, final ScreenSleepEvent e) {
listener.screenAboutToSleep(e);
}
void registerNativeListener() {
nativeRegisterForNotification(REGISTER_SCREEN_SLEEP);
}
}
static class _SystemSleepDispatcher extends _BooleanAppEventMultiplexor<SystemSleepListener, SystemSleepEvent> {
SystemSleepEvent createEvent(final boolean isTrue) { return new SystemSleepEvent(); }
void performFalseEventOn(final SystemSleepListener listener, final SystemSleepEvent e) {
listener.systemAwoke(e);
}
void performTrueEventOn(final SystemSleepListener listener, final SystemSleepEvent e) {
listener.systemAboutToSleep(e);
}
void registerNativeListener() {
nativeRegisterForNotification(REGISTER_SYSTEM_SLEEP);
}
}
static class _OpenFileDispatcher extends _QueuingAppEventDispatcher<OpenFilesHandler> {
void performUsing(final OpenFilesHandler handler, final _NativeEvent event) {
final List<String> fileNameList = event.get(0);
final ArrayList<File> files = new ArrayList<File>(fileNameList.size());
for (final String fileName : fileNameList) files.add(new File(fileName));
final String searchTerm = event.get(1);
handler.openFiles(new OpenFilesEvent(files, searchTerm));
}
}
static class _PrintFileDispatcher extends _QueuingAppEventDispatcher<PrintFilesHandler> {
void performUsing(final PrintFilesHandler handler, final _NativeEvent event) {
final List<String> fileNameList = event.get(0);
final ArrayList<File> files = new ArrayList<File>(fileNameList.size());
for (final String fileName : fileNameList) files.add(new File(fileName));
handler.printFiles(new PrintFilesEvent(files));
}
}
static class _OpenURIDispatcher extends _QueuingAppEventDispatcher<OpenURIHandler> {
void performUsing(final OpenURIHandler handler, final _NativeEvent event) {
final String urlString = event.get(0);
try {
handler.openURI(new OpenURIEvent(new URI(urlString)));
} catch (final URISyntaxException e) {
throw new RuntimeException(e);
}
}
}
class _QuitDispatcher extends _AppEventDispatcher<QuitHandler> {
void performDefaultAction(final _NativeEvent event) {
obtainQuitResponse().performQuit();
}
void performUsing(final QuitHandler handler, final _NativeEvent event) {
if (_AppMiscHandlers.isSuddenTerminationEnbaled()) {
performDefaultAction(event);
return;
}
final MacQuitResponse response = obtainQuitResponse();             handler.handleQuitRequestWith(new QuitEvent(), response);
}
}
static class _NativeEvent {
Object[] args;
public _NativeEvent(final Object... args) {
this.args = args;
}
@SuppressWarnings("unchecked")
<T> T get(final int i) {
if (args == null) return null;
return (T)args[i];
}
}
abstract static class _AppEventMultiplexor<L> {
private final Map<L, AppContext> listenerToAppContext =
new IdentityHashMap<L, AppContext>();
boolean nativeListenerRegistered;
void dispatch(final _NativeEvent event, final Object... args) {
final ArrayList<Map.Entry<L, AppContext>> localEntries;
synchronized (this) {
if (listenerToAppContext.size() == 0) {
return;
}
localEntries = new ArrayList<Map.Entry<L, AppContext>>(listenerToAppContext.size());
localEntries.addAll(listenerToAppContext.entrySet());
}
for (final Map.Entry<L, AppContext> e : localEntries) {
final L listener = e.getKey();
final AppContext listenerContext = e.getValue();
SunToolkit.invokeLaterOnAppContext(listenerContext, new Runnable() {
public void run() {
performOnListener(listener, event);
}
});
}
}
synchronized void addListener(final L listener) {
setListenerContext(listener, AppContext.getAppContext());
if (!nativeListenerRegistered) {
registerNativeListener();
nativeListenerRegistered = true;
}
}
synchronized void removeListener(final L listener) {
listenerToAppContext.remove(listener);
}
abstract void performOnListener(L listener, final _NativeEvent event);
void registerNativeListener() { }
private void setListenerContext(L listener, AppContext listenerContext) {
if (listenerContext == null) {
throw new RuntimeException(
"Attempting to add a listener from a thread group without AppContext");
}
listenerToAppContext.put(listener, AppContext.getAppContext());
}
}
abstract static class _BooleanAppEventMultiplexor<L, E> extends _AppEventMultiplexor<L> {
@Override
void performOnListener(L listener, final _NativeEvent event) {
final boolean isTrue = Boolean.TRUE.equals(event.get(0));
final E e = createEvent(isTrue);
if (isTrue) {
performTrueEventOn(listener, e);
} else {
performFalseEventOn(listener, e);
}
}
abstract E createEvent(final boolean isTrue);
abstract void performTrueEventOn(final L listener, final E e);
abstract void performFalseEventOn(final L listener, final E e);
}
abstract static class _AppEventDispatcher<H> {
H _handler;
AppContext handlerContext;
void dispatch(final _NativeEvent event) {
final H localHandler;
final AppContext localHandlerContext;
synchronized (_AppEventDispatcher.this) {
localHandler = _handler;
localHandlerContext = handlerContext;
}
if (localHandler == null) {
performDefaultAction(event);
} else {
SunToolkit.invokeLaterOnAppContext(localHandlerContext, new Runnable() {
public void run() {
performUsing(localHandler, event);
}
});
}
}
synchronized void setHandler(final H handler) {
this._handler = handler;
setHandlerContext(AppContext.getAppContext());
}
void performDefaultAction(final _NativeEvent event) { }         abstract void performUsing(final H handler, final _NativeEvent event);
protected void setHandlerContext(AppContext ctx) {
if (ctx == null) {
throw new RuntimeException(
"Attempting to set a handler from a thread group without AppContext");
}
handlerContext = ctx;
}
}
abstract static class _QueuingAppEventDispatcher<H> extends _AppEventDispatcher<H> {
List<_NativeEvent> queuedEvents = new LinkedList<_NativeEvent>();
@Override
void dispatch(final _NativeEvent event) {
synchronized (this) {
if (queuedEvents != null) {
queuedEvents.add(event);
return;
}
}
super.dispatch(event);
}
synchronized void setHandler(final H handler) {
this._handler = handler;
setHandlerContext(AppContext.getAppContext());
if (queuedEvents != null) {
final java.util.List<_NativeEvent> localQueuedEvents = queuedEvents;
queuedEvents = null;
if (localQueuedEvents.size() != 0) {
for (final _NativeEvent arg : localQueuedEvents) {
dispatch(arg);
}
}
}
}
}
}
package com.apple.eawt;
import java.awt.Container;
import java.awt.Frame;
import javax.swing.JFrame;
import javax.swing.JLayeredPane;
import javax.swing.JMenuBar;
import javax.swing.plaf.MenuBarUI;
import com.apple.laf.ScreenMenuBar;
import sun.awt.AWTAccessor;
import sun.lwawt.macosx.CMenuBar;
import com.apple.laf.AquaMenuBarUI;
class _AppMenuBarHandler {
private static final int MENU_ABOUT = 1;
private static final int MENU_PREFS = 2;
private static native void nativeSetMenuState(final int menu, final boolean visible, final boolean enabled);
private static native void nativeSetDefaultMenuBar(final long menuBarPeer);
private static native void nativeActivateDefaultMenuBar(final long menuBarPeer);
static final _AppMenuBarHandler instance = new _AppMenuBarHandler();
static _AppMenuBarHandler getInstance() {
return instance;
}
private static ScreenMenuBar defaultMenuBar;
private static void initMenuStates(final boolean aboutMenuItemVisible,
final boolean aboutMenuItemEnabled,
final boolean prefsMenuItemVisible,
final boolean prefsMenuItemEnabled) {
synchronized (instance) {
instance.aboutMenuItemVisible = aboutMenuItemVisible;
instance.aboutMenuItemEnabled = aboutMenuItemEnabled;
instance.prefsMenuItemVisible = prefsMenuItemVisible;
instance.prefsMenuItemEnabled = prefsMenuItemEnabled;
}
}
_AppMenuBarHandler() { }
boolean aboutMenuItemVisible;
boolean aboutMenuItemEnabled;
boolean prefsMenuItemVisible;
boolean prefsMenuItemEnabled;
boolean prefsMenuItemExplicitlySet;
void setDefaultMenuBar(final JMenuBar menuBar) {
installDefaultMenuBar(menuBar);
}
static boolean isMenuBarActivationNeeded() {
final Frame[] frames = Frame.getFrames();
for (final Frame frame : frames) {
if (frame.isVisible() && !isFrameMinimized(frame)) {
return false;
}
}
return true;
}
static boolean isFrameMinimized(final Frame frame) {
return (frame.getExtendedState() & Frame.ICONIFIED) != 0;
}
static void installDefaultMenuBar(final JMenuBar menuBar) {
if (menuBar == null) {
if (defaultMenuBar != null) {
defaultMenuBar.removeNotify();
defaultMenuBar = null;
}
nativeSetDefaultMenuBar(0);
return;
}
Container parent = menuBar.getParent();
if (parent instanceof JLayeredPane) {
((JLayeredPane) parent).remove(menuBar);
}
MenuBarUI ui = menuBar.getUI();
if (!(ui instanceof AquaMenuBarUI)) {
ui = new AquaMenuBarUI();
menuBar.setUI(ui);
}
final AquaMenuBarUI aquaUI = (AquaMenuBarUI)ui;
final ScreenMenuBar screenMenuBar = aquaUI.getScreenMenuBar();
if (screenMenuBar == null) {
throw new IllegalStateException("Application.setDefaultMenuBar() only works if apple.laf.useScreenMenuBar=true");
}
if (screenMenuBar != defaultMenuBar) {
if (defaultMenuBar != null) {
defaultMenuBar.removeNotify();
}
defaultMenuBar = screenMenuBar;
screenMenuBar.addNotify();
}
final Object peer = AWTAccessor.getMenuComponentAccessor().getPeer(screenMenuBar);
if (!(peer instanceof CMenuBar)) {
throw new IllegalStateException("Unable to determine native menu bar from provided JMenuBar");
}
((CMenuBar) peer).execute(_AppMenuBarHandler::nativeSetDefaultMenuBar);
if (isMenuBarActivationNeeded()) {
((CMenuBar) peer).execute(_AppMenuBarHandler::nativeActivateDefaultMenuBar);
}
}
void setAboutMenuItemVisible(final boolean present) {
synchronized (this) {
if (aboutMenuItemVisible == present) return;
aboutMenuItemVisible = present;
}
nativeSetMenuState(MENU_ABOUT, aboutMenuItemVisible, aboutMenuItemEnabled);
}
void setPreferencesMenuItemVisible(final boolean present) {
synchronized (this) {
prefsMenuItemExplicitlySet = true;
if (prefsMenuItemVisible == present) return;
prefsMenuItemVisible = present;
}
nativeSetMenuState(MENU_PREFS, prefsMenuItemVisible, prefsMenuItemEnabled);
}
void setAboutMenuItemEnabled(final boolean enable) {
synchronized (this) {
if (aboutMenuItemEnabled == enable) return;
aboutMenuItemEnabled = enable;
}
nativeSetMenuState(MENU_ABOUT, aboutMenuItemVisible, aboutMenuItemEnabled);
}
void setPreferencesMenuItemEnabled(final boolean enable) {
synchronized (this) {
prefsMenuItemExplicitlySet = true;
if (prefsMenuItemEnabled == enable) return;
prefsMenuItemEnabled = enable;
}
nativeSetMenuState(MENU_PREFS, prefsMenuItemVisible, prefsMenuItemEnabled);
}
boolean isAboutMenuItemVisible() {
return aboutMenuItemVisible;
}
boolean isPreferencesMenuItemVisible() {
return prefsMenuItemVisible;
}
boolean isAboutMenuItemEnabled() {
return aboutMenuItemEnabled;
}
boolean isPreferencesMenuItemEnabled() {
return prefsMenuItemEnabled;
}
}
package com.apple.eawt;
class _AppMiscHandlers {
private static boolean isSuddenTerminationEnabled;
private static native void nativeOpenHelpViewer();
private static native void nativeRequestActivation(final boolean allWindows);
private static native void nativeRequestUserAttention(final boolean critical);
private static native void nativeEnableSuddenTermination();
private static native void nativeDisableSuddenTermination();
static void openHelpViewer() {
nativeOpenHelpViewer();
}
static void requestActivation(final boolean allWindows) {
nativeRequestActivation(allWindows);
}
static void requestUserAttention(final boolean critical) {
nativeRequestUserAttention(critical);
}
static void enableSuddenTermination() {
isSuddenTerminationEnabled = true;
nativeEnableSuddenTermination();
}
static void disableSuddenTermination() {
isSuddenTerminationEnabled = false;
nativeDisableSuddenTermination();
}
public static boolean isSuddenTerminationEnbaled() {
return isSuddenTerminationEnabled;
}
}
package com.apple.eawt;
interface _OpenAppHandler {
void handleOpenApp();
}
package com.sun.org.apache.bcel.internal.generic;
public class AALOAD extends ArrayInstruction implements StackProducer {
public AALOAD() {
super(com.sun.org.apache.bcel.internal.Const.AALOAD);
}
@Override
public void accept( final Visitor v ) {
v.visitStackProducer(this);
v.visitExceptionThrower(this);
v.visitTypedInstruction(this);
v.visitArrayInstruction(this);
v.visitAALOAD(this);
}
}
package jdk.vm.ci.aarch64;
import java.nio.ByteOrder;
import java.util.EnumSet;
import jdk.vm.ci.code.Architecture;
import jdk.vm.ci.code.CPUFeatureName;
import jdk.vm.ci.code.Register;
import jdk.vm.ci.code.Register.RegisterCategory;
import jdk.vm.ci.code.RegisterArray;
import jdk.vm.ci.meta.JavaKind;
import jdk.vm.ci.meta.PlatformKind;
public class AArch64 extends Architecture {
public static final RegisterCategory CPU = new RegisterCategory("CPU");
public static final Register r0 = new Register(0, 0, "r0", CPU);
public static final Register r1 = new Register(1, 1, "r1", CPU);
public static final Register r2 = new Register(2, 2, "r2", CPU);
public static final Register r3 = new Register(3, 3, "r3", CPU);
public static final Register r4 = new Register(4, 4, "r4", CPU);
public static final Register r5 = new Register(5, 5, "r5", CPU);
public static final Register r6 = new Register(6, 6, "r6", CPU);
public static final Register r7 = new Register(7, 7, "r7", CPU);
public static final Register r8 = new Register(8, 8, "r8", CPU);
public static final Register r9 = new Register(9, 9, "r9", CPU);
public static final Register r10 = new Register(10, 10, "r10", CPU);
public static final Register r11 = new Register(11, 11, "r11", CPU);
public static final Register r12 = new Register(12, 12, "r12", CPU);
public static final Register r13 = new Register(13, 13, "r13", CPU);
public static final Register r14 = new Register(14, 14, "r14", CPU);
public static final Register r15 = new Register(15, 15, "r15", CPU);
public static final Register r16 = new Register(16, 16, "r16", CPU);
public static final Register r17 = new Register(17, 17, "r17", CPU);
public static final Register r18 = new Register(18, 18, "r18", CPU);
public static final Register r19 = new Register(19, 19, "r19", CPU);
public static final Register r20 = new Register(20, 20, "r20", CPU);
public static final Register r21 = new Register(21, 21, "r21", CPU);
public static final Register r22 = new Register(22, 22, "r22", CPU);
public static final Register r23 = new Register(23, 23, "r23", CPU);
public static final Register r24 = new Register(24, 24, "r24", CPU);
public static final Register r25 = new Register(25, 25, "r25", CPU);
public static final Register r26 = new Register(26, 26, "r26", CPU);
public static final Register r27 = new Register(27, 27, "r27", CPU);
public static final Register r28 = new Register(28, 28, "r28", CPU);
public static final Register r29 = new Register(29, 29, "r29", CPU);
public static final Register r30 = new Register(30, 30, "r30", CPU);
public static final Register r31 = new Register(31, 31, "r31", CPU);
public static final Register zr = new Register(32, 31, "zr", CPU);
public static final Register sp = new Register(33, 31, "sp", CPU);
public static final Register lr = r30;
public static final Register rscratch1 = r8;
public static final Register rscratch2 = r9;
public static final RegisterArray cpuRegisters = new RegisterArray(
r0,  r1,  r2,  r3,  r4,  r5,  r6,  r7,
r8,  r9,  r10, r11, r12, r13, r14, r15,
r16, r17, r18, r19, r20, r21, r22, r23,
r24, r25, r26, r27, r28, r29, r30, r31,
zr,  sp
);
public static final RegisterCategory SIMD = new RegisterCategory("SIMD");
public static final Register v0 = new Register(34, 0, "v0", SIMD);
public static final Register v1 = new Register(35, 1, "v1", SIMD);
public static final Register v2 = new Register(36, 2, "v2", SIMD);
public static final Register v3 = new Register(37, 3, "v3", SIMD);
public static final Register v4 = new Register(38, 4, "v4", SIMD);
public static final Register v5 = new Register(39, 5, "v5", SIMD);
public static final Register v6 = new Register(40, 6, "v6", SIMD);
public static final Register v7 = new Register(41, 7, "v7", SIMD);
public static final Register v8 = new Register(42, 8, "v8", SIMD);
public static final Register v9 = new Register(43, 9, "v9", SIMD);
public static final Register v10 = new Register(44, 10, "v10", SIMD);
public static final Register v11 = new Register(45, 11, "v11", SIMD);
public static final Register v12 = new Register(46, 12, "v12", SIMD);
public static final Register v13 = new Register(47, 13, "v13", SIMD);
public static final Register v14 = new Register(48, 14, "v14", SIMD);
public static final Register v15 = new Register(49, 15, "v15", SIMD);
public static final Register v16 = new Register(50, 16, "v16", SIMD);
public static final Register v17 = new Register(51, 17, "v17", SIMD);
public static final Register v18 = new Register(52, 18, "v18", SIMD);
public static final Register v19 = new Register(53, 19, "v19", SIMD);
public static final Register v20 = new Register(54, 20, "v20", SIMD);
public static final Register v21 = new Register(55, 21, "v21", SIMD);
public static final Register v22 = new Register(56, 22, "v22", SIMD);
public static final Register v23 = new Register(57, 23, "v23", SIMD);
public static final Register v24 = new Register(58, 24, "v24", SIMD);
public static final Register v25 = new Register(59, 25, "v25", SIMD);
public static final Register v26 = new Register(60, 26, "v26", SIMD);
public static final Register v27 = new Register(61, 27, "v27", SIMD);
public static final Register v28 = new Register(62, 28, "v28", SIMD);
public static final Register v29 = new Register(63, 29, "v29", SIMD);
public static final Register v30 = new Register(64, 30, "v30", SIMD);
public static final Register v31 = new Register(65, 31, "v31", SIMD);
public static final RegisterArray simdRegisters = new RegisterArray(
v0,  v1,  v2,  v3,  v4,  v5,  v6,  v7,
v8,  v9,  v10, v11, v12, v13, v14, v15,
v16, v17, v18, v19, v20, v21, v22, v23,
v24, v25, v26, v27, v28, v29, v30, v31
);
public static final RegisterArray allRegisters = new RegisterArray(
r0,  r1,  r2,  r3,  r4,  r5,  r6,  r7,
r8,  r9,  r10, r11, r12, r13, r14, r15,
r16, r17, r18, r19, r20, r21, r22, r23,
r24, r25, r26, r27, r28, r29, r30, r31,
zr,  sp,
v0,  v1,  v2,  v3,  v4,  v5,  v6,  v7,
v8,  v9,  v10, v11, v12, v13, v14, v15,
v16, v17, v18, v19, v20, v21, v22, v23,
v24, v25, v26, v27, v28, v29, v30, v31
);
public enum CPUFeature implements CPUFeatureName {
FP,
ASIMD,
EVTSTRM,
AES,
PMULL,
SHA1,
SHA2,
CRC32,
LSE,
DCPOP,
SHA3,
SHA512,
SVE,
PACA,
SVEBITPERM,
SVE2,
STXR_PREFETCH,
A53MAC,
}
private final EnumSet<CPUFeature> features;
public enum Flag {
UseCRC32,
UseNeon,
UseSIMDForMemoryOps,
AvoidUnalignedAccesses,
UseLSE,
UseBlockZeroing
}
private final EnumSet<Flag> flags;
public AArch64(EnumSet<CPUFeature> features, EnumSet<Flag> flags) {
super("aarch64", AArch64Kind.QWORD, ByteOrder.LITTLE_ENDIAN, true, allRegisters, 0, 0, 0);
this.features = features;
this.flags = flags;
}
@Override
public EnumSet<CPUFeature> getFeatures() {
return features;
}
public EnumSet<Flag> getFlags() {
return flags;
}
@Override
public PlatformKind getPlatformKind(JavaKind javaKind) {
switch (javaKind) {
case Boolean:
case Byte:
return AArch64Kind.BYTE;
case Short:
case Char:
return AArch64Kind.WORD;
case Int:
return AArch64Kind.DWORD;
case Long:
case Object:
return AArch64Kind.QWORD;
case Float:
return AArch64Kind.SINGLE;
case Double:
return AArch64Kind.DOUBLE;
default:
return null;
}
}
@Override
public boolean canStoreValue(RegisterCategory category, PlatformKind platformKind) {
AArch64Kind kind = (AArch64Kind) platformKind;
if (kind.isInteger()) {
return category.equals(CPU);
} else if (kind.isSIMD()) {
return category.equals(SIMD);
}
return false;
}
@Override
public AArch64Kind getLargestStorableKind(RegisterCategory category) {
if (category.equals(CPU)) {
return AArch64Kind.QWORD;
} else if (category.equals(SIMD)) {
return AArch64Kind.V128_QWORD;
} else {
return null;
}
}
}
package jdk.internal.foreign.abi.aarch64;
import jdk.internal.foreign.abi.ABIDescriptor;
import jdk.internal.foreign.abi.Architecture;
import jdk.internal.foreign.abi.VMStorage;
public class AArch64Architecture implements Architecture {
public static final Architecture INSTANCE = new AArch64Architecture();
private static final int INTEGER_REG_SIZE = 8;
private static final int VECTOR_REG_SIZE = 16;
private static final int STACK_SLOT_SIZE = 8;
@Override
public boolean isStackType(int cls) {
return cls == StorageClasses.STACK;
}
@Override
public int typeSize(int cls) {
switch (cls) {
case StorageClasses.INTEGER: return INTEGER_REG_SIZE;
case StorageClasses.VECTOR: return VECTOR_REG_SIZE;
case StorageClasses.STACK: return STACK_SLOT_SIZE;
}
throw new IllegalArgumentException("Invalid Storage Class: " + cls);
}
@Override
public int stackType() {
return StorageClasses.STACK;
}
public interface StorageClasses {
int INTEGER = 0;
int VECTOR = 1;
int STACK = 3;
}
public static final VMStorage r0  = integerRegister(0);
public static final VMStorage r1  = integerRegister(1);
public static final VMStorage r2  = integerRegister(2);
public static final VMStorage r3  = integerRegister(3);
public static final VMStorage r4  = integerRegister(4);
public static final VMStorage r5  = integerRegister(5);
public static final VMStorage r6  = integerRegister(6);
public static final VMStorage r7  = integerRegister(7);
public static final VMStorage r8  = integerRegister(8);
public static final VMStorage r9  = integerRegister(9);
public static final VMStorage r10 = integerRegister(10);
public static final VMStorage r11 = integerRegister(11);
public static final VMStorage r12 = integerRegister(12);
public static final VMStorage r13 = integerRegister(13);
public static final VMStorage r14 = integerRegister(14);
public static final VMStorage r15 = integerRegister(15);
public static final VMStorage r16 = integerRegister(16);
public static final VMStorage r17 = integerRegister(17);
public static final VMStorage r18 = integerRegister(18);
public static final VMStorage r19 = integerRegister(19);
public static final VMStorage r20 = integerRegister(20);
public static final VMStorage r21 = integerRegister(21);
public static final VMStorage r22 = integerRegister(22);
public static final VMStorage r23 = integerRegister(23);
public static final VMStorage r24 = integerRegister(24);
public static final VMStorage r25 = integerRegister(25);
public static final VMStorage r26 = integerRegister(26);
public static final VMStorage r27 = integerRegister(27);
public static final VMStorage r28 = integerRegister(28);
public static final VMStorage r29 = integerRegister(29);
public static final VMStorage r30 = integerRegister(30);
public static final VMStorage r31 = integerRegister(31);
public static final VMStorage v0  = vectorRegister(0);
public static final VMStorage v1  = vectorRegister(1);
public static final VMStorage v2  = vectorRegister(2);
public static final VMStorage v3  = vectorRegister(3);
public static final VMStorage v4  = vectorRegister(4);
public static final VMStorage v5  = vectorRegister(5);
public static final VMStorage v6  = vectorRegister(6);
public static final VMStorage v7  = vectorRegister(7);
public static final VMStorage v8  = vectorRegister(8);
public static final VMStorage v9  = vectorRegister(9);
public static final VMStorage v10 = vectorRegister(10);
public static final VMStorage v11 = vectorRegister(11);
public static final VMStorage v12 = vectorRegister(12);
public static final VMStorage v13 = vectorRegister(13);
public static final VMStorage v14 = vectorRegister(14);
public static final VMStorage v15 = vectorRegister(15);
public static final VMStorage v16 = vectorRegister(16);
public static final VMStorage v17 = vectorRegister(17);
public static final VMStorage v18 = vectorRegister(18);
public static final VMStorage v19 = vectorRegister(19);
public static final VMStorage v20 = vectorRegister(20);
public static final VMStorage v21 = vectorRegister(21);
public static final VMStorage v22 = vectorRegister(22);
public static final VMStorage v23 = vectorRegister(23);
public static final VMStorage v24 = vectorRegister(24);
public static final VMStorage v25 = vectorRegister(25);
public static final VMStorage v26 = vectorRegister(26);
public static final VMStorage v27 = vectorRegister(27);
public static final VMStorage v28 = vectorRegister(28);
public static final VMStorage v29 = vectorRegister(29);
public static final VMStorage v30 = vectorRegister(30);
public static final VMStorage v31 = vectorRegister(31);
private static VMStorage integerRegister(int index) {
return new VMStorage(StorageClasses.INTEGER, index, "r" + index);
}
private static VMStorage vectorRegister(int index) {
return new VMStorage(StorageClasses.VECTOR, index, "v" + index);
}
public static VMStorage stackStorage(int index) {
return new VMStorage(StorageClasses.STACK, index, "Stack@" + index);
}
public static ABIDescriptor abiFor(VMStorage[] inputIntRegs,
VMStorage[] inputVectorRegs,
VMStorage[] outputIntRegs,
VMStorage[] outputVectorRegs,
VMStorage[] volatileIntRegs,
VMStorage[] volatileVectorRegs,
int stackAlignment,
int shadowSpace,
VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {
return new ABIDescriptor(
INSTANCE,
new VMStorage[][] {
inputIntRegs,
inputVectorRegs,
},
new VMStorage[][] {
outputIntRegs,
outputVectorRegs,
},
new VMStorage[][] {
volatileIntRegs,
volatileVectorRegs,
},
stackAlignment,
shadowSpace,
targetAddrStorage, retBufAddrStorage);
}
}
package sun.jvm.hotspot.runtime.aarch64;
import sun.jvm.hotspot.debugger.*;
import sun.jvm.hotspot.debugger.aarch64.*;
import sun.jvm.hotspot.code.*;
import sun.jvm.hotspot.interpreter.*;
import sun.jvm.hotspot.runtime.*;
import sun.jvm.hotspot.runtime.aarch64.*;
public class AARCH64CurrentFrameGuess {
private AARCH64ThreadContext context;
private JavaThread       thread;
private Address          spFound;
private Address          fpFound;
private Address          pcFound;
private static final boolean DEBUG = System.getProperty("sun.jvm.hotspot.runtime.aarch64.AARCH64Frame.DEBUG")
!= null;
public AARCH64CurrentFrameGuess(AARCH64ThreadContext context,
JavaThread thread) {
this.context = context;
this.thread  = thread;
}
public boolean run(long regionInBytesToSearch) {
Address sp  = context.getRegisterAsAddress(AARCH64ThreadContext.SP);
Address pc  = context.getRegisterAsAddress(AARCH64ThreadContext.PC);
Address fp  = context.getRegisterAsAddress(AARCH64ThreadContext.FP);
if (sp == null) {
if (thread.getLastJavaSP() != null) {
setValues(thread.getLastJavaSP(), thread.getLastJavaFP(), null);
return true;
}
return false;
}
Address end = sp.addOffsetTo(regionInBytesToSearch);
VM vm       = VM.getVM();
setValues(null, null, null);
if (vm.isJavaPCDbg(pc)) {
if (vm.isClientCompiler()) {
setValues(sp, fp, pc);
return true;
} else {
if (vm.getInterpreter().contains(pc)) {
if (DEBUG) {
System.out.println("CurrentFrameGuess: choosing interpreter frame: sp = " +
sp + ", fp = " + fp + ", pc = " + pc);
}
setValues(sp, fp, pc);
return true;
}
for (long offset = 0;
offset < regionInBytesToSearch;
offset += vm.getAddressSize()) {
try {
Address curSP = sp.addOffsetTo(offset);
Frame frame = new AARCH64Frame(curSP, null, pc);
RegisterMap map = thread.newRegisterMap(false);
while (frame != null) {
if (frame.isEntryFrame() && frame.entryFrameIsFirst()) {
if (DEBUG) {
System.out.println("CurrentFrameGuess: Choosing sp = " + curSP + ", pc = " + pc);
}
setValues(curSP, null, pc);
return true;
}
Frame oldFrame = frame;
frame = frame.sender(map);
if (frame.getSP().lessThanOrEqual(oldFrame.getSP())) {
if (DEBUG) {
System.out.println("CurrentFrameGuess: frame <= oldFrame: " + frame);
}
break;
}
}
} catch (Exception e) {
if (DEBUG) {
System.out.println("CurrentFrameGuess: Exception " + e + " at offset " + offset);
}
}
}
return false;
}
} else {
if (DEBUG) {
System.out.println("CurrentFrameGuess: choosing last Java frame: sp = " +
thread.getLastJavaSP() + ", fp = " + thread.getLastJavaFP());
}
if (thread.getLastJavaSP() == null) {
return false;       }
pc = thread.getLastJavaPC();
fp = thread.getLastJavaFP();
sp = thread.getLastJavaSP();
if (fp == null) {
CodeCache cc = vm.getCodeCache();
if (cc.contains(pc)) {
CodeBlob cb = cc.findBlob(pc);
if (DEBUG) {
System.out.println("FP is null.  Found blob frame size " + cb.getFrameSize());
}
long link_offset = cb.getFrameSize() - 2 * VM.getVM().getAddressSize();
if (link_offset >= 0) {
fp = sp.addOffsetTo(link_offset);
}
}
}
if (vm.isJavaPCDbg(pc)) {
setValues(sp, fp, pc);
} else {
setValues(sp, fp, null);
}
return true;
}
}
public Address getSP() { return spFound; }
public Address getFP() { return fpFound; }
public Address getPC() { return pcFound; }
private void setValues(Address sp, Address fp, Address pc) {
spFound = sp;
fpFound = fp;
pcFound = pc;
}
}
package sun.jvm.hotspot.runtime.aarch64;
import java.util.*;
import sun.jvm.hotspot.code.*;
import sun.jvm.hotspot.compiler.*;
import sun.jvm.hotspot.debugger.*;
import sun.jvm.hotspot.oops.*;
import sun.jvm.hotspot.runtime.*;
import sun.jvm.hotspot.types.*;
import sun.jvm.hotspot.utilities.*;
import sun.jvm.hotspot.utilities.Observable;
import sun.jvm.hotspot.utilities.Observer;
public class AARCH64Frame extends Frame {
private static final boolean DEBUG;
static {
DEBUG = System.getProperty("sun.jvm.hotspot.runtime.aarch64.AARCH64Frame.DEBUG") != null;
}
private static final int LINK_OFFSET                =  0;
private static final int RETURN_ADDR_OFFSET         =  1;
private static final int SENDER_SP_OFFSET           =  2;
private static final int INTERPRETER_FRAME_SENDER_SP_OFFSET = -1;
private static final int INTERPRETER_FRAME_LAST_SP_OFFSET   = INTERPRETER_FRAME_SENDER_SP_OFFSET - 1;
private static final int INTERPRETER_FRAME_METHOD_OFFSET    = INTERPRETER_FRAME_LAST_SP_OFFSET - 1;
private static       int INTERPRETER_FRAME_MDX_OFFSET;           private static       int INTERPRETER_FRAME_PADDING_OFFSET;
private static       int INTERPRETER_FRAME_MIRROR_OFFSET;
private static       int INTERPRETER_FRAME_CACHE_OFFSET;
private static       int INTERPRETER_FRAME_LOCALS_OFFSET;
private static       int INTERPRETER_FRAME_BCX_OFFSET;
private static       int INTERPRETER_FRAME_INITIAL_SP_OFFSET;
private static       int INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET;
private static       int INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET;
private static       int ENTRY_FRAME_CALL_WRAPPER_OFFSET = -8;
private static final int NATIVE_FRAME_INITIAL_PARAM_OFFSET =  2;
private static CIntegerField ropProtectionField;
private static CIntegerField pacMaskField;
private static VMReg fp = new VMReg(29 << 1);
static {
VM.registerVMInitializedObserver(new Observer() {
public void update(Observable o, Object data) {
initialize(VM.getVM().getTypeDataBase());
}
});
}
private static synchronized void initialize(TypeDataBase db) {
INTERPRETER_FRAME_MDX_OFFSET                  = INTERPRETER_FRAME_METHOD_OFFSET - 1;
INTERPRETER_FRAME_PADDING_OFFSET              = INTERPRETER_FRAME_MDX_OFFSET - 1;
INTERPRETER_FRAME_MIRROR_OFFSET               = INTERPRETER_FRAME_PADDING_OFFSET - 1;
INTERPRETER_FRAME_CACHE_OFFSET                = INTERPRETER_FRAME_MIRROR_OFFSET - 1;
INTERPRETER_FRAME_LOCALS_OFFSET               = INTERPRETER_FRAME_CACHE_OFFSET - 1;
INTERPRETER_FRAME_BCX_OFFSET                  = INTERPRETER_FRAME_LOCALS_OFFSET - 1;
INTERPRETER_FRAME_INITIAL_SP_OFFSET           = INTERPRETER_FRAME_BCX_OFFSET - 1;
INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET    = INTERPRETER_FRAME_INITIAL_SP_OFFSET;
INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET = INTERPRETER_FRAME_INITIAL_SP_OFFSET;
Type vmVersion = db.lookupType("VM_Version");
ropProtectionField = vmVersion.getCIntegerField("_rop_protection");
pacMaskField = vmVersion.getCIntegerField("_pac_mask");
}
Address raw_fp;   private Address raw_unextendedSP;
private AARCH64Frame() {
}
private void adjustForDeopt() {
if ( pc != null) {
CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);
if (cb != null && cb.isJavaMethod()) {
NMethod nm = (NMethod) cb;
if (pc.equals(nm.deoptHandlerBegin())) {
if (Assert.ASSERTS_ENABLED) {
Assert.that(this.getUnextendedSP() != null, "null SP in Java frame");
}
pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());
deoptimized = true;
}
}
}
}
public AARCH64Frame(Address raw_sp, Address raw_fp, Address pc) {
this.raw_sp = raw_sp;
this.raw_unextendedSP = raw_sp;
this.raw_fp = raw_fp;
this.pc = pc;
adjustUnextendedSP();
adjustForDeopt();
if (DEBUG) {
System.out.println("AARCH64Frame(sp, fp, pc): " + this);
dumpStack();
}
}
public AARCH64Frame(Address raw_sp, Address raw_fp) {
this.raw_sp = raw_sp;
this.raw_unextendedSP = raw_sp;
this.raw_fp = raw_fp;
Address savedPC = raw_sp.getAddressAt(-1 * VM.getVM().getAddressSize());
if (VM.getVM().isJavaPCDbg(savedPC)) {
this.pc = savedPC;
}
adjustUnextendedSP();
adjustForDeopt();
if (DEBUG) {
System.out.println("AARCH64Frame(sp, fp): " + this);
dumpStack();
}
}
public AARCH64Frame(Address raw_sp, Address raw_unextendedSp, Address raw_fp, Address pc) {
this.raw_sp = raw_sp;
this.raw_unextendedSP = raw_unextendedSp;
this.raw_fp = raw_fp;
this.pc = pc;
adjustUnextendedSP();
adjustForDeopt();
if (DEBUG) {
System.out.println("AARCH64Frame(sp, unextendedSP, fp, pc): " + this);
dumpStack();
}
}
public Object clone() {
AARCH64Frame frame = new AARCH64Frame();
frame.raw_sp = raw_sp;
frame.raw_unextendedSP = raw_unextendedSP;
frame.raw_fp = raw_fp;
frame.pc = pc;
frame.deoptimized = deoptimized;
return frame;
}
public boolean equals(Object arg) {
if (arg == null) {
return false;
}
if (!(arg instanceof AARCH64Frame)) {
return false;
}
AARCH64Frame other = (AARCH64Frame) arg;
return (AddressOps.equal(getSP(), other.getSP()) &&
AddressOps.equal(getUnextendedSP(), other.getUnextendedSP()) &&
AddressOps.equal(getFP(), other.getFP()) &&
AddressOps.equal(getPC(), other.getPC()));
}
public int hashCode() {
if (raw_sp == null) {
return 0;
}
return raw_sp.hashCode();
}
public String toString() {
return "sp: " + (getSP() == null? "null" : getSP().toString()) +
", unextendedSP: " + (getUnextendedSP() == null? "null" : getUnextendedSP().toString()) +
", fp: " + (getFP() == null? "null" : getFP().toString()) +
", pc: " + (pc == null? "null" : pc.toString());
}
public Address getFP() { return raw_fp; }
public Address getSP() { return raw_sp; }
public Address getID() { return raw_sp; }
public boolean isSignalHandlerFrameDbg() { return false; }
public int     getSignalNumberDbg()      { return 0;     }
public String  getSignalNameDbg()        { return null;  }
public boolean isInterpretedFrameValid() {
if (Assert.ASSERTS_ENABLED) {
Assert.that(isInterpretedFrame(), "Not an interpreted frame");
}
if (getFP() == null || getFP().andWithMask(0x3) != null) {
return false;
}
if (getSP() == null || getSP().andWithMask(0x3) != null) {
return false;
}
if (getFP().addOffsetTo(INTERPRETER_FRAME_INITIAL_SP_OFFSET * VM.getVM().getAddressSize()).lessThan(getSP())) {
return false;
}
if (getFP().lessThanOrEqual(getSP())) {
return false;
}
if (getFP().minus(getSP()) > 4096 * VM.getVM().getAddressSize()) {
return false;
}
return true;
}
public Frame sender(RegisterMap regMap, CodeBlob cb) {
AARCH64RegisterMap map = (AARCH64RegisterMap) regMap;
if (Assert.ASSERTS_ENABLED) {
Assert.that(map != null, "map must be set");
}
map.setIncludeArgumentOops(false);
if (isEntryFrame())       return senderForEntryFrame(map);
if (isInterpretedFrame()) return senderForInterpreterFrame(map);
if(cb == null) {
cb = VM.getVM().getCodeCache().findBlob(getPC());
} else {
if (Assert.ASSERTS_ENABLED) {
Assert.that(cb.equals(VM.getVM().getCodeCache().findBlob(getPC())), "Must be the same");
}
}
if (cb != null) {
return senderForCompiledFrame(map, cb);
}
return new AARCH64Frame(getSenderSP(), getLink(), getSenderPC());
}
private Frame senderForEntryFrame(AARCH64RegisterMap map) {
if (DEBUG) {
System.out.println("senderForEntryFrame");
}
if (Assert.ASSERTS_ENABLED) {
Assert.that(map != null, "map must be set");
}
AARCH64JavaCallWrapper jcw = (AARCH64JavaCallWrapper) getEntryFrameCallWrapper();
if (Assert.ASSERTS_ENABLED) {
Assert.that(!entryFrameIsFirst(), "next Java fp must be non zero");
Assert.that(jcw.getLastJavaSP().greaterThan(getSP()), "must be above this frame on stack");
}
AARCH64Frame fr;
if (jcw.getLastJavaPC() != null) {
fr = new AARCH64Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP(), jcw.getLastJavaPC());
} else {
fr = new AARCH64Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP());
}
map.clear();
if (Assert.ASSERTS_ENABLED) {
Assert.that(map.getIncludeArgumentOops(), "should be set by clear");
}
return fr;
}
private void adjustUnextendedSP() {
CodeBlob cb = cb();
NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();
if (senderNm != null) {
if (senderNm.isDeoptMhEntry(getPC())) {
raw_unextendedSP = getFP();
}
else if (senderNm.isDeoptEntry(getPC())) {
}
else if (senderNm.isMethodHandleReturn(getPC())) {
raw_unextendedSP = getFP();
}
}
}
private Frame senderForInterpreterFrame(AARCH64RegisterMap map) {
if (DEBUG) {
System.out.println("senderForInterpreterFrame");
}
Address unextendedSP = addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);
Address sp = addressOfStackSlot(SENDER_SP_OFFSET);
if (map.getUpdateMap())
updateMapWithSavedLink(map, addressOfStackSlot(LINK_OFFSET));
return new AARCH64Frame(sp, unextendedSP, getLink(), getSenderPC());
}
private void updateMapWithSavedLink(RegisterMap map, Address savedFPAddr) {
map.setLocation(fp, savedFPAddr);
}
private Frame senderForCompiledFrame(AARCH64RegisterMap map, CodeBlob cb) {
if (DEBUG) {
System.out.println("senderForCompiledFrame");
}
if (Assert.ASSERTS_ENABLED) {
Assert.that(map != null, "map must be set");
}
if (Assert.ASSERTS_ENABLED) {
Assert.that(cb.getFrameSize() >= 0, "must have non-zero frame size");
}
Address senderSP = getUnextendedSP().addOffsetTo(cb.getFrameSize());
Address senderPC = stripPAC(senderSP.getAddressAt(-1 * VM.getVM().getAddressSize()));
Address savedFPAddr = senderSP.addOffsetTo(- SENDER_SP_OFFSET * VM.getVM().getAddressSize());
if (map.getUpdateMap()) {
map.setIncludeArgumentOops(cb.callerMustGCArguments());
if (cb.getOopMaps() != null) {
ImmutableOopMapSet.updateRegisterMap(this, cb, map, true);
}
updateMapWithSavedLink(map, savedFPAddr);
}
return new AARCH64Frame(senderSP, savedFPAddr.getAddressAt(0), senderPC);
}
protected boolean hasSenderPD() {
return true;
}
public long frameSize() {
return (getSenderSP().minus(getSP()) / VM.getVM().getAddressSize());
}
public Address getLink() {
try {
if (DEBUG) {
System.out.println("Reading link at " + addressOfStackSlot(LINK_OFFSET)
+ " = " + addressOfStackSlot(LINK_OFFSET).getAddressAt(0));
}
return addressOfStackSlot(LINK_OFFSET).getAddressAt(0);
} catch (Exception e) {
if (DEBUG)
System.out.println("Returning null");
return null;
}
}
public Address getUnextendedSP() { return raw_unextendedSP; }
public Address getSenderPCAddr() { return addressOfStackSlot(RETURN_ADDR_OFFSET); }
public Address getSenderPC()     { return stripPAC(getSenderPCAddr().getAddressAt(0)); }
private Address stripPAC(Address addr) {
if (ropProtectionField.getValue() != 0) {
return addr.andWithMask(pacMaskField.getValue());
} else {
return addr;
}
}
public Address getNativeParamAddr(int idx) {
return addressOfStackSlot(NATIVE_FRAME_INITIAL_PARAM_OFFSET + idx);
}
public Address getSenderSP()     { return addressOfStackSlot(SENDER_SP_OFFSET); }
public Address addressOfInterpreterFrameLocals() {
return addressOfStackSlot(INTERPRETER_FRAME_LOCALS_OFFSET);
}
private Address addressOfInterpreterFrameBCX() {
return addressOfStackSlot(INTERPRETER_FRAME_BCX_OFFSET);
}
public int getInterpreterFrameBCI() {
Address bcp = addressOfInterpreterFrameBCX().getAddressAt(0);
Address methodHandle = addressOfInterpreterFrameMethod().getAddressAt(0);
Method method = (Method)Metadata.instantiateWrapperFor(methodHandle);
return bcpToBci(bcp, method);
}
public Address addressOfInterpreterFrameMDX() {
return addressOfStackSlot(INTERPRETER_FRAME_MDX_OFFSET);
}
public Address addressOfInterpreterFrameExpressionStack() {
Address monitorEnd = interpreterFrameMonitorEnd().address();
return monitorEnd.addOffsetTo(-1 * VM.getVM().getAddressSize());
}
public int getInterpreterFrameExpressionStackDirection() { return -1; }
public Address addressOfInterpreterFrameTOS() {
return getSP();
}
public Address addressOfInterpreterFrameTOSAt(int slot) {
return addressOfInterpreterFrameTOS().addOffsetTo(slot * VM.getVM().getAddressSize());
}
public Address getInterpreterFrameSenderSP() {
if (Assert.ASSERTS_ENABLED) {
Assert.that(isInterpretedFrame(), "interpreted frame expected");
}
return addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);
}
public BasicObjectLock interpreterFrameMonitorBegin() {
return new BasicObjectLock(addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET));
}
public BasicObjectLock interpreterFrameMonitorEnd() {
Address result = addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET).getAddressAt(0);
if (Assert.ASSERTS_ENABLED) {
Assert.that(AddressOps.gt(getFP(), result), "result must <  than frame pointer");
Assert.that(AddressOps.lte(getSP(), result), "result must >= than stack pointer");
}
return new BasicObjectLock(result);
}
public int interpreterFrameMonitorSize() {
return BasicObjectLock.size();
}
public Address addressOfInterpreterFrameMethod() {
return addressOfStackSlot(INTERPRETER_FRAME_METHOD_OFFSET);
}
public Address addressOfInterpreterFrameCPCache() {
return addressOfStackSlot(INTERPRETER_FRAME_CACHE_OFFSET);
}
public JavaCallWrapper getEntryFrameCallWrapper() {
return new AARCH64JavaCallWrapper(addressOfStackSlot(ENTRY_FRAME_CALL_WRAPPER_OFFSET).getAddressAt(0));
}
protected Address addressOfSavedOopResult() {
return getSP().addOffsetTo((VM.getVM().isClientCompiler() ? 2 : 3) *
VM.getVM().getAddressSize());
}
protected Address addressOfSavedReceiver() {
return getSP().addOffsetTo(-4 * VM.getVM().getAddressSize());
}
private void dumpStack() {
for (Address addr = getSP().addOffsetTo(-4 * VM.getVM().getAddressSize());
AddressOps.lt(addr, getSP());
addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {
System.out.println(addr + ": " + addr.getAddressAt(0));
}
System.out.println("-----------------------");
for (Address addr = getSP();
AddressOps.lte(addr, getSP().addOffsetTo(20 * VM.getVM().getAddressSize()));
addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {
System.out.println(addr + ": " + addr.getAddressAt(0));
}
}
}
package jdk.vm.ci.hotspot.aarch64;
import static java.util.Collections.emptyMap;
import static jdk.vm.ci.common.InitTimer.timer;
import java.util.EnumSet;
import java.util.Map;
import jdk.vm.ci.aarch64.AArch64;
import jdk.vm.ci.aarch64.AArch64.CPUFeature;
import jdk.vm.ci.code.Architecture;
import jdk.vm.ci.code.RegisterConfig;
import jdk.vm.ci.code.TargetDescription;
import jdk.vm.ci.code.stack.StackIntrospection;
import jdk.vm.ci.common.InitTimer;
import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;
import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;
import jdk.vm.ci.hotspot.HotSpotJVMCIBackendFactory;
import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
import jdk.vm.ci.hotspot.HotSpotMetaAccessProvider;
import jdk.vm.ci.hotspot.HotSpotStackIntrospection;
import jdk.vm.ci.meta.ConstantReflectionProvider;
import jdk.vm.ci.runtime.JVMCIBackend;
public class AArch64HotSpotJVMCIBackendFactory implements HotSpotJVMCIBackendFactory {
private static EnumSet<AArch64.CPUFeature> computeFeatures(AArch64HotSpotVMConfig config) {
Map<String, Long> constants = config.getStore().getConstants();
return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());
}
private static EnumSet<AArch64.Flag> computeFlags(AArch64HotSpotVMConfig config) {
EnumSet<AArch64.Flag> flags = EnumSet.noneOf(AArch64.Flag.class);
if (config.useCRC32) {
flags.add(AArch64.Flag.UseCRC32);
}
if (config.useNeon) {
flags.add(AArch64.Flag.UseNeon);
}
if (config.useSIMDForMemoryOps) {
flags.add(AArch64.Flag.UseSIMDForMemoryOps);
}
if (config.avoidUnalignedAccesses) {
flags.add(AArch64.Flag.AvoidUnalignedAccesses);
}
if (config.useLSE) {
flags.add(AArch64.Flag.UseLSE);
}
if (config.useBlockZeroing) {
flags.add(AArch64.Flag.UseBlockZeroing);
}
return flags;
}
private static TargetDescription createTarget(AArch64HotSpotVMConfig config) {
final int stackFrameAlignment = 16;
final int implicitNullCheckLimit = 4096;
final boolean inlineObjects = true;
Architecture arch = new AArch64(computeFeatures(config), computeFlags(config));
return new TargetDescription(arch, true, stackFrameAlignment, implicitNullCheckLimit, inlineObjects);
}
protected HotSpotConstantReflectionProvider createConstantReflection(HotSpotJVMCIRuntime runtime) {
return new HotSpotConstantReflectionProvider(runtime);
}
private static RegisterConfig createRegisterConfig(AArch64HotSpotVMConfig config, TargetDescription target) {
boolean canUsePlatformRegister = config.linuxOs;
return new AArch64HotSpotRegisterConfig(target, config.useCompressedOops, canUsePlatformRegister);
}
protected HotSpotCodeCacheProvider createCodeCache(HotSpotJVMCIRuntime runtime, TargetDescription target, RegisterConfig regConfig) {
return new HotSpotCodeCacheProvider(runtime, target, regConfig);
}
protected HotSpotMetaAccessProvider createMetaAccess(HotSpotJVMCIRuntime runtime) {
return new HotSpotMetaAccessProvider(runtime);
}
@Override
public String getArchitecture() {
return "aarch64";
}
@Override
public String toString() {
return "JVMCIBackend:" + getArchitecture();
}
@Override
@SuppressWarnings("try")
public JVMCIBackend createJVMCIBackend(HotSpotJVMCIRuntime runtime, JVMCIBackend host) {
assert host == null;
AArch64HotSpotVMConfig config = new AArch64HotSpotVMConfig(runtime.getConfigStore());
TargetDescription target = createTarget(config);
RegisterConfig regConfig;
HotSpotCodeCacheProvider codeCache;
ConstantReflectionProvider constantReflection;
HotSpotMetaAccessProvider metaAccess;
StackIntrospection stackIntrospection;
try (InitTimer t = timer("create providers")) {
try (InitTimer rt = timer("create MetaAccess provider")) {
metaAccess = createMetaAccess(runtime);
}
try (InitTimer rt = timer("create RegisterConfig")) {
regConfig = createRegisterConfig(config, target);
}
try (InitTimer rt = timer("create CodeCache provider")) {
codeCache = createCodeCache(runtime, target, regConfig);
}
try (InitTimer rt = timer("create ConstantReflection provider")) {
constantReflection = createConstantReflection(runtime);
}
try (InitTimer rt = timer("create StackIntrospection provider")) {
stackIntrospection = new HotSpotStackIntrospection(runtime);
}
}
try (InitTimer rt = timer("instantiate backend")) {
return createBackend(metaAccess, codeCache, constantReflection, stackIntrospection);
}
}
protected JVMCIBackend createBackend(HotSpotMetaAccessProvider metaAccess, HotSpotCodeCacheProvider codeCache, ConstantReflectionProvider constantReflection,
StackIntrospection stackIntrospection) {
return new JVMCIBackend(metaAccess, codeCache, constantReflection, stackIntrospection);
}
}
package jdk.vm.ci.hotspot.aarch64;
import static jdk.vm.ci.aarch64.AArch64.lr;
import static jdk.vm.ci.aarch64.AArch64.r0;
import static jdk.vm.ci.aarch64.AArch64.r1;
import static jdk.vm.ci.aarch64.AArch64.r2;
import static jdk.vm.ci.aarch64.AArch64.r3;
import static jdk.vm.ci.aarch64.AArch64.r4;
import static jdk.vm.ci.aarch64.AArch64.r5;
import static jdk.vm.ci.aarch64.AArch64.r6;
import static jdk.vm.ci.aarch64.AArch64.r7;
import static jdk.vm.ci.aarch64.AArch64.rscratch1;
import static jdk.vm.ci.aarch64.AArch64.rscratch2;
import static jdk.vm.ci.aarch64.AArch64.r12;
import static jdk.vm.ci.aarch64.AArch64.r18;
import static jdk.vm.ci.aarch64.AArch64.r27;
import static jdk.vm.ci.aarch64.AArch64.r28;
import static jdk.vm.ci.aarch64.AArch64.r29;
import static jdk.vm.ci.aarch64.AArch64.r31;
import static jdk.vm.ci.aarch64.AArch64.sp;
import static jdk.vm.ci.aarch64.AArch64.v0;
import static jdk.vm.ci.aarch64.AArch64.v1;
import static jdk.vm.ci.aarch64.AArch64.v2;
import static jdk.vm.ci.aarch64.AArch64.v3;
import static jdk.vm.ci.aarch64.AArch64.v4;
import static jdk.vm.ci.aarch64.AArch64.v5;
import static jdk.vm.ci.aarch64.AArch64.v6;
import static jdk.vm.ci.aarch64.AArch64.v7;
import static jdk.vm.ci.aarch64.AArch64.zr;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import jdk.vm.ci.aarch64.AArch64;
import jdk.vm.ci.code.Architecture;
import jdk.vm.ci.code.CallingConvention;
import jdk.vm.ci.code.CallingConvention.Type;
import jdk.vm.ci.code.Register;
import jdk.vm.ci.code.RegisterArray;
import jdk.vm.ci.code.RegisterAttributes;
import jdk.vm.ci.code.RegisterConfig;
import jdk.vm.ci.code.StackSlot;
import jdk.vm.ci.code.TargetDescription;
import jdk.vm.ci.code.ValueKindFactory;
import jdk.vm.ci.common.JVMCIError;
import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
import jdk.vm.ci.meta.AllocatableValue;
import jdk.vm.ci.meta.JavaKind;
import jdk.vm.ci.meta.JavaType;
import jdk.vm.ci.meta.PlatformKind;
import jdk.vm.ci.meta.Value;
import jdk.vm.ci.meta.ValueKind;
public class AArch64HotSpotRegisterConfig implements RegisterConfig {
private final TargetDescription target;
private final RegisterArray allocatable;
private final RegisterArray callerSaved;
private final boolean allAllocatableAreCallerSaved;
private final RegisterAttributes[] attributesMap;
@Override
public RegisterArray getAllocatableRegisters() {
return allocatable;
}
@Override
public RegisterArray filterAllocatableRegisters(PlatformKind kind, RegisterArray registers) {
ArrayList<Register> list = new ArrayList<>();
for (Register reg : registers) {
if (target.arch.canStoreValue(reg.getRegisterCategory(), kind)) {
list.add(reg);
}
}
return new RegisterArray(list);
}
@Override
public RegisterAttributes[] getAttributesMap() {
return attributesMap.clone();
}
private final RegisterArray javaGeneralParameterRegisters = new RegisterArray(r1, r2, r3, r4, r5, r6, r7, r0);
private final RegisterArray nativeGeneralParameterRegisters = new RegisterArray(r0, r1, r2, r3, r4, r5, r6, r7);
private final RegisterArray simdParameterRegisters = new RegisterArray(v0, v1, v2, v3, v4, v5, v6, v7);
public static final Register inlineCacheRegister = rscratch2;
public static final Register metaspaceMethodRegister = r12;
public static final Register platformRegister = r18;
public static final Register heapBaseRegister = r27;
public static final Register threadRegister = r28;
public static final Register fp = r29;
private static final RegisterArray reservedRegisters = new RegisterArray(rscratch1, rscratch2, threadRegister, fp, lr, r31, zr, sp);
private static RegisterArray initAllocatable(Architecture arch, boolean reserveForHeapBase, boolean canUsePlatformRegister) {
RegisterArray allRegisters = arch.getAvailableValueRegisters();
Register[] registers = new Register[allRegisters.size() - reservedRegisters.size() - (reserveForHeapBase ? 1 : 0) - (!canUsePlatformRegister ? 1 : 0)];
List<Register> reservedRegistersList = reservedRegisters.asList();
int idx = 0;
for (Register reg : allRegisters) {
if (reservedRegistersList.contains(reg)) {
continue;
}
if (!canUsePlatformRegister && reg.equals(platformRegister)) {
continue;
}
assert !(reg.equals(threadRegister) || reg.equals(fp) || reg.equals(lr) || reg.equals(r31) || reg.equals(zr) || reg.equals(sp));
if (reserveForHeapBase && reg.equals(heapBaseRegister)) {
continue;
}
registers[idx++] = reg;
}
assert idx == registers.length;
return new RegisterArray(registers);
}
public AArch64HotSpotRegisterConfig(TargetDescription target, boolean useCompressedOops, boolean canUsePlatformRegister) {
this(target, initAllocatable(target.arch, useCompressedOops, canUsePlatformRegister));
assert callerSaved.size() >= allocatable.size();
}
public AArch64HotSpotRegisterConfig(TargetDescription target, RegisterArray allocatable) {
this.target = target;
this.allocatable = allocatable;
Set<Register> callerSaveSet = new HashSet<>();
allocatable.addTo(callerSaveSet);
simdParameterRegisters.addTo(callerSaveSet);
javaGeneralParameterRegisters.addTo(callerSaveSet);
nativeGeneralParameterRegisters.addTo(callerSaveSet);
callerSaved = new RegisterArray(callerSaveSet);
allAllocatableAreCallerSaved = true;
attributesMap = RegisterAttributes.createMap(this, AArch64.allRegisters);
}
@Override
public RegisterArray getCallerSaveRegisters() {
return callerSaved;
}
@Override
public RegisterArray getCalleeSaveRegisters() {
return null;
}
@Override
public boolean areAllAllocatableRegistersCallerSaved() {
return allAllocatableAreCallerSaved;
}
@Override
public CallingConvention getCallingConvention(Type type, JavaType returnType, JavaType[] parameterTypes, ValueKindFactory<?> valueKindFactory) {
HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;
if (type == HotSpotCallingConventionType.NativeCall) {
return callingConvention(nativeGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);
}
return callingConvention(javaGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);
}
@Override
public RegisterArray getCallingConventionRegisters(Type type, JavaKind kind) {
HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;
switch (kind) {
case Boolean:
case Byte:
case Short:
case Char:
case Int:
case Long:
case Object:
return hotspotType == HotSpotCallingConventionType.NativeCall ? nativeGeneralParameterRegisters : javaGeneralParameterRegisters;
case Float:
case Double:
return simdParameterRegisters;
default:
throw JVMCIError.shouldNotReachHere();
}
}
private CallingConvention callingConvention(RegisterArray generalParameterRegisters, JavaType returnType, JavaType[] parameterTypes, HotSpotCallingConventionType type,
ValueKindFactory<?> valueKindFactory) {
AllocatableValue[] locations = new AllocatableValue[parameterTypes.length];
int currentGeneral = 0;
int currentSIMD = 0;
int currentStackOffset = 0;
for (int i = 0; i < parameterTypes.length; i++) {
final JavaKind kind = parameterTypes[i].getJavaKind().getStackKind();
switch (kind) {
case Byte:
case Boolean:
case Short:
case Char:
case Int:
case Long:
case Object:
if (currentGeneral < generalParameterRegisters.size()) {
Register register = generalParameterRegisters.get(currentGeneral++);
locations[i] = register.asValue(valueKindFactory.getValueKind(kind));
}
break;
case Float:
case Double:
if (currentSIMD < simdParameterRegisters.size()) {
Register register = simdParameterRegisters.get(currentSIMD++);
locations[i] = register.asValue(valueKindFactory.getValueKind(kind));
}
break;
default:
throw JVMCIError.shouldNotReachHere();
}
if (locations[i] == null) {
ValueKind<?> valueKind = valueKindFactory.getValueKind(kind);
locations[i] = StackSlot.get(valueKind, currentStackOffset, !type.out);
currentStackOffset += Math.max(valueKind.getPlatformKind().getSizeInBytes(), target.wordSize);
}
}
JavaKind returnKind = returnType == null ? JavaKind.Void : returnType.getJavaKind();
AllocatableValue returnLocation = returnKind == JavaKind.Void ? Value.ILLEGAL : getReturnRegister(returnKind).asValue(valueKindFactory.getValueKind(returnKind.getStackKind()));
return new CallingConvention(currentStackOffset, returnLocation, locations);
}
@Override
public Register getReturnRegister(JavaKind kind) {
switch (kind) {
case Boolean:
case Byte:
case Char:
case Short:
case Int:
case Long:
case Object:
return r0;
case Float:
case Double:
return v0;
case Void:
case Illegal:
return null;
default:
throw new UnsupportedOperationException("no return register for type " + kind);
}
}
@Override
public Register getFrameRegister() {
return sp;
}
@Override
public String toString() {
return String.format("Allocatable: " + getAllocatableRegisters() + "%n" + "CallerSave:  " + getCallerSaveRegisters() + "%n");
}
}
package jdk.vm.ci.hotspot.aarch64;
import jdk.vm.ci.hotspot.HotSpotVMConfigAccess;
import jdk.vm.ci.hotspot.HotSpotVMConfigStore;
import jdk.vm.ci.services.Services;
class AArch64HotSpotVMConfig extends HotSpotVMConfigAccess {
AArch64HotSpotVMConfig(HotSpotVMConfigStore config) {
super(config);
}
final boolean linuxOs = Services.getSavedProperty("os.name", "").startsWith("Linux");
final boolean useCompressedOops = getFlag("UseCompressedOops", Boolean.class);
final boolean useCRC32 = getFlag("UseCRC32", Boolean.class);
final boolean useNeon = getFlag("UseNeon", Boolean.class);
final boolean useSIMDForMemoryOps = getFlag("UseSIMDForMemoryOps", Boolean.class);
final boolean avoidUnalignedAccesses = getFlag("AvoidUnalignedAccesses", Boolean.class);
final boolean useLSE = getFlag("UseLSE", Boolean.class);
final boolean useBlockZeroing = getFlag("UseBlockZeroing", Boolean.class);
final long vmVersionFeatures = getFieldValue("Abstract_VM_Version::_features", Long.class, "uint64_t");
final long aarch64FP = getConstant("VM_Version::CPU_FP", Long.class);
final long aarch64ASIMD = getConstant("VM_Version::CPU_ASIMD", Long.class);
final long aarch64EVTSTRM = getConstant("VM_Version::CPU_EVTSTRM", Long.class);
final long aarch64AES = getConstant("VM_Version::CPU_AES", Long.class);
final long aarch64PMULL = getConstant("VM_Version::CPU_PMULL", Long.class);
final long aarch64SHA1 = getConstant("VM_Version::CPU_SHA1", Long.class);
final long aarch64SHA2 = getConstant("VM_Version::CPU_SHA2", Long.class);
final long aarch64CRC32 = getConstant("VM_Version::CPU_CRC32", Long.class);
final long aarch64LSE = getConstant("VM_Version::CPU_LSE", Long.class);
final long aarch64STXR_PREFETCH = getConstant("VM_Version::CPU_STXR_PREFETCH", Long.class);
final long aarch64A53MAC = getConstant("VM_Version::CPU_A53MAC", Long.class);
}
package sun.jvm.hotspot.runtime.aarch64;
import java.util.*;
import sun.jvm.hotspot.debugger.*;
import sun.jvm.hotspot.types.*;
import sun.jvm.hotspot.runtime.*;
import sun.jvm.hotspot.utilities.Observable;
import sun.jvm.hotspot.utilities.Observer;
public class AARCH64JavaCallWrapper extends JavaCallWrapper {
private static AddressField lastJavaFPField;
static {
VM.registerVMInitializedObserver(new Observer() {
public void update(Observable o, Object data) {
initialize(VM.getVM().getTypeDataBase());
}
});
}
private static synchronized void initialize(TypeDataBase db) {
Type type = db.lookupType("JavaFrameAnchor");
lastJavaFPField  = type.getAddressField("_last_Java_fp");
}
public AARCH64JavaCallWrapper(Address addr) {
super(addr);
}
public Address getLastJavaFP() {
return lastJavaFPField.getValue(addr.addOffsetTo(anchorField.getOffset()));
}
}
package jdk.vm.ci.aarch64;
import jdk.vm.ci.meta.PlatformKind;
public enum AArch64Kind implements PlatformKind {
BYTE(1),
WORD(2),
DWORD(4),
QWORD(8),
SINGLE(4),
DOUBLE(8),
V32_BYTE(4, BYTE),
V32_WORD(4, WORD),
V64_BYTE(8, BYTE),
V64_WORD(8, WORD),
V64_DWORD(8, DWORD),
V128_BYTE(16, BYTE),
V128_WORD(16, WORD),
V128_DWORD(16, DWORD),
V128_QWORD(16, QWORD),
V128_SINGLE(16, SINGLE),
V128_DOUBLE(16, DOUBLE);
private final int size;
private final int vectorLength;
private final AArch64Kind scalar;
private final EnumKey<AArch64Kind> key = new EnumKey<>(this);
AArch64Kind(int size) {
this.size = size;
this.scalar = this;
this.vectorLength = 1;
}
AArch64Kind(int size, AArch64Kind scalar) {
this.size = size;
this.scalar = scalar;
assert size % scalar.size == 0;
this.vectorLength = size / scalar.size;
}
public AArch64Kind getScalar() {
return scalar;
}
@Override
public int getSizeInBytes() {
return size;
}
@Override
public int getVectorLength() {
return vectorLength;
}
@Override
public Key getKey() {
return key;
}
public boolean isInteger() {
switch (this) {
case BYTE:
case WORD:
case DWORD:
case QWORD:
return true;
default:
return false;
}
}
public boolean isSIMD() {
switch (this) {
case SINGLE:
case DOUBLE:
case V32_BYTE:
case V32_WORD:
case V64_BYTE:
case V64_WORD:
case V64_DWORD:
case V128_BYTE:
case V128_WORD:
case V128_DWORD:
case V128_QWORD:
case V128_SINGLE:
case V128_DOUBLE:
return true;
default:
return false;
}
}
@Override
public char getTypeChar() {
switch (this) {
case BYTE:
return 'b';
case WORD:
return 'w';
case DWORD:
return 'd';
case QWORD:
return 'q';
case SINGLE:
return 'S';
case DOUBLE:
return 'D';
case V32_BYTE:
case V32_WORD:
case V64_BYTE:
case V64_WORD:
case V64_DWORD:
case V128_BYTE:
case V128_WORD:
case V128_DWORD:
case V128_QWORD:
case V128_SINGLE:
case V128_DOUBLE:
return 'v';
default:
return '-';
}
}
}
package sun.jvm.hotspot.runtime.aarch64;
import sun.jvm.hotspot.debugger.*;
import sun.jvm.hotspot.runtime.*;
public class AARCH64RegisterMap extends RegisterMap {
public AARCH64RegisterMap(JavaThread thread, boolean updateMap) {
super(thread, updateMap);
}
protected AARCH64RegisterMap(RegisterMap map) {
super(map);
}
public Object clone() {
AARCH64RegisterMap retval = new AARCH64RegisterMap(this);
return retval;
}
protected void clearPD() {}
protected void initializePD() {}
protected void initializeFromPD(RegisterMap map) {}
protected Address getLocationPD(VMReg reg) { return null; }
}
package jdk.vm.ci.code.test.aarch64;
import jdk.vm.ci.aarch64.AArch64;
import jdk.vm.ci.aarch64.AArch64Kind;
import jdk.vm.ci.code.CallingConvention;
import jdk.vm.ci.code.CodeCacheProvider;
import jdk.vm.ci.code.DebugInfo;
import jdk.vm.ci.code.Register;
import jdk.vm.ci.code.RegisterValue;
import jdk.vm.ci.code.StackSlot;
import jdk.vm.ci.code.site.ConstantReference;
import jdk.vm.ci.code.site.DataSectionReference;
import jdk.vm.ci.code.test.TestAssembler;
import jdk.vm.ci.code.test.TestHotSpotVMConfig;
import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
import jdk.vm.ci.hotspot.HotSpotConstant;
import jdk.vm.ci.hotspot.HotSpotForeignCallTarget;
import jdk.vm.ci.meta.AllocatableValue;
import jdk.vm.ci.meta.JavaKind;
import jdk.vm.ci.meta.VMConstant;
public class AArch64TestAssembler extends TestAssembler {
private static final Register scratchRegister = AArch64.rscratch1;
private static final Register doubleScratch = AArch64.v9;
public AArch64TestAssembler(CodeCacheProvider codeCache, TestHotSpotVMConfig config) {
super(codeCache, config,
16 , 16 ,
AArch64Kind.DWORD ,
AArch64.r0, AArch64.r1, AArch64.r2, AArch64.r3,
AArch64.r4, AArch64.r5, AArch64.r6, AArch64.r7);
}
private static int f(int val, int msb, int lsb) {
int nbits = msb - lsb + 1;
assert val >= 0;
assert val < (1 << nbits);
assert msb >= lsb;
return val << lsb;
}
private static int f(Register r, int msb, int lsb) {
assert msb - lsb == 4;
return f(r.encoding, msb, lsb);
}
private void emitNop() {
code.emitInt(0xd503201f);
}
private void emitAdd(Register Rd, Register Rn, Register Rm) {
code.emitInt(f(0b10001011000, 31, 21)
| f(Rm, 20, 16)
| f(0, 15, 10)
| f(Rn, 9, 5)
| f(Rd, 4, 0));
}
private void emitAdd(Register Rd, Register Rn, int imm12) {
code.emitInt(f(0b1001000100, 31, 22)
| f(imm12, 21, 10)
| f(Rn, 9, 5)
| f(Rd, 4, 0));
}
private void emitSub(Register Rd, Register Rn, int imm12) {
code.emitInt(f(0b1101000100, 31, 22)
| f(imm12, 21, 10)
| f(Rn, 9, 5)
| f(Rd, 4, 0));
}
private void emitSub(Register Rd, Register Rn, Register Rm) {
code.emitInt(f(0b11001011001, 31, 21)
| f(Rm, 20, 16)
| f(0b011000, 15, 10)
| f(Rn, 9, 5)
| f(Rd, 4, 0));
}
private void emitMov(Register Rd, Register Rm) {
code.emitInt(f(0b10101010000, 31, 21)
| f(Rm, 20, 16)
| f(0, 15, 10)
| f(AArch64.zr, 9, 5)
| f(Rd, 4, 0));
}
private void emitMovz(Register Rd, int imm16, int shift) {
int hw = 0;
switch (shift) {
case 0:  hw = 0; break;
case 16: hw = 1; break;
case 32: hw = 2; break;
case 48: hw = 3; break;
default: throw new IllegalArgumentException();
}
code.emitInt(f(0b110100101, 31, 23)
| f(hw, 22, 21)
| f(imm16, 20, 5)
| f(Rd, 4, 0));
}
private void emitMovk(Register Rd, int imm16, int shift) {
int hw = 0;
switch (shift) {
case 0:  hw = 0; break;
case 16: hw = 1; break;
case 32: hw = 2; break;
case 48: hw = 3; break;
default: throw new IllegalArgumentException();
}
code.emitInt(f(0b111100101, 31, 23)
| f(hw, 22, 21)
| f(imm16, 20, 5)
| f(Rd, 4, 0));
}
private void emitShiftLeft(Register Rd, Register Rn, int shift) {
code.emitInt(f(0b1101001101, 31, 22)
| f(-shift & 0b111111, 21, 16)
| f(63 - shift, 15, 10)
| f(Rn, 9, 5)
| f(Rd, 4, 0));
}
private void emitLoadRegister(Register Rt, AArch64Kind kind, int offset) {
int opc = 0;
switch (kind) {
case DWORD: opc = 0; break;
case QWORD: opc = 1; break;
default: throw new IllegalArgumentException();
}
code.emitInt(f(opc, 31, 30)
| f(0b011000, 29, 24)
| f(offset, 23, 5)
| f(Rt, 4, 0));
}
private void emitLoadRegister(Register Rt, AArch64Kind kind, Register Rn, int offset) {
assert offset >= 0;
int size = 0;
switch (kind) {
case DWORD: size = 0b10; break;
case QWORD: size = 0b11; break;
default: throw new IllegalArgumentException();
}
code.emitInt(f(size, 31, 30)
| f(0b11100101, 29, 22)
| f(offset >> size, 21, 10)
| f(Rn, 9, 5)
| f(Rt, 4, 0));
}
private void emitStoreRegister(Register Rt, AArch64Kind kind, Register Rn, int offset) {
assert offset >= 0;
int size = 0, fp = 0;
switch (kind) {
case DWORD: size = 0b10; fp = 0; break;
case QWORD: size = 0b11; fp = 0; break;
case SINGLE: size = 0b10; fp = 1; break;
case DOUBLE: size = 0b11; fp = 1; break;
default: throw new IllegalArgumentException();
}
code.emitInt(f(size, 31, 30)
| f(0b111, 29, 27)
| f(fp, 26, 26)
| f(0b0100, 25, 22)
| f(offset >> size, 21, 10)
| f(Rn, 9, 5)
| f(Rt, 4, 0));
}
private void emitBlr(Register Rn) {
code.emitInt(f(0b1101011000111111000000, 31, 10)
| f(Rn, 9, 5)
| f(0, 4, 0));
}
private void emitFmov(Register Rd, AArch64Kind kind, Register Rn) {
int ftype = 0, sf = 0;
switch (kind) {
case SINGLE: sf = 0; ftype = 0b00; break;
case DOUBLE: sf = 1; ftype = 0b01; break;
default: throw new IllegalArgumentException();
}
code.emitInt(f(sf, 31, 31)
| f(0b0011110, 30, 24)
| f(ftype, 23, 22)
| f(0b100111, 21, 16)
| f(0, 15, 10)
| f(Rn, 9, 5)
| f(Rd, 4, 0));
}
@Override
public void emitGrowStack(int size) {
assert size % 16 == 0;
if (size > -4096 && size < 0) {
emitAdd(AArch64.sp, AArch64.sp, -size);
} else if (size == 0) {
} else if (size < 4096) {
emitSub(AArch64.sp, AArch64.sp, size);
} else if (size < 65535) {
emitMovz(scratchRegister, size & 0xffff, 0);
emitMovk(scratchRegister, (size >> 16) & 0xffff, 16);
emitSub(AArch64.sp, AArch64.sp, scratchRegister);
} else {
throw new IllegalArgumentException();
}
}
@Override
public void emitPrologue() {
emitNop();
if (config.ropProtection) {
code.emitInt(0xdac103be);          }
code.emitInt(0xa9be7bfd);          code.emitInt(0x910003fd);
setDeoptRescueSlot(newStackSlot(AArch64Kind.QWORD));
}
@Override
public void emitEpilogue() {
recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);
recordCall(new HotSpotForeignCallTarget(config.handleDeoptStub), 4*4, true, null);
emitCall(0xdeaddeaddeadL);
}
@Override
public void emitCallPrologue(CallingConvention cc, Object... prim) {
emitGrowStack(cc.getStackSize());
frameSize += cc.getStackSize();
AllocatableValue[] args = cc.getArguments();
for (int i = 0; i < args.length; i++) {
emitLoad(args[i], prim[i]);
}
}
@Override
public void emitCallEpilogue(CallingConvention cc) {
emitGrowStack(-cc.getStackSize());
frameSize -= cc.getStackSize();
}
@Override
public void emitCall(long addr) {
emitLoadPointer48(scratchRegister, addr);
emitBlr(scratchRegister);
}
@Override
public void emitLoad(AllocatableValue av, Object prim) {
if (av instanceof RegisterValue) {
Register reg = ((RegisterValue) av).getRegister();
if (prim instanceof Float) {
emitLoadFloat(reg, (Float) prim);
} else if (prim instanceof Double) {
emitLoadDouble(reg, (Double) prim);
} else if (prim instanceof Integer) {
emitLoadInt(reg, (Integer) prim);
} else if (prim instanceof Long) {
emitLoadLong(reg, (Long) prim);
}
} else if (av instanceof StackSlot) {
StackSlot slot = (StackSlot) av;
if (prim instanceof Float) {
emitFloatToStack(slot, emitLoadFloat(doubleScratch, (Float) prim));
} else if (prim instanceof Double) {
emitDoubleToStack(slot, emitLoadDouble(doubleScratch, (Double) prim));
} else if (prim instanceof Integer) {
emitIntToStack(slot, emitLoadInt(scratchRegister, (Integer) prim));
} else if (prim instanceof Long) {
emitLongToStack(slot, emitLoadLong(scratchRegister, (Long) prim));
} else {
assert false : "Unimplemented";
}
} else {
throw new IllegalArgumentException("Unknown value " + av);
}
}
private void emitLoadPointer32(Register ret, long addr) {
long a = addr;
long al = a;
a >>= 16;
long ah = a;
a >>= 16;
assert a == 0 : "invalid pointer" + Long.toHexString(addr);
emitMovz(ret, ((int)ah & 0xffff), 16);
emitMovk(ret, ((int)al & 0xffff), 0);
}
private void emitLoadPointer48(Register ret, long addr) {
long a = addr;
emitMovz(ret, ((int)a & 0xffff), 0);
a >>= 16;
emitMovk(ret, ((int)a & 0xffff), 16);
a >>= 16;
emitMovk(ret, ((int)a & 0xffff), 32);
a >>= 16;
assert a == 0 : "invalid pointer" + Long.toHexString(addr);
}
@Override
public Register emitLoadPointer(HotSpotConstant c) {
recordDataPatchInCode(new ConstantReference((VMConstant) c));
Register ret = newRegister();
if (c.isCompressed()) {
emitLoadPointer32(ret, 0xdeaddeadL);
} else {
emitLoadPointer48(ret, 0xdeaddeaddeadL);
}
return ret;
}
@Override
public Register emitLoadPointer(Register b, int offset) {
Register ret = newRegister();
emitLoadRegister(ret, AArch64Kind.QWORD, b, offset);
return ret;
}
@Override
public Register emitLoadNarrowPointer(DataSectionReference ref) {
recordDataPatchInCode(ref);
Register ret = newRegister();
emitLoadRegister(ret, AArch64Kind.DWORD, 0xdead);
return ret;
}
@Override
public Register emitLoadPointer(DataSectionReference ref) {
recordDataPatchInCode(ref);
Register ret = newRegister();
emitLoadRegister(ret, AArch64Kind.QWORD, 0xdead);
return ret;
}
private Register emitLoadDouble(Register reg, double c) {
DataSectionReference ref = new DataSectionReference();
ref.setOffset(data.position());
data.emitDouble(c);
recordDataPatchInCode(ref);
emitLoadRegister(scratchRegister, AArch64Kind.QWORD, 0xdead);
emitFmov(reg, AArch64Kind.DOUBLE, scratchRegister);
return reg;
}
private Register emitLoadFloat(Register reg, float c) {
DataSectionReference ref = new DataSectionReference();
ref.setOffset(data.position());
data.emitFloat(c);
recordDataPatchInCode(ref);
emitLoadRegister(scratchRegister, AArch64Kind.DWORD, 0xdead);
emitFmov(reg, AArch64Kind.SINGLE, scratchRegister);
return reg;
}
@Override
public Register emitLoadFloat(float c) {
Register ret = AArch64.v0;
return emitLoadFloat(ret, c);
}
private Register emitLoadLong(Register reg, long c) {
emitMovz(reg, (int)(c & 0xffff), 0);
emitMovk(reg, (int)((c >> 16) & 0xffff), 16);
emitMovk(reg, (int)((c >> 32) & 0xffff), 32);
emitMovk(reg, (int)((c >> 48) & 0xffff), 48);
return reg;
}
@Override
public Register emitLoadLong(long c) {
Register ret = newRegister();
return emitLoadLong(ret, c);
}
private Register emitLoadInt(Register reg, int c) {
emitMovz(reg, (int)(c & 0xffff), 0);
emitMovk(reg, (int)((c >> 16) & 0xffff), 16);
return reg;
}
@Override
public Register emitLoadInt(int c) {
Register ret = newRegister();
return emitLoadInt(ret, c);
}
@Override
public Register emitIntArg0() {
return codeCache.getRegisterConfig()
.getCallingConventionRegisters(HotSpotCallingConventionType.JavaCall, JavaKind.Int)
.get(0);
}
@Override
public Register emitIntArg1() {
return codeCache.getRegisterConfig()
.getCallingConventionRegisters(HotSpotCallingConventionType.JavaCall, JavaKind.Int)
.get(1);
}
@Override
public Register emitIntAdd(Register a, Register b) {
emitAdd(a, a, b);
return a;
}
@Override
public void emitTrap(DebugInfo info) {
emitMovz(scratchRegister, 0, 0);
recordImplicitException(info);
emitLoadRegister(AArch64.zr, AArch64Kind.QWORD, scratchRegister, 0);
}
@Override
public void emitIntRet(Register a) {
emitMov(AArch64.r0, a);
code.emitInt(0x910003bf);          code.emitInt(0xa8c27bfd);          if (config.ropProtection) {
code.emitInt(0xdac113be);          }
code.emitInt(0xd65f03c0);      }
@Override
public void emitFloatRet(Register a) {
assert a == AArch64.v0 : "Unimplemented move " + a;
code.emitInt(0x910003bf);          code.emitInt(0xa8c27bfd);          if (config.ropProtection) {
code.emitInt(0xdac113be);          }
code.emitInt(0xd65f03c0);      }
@Override
public void emitPointerRet(Register a) {
emitIntRet(a);
}
@Override
public StackSlot emitPointerToStack(Register a) {
return emitLongToStack(a);
}
@Override
public StackSlot emitNarrowPointerToStack(Register a) {
return emitIntToStack(a);
}
@Override
public Register emitUncompressPointer(Register compressed, long base, int shift) {
if (shift > 0) {
emitShiftLeft(compressed, compressed, shift);
}
if (base != 0) {
emitLoadLong(scratchRegister, base);
emitAdd(compressed, compressed, scratchRegister);
}
return compressed;
}
private StackSlot emitDoubleToStack(StackSlot slot, Register a) {
emitStoreRegister(a, AArch64Kind.DOUBLE, AArch64.sp, slot.getOffset(frameSize));
return slot;
}
@Override
public StackSlot emitDoubleToStack(Register a) {
StackSlot ret = newStackSlot(AArch64Kind.DOUBLE);
return emitDoubleToStack(ret, a);
}
private StackSlot emitFloatToStack(StackSlot slot, Register a) {
emitStoreRegister(a, AArch64Kind.SINGLE, AArch64.sp, slot.getOffset(frameSize));
return slot;
}
@Override
public StackSlot emitFloatToStack(Register a) {
StackSlot ret = newStackSlot(AArch64Kind.SINGLE);
return emitFloatToStack(ret, a);
}
private StackSlot emitIntToStack(StackSlot slot, Register a) {
emitStoreRegister(a, AArch64Kind.DWORD, AArch64.sp, slot.getOffset(frameSize));
return slot;
}
@Override
public StackSlot emitIntToStack(Register a) {
StackSlot ret = newStackSlot(AArch64Kind.DWORD);
return emitIntToStack(ret, a);
}
private StackSlot emitLongToStack(StackSlot slot, Register a) {
emitStoreRegister(a, AArch64Kind.QWORD, AArch64.sp, slot.getOffset(frameSize));
return slot;
}
@Override
public StackSlot emitLongToStack(Register a) {
StackSlot ret = newStackSlot(AArch64Kind.QWORD);
return emitLongToStack(ret, a);
}
}
package sun.jvm.hotspot.debugger.aarch64;
import java.lang.annotation.Native;
import sun.jvm.hotspot.debugger.*;
import sun.jvm.hotspot.debugger.cdbg.*;
public abstract class AARCH64ThreadContext implements ThreadContext {
@Native
public static final int R0 = 0;
public static final int R1 = 1;
public static final int R2 = 2;
public static final int R3 = 3;
public static final int R4 = 4;
public static final int R5 = 5;
public static final int R6 = 6;
public static final int R7 = 7;
public static final int R8 = 8;
public static final int R9 = 9;
public static final int R10 = 10;
public static final int R11 = 11;
public static final int R12 = 12;
public static final int R13 = 13;
public static final int R14 = 14;
public static final int R15 = 15;
public static final int R16 = 16;
public static final int R17 = 17;
public static final int R18 = 18;
public static final int R19 = 19;
public static final int R20 = 20;
public static final int R21 = 21;
public static final int R22 = 22;
public static final int R23 = 23;
public static final int R24 = 24;
public static final int R25 = 25;
public static final int R26 = 26;
public static final int R27 = 27;
public static final int R28 = 28;
public static final int FP = 29;
public static final int LR = 30;
public static final int SP = 31;
public static final int PC = 32;
public static final int PSTATE = 33;
public static final int NPRGREG = 34;
private long[] data;
public AARCH64ThreadContext() {
data = new long[NPRGREG];
}
public int getNumRegisters() {
return NPRGREG;
}
public String getRegisterName(int index) {
switch (index) {
case LR: return "lr";
case SP: return "sp";
case PC: return "pc";
default:
return "r" + index;
}
}
public void setRegister(int index, long value) {
data[index] = value;
}
public long getRegister(int index) {
return data[index];
}
public CFrame getTopFrame(Debugger dbg) {
return null;
}
public abstract void setRegisterAsAddress(int index, Address value);
public abstract Address getRegisterAsAddress(int index);
}
package sun.java2d.pipe;
import java.awt.BasicStroke;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.Rectangle2D;
import sun.awt.SunHints;
import sun.java2d.ReentrantContext;
import sun.java2d.ReentrantContextProvider;
import sun.java2d.ReentrantContextProviderTL;
import sun.java2d.SunGraphics2D;
public final class AAShapePipe
implements ShapeDrawPipe, ParallelogramPipe
{
static final RenderingEngine RDR_ENGINE = RenderingEngine.getInstance();
private static final ReentrantContextProvider<TileState> TILE_STATE_PROVIDER =
new ReentrantContextProviderTL<TileState>(
ReentrantContextProvider.REF_HARD)
{
@Override
protected TileState newContext() {
return new TileState();
}
};
final CompositePipe outpipe;
public AAShapePipe(CompositePipe pipe) {
outpipe = pipe;
}
@Override
public void draw(SunGraphics2D sg, Shape s) {
final BasicStroke bs;
if (sg.stroke instanceof BasicStroke) {
bs = (BasicStroke) sg.stroke;
} else {
s = sg.stroke.createStrokedShape(s);
bs = null;
}
renderPath(sg, s, bs);
}
@Override
public void fill(SunGraphics2D sg, Shape s) {
renderPath(sg, s, null);
}
@Override
public void fillParallelogram(SunGraphics2D sg,
double ux1, double uy1,
double ux2, double uy2,
double x, double y,
double dx1, double dy1,
double dx2, double dy2)
{
final TileState ts = TILE_STATE_PROVIDER.acquire();
try {
final int[] abox = ts.abox;
final AATileGenerator aatg =
RDR_ENGINE.getAATileGenerator(x, y, dx1, dy1, dx2, dy2, 0, 0,
sg.getCompClip(), abox);
if (aatg != null) {
renderTiles(sg, ts.computeBBox(ux1, uy1, ux2, uy2),
aatg, abox, ts);
}
} finally {
TILE_STATE_PROVIDER.release(ts);
}
}
@Override
public void drawParallelogram(SunGraphics2D sg,
double ux1, double uy1,
double ux2, double uy2,
double x, double y,
double dx1, double dy1,
double dx2, double dy2,
double lw1, double lw2)
{
final TileState ts = TILE_STATE_PROVIDER.acquire();
try {
final int[] abox = ts.abox;
final AATileGenerator aatg =
RDR_ENGINE.getAATileGenerator(x, y, dx1, dy1, dx2, dy2, lw1,
lw2, sg.getCompClip(), abox);
if (aatg != null) {
renderTiles(sg, ts.computeBBox(ux1, uy1, ux2, uy2),
aatg, abox, ts);
}
} finally {
TILE_STATE_PROVIDER.release(ts);
}
}
public void renderPath(SunGraphics2D sg, Shape s, BasicStroke bs) {
final boolean adjust = (bs != null &&
sg.strokeHint != SunHints.INTVAL_STROKE_PURE);
final boolean thin = (sg.strokeState <= SunGraphics2D.STROKE_THINDASHED);
final TileState ts = TILE_STATE_PROVIDER.acquire();
try {
final int[] abox = ts.abox;
final AATileGenerator aatg =
RDR_ENGINE.getAATileGenerator(s, sg.transform, sg.getCompClip(),
bs, thin, adjust, abox);
if (aatg != null) {
renderTiles(sg, s, aatg, abox, ts);
}
} finally {
TILE_STATE_PROVIDER.release(ts);
}
}
public void renderTiles(SunGraphics2D sg, Shape s,
final AATileGenerator aatg,
final int[] abox, final TileState ts)
{
Object context = null;
try {
context = outpipe.startSequence(sg, s,
ts.computeDevBox(abox),
abox);
final int x0 = abox[0];
final int y0 = abox[1];
final int x1 = abox[2];
final int y1 = abox[3];
final int tw = aatg.getTileWidth();
final int th = aatg.getTileHeight();
final byte[] alpha = ts.getAlphaTile(tw * th);
byte[] atile;
for (int y = y0; y < y1; y += th) {
final int h = Math.min(th, y1 - y);
for (int x = x0; x < x1; x += tw) {
final int w = Math.min(tw, x1 - x);
final int a = aatg.getTypicalAlpha();
if (a == 0x00 || !outpipe.needTile(context, x, y, w, h)) {
aatg.nextTile();
outpipe.skipTile(context, x, y);
continue;
}
if (a == 0xff) {
atile = null;
aatg.nextTile();
} else {
atile = alpha;
aatg.getAlpha(alpha, 0, tw);
}
outpipe.renderPathTile(context, atile, 0, tw, x, y, w, h);
}
}
} finally {
aatg.dispose();
if (context != null) {
outpipe.endSequence(context);
}
}
}
static final class TileState extends ReentrantContext {
private byte[] theTile = new byte[32 * 32];
final int[] abox = new int[4];
private final Rectangle dev = new Rectangle();
private final Rectangle2D.Double bbox2D = new Rectangle2D.Double();
byte[] getAlphaTile(int len) {
byte[] t = theTile;
if (t.length < len) {
theTile = t = new byte[len];
}
return t;
}
Rectangle computeDevBox(final int[] abox) {
final Rectangle box = this.dev;
box.x = abox[0];
box.y = abox[1];
box.width = abox[2] - abox[0];
box.height = abox[3] - abox[1];
return box;
}
Rectangle2D computeBBox(double ux1, double uy1,
double ux2, double uy2)
{
if ((ux2 -= ux1) < 0.0) {
ux1 += ux2;
ux2 = -ux2;
}
if ((uy2 -= uy1) < 0.0) {
uy1 += uy2;
uy2 = -uy2;
}
final Rectangle2D.Double box = this.bbox2D;
box.x = ux1;
box.y = uy1;
box.width = ux2;
box.height = uy2;
return box;
}
}
}
package com.sun.org.apache.bcel.internal.generic;
public class AASTORE extends ArrayInstruction implements StackConsumer {
public AASTORE() {
super(com.sun.org.apache.bcel.internal.Const.AASTORE);
}
@Override
public void accept( final Visitor v ) {
v.visitStackConsumer(this);
v.visitExceptionThrower(this);
v.visitTypedInstruction(this);
v.visitArrayInstruction(this);
v.visitAASTORE(this);
}
}
package sun.java2d.pipe;
import sun.awt.SunHints;
import sun.java2d.SunGraphics2D;
import sun.font.GlyphList;
public class AATextRenderer extends GlyphListLoopPipe
implements LoopBasedPipe
{
protected void drawGlyphList(SunGraphics2D sg2d, GlyphList gl) {
drawGlyphList(sg2d, gl, SunHints.INTVAL_TEXT_ANTIALIAS_ON);
}
}
package sun.java2d.pipe;
public interface AATileGenerator {
public int getTileWidth();
public int getTileHeight();
public int getTypicalAlpha();
public void nextTile();
public void getAlpha(byte[] tile, int offset, int rowstride);
public void dispose();
}
package jdk.internal.joptsimple.internal;
import java.util.Map;
import java.util.TreeMap;
public class AbbreviationMap<V> implements OptionNameMap<V> {
private final Map<Character, AbbreviationMap<V>> children = new TreeMap<>();
private String key;
private V value;
private int keysBeyond;
@Override
public boolean contains(String key) {
return get(key) != null;
}
@Override
public V get( String key ) {
char[] chars = charsOf( key );
AbbreviationMap<V> child = this;
for ( char each : chars ) {
child = child.children.get( each );
if ( child == null )
return null;
}
return child.value;
}
@Override
public void put( String key, V newValue ) {
if ( newValue == null )
throw new NullPointerException();
if ( key.length() == 0 )
throw new IllegalArgumentException();
char[] chars = charsOf(key);
add( chars, newValue, 0, chars.length );
}
@Override
public void putAll( Iterable<String> keys, V newValue ) {
for ( String each : keys )
put( each, newValue );
}
private boolean add( char[] chars, V newValue, int offset, int length ) {
if ( offset == length ) {
value = newValue;
boolean wasAlreadyAKey = key != null;
key = new String( chars );
return !wasAlreadyAKey;
}
char nextChar = chars[ offset ];
AbbreviationMap<V> child = children.get( nextChar );
if ( child == null ) {
child = new AbbreviationMap<>();
children.put( nextChar, child );
}
boolean newKeyAdded = child.add( chars, newValue, offset + 1, length );
if ( newKeyAdded )
++keysBeyond;
if ( key == null )
value = keysBeyond > 1 ? null : newValue;
return newKeyAdded;
}
@Override
public void remove( String key ) {
if ( key.length() == 0 )
throw new IllegalArgumentException();
char[] keyChars = charsOf(key);
remove( keyChars, 0, keyChars.length );
}
private boolean remove( char[] aKey, int offset, int length ) {
if ( offset == length )
return removeAtEndOfKey();
char nextChar = aKey[ offset ];
AbbreviationMap<V> child = children.get( nextChar );
if ( child == null || !child.remove( aKey, offset + 1, length ) )
return false;
--keysBeyond;
if ( child.keysBeyond == 0 )
children.remove( nextChar );
if ( keysBeyond == 1 && key == null )
setValueToThatOfOnlyChild();
return true;
}
private void setValueToThatOfOnlyChild() {
Map.Entry<Character, AbbreviationMap<V>> entry = children.entrySet().iterator().next();
AbbreviationMap<V> onlyChild = entry.getValue();
value = onlyChild.value;
}
private boolean removeAtEndOfKey() {
if ( key == null )
return false;
key = null;
if ( keysBeyond == 1 )
setValueToThatOfOnlyChild();
else
value = null;
return true;
}
@Override
public Map<String, V> toJavaUtilMap() {
Map<String, V> mappings = new TreeMap<>();
addToMappings( mappings );
return mappings;
}
private void addToMappings( Map<String, V> mappings ) {
if ( key != null )
mappings.put( key, value );
for ( AbbreviationMap<V> each : children.values() )
each.addToMappings( mappings );
}
private static char[] charsOf( String aKey ) {
char[] chars = new char[ aKey.length() ];
aKey.getChars( 0, aKey.length(), chars, 0 );
return chars;
}
}
package jdk.internal.foreign.abi;
public class ABIDescriptor {
final Architecture arch;
public final VMStorage[][] inputStorage;
public final VMStorage[][] outputStorage;
final VMStorage[][] volatileStorage;
final int stackAlignment;
final int shadowSpace;
final VMStorage targetAddrStorage;
final VMStorage retBufAddrStorage;
public ABIDescriptor(Architecture arch, VMStorage[][] inputStorage, VMStorage[][] outputStorage,
VMStorage[][] volatileStorage, int stackAlignment, int shadowSpace,
VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {
this.arch = arch;
this.inputStorage = inputStorage;
this.outputStorage = outputStorage;
this.volatileStorage = volatileStorage;
this.stackAlignment = stackAlignment;
this.shadowSpace = shadowSpace;
this.targetAddrStorage = targetAddrStorage;
this.retBufAddrStorage = retBufAddrStorage;
}
public VMStorage targetAddrStorage() {
return targetAddrStorage;
}
public VMStorage retBufAddrStorage() {
return retBufAddrStorage;
}
}
package com.sun.tools.javac.util;
public class Abort extends Error {
private static final long serialVersionUID = 0;
public Abort(Throwable cause) {
super(cause);
}
public Abort() {
super();
}
}
package com.sun.org.apache.xerces.internal.dom;
public class AbortException extends RuntimeException {
private static final long serialVersionUID = 2608302175475740417L;
public AbortException() { super(null, null, false, false); }
}
package compiler.testlibrary.rtm;
import jdk.test.lib.Asserts;
import jdk.test.whitebox.WhiteBox;
import java.util.Objects;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
public abstract class AbortProvoker implements CompilableTest {
public static final long DEFAULT_ITERATIONS = 10000L;
private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
@SuppressWarnings("unused")
private static int sharedState = 0;
public static Object inflateMonitor(Object monitor) throws Exception {
CyclicBarrier barrier = new CyclicBarrier(2);
Runnable inflatingRunnable = () -> {
synchronized (monitor) {
try {
barrier.await();
} catch (BrokenBarrierException  | InterruptedException e) {
throw new RuntimeException(
"Synchronization issue occurred.", e);
}
try {
monitor.wait();
} catch (InterruptedException e) {
throw new AssertionError("The thread waiting on an"
+ " inflated monitor was interrupted, thus test"
+ " results may be incorrect.", e);
}
}
};
Thread t = new Thread(inflatingRunnable);
t.setDaemon(true);
t.start();
barrier.await();
synchronized (monitor) {
sharedState++;
}
verifyMonitorState(monitor, true );
return monitor;
}
public static void verifyMonitorState(Object monitor,
boolean shouldBeInflated) {
if (!shouldBeInflated && WHITE_BOX.isMonitorInflated(monitor)) {
boolean did_deflation = WHITE_BOX.deflateIdleMonitors();
Asserts.assertEQ(did_deflation, true,
"deflateIdleMonitors() should have worked.");
}
Asserts.assertEQ(WHITE_BOX.isMonitorInflated(monitor), shouldBeInflated,
"Monitor in a wrong state.");
}
public static void verifyMonitorState(AbortProvoker provoker,
boolean shouldBeInflated) {
verifyMonitorState(provoker.monitor, shouldBeInflated);
}
public static void main(String args[]) throws Throwable {
Asserts.assertGT(args.length, 0, "At least one argument is required.");
AbortType abortType = AbortType.lookup(Integer.valueOf(args[0]));
boolean monitorShouldBeInflated = true;
long iterations = AbortProvoker.DEFAULT_ITERATIONS;
if (args.length > 1) {
monitorShouldBeInflated = Boolean.valueOf(args[1]);
if (args.length > 2) {
iterations = Long.valueOf(args[2]);
if (args.length > 3) {
Thread.sleep(Integer.valueOf(args[3]));
}
}
}
AbortProvoker provoker = abortType.provoker();
if (monitorShouldBeInflated) {
provoker.inflateMonitor();
}
for (long i = 0; i < iterations; i++) {
AbortProvoker.verifyMonitorState(provoker, monitorShouldBeInflated);
provoker.forceAbort();
}
}
protected final Object monitor;
protected AbortProvoker() {
this(new Object());
}
protected AbortProvoker(Object monitor) {
this.monitor = Objects.requireNonNull(monitor);
}
public void inflateMonitor() throws Exception {
AbortProvoker.inflateMonitor(monitor);
}
public abstract void forceAbort();
@Override
public String[] getMethodsToCompileNames() {
return new String[] { getMethodWithLockName() };
}
@Override
public String getMethodWithLockName() {
return this.getClass().getName() + "::forceAbort";
}
}
package compiler.testlibrary.rtm;
import jdk.test.lib.Asserts;
import java.util.HashMap;
import java.util.Map;
public enum AbortType {
XABORT(0),
RETRIABLE(1),
MEM_CONFLICT(2),
BUF_OVERFLOW(3),
DEBUG_BREAKPOINT(4),
NESTED_ABORT(5);
private final int type;
private static final Map<Integer, AbortType> LOOKUP_MAP = new HashMap<>();
static {
for (AbortType abortType : AbortType.values()) {
Asserts.assertFalse(LOOKUP_MAP.containsKey(abortType.type),
"Abort type values should be unique.");
LOOKUP_MAP.put(abortType.type, abortType);
}
}
private AbortType(int type) {
this.type = type;
}
public AbortProvoker provoker() {
return AbortType.createNewProvoker(this);
}
public static AbortType lookup(int type) {
Asserts.assertLT(type, AbortType.values().length,
"Unknown abort type.");
return LOOKUP_MAP.get(type);
}
private static AbortProvoker createNewProvoker(AbortType type) {
switch (type) {
case XABORT:
return new XAbortProvoker();
case MEM_CONFLICT:
return new MemoryConflictProvoker();
case BUF_OVERFLOW:
return new BufferOverflowProvoker();
case NESTED_ABORT:
return new NestedAbortProvoker();
default:
throw new RuntimeException("No provoker exists for type "
+ type.name());
}
}
@Override
public String toString() {
return Integer.toString(type);
}
}
package com.sun.java.swing.action;
public class AboutAction extends DelegateAction
{
public AboutAction()
{
this("general/About16.gif");
}
public AboutAction(String iconPath)
{
super("About...", ActionManager.getIcon(iconPath));
putValue("ActionCommandKey", "about-command");
putValue("ShortDescription", "About...");
putValue("LongDescription", "System information and version of the application.");
putValue("MnemonicKey", VALUE_MNEMONIC);
}
public static final String VALUE_COMMAND = "about-command";
public static final String VALUE_NAME = "About...";
public static final String VALUE_SMALL_ICON = "general/About16.gif";
public static final String VALUE_LARGE_ICON = "general/About24.gif";
public static final Integer VALUE_MNEMONIC = 65;
public static final String VALUE_SHORT_DESCRIPTION = "About...";
public static final String VALUE_LONG_DESCRIPTION = "System information and version of the application.";
}
package sun.tools.jconsole;
import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Desktop;
import java.awt.FlowLayout;
import java.awt.Graphics2D;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.event.ActionEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.geom.Rectangle2D;
import java.beans.PropertyVetoException;
import java.net.URI;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.BorderFactory;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JEditorPane;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultHighlighter;
import javax.swing.text.Document;
import javax.swing.text.Highlighter;
import javax.swing.text.JTextComponent;
import javax.swing.text.View;
import static java.awt.BorderLayout.CENTER;
import static java.awt.BorderLayout.NORTH;
import static java.awt.BorderLayout.SOUTH;
import static sun.tools.jconsole.Utilities.setAccessibleDescription;
import static sun.tools.jconsole.Utilities.setAccessibleName;
@SuppressWarnings("serial")
public class AboutDialog extends InternalDialog {
private static final Color textColor     = new Color(87,   88,  89);
private static final Color bgColor       = new Color(232, 237, 241);
private static final Color borderColor   = Color.black;
private Icon mastheadIcon =
new MastheadIcon(Messages.HELP_ABOUT_DIALOG_MASTHEAD_TITLE);
private static AboutDialog aboutDialog;
private JLabel statusBar;
private Action closeAction;
private JEditorPane helpLink;
private final String urlStr = getOnlineDocUrl();
public AboutDialog(JConsole jConsole) {
super(jConsole, Messages.HELP_ABOUT_DIALOG_TITLE, false);
setAccessibleDescription(this, Messages.HELP_ABOUT_DIALOG_ACCESSIBLE_DESCRIPTION);
setDefaultCloseOperation(HIDE_ON_CLOSE);
setResizable(false);
JComponent cp = (JComponent)getContentPane();
createActions();
JLabel mastheadLabel = new JLabel(mastheadIcon);
setAccessibleName(mastheadLabel,
Messages.HELP_ABOUT_DIALOG_MASTHEAD_ACCESSIBLE_NAME);
JPanel mainPanel = new TPanel(0, 0);
mainPanel.add(mastheadLabel, NORTH);
String jConsoleVersion = Version.getVersion();
String vmName = System.getProperty("java.vm.name");
String vmVersion = System.getProperty("java.vm.version");
String locUrlStr = urlStr;
if (isBrowseSupported()) {
locUrlStr = "<a style='color:#35556b' href=\"" + locUrlStr + "\">" + locUrlStr + "</a>";
}
JPanel infoAndLogoPanel = new JPanel(new BorderLayout(10, 10));
infoAndLogoPanel.setBackground(bgColor);
String colorStr = String.format("%06x", textColor.getRGB() & 0xFFFFFF);
helpLink = new JEditorPane("text/html",
"<html><font color=#"+ colorStr + ">" +
Resources.format(Messages.HELP_ABOUT_DIALOG_JCONSOLE_VERSION, jConsoleVersion) +
"<p>" + Resources.format(Messages.HELP_ABOUT_DIALOG_JAVA_VERSION, (vmName +", "+ vmVersion)) +
"<p>" + locUrlStr + "</html>");
helpLink.setOpaque(false);
helpLink.setEditable(false);
helpLink.setForeground(textColor);
mainPanel.setBorder(BorderFactory.createLineBorder(borderColor));
infoAndLogoPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
helpLink.addKeyListener(new KeyAdapter() {
@Override
public void keyPressed(KeyEvent e) {
if ((e.getKeyCode() == KeyEvent.VK_ENTER) || (e.getKeyCode() == KeyEvent.VK_SPACE)) {
browse(urlStr);
e.consume();
}
}
});
helpLink.addFocusListener(new FocusListener() {
@Override
public void focusGained(FocusEvent e) {
highlight();
}
@Override
public void focusLost(FocusEvent e) {
removeHighlights();
}
});
helpLink.addHyperlinkListener(new HyperlinkListener() {
public void hyperlinkUpdate(HyperlinkEvent e) {
if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
browse(e.getDescription());
}
}
});
infoAndLogoPanel.add(helpLink, NORTH);
ImageIcon brandLogoIcon = new ImageIcon(getClass().getResource("resources/brandlogo.png"));
JLabel brandLogo = new JLabel(brandLogoIcon, JLabel.LEADING);
JButton closeButton = new JButton(closeAction);
JPanel bottomPanel = new TPanel(0, 0);
JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.TRAILING));
buttonPanel.setOpaque(false);
mainPanel.add(infoAndLogoPanel, CENTER);
cp.add(bottomPanel, SOUTH);
infoAndLogoPanel.add(brandLogo, SOUTH);
buttonPanel.setBorder(new EmptyBorder(2, 12, 2, 12));
buttonPanel.add(closeButton);
bottomPanel.add(buttonPanel, NORTH);
statusBar = new JLabel(" ");
bottomPanel.add(statusBar, SOUTH);
cp.add(mainPanel, NORTH);
pack();
setLocationRelativeTo(jConsole);
Utilities.updateTransparency(this);
}
public void highlight() {
try {
removeHighlights();
Highlighter hilite = helpLink.getHighlighter();
Document doc = helpLink.getDocument();
String text = doc.getText(0, doc.getLength());
int pos = text.indexOf(urlStr);
hilite.addHighlight(pos, pos + urlStr.length(), new HighlightPainter());
} catch (BadLocationException e) {
}
}
public void removeHighlights() {
Highlighter hilite = helpLink.getHighlighter();
hilite.removeAllHighlights();
}
public void showDialog() {
statusBar.setText(" ");
setVisible(true);
try {
setSelected(true);
} catch (PropertyVetoException e) {
}
}
private static AboutDialog getAboutDialog(JConsole jConsole) {
if (aboutDialog == null) {
aboutDialog = new AboutDialog(jConsole);
}
return aboutDialog;
}
static void showAboutDialog(JConsole jConsole) {
getAboutDialog(jConsole).showDialog();
}
static void browseUserGuide(JConsole jConsole) {
getAboutDialog(jConsole).browse(getOnlineDocUrl());
}
static boolean isBrowseSupported() {
return (Desktop.isDesktopSupported() &&
Desktop.getDesktop().isSupported(Desktop.Action.BROWSE));
}
void browse(String urlStr) {
try {
Desktop.getDesktop().browse(new URI(urlStr));
} catch (Exception ex) {
showDialog();
statusBar.setText(ex.getLocalizedMessage());
if (JConsole.isDebug()) {
ex.printStackTrace();
}
}
}
private void createActions() {
closeAction = new AbstractAction(Messages.CLOSE) {
public void actionPerformed(ActionEvent ev) {
setVisible(false);
statusBar.setText("");
}
};
}
private static String getOnlineDocUrl() {
String version = Integer.toString(Runtime.version().feature());
return Resources.format(Messages.HELP_ABOUT_DIALOG_USER_GUIDE_LINK_URL,
version);
}
private static class TPanel extends JPanel {
TPanel(int hgap, int vgap) {
super(new BorderLayout(hgap, vgap));
setOpaque(false);
}
}
private static class HighlightPainter
extends DefaultHighlighter.DefaultHighlightPainter {
public HighlightPainter() {
super(null);
}
@Override
public Shape paintLayer(Graphics g, int offs0, int offs1, Shape bounds,
JTextComponent c, View view) {
g.setColor(c.getSelectionColor());
Rectangle alloc;
if (bounds instanceof Rectangle) {
alloc = (Rectangle)bounds;
} else {
alloc = bounds.getBounds();
}
Graphics2D g2d = (Graphics2D)g;
float[] dash = { 2F, 2F };
Stroke dashedStroke = new BasicStroke(1F, BasicStroke.CAP_SQUARE,
BasicStroke.JOIN_MITER, 3F, dash, 0F);
g2d.fill(dashedStroke.createStrokedShape(
new Rectangle2D.Float(alloc.x, alloc.y,
alloc.width - 1, alloc.height - 1)));
return alloc;
}
}
}
package java.awt.desktop;
import java.awt.Desktop;
import java.awt.GraphicsEnvironment;
import java.awt.HeadlessException;
import java.io.Serial;
public final class AboutEvent extends AppEvent {
@Serial
private static final long serialVersionUID = -5987180734802756477L;
public AboutEvent() {
}
}
package java.awt.desktop;
public interface AboutHandler {
public void handleAbout(AboutEvent e);
}
package com.sun.jdi;
public class AbsentInformationException extends Exception {
private static final long serialVersionUID = 4988939309582416373L;
public AbsentInformationException() {
super();
}
public AbsentInformationException(String s) {
super(s);
}
}
package com.sun.org.apache.xalan.internal.xsltc.dom;
import com.sun.org.apache.xalan.internal.xsltc.runtime.BasisLibrary;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.dtm.ref.DTMAxisIteratorBase;
import com.sun.org.apache.xml.internal.dtm.ref.DTMDefaultBase;
public final class AbsoluteIterator extends DTMAxisIteratorBase {
private DTMAxisIterator _source;
public AbsoluteIterator(DTMAxisIterator source) {
_source = source;
}
public void setRestartable(boolean isRestartable) {
_isRestartable = isRestartable;
_source.setRestartable(isRestartable);
}
public DTMAxisIterator setStartNode(int node) {
_startNode = DTMDefaultBase.ROOTNODE;
if (_isRestartable) {
_source.setStartNode(_startNode);
resetPosition();
}
return this;
}
public int next() {
return returnNode(_source.next());
}
public DTMAxisIterator cloneIterator() {
try {
final AbsoluteIterator clone = (AbsoluteIterator) super.clone();
clone._source = _source.cloneIterator();                clone.resetPosition();
clone._isRestartable = false;
return clone;
}
catch (CloneNotSupportedException e) {
BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
e.toString());
return null;
}
}
public DTMAxisIterator reset() {
_source.reset();
return resetPosition();
}
public void setMark() {
_source.setMark();
}
public void gotoMark() {
_source.gotoMark();
}
}
package com.sun.org.apache.xalan.internal.xsltc.compiler;
import com.sun.org.apache.bcel.internal.generic.ALOAD;
import com.sun.org.apache.bcel.internal.generic.ASTORE;
import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
import com.sun.org.apache.bcel.internal.generic.INVOKEINTERFACE;
import com.sun.org.apache.bcel.internal.generic.INVOKESPECIAL;
import com.sun.org.apache.bcel.internal.generic.InstructionList;
import com.sun.org.apache.bcel.internal.generic.LocalVariableGen;
import com.sun.org.apache.bcel.internal.generic.NEW;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ClassGenerator;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.MethodGenerator;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.NodeType;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
final class AbsoluteLocationPath extends Expression {
private Expression _path;
public AbsoluteLocationPath() {
_path = null;
}
public AbsoluteLocationPath(Expression path) {
_path = path;
if (path != null) {
_path.setParent(this);
}
}
public void setParser(Parser parser) {
super.setParser(parser);
if (_path != null) {
_path.setParser(parser);
}
}
public Expression getPath() {
return(_path);
}
public String toString() {
return "AbsoluteLocationPath(" +
(_path != null ? _path.toString() : "null") + ')';
}
public Type typeCheck(SymbolTable stable) throws TypeCheckError {
if (_path != null) {
final Type ptype = _path.typeCheck(stable);
if (ptype instanceof NodeType) {                            _path = new CastExpr(_path, Type.NodeSet);
}
}
return _type = Type.NodeSet;
}
public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
final ConstantPoolGen cpg = classGen.getConstantPool();
final InstructionList il = methodGen.getInstructionList();
if (_path != null) {
final int initAI = cpg.addMethodref(ABSOLUTE_ITERATOR,
"<init>",
"("
+ NODE_ITERATOR_SIG
+ ")V");
_path.translate(classGen, methodGen);
LocalVariableGen relPathIterator
= methodGen.addLocalVariable("abs_location_path_tmp",
Util.getJCRefType(NODE_ITERATOR_SIG),
null, null);
relPathIterator.setStart(
il.append(new ASTORE(relPathIterator.getIndex())));
il.append(new NEW(cpg.addClass(ABSOLUTE_ITERATOR)));
il.append(DUP);
relPathIterator.setEnd(
il.append(new ALOAD(relPathIterator.getIndex())));
il.append(new INVOKESPECIAL(initAI));
}
else {
final int gitr = cpg.addInterfaceMethodref(DOM_INTF,
"getIterator",
"()"+NODE_ITERATOR_SIG);
il.append(methodGen.loadDOM());
il.append(new INVOKEINTERFACE(gitr, 1));
}
}
}
package com.sun.org.apache.xalan.internal.xsltc.compiler;
import com.sun.org.apache.bcel.internal.generic.BranchHandle;
import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
import com.sun.org.apache.bcel.internal.generic.GOTO_W;
import com.sun.org.apache.bcel.internal.generic.IF_ICMPEQ;
import com.sun.org.apache.bcel.internal.generic.ILOAD;
import com.sun.org.apache.bcel.internal.generic.INVOKEINTERFACE;
import com.sun.org.apache.bcel.internal.generic.ISTORE;
import com.sun.org.apache.bcel.internal.generic.InstructionHandle;
import com.sun.org.apache.bcel.internal.generic.InstructionList;
import com.sun.org.apache.bcel.internal.generic.LocalVariableGen;
import com.sun.org.apache.bcel.internal.generic.PUSH;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ClassGenerator;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.MethodGenerator;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
import com.sun.org.apache.xml.internal.dtm.DTM;
final class AbsolutePathPattern extends LocationPathPattern {
private final RelativePathPattern _left;
public AbsolutePathPattern(RelativePathPattern left) {
_left = left;
if (left != null) {
left.setParent(this);
}
}
public void setParser(Parser parser) {
super.setParser(parser);
if (_left != null)
_left.setParser(parser);
}
public Type typeCheck(SymbolTable stable) throws TypeCheckError {
return _left == null ? Type.Root : _left.typeCheck(stable);
}
public boolean isWildcard() {
return false;
}
public StepPattern getKernelPattern() {
return _left != null ? _left.getKernelPattern() : null;
}
public void reduceKernelPattern() {
_left.reduceKernelPattern();
}
public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
final ConstantPoolGen cpg = classGen.getConstantPool();
final InstructionList il = methodGen.getInstructionList();
if (_left != null) {
if (_left instanceof StepPattern) {
final LocalVariableGen local =
methodGen.addLocalVariable2("apptmp",
Util.getJCRefType(NODE_SIG),
null);
il.append(DUP);
local.setStart(il.append(new ISTORE(local.getIndex())));
_left.translate(classGen, methodGen);
il.append(methodGen.loadDOM());
local.setEnd(il.append(new ILOAD(local.getIndex())));
methodGen.removeLocalVariable(local);
}
else {
_left.translate(classGen, methodGen);
}
}
final int getParent = cpg.addInterfaceMethodref(DOM_INTF,
GET_PARENT,
GET_PARENT_SIG);
final int getType = cpg.addInterfaceMethodref(DOM_INTF,
"getExpandedTypeID",
"(I)I");
InstructionHandle begin = il.append(methodGen.loadDOM());
il.append(SWAP);
il.append(new INVOKEINTERFACE(getParent, 2));
if (_left instanceof AncestorPattern) {
il.append(methodGen.loadDOM());
il.append(SWAP);
}
il.append(new INVOKEINTERFACE(getType, 2));
il.append(new PUSH(cpg, DTM.DOCUMENT_NODE));
final BranchHandle skip = il.append(new IF_ICMPEQ(null));
_falseList.add(il.append(new GOTO_W(null)));
skip.setTarget(il.append(NOP));
if (_left != null) {
_left.backPatchTrueList(begin);
if (_left instanceof AncestorPattern) {
final AncestorPattern ancestor = (AncestorPattern) _left;
_falseList.backPatch(ancestor.getLoopHandle());                     }
_falseList.append(_left._falseList);
}
}
public String toString() {
return "absolutePathPattern(" + (_left != null ? _left.toString() : ")");
}
}
package sun.nio.fs;
import java.nio.file.attribute.*;
import java.util.*;
import java.io.IOException;
abstract class AbstractAclFileAttributeView
implements AclFileAttributeView, DynamicFileAttributeView
{
private static final String OWNER_NAME = "owner";
private static final String ACL_NAME = "acl";
@Override
public final String name() {
return "acl";
}
@Override
@SuppressWarnings("unchecked")
public final void setAttribute(String attribute, Object value)
throws IOException
{
if (attribute.equals(OWNER_NAME)) {
setOwner((UserPrincipal)value);
return;
}
if (attribute.equals(ACL_NAME)) {
setAcl((List<AclEntry>)value);
return;
}
throw new IllegalArgumentException("'" + name() + ":" +
attribute + "' not recognized");
}
@Override
public final Map<String,Object> readAttributes(String[] attributes)
throws IOException
{
boolean acl = false;
boolean owner = false;
for (String attribute: attributes) {
if (attribute.equals("*")) {
owner = true;
acl = true;
continue;
}
if (attribute.equals(ACL_NAME)) {
acl = true;
continue;
}
if (attribute.equals(OWNER_NAME)) {
owner = true;
continue;
}
throw new IllegalArgumentException("'" + name() + ":" +
attribute + "' not recognized");
}
Map<String,Object> result = new HashMap<>(2);
if (acl)
result.put(ACL_NAME, getAcl());
if (owner)
result.put(OWNER_NAME, getOwner());
return Collections.unmodifiableMap(result);
}
}
package javax.swing;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serial;
import java.io.Serializable;
import java.security.AccessController;
import javax.swing.event.SwingPropertyChangeSupport;
import sun.security.action.GetPropertyAction;
@SuppressWarnings("serial") public abstract class AbstractAction implements Action, Cloneable, Serializable
{
private static Boolean RECONFIGURE_ON_NULL;
protected boolean enabled = true;
private transient ArrayTable arrayTable;
@SuppressWarnings("removal")
static boolean shouldReconfigure(PropertyChangeEvent e) {
if (e.getPropertyName() == null) {
synchronized(AbstractAction.class) {
if (RECONFIGURE_ON_NULL == null) {
RECONFIGURE_ON_NULL = Boolean.valueOf(
AccessController.doPrivileged(new GetPropertyAction(
"swing.actions.reconfigureOnNull", "false")));
}
return RECONFIGURE_ON_NULL;
}
}
return false;
}
static void setEnabledFromAction(JComponent c, Action a) {
c.setEnabled((a != null) ? a.isEnabled() : true);
}
static void setToolTipTextFromAction(JComponent c, Action a) {
c.setToolTipText(a != null ?
(String)a.getValue(Action.SHORT_DESCRIPTION) : null);
}
static boolean hasSelectedKey(Action a) {
return (a != null && a.getValue(Action.SELECTED_KEY) != null);
}
static boolean isSelected(Action a) {
return Boolean.TRUE.equals(a.getValue(Action.SELECTED_KEY));
}
public AbstractAction() {
}
public AbstractAction(String name) {
putValue(Action.NAME, name);
}
public AbstractAction(String name, Icon icon) {
this(name);
putValue(Action.SMALL_ICON, icon);
}
public Object getValue(String key) {
if (key == "enabled") {
return enabled;
}
if (arrayTable == null) {
return null;
}
return arrayTable.get(key);
}
public void putValue(String key, Object newValue) {
Object oldValue = null;
if (key == "enabled") {
if (!(newValue instanceof Boolean)) {
newValue = false;
}
oldValue = enabled;
enabled = (Boolean)newValue;
} else {
if (arrayTable == null) {
arrayTable = new ArrayTable();
}
if (arrayTable.containsKey(key))
oldValue = arrayTable.get(key);
if (newValue == null) {
arrayTable.remove(key);
} else {
arrayTable.put(key,newValue);
}
}
firePropertyChange(key, oldValue, newValue);
}
public boolean isEnabled() {
return enabled;
}
public void setEnabled(boolean newValue) {
boolean oldValue = this.enabled;
if (oldValue != newValue) {
this.enabled = newValue;
firePropertyChange("enabled",
Boolean.valueOf(oldValue), Boolean.valueOf(newValue));
}
}
public Object[] getKeys() {
if (arrayTable == null) {
return null;
}
Object[] keys = new Object[arrayTable.size()];
arrayTable.getKeys(keys);
return keys;
}
protected SwingPropertyChangeSupport changeSupport;
protected void firePropertyChange(String propertyName, Object oldValue, Object newValue) {
if (changeSupport == null ||
(oldValue != null && newValue != null && oldValue.equals(newValue))) {
return;
}
changeSupport.firePropertyChange(propertyName, oldValue, newValue);
}
public synchronized void addPropertyChangeListener(PropertyChangeListener listener) {
if (changeSupport == null) {
changeSupport = new SwingPropertyChangeSupport(this);
}
changeSupport.addPropertyChangeListener(listener);
}
public synchronized void removePropertyChangeListener(PropertyChangeListener listener) {
if (changeSupport == null) {
return;
}
changeSupport.removePropertyChangeListener(listener);
}
public synchronized PropertyChangeListener[] getPropertyChangeListeners() {
if (changeSupport == null) {
return new PropertyChangeListener[0];
}
return changeSupport.getPropertyChangeListeners();
}
protected Object clone() throws CloneNotSupportedException {
AbstractAction newAction = (AbstractAction)super.clone();
synchronized(this) {
if (arrayTable != null) {
newAction.arrayTable = (ArrayTable)arrayTable.clone();
}
}
return newAction;
}
@Serial
private void writeObject(ObjectOutputStream s) throws IOException {
s.defaultWriteObject();
ArrayTable.writeArrayTable(s, arrayTable);
}
@Serial
private void readObject(ObjectInputStream s) throws ClassNotFoundException,
IOException {
s.defaultReadObject();
for (int counter = s.readInt() - 1; counter >= 0; counter--) {
putValue((String)s.readObject(), s.readObject());
}
}
}
package sun.security.util;
import java.security.AccessController;
import java.security.AlgorithmConstraints;
import java.security.PrivilegedAction;
import java.security.Security;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.TreeSet;
import java.util.List;
import java.util.Set;
public abstract class AbstractAlgorithmConstraints
implements AlgorithmConstraints {
protected final AlgorithmDecomposer decomposer;
protected AbstractAlgorithmConstraints(AlgorithmDecomposer decomposer) {
this.decomposer = decomposer;
}
static Set<String> getAlgorithms(String propertyName) {
@SuppressWarnings("removal")
String property = AccessController.doPrivileged(
new PrivilegedAction<String>() {
@Override
public String run() {
return Security.getProperty(propertyName);
}
});
String[] algorithmsInProperty = null;
if (property != null && !property.isEmpty()) {
if (property.length() >= 2 && property.charAt(0) == '"' &&
property.charAt(property.length() - 1) == '"') {
property = property.substring(1, property.length() - 1);
}
algorithmsInProperty = property.split(",");
for (int i = 0; i < algorithmsInProperty.length; i++) {
algorithmsInProperty[i] = algorithmsInProperty[i].trim();
}
}
if (algorithmsInProperty == null) {
return Collections.emptySet();
}
Set<String> algorithmsInPropertySet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
algorithmsInPropertySet.addAll(Arrays.asList(algorithmsInProperty));
return algorithmsInPropertySet;
}
static boolean checkAlgorithm(Set<String> algorithms, String algorithm,
AlgorithmDecomposer decomposer) {
if (algorithm == null || algorithm.isEmpty()) {
throw new IllegalArgumentException("No algorithm name specified");
}
if (algorithms.contains(algorithm)) {
return false;
}
Set<String> elements = decomposer.decompose(algorithm);
for (String element : elements) {
if (algorithms.contains(element)) {
return false;
}
}
return true;
}
}
package javax.lang.model.util;
import static javax.lang.model.SourceVersion.*;
import javax.lang.model.SourceVersion;
import javax.annotation.processing.SupportedSourceVersion;
@SupportedSourceVersion(RELEASE_20)
public abstract class AbstractAnnotationValueVisitor14<R, P> extends AbstractAnnotationValueVisitor9<R, P> {
protected AbstractAnnotationValueVisitor14() {
super();
}
}
package javax.lang.model.util;
import javax.lang.model.element.*;
import static javax.lang.model.SourceVersion.*;
import javax.lang.model.SourceVersion;
import javax.annotation.processing.SupportedSourceVersion;
@SupportedSourceVersion(RELEASE_6)
public abstract class AbstractAnnotationValueVisitor6<R, P>
implements AnnotationValueVisitor<R, P> {
@Deprecated(since="9")
protected AbstractAnnotationValueVisitor6() {}
public final R visit(AnnotationValue av, P p) {
return av.accept(this, p);
}
public final R visit(AnnotationValue av) {
return av.accept(this, null);
}
@Override
public R visitUnknown(AnnotationValue av, P p) {
throw new UnknownAnnotationValueException(av, p);
}
}
package javax.lang.model.util;
import static javax.lang.model.SourceVersion.*;
import javax.lang.model.SourceVersion;
import javax.annotation.processing.SupportedSourceVersion;
@SupportedSourceVersion(RELEASE_7)
public abstract class AbstractAnnotationValueVisitor7<R, P> extends AbstractAnnotationValueVisitor6<R, P> {
@Deprecated(since="12")
protected AbstractAnnotationValueVisitor7() {
super();     }
}
package javax.lang.model.util;
import static javax.lang.model.SourceVersion.*;
import javax.lang.model.SourceVersion;
import javax.annotation.processing.SupportedSourceVersion;
@SupportedSourceVersion(RELEASE_8)
public abstract class AbstractAnnotationValueVisitor8<R, P> extends AbstractAnnotationValueVisitor7<R, P> {
@SuppressWarnings("deprecation")     protected AbstractAnnotationValueVisitor8() {
super();
}
}
package javax.lang.model.util;
import static javax.lang.model.SourceVersion.*;
import javax.lang.model.SourceVersion;
import javax.annotation.processing.SupportedSourceVersion;
@SupportedSourceVersion(RELEASE_14)
public abstract class AbstractAnnotationValueVisitor9<R, P> extends AbstractAnnotationValueVisitor8<R, P> {
protected AbstractAnnotationValueVisitor9() {
super();
}
}
package jdk.jpackage.internal;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.util.Map;
import java.util.List;
import static jdk.jpackage.internal.OverridableResource.createResource;
import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;
import static jdk.jpackage.internal.StandardBundlerParam.ICON;
import static jdk.jpackage.internal.StandardBundlerParam.SOURCE_DIR;
import static jdk.jpackage.internal.StandardBundlerParam.APP_CONTENT;
import jdk.jpackage.internal.resources.ResourceLocator;
public abstract class AbstractAppImageBuilder {
private final Path root;
protected final ApplicationLayout appLayout;
public AbstractAppImageBuilder(Path root) {
this.root = root;
appLayout = ApplicationLayout.platformAppImage().resolveAt(root);
}
public InputStream getResourceAsStream(String name) {
return ResourceLocator.class.getResourceAsStream(name);
}
public abstract void prepareApplicationFiles(
Map<String, ? super Object> params) throws IOException;
protected void writeCfgFile(Map<String, ? super Object> params) throws
IOException {
new CfgFile().initFromParams(params).create(root);
}
ApplicationLayout getAppLayout() {
return appLayout;
}
protected void copyApplication(Map<String, ? super Object> params)
throws IOException {
Path inputPath = SOURCE_DIR.fetchFrom(params);
if (inputPath != null) {
IOUtils.copyRecursive(SOURCE_DIR.fetchFrom(params),
appLayout.appDirectory());
}
AppImageFile.save(root, params);
List<String> items = APP_CONTENT.fetchFrom(params);
for (String item : items) {
IOUtils.copyRecursive(Path.of(item),
appLayout.contentDirectory().resolve(Path.of(item).getFileName()));
}
}
public static OverridableResource createIconResource(String defaultIconName,
BundlerParamInfo<Path> iconParam, Map<String, ? super Object> params,
Map<String, ? super Object> mainParams) throws IOException {
if (mainParams != null) {
params = AddLauncherArguments.merge(mainParams, params, ICON.getID(),
iconParam.getID());
}
final String resourcePublicName = APP_NAME.fetchFrom(params)
+ IOUtils.getSuffix(Path.of(defaultIconName));
IconType iconType = getLauncherIconType(params);
if (iconType == IconType.NoIcon) {
return null;
}
OverridableResource resource = createResource(defaultIconName, params)
.setCategory("icon")
.setExternal(iconParam.fetchFrom(params))
.setPublicName(resourcePublicName);
if (iconType == IconType.DefaultOrResourceDirIcon && mainParams != null) {
final Path nullPath = null;
if (resource.saveToFile(nullPath)
!= OverridableResource.Source.ResourceDir) {
resource = createIconResource(defaultIconName, iconParam,
mainParams, null).setLogPublicName(resourcePublicName);
}
}
return resource;
}
private enum IconType { DefaultOrResourceDirIcon, CustomIcon, NoIcon };
private static IconType getLauncherIconType(Map<String, ? super Object> params) {
Path launcherIcon = ICON.fetchFrom(params);
if (launcherIcon == null) {
return IconType.DefaultOrResourceDirIcon;
}
if (launcherIcon.toFile().getName().isEmpty()) {
return IconType.NoIcon;
}
return IconType.CustomIcon;
}
}
package jdk.internal.net.http;
import java.net.InetSocketAddress;
import java.util.Arrays;
import java.util.ArrayDeque;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import javax.net.ssl.SNIHostName;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLParameters;
import jdk.internal.net.http.common.SSLTube;
import jdk.internal.net.http.common.Log;
import jdk.internal.net.http.common.Utils;
import static jdk.internal.net.http.common.Utils.ServerName;
abstract class AbstractAsyncSSLConnection extends HttpConnection
{
protected final SSLEngine engine;
protected final String serverName;
protected final SSLParameters sslParameters;
private static final boolean disableHostnameVerification
= Utils.isHostnameVerificationDisabled();
AbstractAsyncSSLConnection(InetSocketAddress addr,
HttpClientImpl client,
ServerName serverName, int port,
String[] alpn) {
super(addr, client);
this.serverName = serverName.getName();
SSLContext context = client.theSSLContext();
sslParameters = createSSLParameters(client, serverName, alpn);
Log.logParams(sslParameters);
engine = createEngine(context, serverName.getName(), port, sslParameters);
}
abstract SSLTube getConnectionFlow();
final CompletableFuture<String> getALPN() {
return getConnectionFlow().getALPN();
}
final SSLEngine getEngine() { return engine; }
private static boolean contains(String[] rr, String target) {
for (String s : rr)
if (target.equalsIgnoreCase(s))
return true;
return false;
}
private static SSLParameters createSSLParameters(HttpClientImpl client,
ServerName serverName,
String[] alpn) {
SSLParameters sslp = client.sslParameters();
SSLParameters sslParameters = Utils.copySSLParameters(sslp);
if (alpn != null && alpn.length != 0 && !contains(alpn, "http/1.1")) {
ArrayDeque<String> l = new ArrayDeque<>();
for (String proto : sslParameters.getProtocols()) {
if (!proto.startsWith("SSL") && !proto.endsWith("v1.1") && !proto.endsWith("v1")) {
l.add(proto);
}
}
String[] a1 = l.toArray(new String[0]);
sslParameters.setProtocols(a1);
}
if (!disableHostnameVerification)
sslParameters.setEndpointIdentificationAlgorithm("HTTPS");
if (alpn != null) {
Log.logSSL("AbstractAsyncSSLConnection: Setting application protocols: {0}",
Arrays.toString(alpn));
sslParameters.setApplicationProtocols(alpn);
} else {
Log.logSSL("AbstractAsyncSSLConnection: no applications set!");
}
if (!serverName.isLiteral()) {
String name = serverName.getName();
if (name != null && name.length() > 0) {
sslParameters.setServerNames(List.of(new SNIHostName(name)));
}
}
return sslParameters;
}
private static SSLEngine createEngine(SSLContext context, String serverName, int port,
SSLParameters sslParameters) {
SSLEngine engine = context.createSSLEngine(serverName, port);
engine.setUseClientMode(true);
engine.setSSLParameters(sslParameters);
return engine;
}
@Override
final boolean isSecure() {
return true;
}
}
package sun.nio.fs;
import java.nio.file.attribute.*;
import java.util.*;
import java.io.IOException;
abstract class AbstractBasicFileAttributeView
implements BasicFileAttributeView, DynamicFileAttributeView
{
private static final String SIZE_NAME = "size";
private static final String CREATION_TIME_NAME = "creationTime";
private static final String LAST_ACCESS_TIME_NAME = "lastAccessTime";
private static final String LAST_MODIFIED_TIME_NAME = "lastModifiedTime";
private static final String FILE_KEY_NAME = "fileKey";
private static final String IS_DIRECTORY_NAME = "isDirectory";
private static final String IS_REGULAR_FILE_NAME = "isRegularFile";
private static final String IS_SYMBOLIC_LINK_NAME = "isSymbolicLink";
private static final String IS_OTHER_NAME = "isOther";
static final Set<String> basicAttributeNames =
Util.newSet(SIZE_NAME,
CREATION_TIME_NAME,
LAST_ACCESS_TIME_NAME,
LAST_MODIFIED_TIME_NAME,
FILE_KEY_NAME,
IS_DIRECTORY_NAME,
IS_REGULAR_FILE_NAME,
IS_SYMBOLIC_LINK_NAME,
IS_OTHER_NAME);
protected AbstractBasicFileAttributeView() { }
@Override
public String name() {
return "basic";
}
@Override
public void setAttribute(String attribute, Object value)
throws IOException
{
if (attribute.equals(LAST_MODIFIED_TIME_NAME)) {
setTimes((FileTime)value, null, null);
return;
}
if (attribute.equals(LAST_ACCESS_TIME_NAME)) {
setTimes(null, (FileTime)value, null);
return;
}
if (attribute.equals(CREATION_TIME_NAME)) {
setTimes(null, null, (FileTime)value);
return;
}
throw new IllegalArgumentException("'" + name() + ":" +
attribute + "' not recognized");
}
static class AttributesBuilder {
private Set<String> names = new HashSet<>();
private Map<String,Object> map = new HashMap<>();
private boolean copyAll;
private AttributesBuilder(Set<String> allowed, String[] requested) {
for (String name: requested) {
if (name.equals("*")) {
copyAll = true;
} else {
if (!allowed.contains(name))
throw new IllegalArgumentException("'" + name + "' not recognized");
names.add(name);
}
}
}
static AttributesBuilder create(Set<String> allowed, String[] requested) {
return new AttributesBuilder(allowed, requested);
}
boolean match(String name) {
return copyAll || names.contains(name);
}
void add(String name, Object value) {
map.put(name, value);
}
Map<String,Object> unmodifiableMap() {
return Collections.unmodifiableMap(map);
}
}
final void addRequestedBasicAttributes(BasicFileAttributes attrs,
AttributesBuilder builder)
{
if (builder.match(SIZE_NAME))
builder.add(SIZE_NAME, attrs.size());
if (builder.match(CREATION_TIME_NAME))
builder.add(CREATION_TIME_NAME, attrs.creationTime());
if (builder.match(LAST_ACCESS_TIME_NAME))
builder.add(LAST_ACCESS_TIME_NAME, attrs.lastAccessTime());
if (builder.match(LAST_MODIFIED_TIME_NAME))
builder.add(LAST_MODIFIED_TIME_NAME, attrs.lastModifiedTime());
if (builder.match(FILE_KEY_NAME))
builder.add(FILE_KEY_NAME, attrs.fileKey());
if (builder.match(IS_DIRECTORY_NAME))
builder.add(IS_DIRECTORY_NAME, attrs.isDirectory());
if (builder.match(IS_REGULAR_FILE_NAME))
builder.add(IS_REGULAR_FILE_NAME, attrs.isRegularFile());
if (builder.match(IS_SYMBOLIC_LINK_NAME))
builder.add(IS_SYMBOLIC_LINK_NAME, attrs.isSymbolicLink());
if (builder.match(IS_OTHER_NAME))
builder.add(IS_OTHER_NAME, attrs.isOther());
}
@Override
public Map<String,Object> readAttributes(String[] requested)
throws IOException
{
AttributesBuilder builder =
AttributesBuilder.create(basicAttributeNames, requested);
addRequestedBasicAttributes(readAttributes(), builder);
return builder.unmodifiableMap();
}
}
package javax.swing.border;
import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.Component;
import java.io.Serializable;
@SuppressWarnings("serial")
public abstract class AbstractBorder implements Border, Serializable
{
protected AbstractBorder() {}
public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {
}
public Insets getBorderInsets(Component c)       {
return getBorderInsets(c, new Insets(0, 0, 0, 0));
}
public Insets getBorderInsets(Component c, Insets insets) {
insets.left = insets.top = insets.right = insets.bottom = 0;
return insets;
}
public boolean isBorderOpaque() { return false; }
public Rectangle getInteriorRectangle(Component c, int x, int y, int width, int height) {
return getInteriorRectangle(c, this, x, y, width, height);
}
public static Rectangle getInteriorRectangle(Component c, Border b, int x, int y, int width, int height) {
Insets insets;
if(b != null)
insets = b.getBorderInsets(c);
else
insets = new Insets(0, 0, 0, 0);
return new Rectangle(x + insets.left,
y + insets.top,
width - insets.right - insets.left,
height - insets.top - insets.bottom);
}
public int getBaseline(Component c, int width, int height) {
if (width < 0 || height < 0) {
throw new IllegalArgumentException(
"Width and height must be >= 0");
}
return -1;
}
public Component.BaselineResizeBehavior getBaselineResizeBehavior(
Component c) {
if (c == null) {
throw new NullPointerException("Component must be non-null");
}
return Component.BaselineResizeBehavior.OTHER;
}
static boolean isLeftToRight( Component c ) {
return c.getComponentOrientation().isLeftToRight();
}
}
package jdk.jfr.events;
import jdk.internal.misc.VM.BufferPool;
import jdk.internal.misc.VM;
import jdk.jfr.*;
@Category({ "Java Application", "Statistics" })
public abstract class AbstractBufferStatisticsEvent extends AbstractJDKEvent {
protected AbstractBufferStatisticsEvent(BufferPool bufferPool) {
count = bufferPool.getCount();
totalCapacity = bufferPool.getTotalCapacity();
memoryUsed = bufferPool.getMemoryUsed();
}
@Label("Count")
final long count;
@Label("Total Capacity")
@DataAmount
final long totalCapacity;
@Label("Memory Used")
@DataAmount
final long memoryUsed;
static BufferPool findPoolByName(String name) {
for (BufferPool pool : VM.getBufferPools()) {
if (pool.getName().equals(name)) {
return pool;
}
}
throw new InternalError("No buffer pool with name " + name);
}
}
package jdk.javadoc.internal.doclets.toolkit.builders;
import java.util.*;
import javax.lang.model.element.PackageElement;
import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
import jdk.javadoc.internal.doclets.toolkit.DocletException;
import jdk.javadoc.internal.doclets.toolkit.Messages;
import jdk.javadoc.internal.doclets.toolkit.Resources;
import jdk.javadoc.internal.doclets.toolkit.util.Utils;
public abstract class AbstractBuilder {
public static class Context {
final BaseConfiguration configuration;
final Set<PackageElement> containingPackagesSeen;
Context(BaseConfiguration configuration, Set<PackageElement> containingPackagesSeen) {
this.configuration = configuration;
this.containingPackagesSeen = containingPackagesSeen;
}
}
protected final BaseConfiguration configuration;
protected final BaseOptions options;
protected final BuilderFactory builderFactory;
protected final Messages messages;
protected final Resources resources;
protected final Utils utils;
protected final Set<PackageElement> containingPackagesSeen;
public AbstractBuilder(Context c) {
this.configuration = c.configuration;
this.options = configuration.getOptions();
this.builderFactory = configuration.getBuilderFactory();
this.messages = configuration.getMessages();
this.resources = configuration.getDocResources();
this.utils = configuration.utils;
this.containingPackagesSeen = c.containingPackagesSeen;
}
public abstract void build() throws DocletException;
}
package jdk.jpackage.internal;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Map;
abstract class AbstractBundler implements Bundler {
static final BundlerParamInfo<Path> IMAGES_ROOT =
new StandardBundlerParam<>(
"imagesRoot",
Path.class,
params ->
StandardBundlerParam.TEMP_ROOT.fetchFrom(params).resolve("images"),
(s, p) -> null);
@Override
public String toString() {
return getName();
}
@Override
public void cleanup(Map<String, ? super Object> params) {
try {
IOUtils.deleteRecursive(
StandardBundlerParam.TEMP_ROOT.fetchFrom(params));
} catch (IOException e) {
Log.verbose(e.getMessage());
}
}
}
package javax.swing;
import java.awt.*;
import java.awt.event.*;
import java.text.*;
import java.awt.geom.*;
import java.beans.JavaBean;
import java.beans.BeanProperty;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.beans.Transient;
import java.util.Enumeration;
import java.io.Serializable;
import javax.swing.event.*;
import javax.swing.plaf.*;
import javax.accessibility.*;
import javax.swing.text.*;
@JavaBean(defaultProperty = "UI")
@SuppressWarnings("serial") public abstract class AbstractButton extends JComponent implements ItemSelectable, SwingConstants {
public static final String MODEL_CHANGED_PROPERTY = "model";
public static final String TEXT_CHANGED_PROPERTY = "text";
public static final String MNEMONIC_CHANGED_PROPERTY = "mnemonic";
public static final String MARGIN_CHANGED_PROPERTY = "margin";
public static final String VERTICAL_ALIGNMENT_CHANGED_PROPERTY = "verticalAlignment";
public static final String HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY = "horizontalAlignment";
public static final String VERTICAL_TEXT_POSITION_CHANGED_PROPERTY = "verticalTextPosition";
public static final String HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY = "horizontalTextPosition";
public static final String BORDER_PAINTED_CHANGED_PROPERTY = "borderPainted";
public static final String FOCUS_PAINTED_CHANGED_PROPERTY = "focusPainted";
public static final String ROLLOVER_ENABLED_CHANGED_PROPERTY = "rolloverEnabled";
public static final String CONTENT_AREA_FILLED_CHANGED_PROPERTY = "contentAreaFilled";
public static final String ICON_CHANGED_PROPERTY = "icon";
public static final String PRESSED_ICON_CHANGED_PROPERTY = "pressedIcon";
public static final String SELECTED_ICON_CHANGED_PROPERTY = "selectedIcon";
public static final String ROLLOVER_ICON_CHANGED_PROPERTY = "rolloverIcon";
public static final String ROLLOVER_SELECTED_ICON_CHANGED_PROPERTY = "rolloverSelectedIcon";
public static final String DISABLED_ICON_CHANGED_PROPERTY = "disabledIcon";
public static final String DISABLED_SELECTED_ICON_CHANGED_PROPERTY = "disabledSelectedIcon";
protected ButtonModel model                = null;
private String     text                    = "";     private Insets     margin                  = null;
private Insets     defaultMargin           = null;
private Icon       defaultIcon             = null;
private Icon       pressedIcon             = null;
private Icon       disabledIcon            = null;
private Icon       selectedIcon            = null;
private Icon       disabledSelectedIcon    = null;
private Icon       rolloverIcon            = null;
private Icon       rolloverSelectedIcon    = null;
private boolean    paintBorder             = true;
private boolean    paintFocus              = true;
private boolean    rolloverEnabled         = false;
private boolean    contentAreaFilled         = true;
private int        verticalAlignment       = CENTER;
private int        horizontalAlignment     = CENTER;
private int        verticalTextPosition    = CENTER;
private int        horizontalTextPosition  = TRAILING;
private int        iconTextGap             = 4;
private int        mnemonic;
private int        mnemonicIndex           = -1;
private long       multiClickThreshhold    = 0;
private boolean    borderPaintedSet        = false;
private boolean    rolloverEnabledSet      = false;
private boolean    iconTextGapSet          = false;
private boolean    contentAreaFilledSet    = false;
private boolean setLayout = false;
boolean defaultCapable = true;
private Handler handler;
protected ChangeListener changeListener = null;
protected ActionListener actionListener = null;
protected ItemListener itemListener = null;
protected transient ChangeEvent changeEvent;
private boolean hideActionText = false;
protected AbstractButton() {}
@BeanProperty(expert = true, description
= "Whether the text of the button should come from the <code>Action</code>.")
public void setHideActionText(boolean hideActionText) {
if (hideActionText != this.hideActionText) {
this.hideActionText = hideActionText;
if (getAction() != null) {
setTextFromAction(getAction(), false);
}
firePropertyChange("hideActionText", !hideActionText,
hideActionText);
}
}
public boolean getHideActionText() {
return hideActionText;
}
public String getText() {
return text;
}
@BeanProperty(preferred = true, visualUpdate = true, description
= "The button's text.")
public void setText(String text) {
String oldValue = this.text;
this.text = text;
firePropertyChange(TEXT_CHANGED_PROPERTY, oldValue, text);
updateDisplayedMnemonicIndex(text, getMnemonic());
if (accessibleContext != null) {
accessibleContext.firePropertyChange(
AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
oldValue, text);
}
if (text == null || oldValue == null || !text.equals(oldValue)) {
revalidate();
repaint();
}
}
public boolean isSelected() {
return model.isSelected();
}
public void setSelected(boolean b) {
boolean oldValue = isSelected();
model.setSelected(b);
}
public void doClick() {
doClick(68);
}
public void doClick(int pressTime) {
Dimension size = getSize();
model.setArmed(true);
model.setPressed(true);
paintImmediately(new Rectangle(0,0, size.width, size.height));
try {
Thread.sleep(pressTime);
} catch(InterruptedException ie) {
}
model.setPressed(false);
model.setArmed(false);
}
@BeanProperty(visualUpdate = true, description
= "The space between the button's border and the label.")
public void setMargin(Insets m) {
if(m instanceof UIResource) {
defaultMargin = m;
} else if(margin instanceof UIResource) {
defaultMargin = margin;
}
if(m == null && defaultMargin != null) {
m = defaultMargin;
}
Insets old = margin;
margin = m;
firePropertyChange(MARGIN_CHANGED_PROPERTY, old, m);
if (old == null || !old.equals(m)) {
revalidate();
repaint();
}
}
public Insets getMargin() {
return (margin == null) ? null : (Insets) margin.clone();
}
public Icon getIcon() {
return defaultIcon;
}
@BeanProperty(visualUpdate = true, description
= "The button's default icon")
public void setIcon(Icon defaultIcon) {
Icon oldValue = this.defaultIcon;
this.defaultIcon = defaultIcon;
if (defaultIcon != oldValue && (disabledIcon instanceof UIResource)) {
disabledIcon = null;
}
firePropertyChange(ICON_CHANGED_PROPERTY, oldValue, defaultIcon);
if (accessibleContext != null) {
accessibleContext.firePropertyChange(
AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
oldValue, defaultIcon);
}
if (defaultIcon != oldValue) {
if (defaultIcon == null || oldValue == null ||
defaultIcon.getIconWidth() != oldValue.getIconWidth() ||
defaultIcon.getIconHeight() != oldValue.getIconHeight()) {
revalidate();
}
repaint();
}
}
public Icon getPressedIcon() {
return pressedIcon;
}
@BeanProperty(visualUpdate = true, description
= "The pressed icon for the button.")
public void setPressedIcon(Icon pressedIcon) {
Icon oldValue = this.pressedIcon;
this.pressedIcon = pressedIcon;
firePropertyChange(PRESSED_ICON_CHANGED_PROPERTY, oldValue, pressedIcon);
if (accessibleContext != null) {
accessibleContext.firePropertyChange(
AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
oldValue, pressedIcon);
}
if (pressedIcon != oldValue) {
if (getModel().isPressed()) {
repaint();
}
}
}
public Icon getSelectedIcon() {
return selectedIcon;
}
@BeanProperty(visualUpdate = true, description
= "The selected icon for the button.")
public void setSelectedIcon(Icon selectedIcon) {
Icon oldValue = this.selectedIcon;
this.selectedIcon = selectedIcon;
if (selectedIcon != oldValue &&
disabledSelectedIcon instanceof UIResource) {
disabledSelectedIcon = null;
}
firePropertyChange(SELECTED_ICON_CHANGED_PROPERTY, oldValue, selectedIcon);
if (accessibleContext != null) {
accessibleContext.firePropertyChange(
AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
oldValue, selectedIcon);
}
if (selectedIcon != oldValue) {
if (isSelected()) {
repaint();
}
}
}
public Icon getRolloverIcon() {
return rolloverIcon;
}
@BeanProperty(visualUpdate = true, description
= "The rollover icon for the button.")
public void setRolloverIcon(Icon rolloverIcon) {
Icon oldValue = this.rolloverIcon;
this.rolloverIcon = rolloverIcon;
firePropertyChange(ROLLOVER_ICON_CHANGED_PROPERTY, oldValue, rolloverIcon);
if (accessibleContext != null) {
accessibleContext.firePropertyChange(
AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
oldValue, rolloverIcon);
}
setRolloverEnabled(true);
if (rolloverIcon != oldValue) {
repaint();
}
}
public Icon getRolloverSelectedIcon() {
return rolloverSelectedIcon;
}
@BeanProperty(visualUpdate = true, description
= "The rollover selected icon for the button.")
public void setRolloverSelectedIcon(Icon rolloverSelectedIcon) {
Icon oldValue = this.rolloverSelectedIcon;
this.rolloverSelectedIcon = rolloverSelectedIcon;
firePropertyChange(ROLLOVER_SELECTED_ICON_CHANGED_PROPERTY, oldValue, rolloverSelectedIcon);
if (accessibleContext != null) {
accessibleContext.firePropertyChange(
AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
oldValue, rolloverSelectedIcon);
}
setRolloverEnabled(true);
if (rolloverSelectedIcon != oldValue) {
if (isSelected()) {
repaint();
}
}
}
@Transient
public Icon getDisabledIcon() {
if (disabledIcon == null) {
disabledIcon = UIManager.getLookAndFeel().getDisabledIcon(this, getIcon());
if (disabledIcon != null) {
firePropertyChange(DISABLED_ICON_CHANGED_PROPERTY, null, disabledIcon);
}
}
return disabledIcon;
}
@BeanProperty(visualUpdate = true, description
= "The disabled icon for the button.")
public void setDisabledIcon(Icon disabledIcon) {
Icon oldValue = this.disabledIcon;
this.disabledIcon = disabledIcon;
firePropertyChange(DISABLED_ICON_CHANGED_PROPERTY, oldValue, disabledIcon);
if (accessibleContext != null) {
accessibleContext.firePropertyChange(
AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
oldValue, disabledIcon);
}
if (disabledIcon != oldValue) {
if (!isEnabled()) {
repaint();
}
}
}
public Icon getDisabledSelectedIcon() {
if (disabledSelectedIcon == null) {
if (selectedIcon != null) {
disabledSelectedIcon = UIManager.getLookAndFeel().
getDisabledSelectedIcon(this, getSelectedIcon());
} else {
return getDisabledIcon();
}
}
return disabledSelectedIcon;
}
@BeanProperty(visualUpdate = true, description
= "The disabled selection icon for the button.")
public void setDisabledSelectedIcon(Icon disabledSelectedIcon) {
Icon oldValue = this.disabledSelectedIcon;
this.disabledSelectedIcon = disabledSelectedIcon;
firePropertyChange(DISABLED_SELECTED_ICON_CHANGED_PROPERTY, oldValue, disabledSelectedIcon);
if (accessibleContext != null) {
accessibleContext.firePropertyChange(
AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
oldValue, disabledSelectedIcon);
}
if (disabledSelectedIcon != oldValue) {
if (disabledSelectedIcon == null || oldValue == null ||
disabledSelectedIcon.getIconWidth() != oldValue.getIconWidth() ||
disabledSelectedIcon.getIconHeight() != oldValue.getIconHeight()) {
revalidate();
}
if (!isEnabled() && isSelected()) {
repaint();
}
}
}
public int getVerticalAlignment() {
return verticalAlignment;
}
@BeanProperty(visualUpdate = true, enumerationValues = {
"SwingConstants.TOP",
"SwingConstants.CENTER",
"SwingConstants.BOTTOM"}, description
= "The vertical alignment of the icon and text.")
public void setVerticalAlignment(int alignment) {
if (alignment == verticalAlignment) return;
int oldValue = verticalAlignment;
verticalAlignment = checkVerticalKey(alignment, "verticalAlignment");
firePropertyChange(VERTICAL_ALIGNMENT_CHANGED_PROPERTY, oldValue, verticalAlignment);         repaint();
}
public int getHorizontalAlignment() {
return horizontalAlignment;
}
@BeanProperty(visualUpdate = true, enumerationValues = {
"SwingConstants.LEFT",
"SwingConstants.CENTER",
"SwingConstants.RIGHT",
"SwingConstants.LEADING",
"SwingConstants.TRAILING"}, description
= "The horizontal alignment of the icon and text.")
public void setHorizontalAlignment(int alignment) {
if (alignment == horizontalAlignment) return;
int oldValue = horizontalAlignment;
horizontalAlignment = checkHorizontalKey(alignment,
"horizontalAlignment");
firePropertyChange(HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY,
oldValue, horizontalAlignment);
repaint();
}
public int getVerticalTextPosition() {
return verticalTextPosition;
}
@BeanProperty(visualUpdate = true, enumerationValues = {
"SwingConstants.TOP",
"SwingConstants.CENTER",
"SwingConstants.BOTTOM"}, description
= "The vertical position of the text relative to the icon.")
public void setVerticalTextPosition(int textPosition) {
if (textPosition == verticalTextPosition) return;
int oldValue = verticalTextPosition;
verticalTextPosition = checkVerticalKey(textPosition, "verticalTextPosition");
firePropertyChange(VERTICAL_TEXT_POSITION_CHANGED_PROPERTY, oldValue, verticalTextPosition);
revalidate();
repaint();
}
public int getHorizontalTextPosition() {
return horizontalTextPosition;
}
@BeanProperty(visualUpdate = true, enumerationValues = {
"SwingConstants.LEFT",
"SwingConstants.CENTER",
"SwingConstants.RIGHT",
"SwingConstants.LEADING",
"SwingConstants.TRAILING"}, description
= "The horizontal position of the text relative to the icon.")
public void setHorizontalTextPosition(int textPosition) {
if (textPosition == horizontalTextPosition) return;
int oldValue = horizontalTextPosition;
horizontalTextPosition = checkHorizontalKey(textPosition,
"horizontalTextPosition");
firePropertyChange(HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY,
oldValue,
horizontalTextPosition);
revalidate();
repaint();
}
public int getIconTextGap() {
return iconTextGap;
}
@BeanProperty(visualUpdate = true, description
= "If both the icon and text properties are set, this property defines the space between them.")
public void setIconTextGap(int iconTextGap) {
int oldValue = this.iconTextGap;
this.iconTextGap = iconTextGap;
iconTextGapSet = true;
firePropertyChange("iconTextGap", oldValue, iconTextGap);
if (iconTextGap != oldValue) {
revalidate();
repaint();
}
}
protected int checkHorizontalKey(int key, String exception) {
if ((key == LEFT) ||
(key == CENTER) ||
(key == RIGHT) ||
(key == LEADING) ||
(key == TRAILING)) {
return key;
} else {
throw new IllegalArgumentException(exception);
}
}
protected int checkVerticalKey(int key, String exception) {
if ((key == TOP) || (key == CENTER) || (key == BOTTOM)) {
return key;
} else {
throw new IllegalArgumentException(exception);
}
}
public void removeNotify() {
super.removeNotify();
if(isRolloverEnabled()) {
getModel().setRollover(false);
}
}
public void setActionCommand(String actionCommand) {
getModel().setActionCommand(actionCommand);
}
public String getActionCommand() {
String ac = getModel().getActionCommand();
if(ac == null) {
ac = getText();
}
return ac;
}
private Action action;
private PropertyChangeListener actionPropertyChangeListener;
@BeanProperty(visualUpdate = true, description
= "the Action instance connected with this ActionEvent source")
public void setAction(Action a) {
Action oldValue = getAction();
if (action==null || !action.equals(a)) {
action = a;
if (oldValue!=null) {
removeActionListener(oldValue);
oldValue.removePropertyChangeListener(actionPropertyChangeListener);
actionPropertyChangeListener = null;
}
configurePropertiesFromAction(action);
if (action!=null) {
if (!isListener(ActionListener.class, action)) {
addActionListener(action);
}
actionPropertyChangeListener = createActionPropertyChangeListener(action);
action.addPropertyChangeListener(actionPropertyChangeListener);
}
firePropertyChange("action", oldValue, action);
}
}
private boolean isListener(Class<?> c, ActionListener a) {
boolean isListener = false;
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==c && listeners[i+1]==a) {
isListener=true;
}
}
return isListener;
}
public Action getAction() {
return action;
}
protected void configurePropertiesFromAction(Action a) {
setMnemonicFromAction(a);
setTextFromAction(a, false);
AbstractAction.setToolTipTextFromAction(this, a);
setIconFromAction(a);
setActionCommandFromAction(a);
AbstractAction.setEnabledFromAction(this, a);
if (AbstractAction.hasSelectedKey(a) &&
shouldUpdateSelectedStateFromAction()) {
setSelectedFromAction(a);
}
setDisplayedMnemonicIndexFromAction(a, false);
}
void clientPropertyChanged(Object key, Object oldValue,
Object newValue) {
if (key == "hideActionText") {
boolean current = (newValue instanceof Boolean) ?
(Boolean)newValue : false;
if (getHideActionText() != current) {
setHideActionText(current);
}
}
}
boolean shouldUpdateSelectedStateFromAction() {
return false;
}
protected void actionPropertyChanged(Action action, String propertyName) {
if (propertyName == Action.NAME) {
setTextFromAction(action, true);
} else if (propertyName == "enabled") {
AbstractAction.setEnabledFromAction(this, action);
} else if (propertyName == Action.SHORT_DESCRIPTION) {
AbstractAction.setToolTipTextFromAction(this, action);
} else if (propertyName == Action.SMALL_ICON) {
smallIconChanged(action);
} else if (propertyName == Action.MNEMONIC_KEY) {
setMnemonicFromAction(action);
} else if (propertyName == Action.ACTION_COMMAND_KEY) {
setActionCommandFromAction(action);
} else if (propertyName == Action.SELECTED_KEY &&
AbstractAction.hasSelectedKey(action) &&
shouldUpdateSelectedStateFromAction()) {
setSelectedFromAction(action);
} else if (propertyName == Action.DISPLAYED_MNEMONIC_INDEX_KEY) {
setDisplayedMnemonicIndexFromAction(action, true);
} else if (propertyName == Action.LARGE_ICON_KEY) {
largeIconChanged(action);
}
}
private void setDisplayedMnemonicIndexFromAction(
Action a, boolean fromPropertyChange) {
Integer iValue = (a == null) ? null :
(Integer)a.getValue(Action.DISPLAYED_MNEMONIC_INDEX_KEY);
if (fromPropertyChange || iValue != null) {
int value;
if (iValue == null) {
value = -1;
} else {
value = iValue;
String text = getText();
if (text == null || value >= text.length()) {
value = -1;
}
}
setDisplayedMnemonicIndex(value);
}
}
private void setMnemonicFromAction(Action a) {
Integer n = (a == null) ? null :
(Integer)a.getValue(Action.MNEMONIC_KEY);
setMnemonic((n == null) ? '\0' : n);
}
private void setTextFromAction(Action a, boolean propertyChange) {
boolean hideText = getHideActionText();
if (!propertyChange) {
setText((a != null && !hideText) ?
(String)a.getValue(Action.NAME) : null);
}
else if (!hideText) {
setText((String)a.getValue(Action.NAME));
}
}
void setIconFromAction(Action a) {
Icon icon = null;
if (a != null) {
icon = (Icon)a.getValue(Action.LARGE_ICON_KEY);
if (icon == null) {
icon = (Icon)a.getValue(Action.SMALL_ICON);
}
}
setIcon(icon);
}
void smallIconChanged(Action a) {
if (a.getValue(Action.LARGE_ICON_KEY) == null) {
setIconFromAction(a);
}
}
void largeIconChanged(Action a) {
setIconFromAction(a);
}
private void setActionCommandFromAction(Action a) {
setActionCommand((a != null) ?
(String)a.getValue(Action.ACTION_COMMAND_KEY) :
null);
}
private void setSelectedFromAction(Action a) {
boolean selected = false;
if (a != null) {
selected = AbstractAction.isSelected(a);
}
if (selected != isSelected()) {
setSelected(selected);
if (!selected && isSelected()) {
if (getModel() instanceof DefaultButtonModel) {
ButtonGroup group = ((DefaultButtonModel)getModel()).getGroup();
if (group != null) {
group.clearSelection();
}
}
}
}
}
protected PropertyChangeListener createActionPropertyChangeListener(Action a) {
return createActionPropertyChangeListener0(a);
}
PropertyChangeListener createActionPropertyChangeListener0(Action a) {
return new ButtonActionPropertyChangeListener(this, a);
}
@SuppressWarnings("serial")
private static class ButtonActionPropertyChangeListener
extends ActionPropertyChangeListener<AbstractButton> {
ButtonActionPropertyChangeListener(AbstractButton b, Action a) {
super(b, a);
}
protected void actionPropertyChanged(AbstractButton button,
Action action,
PropertyChangeEvent e) {
if (AbstractAction.shouldReconfigure(e)) {
button.configurePropertiesFromAction(action);
} else {
button.actionPropertyChanged(action, e.getPropertyName());
}
}
}
public boolean isBorderPainted() {
return paintBorder;
}
@BeanProperty(visualUpdate = true, description
= "Whether the border should be painted.")
public void setBorderPainted(boolean b) {
boolean oldValue = paintBorder;
paintBorder = b;
borderPaintedSet = true;
firePropertyChange(BORDER_PAINTED_CHANGED_PROPERTY, oldValue, paintBorder);
if (b != oldValue) {
revalidate();
repaint();
}
}
protected void paintBorder(Graphics g) {
if (isBorderPainted()) {
super.paintBorder(g);
}
}
public boolean isFocusPainted() {
return paintFocus;
}
@BeanProperty(visualUpdate = true, description
= "Whether focus should be painted")
public void setFocusPainted(boolean b) {
boolean oldValue = paintFocus;
paintFocus = b;
firePropertyChange(FOCUS_PAINTED_CHANGED_PROPERTY, oldValue, paintFocus);
if (b != oldValue && isFocusOwner()) {
revalidate();
repaint();
}
}
public boolean isContentAreaFilled() {
return contentAreaFilled;
}
@BeanProperty(visualUpdate = true, description
= "Whether the button should paint the content area or leave it transparent.")
public void setContentAreaFilled(boolean b) {
boolean oldValue = contentAreaFilled;
contentAreaFilled = b;
contentAreaFilledSet = true;
firePropertyChange(CONTENT_AREA_FILLED_CHANGED_PROPERTY, oldValue, contentAreaFilled);
if (b != oldValue) {
repaint();
}
}
public boolean isRolloverEnabled() {
return rolloverEnabled;
}
@BeanProperty(visualUpdate = true, description
= "Whether rollover effects should be enabled.")
public void setRolloverEnabled(boolean b) {
boolean oldValue = rolloverEnabled;
rolloverEnabled = b;
rolloverEnabledSet = true;
firePropertyChange(ROLLOVER_ENABLED_CHANGED_PROPERTY, oldValue, rolloverEnabled);
if (b != oldValue) {
repaint();
}
}
public int getMnemonic() {
return mnemonic;
}
@BeanProperty(visualUpdate = true, description
= "the keyboard character mnemonic")
public void setMnemonic(int mnemonic) {
int oldValue = getMnemonic();
model.setMnemonic(mnemonic);
updateMnemonicProperties();
}
@BeanProperty(visualUpdate = true, description
= "the keyboard character mnemonic")
public void setMnemonic(char mnemonic) {
int vk = (int) mnemonic;
if(vk >= 'a' && vk <='z')
vk -= ('a' - 'A');
setMnemonic(vk);
}
@BeanProperty(visualUpdate = true, description
= "the index into the String to draw the keyboard character mnemonic at")
public void setDisplayedMnemonicIndex(int index)
throws IllegalArgumentException {
int oldValue = mnemonicIndex;
if (index == -1) {
mnemonicIndex = -1;
} else {
String text = getText();
int textLength = (text == null) ? 0 : text.length();
if (index < -1 || index >= textLength) {                  throw new IllegalArgumentException("index == " + index);
}
}
mnemonicIndex = index;
firePropertyChange("displayedMnemonicIndex", oldValue, index);
if (index != oldValue) {
revalidate();
repaint();
}
}
public int getDisplayedMnemonicIndex() {
return mnemonicIndex;
}
private void updateDisplayedMnemonicIndex(String text, int mnemonic) {
setDisplayedMnemonicIndex(
SwingUtilities.findDisplayedMnemonicIndex(text, mnemonic));
}
private void updateMnemonicProperties() {
int newMnemonic = model.getMnemonic();
if (mnemonic != newMnemonic) {
int oldValue = mnemonic;
mnemonic = newMnemonic;
firePropertyChange(MNEMONIC_CHANGED_PROPERTY,
oldValue, mnemonic);
updateDisplayedMnemonicIndex(getText(), mnemonic);
revalidate();
repaint();
}
}
public void setMultiClickThreshhold(long threshhold) {
if (threshhold < 0) {
throw new IllegalArgumentException("threshhold must be >= 0");
}
this.multiClickThreshhold = threshhold;
}
public long getMultiClickThreshhold() {
return multiClickThreshhold;
}
public ButtonModel getModel() {
return model;
}
@BeanProperty(description
= "Model that the Button uses.")
public void setModel(ButtonModel newModel) {
ButtonModel oldModel = getModel();
if (oldModel != null) {
oldModel.removeChangeListener(changeListener);
oldModel.removeActionListener(actionListener);
oldModel.removeItemListener(itemListener);
changeListener = null;
actionListener = null;
itemListener = null;
}
model = newModel;
if (newModel != null) {
changeListener = createChangeListener();
actionListener = createActionListener();
itemListener = createItemListener();
newModel.addChangeListener(changeListener);
newModel.addActionListener(actionListener);
newModel.addItemListener(itemListener);
updateMnemonicProperties();
super.setEnabled(newModel.isEnabled());
} else {
mnemonic = '\0';
}
updateDisplayedMnemonicIndex(getText(), mnemonic);
firePropertyChange(MODEL_CHANGED_PROPERTY, oldModel, newModel);
if (newModel != oldModel) {
revalidate();
repaint();
}
}
public ButtonUI getUI() {
return (ButtonUI) ui;
}
@BeanProperty(hidden = true, visualUpdate = true, description
= "The UI object that implements the LookAndFeel.")
public void setUI(ButtonUI ui) {
super.setUI(ui);
if (disabledIcon instanceof UIResource) {
setDisabledIcon(null);
}
if (disabledSelectedIcon instanceof UIResource) {
setDisabledSelectedIcon(null);
}
}
public void updateUI() {
}
protected void addImpl(Component comp, Object constraints, int index) {
if (!setLayout) {
setLayout(new OverlayLayout(this));
}
super.addImpl(comp, constraints, index);
}
public void setLayout(LayoutManager mgr) {
setLayout = true;
super.setLayout(mgr);
}
public void addChangeListener(ChangeListener l) {
listenerList.add(ChangeListener.class, l);
}
public void removeChangeListener(ChangeListener l) {
listenerList.remove(ChangeListener.class, l);
}
@BeanProperty(bound = false)
public ChangeListener[] getChangeListeners() {
return listenerList.getListeners(ChangeListener.class);
}
protected void fireStateChanged() {
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==ChangeListener.class) {
if (changeEvent == null)
changeEvent = new ChangeEvent(this);
((ChangeListener)listeners[i+1]).stateChanged(changeEvent);
}
}
}
public void addActionListener(ActionListener l) {
listenerList.add(ActionListener.class, l);
}
public void removeActionListener(ActionListener l) {
if ((l != null) && (getAction() == l)) {
setAction(null);
} else {
listenerList.remove(ActionListener.class, l);
}
}
@BeanProperty(bound = false)
public ActionListener[] getActionListeners() {
return listenerList.getListeners(ActionListener.class);
}
protected ChangeListener createChangeListener() {
return getHandler();
}
@SuppressWarnings("serial")
protected class ButtonChangeListener implements ChangeListener, Serializable {
ButtonChangeListener() {
}
public void stateChanged(ChangeEvent e) {
getHandler().stateChanged(e);
}
}
protected void fireActionPerformed(ActionEvent event) {
Object[] listeners = listenerList.getListenerList();
ActionEvent e = null;
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==ActionListener.class) {
if (e == null) {
String actionCommand = event.getActionCommand();
if(actionCommand == null) {
actionCommand = getActionCommand();
}
e = new ActionEvent(AbstractButton.this,
ActionEvent.ACTION_PERFORMED,
actionCommand,
event.getWhen(),
event.getModifiers());
}
((ActionListener)listeners[i+1]).actionPerformed(e);
}
}
}
protected void fireItemStateChanged(ItemEvent event) {
Object[] listeners = listenerList.getListenerList();
ItemEvent e = null;
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==ItemListener.class) {
if (e == null) {
e = new ItemEvent(AbstractButton.this,
ItemEvent.ITEM_STATE_CHANGED,
AbstractButton.this,
event.getStateChange());
}
((ItemListener)listeners[i+1]).itemStateChanged(e);
}
}
if (accessibleContext != null) {
if (event.getStateChange() == ItemEvent.SELECTED) {
accessibleContext.firePropertyChange(
AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
null, AccessibleState.SELECTED);
accessibleContext.firePropertyChange(
AccessibleContext.ACCESSIBLE_VALUE_PROPERTY,
Integer.valueOf(0), Integer.valueOf(1));
} else {
accessibleContext.firePropertyChange(
AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
AccessibleState.SELECTED, null);
accessibleContext.firePropertyChange(
AccessibleContext.ACCESSIBLE_VALUE_PROPERTY,
Integer.valueOf(1), Integer.valueOf(0));
}
}
}
protected ActionListener createActionListener() {
return getHandler();
}
protected ItemListener createItemListener() {
return getHandler();
}
public void setEnabled(boolean b) {
if (!b && model.isRollover()) {
model.setRollover(false);
}
super.setEnabled(b);
model.setEnabled(b);
}
@Deprecated
public String getLabel() {
return getText();
}
@Deprecated
@BeanProperty(description
= "Replace by setText(text)")
public void setLabel(String label) {
setText(label);
}
public void addItemListener(ItemListener l) {
listenerList.add(ItemListener.class, l);
}
public void removeItemListener(ItemListener l) {
listenerList.remove(ItemListener.class, l);
}
@BeanProperty(bound = false)
public ItemListener[] getItemListeners() {
return listenerList.getListeners(ItemListener.class);
}
@BeanProperty(bound = false)
public Object[] getSelectedObjects() {
if (isSelected() == false) {
return null;
}
Object[] selectedObjects = new Object[1];
selectedObjects[0] = getText();
return selectedObjects;
}
protected void init(String text, Icon icon) {
if(text != null) {
setText(text);
}
if(icon != null) {
setIcon(icon);
}
updateUI();
setAlignmentX(LEFT_ALIGNMENT);
setAlignmentY(CENTER_ALIGNMENT);
}
public boolean imageUpdate(Image img, int infoflags,
int x, int y, int w, int h) {
Icon iconDisplayed = null;
if (!model.isEnabled()) {
if (model.isSelected()) {
iconDisplayed = getDisabledSelectedIcon();
} else {
iconDisplayed = getDisabledIcon();
}
} else if (model.isPressed() && model.isArmed()) {
iconDisplayed = getPressedIcon();
} else if (isRolloverEnabled() && model.isRollover()) {
if (model.isSelected()) {
iconDisplayed = getRolloverSelectedIcon();
} else {
iconDisplayed = getRolloverIcon();
}
} else if (model.isSelected()) {
iconDisplayed = getSelectedIcon();
}
if (iconDisplayed == null) {
iconDisplayed = getIcon();
}
if (iconDisplayed == null
|| !SwingUtilities.doesIconReferenceImage(iconDisplayed, img)) {
return false;
}
return super.imageUpdate(img, infoflags, x, y, w, h);
}
void setUIProperty(String propertyName, Object value) {
if (propertyName == "borderPainted") {
if (!borderPaintedSet) {
setBorderPainted(((Boolean)value).booleanValue());
borderPaintedSet = false;
}
} else if (propertyName == "rolloverEnabled") {
if (!rolloverEnabledSet) {
setRolloverEnabled(((Boolean)value).booleanValue());
rolloverEnabledSet = false;
}
} else if (propertyName == "iconTextGap") {
if (!iconTextGapSet) {
setIconTextGap(((Number)value).intValue());
iconTextGapSet = false;
}
} else if (propertyName == "contentAreaFilled") {
if (!contentAreaFilledSet) {
setContentAreaFilled(((Boolean)value).booleanValue());
contentAreaFilledSet = false;
}
} else {
super.setUIProperty(propertyName, value);
}
}
protected String paramString() {
String defaultIconString = ((defaultIcon != null)
&& (defaultIcon != this) ?
defaultIcon.toString() : "");
String pressedIconString = ((pressedIcon != null)
&& (pressedIcon != this) ?
pressedIcon.toString() : "");
String disabledIconString = ((disabledIcon != null)
&& (disabledIcon != this) ?
disabledIcon.toString() : "");
String selectedIconString = ((selectedIcon != null)
&& (selectedIcon != this) ?
selectedIcon.toString() : "");
String disabledSelectedIconString = ((disabledSelectedIcon != null) &&
(disabledSelectedIcon != this) ?
disabledSelectedIcon.toString()
: "");
String rolloverIconString = ((rolloverIcon != null)
&& (rolloverIcon != this) ?
rolloverIcon.toString() : "");
String rolloverSelectedIconString = ((rolloverSelectedIcon != null) &&
(rolloverSelectedIcon != this) ?
rolloverSelectedIcon.toString()
: "");
String paintBorderString = (paintBorder ? "true" : "false");
String paintFocusString = (paintFocus ? "true" : "false");
String rolloverEnabledString = (rolloverEnabled ? "true" : "false");
return super.paramString() +
",defaultIcon=" + defaultIconString +
",disabledIcon=" + disabledIconString +
",disabledSelectedIcon=" + disabledSelectedIconString +
",margin=" + margin +
",paintBorder=" + paintBorderString +
",paintFocus=" + paintFocusString +
",pressedIcon=" + pressedIconString +
",rolloverEnabled=" + rolloverEnabledString +
",rolloverIcon=" + rolloverIconString +
",rolloverSelectedIcon=" + rolloverSelectedIconString +
",selectedIcon=" + selectedIconString +
",text=" + text;
}
private Handler getHandler() {
if (handler == null) {
handler = new Handler();
}
return handler;
}
@SuppressWarnings("serial")
class Handler implements ActionListener, ChangeListener, ItemListener,
Serializable {
public void stateChanged(ChangeEvent e) {
Object source = e.getSource();
updateMnemonicProperties();
if (isEnabled() != model.isEnabled()) {
setEnabled(model.isEnabled());
}
fireStateChanged();
repaint();
}
public void actionPerformed(ActionEvent event) {
fireActionPerformed(event);
}
public void itemStateChanged(ItemEvent event) {
fireItemStateChanged(event);
if (shouldUpdateSelectedStateFromAction()) {
Action action = getAction();
if (action != null && AbstractAction.hasSelectedKey(action)) {
boolean selected = isSelected();
boolean isActionSelected = AbstractAction.isSelected(
action);
if (isActionSelected != selected) {
action.putValue(Action.SELECTED_KEY, selected);
}
}
}
}
}
@SuppressWarnings("serial")     protected abstract class AccessibleAbstractButton
extends AccessibleJComponent implements AccessibleAction,
AccessibleValue, AccessibleText, AccessibleExtendedComponent {
protected AccessibleAbstractButton() {}
public String getAccessibleName() {
String name = accessibleName;
if (name == null) {
name = (String)getClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY);
}
if (name == null) {
name = AbstractButton.this.getText();
}
if (name == null) {
name = super.getAccessibleName();
}
return name;
}
public AccessibleIcon [] getAccessibleIcon() {
Icon defaultIcon = getIcon();
if (defaultIcon instanceof Accessible) {
AccessibleContext ac =
((Accessible)defaultIcon).getAccessibleContext();
if (ac instanceof AccessibleIcon ai) {
return new AccessibleIcon[] { ai };
}
}
return null;
}
public AccessibleStateSet getAccessibleStateSet() {
AccessibleStateSet states = super.getAccessibleStateSet();
if (getModel().isArmed()) {
states.add(AccessibleState.ARMED);
}
if (isFocusOwner()) {
states.add(AccessibleState.FOCUSED);
}
if (getModel().isPressed()) {
states.add(AccessibleState.PRESSED);
}
if (isSelected()) {
states.add(AccessibleState.CHECKED);
}
return states;
}
public AccessibleRelationSet getAccessibleRelationSet() {
AccessibleRelationSet relationSet
= super.getAccessibleRelationSet();
if (!relationSet.contains(AccessibleRelation.MEMBER_OF)) {
ButtonModel model = getModel();
if (model instanceof DefaultButtonModel defaultModel) {
ButtonGroup group = defaultModel.getGroup();
if (group != null) {
int len = group.getButtonCount();
Object [] target = new Object[len];
Enumeration<AbstractButton> elem = group.getElements();
for (int i = 0; i < len; i++) {
if (elem.hasMoreElements()) {
target[i] = elem.nextElement();
}
}
AccessibleRelation relation =
new AccessibleRelation(AccessibleRelation.MEMBER_OF);
relation.setTarget(target);
relationSet.add(relation);
}
}
}
return relationSet;
}
public AccessibleAction getAccessibleAction() {
return this;
}
public AccessibleValue getAccessibleValue() {
return this;
}
public int getAccessibleActionCount() {
return 1;
}
public String getAccessibleActionDescription(int i) {
if (i == 0) {
return UIManager.getString("AbstractButton.clickText");
} else {
return null;
}
}
public boolean doAccessibleAction(int i) {
if (i == 0) {
doClick();
return true;
} else {
return false;
}
}
public Number getCurrentAccessibleValue() {
if (isSelected()) {
return Integer.valueOf(1);
} else {
return Integer.valueOf(0);
}
}
public boolean setCurrentAccessibleValue(Number n) {
if (n == null) {
return false;
}
int i = n.intValue();
if (i == 0) {
setSelected(false);
} else {
setSelected(true);
}
return true;
}
public Number getMinimumAccessibleValue() {
return Integer.valueOf(0);
}
public Number getMaximumAccessibleValue() {
return Integer.valueOf(1);
}
public AccessibleText getAccessibleText() {
View view = (View)AbstractButton.this.getClientProperty("html");
if (view != null) {
return this;
} else {
return null;
}
}
public int getIndexAtPoint(Point p) {
View view = (View) AbstractButton.this.getClientProperty("html");
if (view != null) {
Rectangle r = getTextRectangle();
if (r == null) {
return -1;
}
Rectangle2D.Float shape =
new Rectangle2D.Float(r.x, r.y, r.width, r.height);
Position.Bias[] bias = new Position.Bias[1];
return view.viewToModel(p.x, p.y, shape, bias);
} else {
return -1;
}
}
public Rectangle getCharacterBounds(int i) {
View view = (View) AbstractButton.this.getClientProperty("html");
if (view != null) {
Rectangle r = getTextRectangle();
if (r == null) {
return null;
}
Rectangle2D.Float shape =
new Rectangle2D.Float(r.x, r.y, r.width, r.height);
try {
Shape charShape =
view.modelToView(i, shape, Position.Bias.Forward);
return charShape.getBounds();
} catch (BadLocationException e) {
return null;
}
} else {
return null;
}
}
public int getCharCount() {
View view = (View) AbstractButton.this.getClientProperty("html");
if (view != null) {
Document d = view.getDocument();
if (d instanceof StyledDocument) {
StyledDocument doc = (StyledDocument)d;
return doc.getLength();
}
}
return accessibleContext.getAccessibleName().length();
}
public int getCaretPosition() {
return -1;
}
public String getAtIndex(int part, int index) {
if (index < 0 || index >= getCharCount()) {
return null;
}
switch (part) {
case AccessibleText.CHARACTER:
try {
return getText(index, 1);
} catch (BadLocationException e) {
return null;
}
case AccessibleText.WORD:
try {
String s = getText(0, getCharCount());
BreakIterator words = BreakIterator.getWordInstance(getLocale());
words.setText(s);
int end = words.following(index);
return s.substring(words.previous(), end);
} catch (BadLocationException e) {
return null;
}
case AccessibleText.SENTENCE:
try {
String s = getText(0, getCharCount());
BreakIterator sentence =
BreakIterator.getSentenceInstance(getLocale());
sentence.setText(s);
int end = sentence.following(index);
return s.substring(sentence.previous(), end);
} catch (BadLocationException e) {
return null;
}
default:
return null;
}
}
public String getAfterIndex(int part, int index) {
if (index < 0 || index >= getCharCount()) {
return null;
}
switch (part) {
case AccessibleText.CHARACTER:
if (index+1 >= getCharCount()) {
return null;
}
try {
return getText(index+1, 1);
} catch (BadLocationException e) {
return null;
}
case AccessibleText.WORD:
try {
String s = getText(0, getCharCount());
BreakIterator words = BreakIterator.getWordInstance(getLocale());
words.setText(s);
int start = words.following(index);
if (start == BreakIterator.DONE || start >= s.length()) {
return null;
}
int end = words.following(start);
if (end == BreakIterator.DONE || end >= s.length()) {
return null;
}
return s.substring(start, end);
} catch (BadLocationException e) {
return null;
}
case AccessibleText.SENTENCE:
try {
String s = getText(0, getCharCount());
BreakIterator sentence =
BreakIterator.getSentenceInstance(getLocale());
sentence.setText(s);
int start = sentence.following(index);
if (start == BreakIterator.DONE || start > s.length()) {
return null;
}
int end = sentence.following(start);
if (end == BreakIterator.DONE || end > s.length()) {
return null;
}
return s.substring(start, end);
} catch (BadLocationException e) {
return null;
}
default:
return null;
}
}
public String getBeforeIndex(int part, int index) {
if (index < 0 || index > getCharCount()-1) {
return null;
}
switch (part) {
case AccessibleText.CHARACTER:
if (index == 0) {
return null;
}
try {
return getText(index-1, 1);
} catch (BadLocationException e) {
return null;
}
case AccessibleText.WORD:
try {
String s = getText(0, getCharCount());
BreakIterator words = BreakIterator.getWordInstance(getLocale());
words.setText(s);
int end = words.following(index);
end = words.previous();
int start = words.previous();
if (start == BreakIterator.DONE) {
return null;
}
return s.substring(start, end);
} catch (BadLocationException e) {
return null;
}
case AccessibleText.SENTENCE:
try {
String s = getText(0, getCharCount());
BreakIterator sentence =
BreakIterator.getSentenceInstance(getLocale());
sentence.setText(s);
int end = sentence.following(index);
end = sentence.previous();
int start = sentence.previous();
if (start == BreakIterator.DONE) {
return null;
}
return s.substring(start, end);
} catch (BadLocationException e) {
return null;
}
default:
return null;
}
}
public AttributeSet getCharacterAttribute(int i) {
View view = (View) AbstractButton.this.getClientProperty("html");
if (view != null) {
Document d = view.getDocument();
if (d instanceof StyledDocument) {
StyledDocument doc = (StyledDocument)d;
Element elem = doc.getCharacterElement(i);
if (elem != null) {
return elem.getAttributes();
}
}
}
return null;
}
public int getSelectionStart() {
return -1;
}
public int getSelectionEnd() {
return -1;
}
public String getSelectedText() {
return null;
}
private String getText(int offset, int length)
throws BadLocationException {
View view = (View) AbstractButton.this.getClientProperty("html");
if (view != null) {
Document d = view.getDocument();
if (d instanceof StyledDocument) {
StyledDocument doc = (StyledDocument)d;
return doc.getText(offset, length);
}
}
return null;
}
private Rectangle getTextRectangle() {
String text = AbstractButton.this.getText();
Icon icon = (AbstractButton.this.isEnabled()) ? AbstractButton.this.getIcon() : AbstractButton.this.getDisabledIcon();
if ((icon == null) && (text == null)) {
return null;
}
Rectangle paintIconR = new Rectangle();
Rectangle paintTextR = new Rectangle();
Rectangle paintViewR = new Rectangle();
Insets paintViewInsets = new Insets(0, 0, 0, 0);
paintViewInsets = AbstractButton.this.getInsets(paintViewInsets);
paintViewR.x = paintViewInsets.left;
paintViewR.y = paintViewInsets.top;
paintViewR.width = AbstractButton.this.getWidth() - (paintViewInsets.left + paintViewInsets.right);
paintViewR.height = AbstractButton.this.getHeight() - (paintViewInsets.top + paintViewInsets.bottom);
String clippedText = SwingUtilities.layoutCompoundLabel(
AbstractButton.this,
getFontMetrics(getFont()),
text,
icon,
AbstractButton.this.getVerticalAlignment(),
AbstractButton.this.getHorizontalAlignment(),
AbstractButton.this.getVerticalTextPosition(),
AbstractButton.this.getHorizontalTextPosition(),
paintViewR,
paintIconR,
paintTextR,
0);
return paintTextR;
}
AccessibleExtendedComponent getAccessibleExtendedComponent() {
return this;
}
public String getToolTipText() {
return AbstractButton.this.getToolTipText();
}
public String getTitledBorderText() {
return super.getTitledBorderText();
}
public AccessibleKeyBinding getAccessibleKeyBinding() {
int mnemonic = AbstractButton.this.getMnemonic();
if (mnemonic == 0) {
return null;
}
return new ButtonKeyBinding(mnemonic);
}
class ButtonKeyBinding implements AccessibleKeyBinding {
int mnemonic;
ButtonKeyBinding(int mnemonic) {
this.mnemonic = mnemonic;
}
public int getAccessibleKeyBindingCount() {
return 1;
}
public java.lang.Object getAccessibleKeyBinding(int i) {
if (i != 0) {
throw new IllegalArgumentException();
}
return KeyStroke.getKeyStroke(mnemonic, 0);
}
}
}
}
package sun.util.calendar;
import java.util.Locale;
import java.util.TimeZone;
public abstract class AbstractCalendar extends CalendarSystem {
static final int SECOND_IN_MILLIS = 1000;
static final int MINUTE_IN_MILLIS = SECOND_IN_MILLIS * 60;
static final int HOUR_IN_MILLIS = MINUTE_IN_MILLIS * 60;
static final int DAY_IN_MILLIS = HOUR_IN_MILLIS * 24;
static final int EPOCH_OFFSET = 719163;
private Era[] eras;
protected AbstractCalendar() {
}
public Era getEra(String eraName) {
if (eras != null) {
for (Era era : eras) {
if (era.getName().equals(eraName)) {
return era;
}
}
}
return null;
}
public Era[] getEras() {
Era[] e = null;
if (eras != null) {
e = new Era[eras.length];
System.arraycopy(eras, 0, e, 0, eras.length);
}
return e;
}
public void setEra(CalendarDate date, String eraName) {
if (eras == null) {
return;         }
for (int i = 0; i < eras.length; i++) {
Era e = eras[i];
if (e != null && e.getName().equals(eraName)) {
date.setEra(e);
return;
}
}
throw new IllegalArgumentException("unknown era name: " + eraName);
}
protected void setEras(Era[] eras) {
this.eras = eras;
}
public CalendarDate getCalendarDate() {
return getCalendarDate(System.currentTimeMillis(), newCalendarDate());
}
public CalendarDate getCalendarDate(long millis) {
return getCalendarDate(millis, newCalendarDate());
}
public CalendarDate getCalendarDate(long millis, TimeZone zone) {
CalendarDate date = newCalendarDate(zone);
return getCalendarDate(millis, date);
}
public CalendarDate getCalendarDate(long millis, CalendarDate date) {
int ms = 0;                     int zoneOffset = 0;
int saving = 0;
long days = 0;
TimeZone zi = date.getZone();
if (zi != null) {
int[] offsets = new int[2];
if (zi instanceof ZoneInfo) {
zoneOffset = ((ZoneInfo)zi).getOffsets(millis, offsets);
} else {
zoneOffset = zi.getOffset(millis);
offsets[0] = zi.getRawOffset();
offsets[1] = zoneOffset - offsets[0];
}
days = zoneOffset / DAY_IN_MILLIS;
ms = zoneOffset % DAY_IN_MILLIS;
saving = offsets[1];
}
date.setZoneOffset(zoneOffset);
date.setDaylightSaving(saving);
days += millis / DAY_IN_MILLIS;
ms += (int) (millis % DAY_IN_MILLIS);
if (ms >= DAY_IN_MILLIS) {
ms -= DAY_IN_MILLIS;
++days;
} else {
while (ms < 0) {
ms += DAY_IN_MILLIS;
--days;
}
}
days += EPOCH_OFFSET;
getCalendarDateFromFixedDate(date, days);
setTimeOfDay(date, ms);
date.setLeapYear(isLeapYear(date));
date.setNormalized(true);
return date;
}
public long getTime(CalendarDate date) {
long gd = getFixedDate(date);
long ms = (gd - EPOCH_OFFSET) * DAY_IN_MILLIS + getTimeOfDay(date);
int zoneOffset = 0;
TimeZone zi = date.getZone();
if (zi != null) {
if (date.isNormalized()) {
return ms - date.getZoneOffset();
}
int[] offsets = new int[2];
if (date.isStandardTime()) {
if (zi instanceof ZoneInfo) {
((ZoneInfo)zi).getOffsetsByStandard(ms, offsets);
zoneOffset = offsets[0];
} else {
zoneOffset = zi.getOffset(ms - zi.getRawOffset());
}
} else {
if (zi instanceof ZoneInfo) {
zoneOffset = ((ZoneInfo)zi).getOffsetsByWall(ms, offsets);
} else {
zoneOffset = zi.getOffset(ms - zi.getRawOffset());
}
}
}
ms -= zoneOffset;
getCalendarDate(ms, date);
return ms;
}
protected long getTimeOfDay(CalendarDate date) {
long fraction = date.getTimeOfDay();
if (fraction != CalendarDate.TIME_UNDEFINED) {
return fraction;
}
fraction = getTimeOfDayValue(date);
date.setTimeOfDay(fraction);
return fraction;
}
public long getTimeOfDayValue(CalendarDate date) {
long fraction = date.getHours();
fraction *= 60;
fraction += date.getMinutes();
fraction *= 60;
fraction += date.getSeconds();
fraction *= 1000;
fraction += date.getMillis();
return fraction;
}
public CalendarDate setTimeOfDay(CalendarDate cdate, int fraction) {
if (fraction < 0) {
throw new IllegalArgumentException();
}
boolean normalizedState = cdate.isNormalized();
int time = fraction;
int hours = time / HOUR_IN_MILLIS;
time %= HOUR_IN_MILLIS;
int minutes = time / MINUTE_IN_MILLIS;
time %= MINUTE_IN_MILLIS;
int seconds = time / SECOND_IN_MILLIS;
time %= SECOND_IN_MILLIS;
cdate.setHours(hours);
cdate.setMinutes(minutes);
cdate.setSeconds(seconds);
cdate.setMillis(time);
cdate.setTimeOfDay(fraction);
if (hours < 24 && normalizedState) {
cdate.setNormalized(normalizedState);
}
return cdate;
}
public int getWeekLength() {
return 7;
}
protected abstract boolean isLeapYear(CalendarDate date);
public CalendarDate getNthDayOfWeek(int nth, int dayOfWeek, CalendarDate date) {
CalendarDate ndate = (CalendarDate) date.clone();
normalize(ndate);
long fd = getFixedDate(ndate);
long nfd;
if (nth > 0) {
nfd = 7 * nth + getDayOfWeekDateBefore(fd, dayOfWeek);
} else {
nfd = 7 * nth + getDayOfWeekDateAfter(fd, dayOfWeek);
}
getCalendarDateFromFixedDate(ndate, nfd);
return ndate;
}
static long getDayOfWeekDateBefore(long fixedDate, int dayOfWeek) {
return getDayOfWeekDateOnOrBefore(fixedDate - 1, dayOfWeek);
}
static long getDayOfWeekDateAfter(long fixedDate, int dayOfWeek) {
return getDayOfWeekDateOnOrBefore(fixedDate + 7, dayOfWeek);
}
public static long getDayOfWeekDateOnOrBefore(long fixedDate, int dayOfWeek) {
long fd = fixedDate - (dayOfWeek - 1);
if (fd >= 0) {
return fixedDate - (fd % 7);
}
return fixedDate - CalendarUtils.mod(fd, 7);
}
protected abstract long getFixedDate(CalendarDate date);
protected abstract void getCalendarDateFromFixedDate(CalendarDate date,
long fixedDate);
public boolean validateTime(CalendarDate date) {
int t = date.getHours();
if (t < 0 || t >= 24) {
return false;
}
t = date.getMinutes();
if (t < 0 || t >= 60) {
return false;
}
t = date.getSeconds();
if (t < 0 || t >= 60) {
return false;
}
t = date.getMillis();
if (t < 0 || t >= 1000) {
return false;
}
return true;
}
int normalizeTime(CalendarDate date) {
long fraction = getTimeOfDay(date);
long days = 0;
if (fraction >= DAY_IN_MILLIS) {
days = fraction / DAY_IN_MILLIS;
fraction %= DAY_IN_MILLIS;
} else if (fraction < 0) {
days = CalendarUtils.floorDivide(fraction, DAY_IN_MILLIS);
if (days != 0) {
fraction -= DAY_IN_MILLIS * days;             }
}
if (days != 0) {
date.setTimeOfDay(fraction);
}
date.setMillis((int)(fraction % 1000));
fraction /= 1000;
date.setSeconds((int)(fraction % 60));
fraction /= 60;
date.setMinutes((int)(fraction % 60));
date.setHours((int)(fraction / 60));
return (int)days;
}
}
package javax.swing;
import javax.swing.event.*;
import java.util.EventObject;
import java.io.Serializable;
@SuppressWarnings("serial") public abstract class AbstractCellEditor implements CellEditor, Serializable {
protected EventListenerList listenerList = new EventListenerList();
protected transient ChangeEvent changeEvent = null;
protected AbstractCellEditor() {}
public boolean isCellEditable(EventObject e) {
return true;
}
public boolean shouldSelectCell(EventObject anEvent) {
return true;
}
public boolean stopCellEditing() {
fireEditingStopped();
return true;
}
public void  cancelCellEditing() {
fireEditingCanceled();
}
public void addCellEditorListener(CellEditorListener l) {
listenerList.add(CellEditorListener.class, l);
}
public void removeCellEditorListener(CellEditorListener l) {
listenerList.remove(CellEditorListener.class, l);
}
public CellEditorListener[] getCellEditorListeners() {
return listenerList.getListeners(CellEditorListener.class);
}
protected void fireEditingStopped() {
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==CellEditorListener.class) {
if (changeEvent == null)
changeEvent = new ChangeEvent(this);
((CellEditorListener)listeners[i+1]).editingStopped(changeEvent);
}
}
}
protected void fireEditingCanceled() {
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==CellEditorListener.class) {
if (changeEvent == null)
changeEvent = new ChangeEvent(this);
((CellEditorListener)listeners[i+1]).editingCanceled(changeEvent);
}
}
}
}
package sun.nio.cs.ext;
import java.lang.ref.SoftReference;
import java.nio.charset.Charset;
import java.nio.charset.spi.CharsetProvider;
import java.util.ArrayList;
import java.util.TreeMap;
import java.util.Iterator;
import java.util.Map;
public class AbstractCharsetProvider
extends CharsetProvider
{
private Map<String,String> classMap
= new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
private Map<String,String> aliasMap
= new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
private Map<String,String[]> aliasNameMap
= new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
private Map<String,SoftReference<Charset>> cache
= new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
private String packagePrefix;
protected AbstractCharsetProvider() {
packagePrefix = "sun.nio.cs.";
}
protected AbstractCharsetProvider(String pkgPrefixName) {
packagePrefix = pkgPrefixName.concat(".");
}
private static <K,V> void remove(Map<K,V> m, K name) {
V x  = m.remove(name);
assert (x != null);
}
protected void charset(String name, String className, String[] aliases) {
synchronized (this) {
classMap.putIfAbsent(name, className);
for (int i = 0; i < aliases.length; i++)
aliasMap.putIfAbsent(aliases[i], name);
aliasNameMap.putIfAbsent(name, aliases);
cache.clear();
}
}
protected void deleteCharset(String name, String[] aliases) {
synchronized (this) {
remove(classMap, name);
for (int i = 0; i < aliases.length; i++)
remove(aliasMap, aliases[i]);
remove(aliasNameMap, name);
cache.clear();
}
}
protected boolean hasCharset(String name) {
synchronized (this) {
return classMap.containsKey(name);
}
}
protected void init() { }
private String canonicalize(String charsetName) {
String acn = aliasMap.get(charsetName);
return (acn != null) ? acn : charsetName;
}
private Charset lookup(String csn) {
SoftReference<Charset> sr = cache.get(csn);
if (sr != null) {
Charset cs = sr.get();
if (cs != null)
return cs;
}
String cln = classMap.get(csn);
if (cln == null)
return null;
try {
Class<?> c = Class.forName(packagePrefix.concat(cln),
true,
this.getClass().getClassLoader());
@SuppressWarnings("deprecation")
Charset cs = (Charset)c.newInstance();
cache.put(csn, new SoftReference<Charset>(cs));
return cs;
} catch (ClassNotFoundException x) {
return null;
} catch (IllegalAccessException x) {
return null;
} catch (InstantiationException x) {
return null;
}
}
public final Charset charsetForName(String charsetName) {
synchronized (this) {
init();
return lookup(canonicalize(charsetName));
}
}
public final Iterator<Charset> charsets() {
final ArrayList<String> ks;
synchronized (this) {
init();
ks = new ArrayList<>(classMap.keySet());
}
return new Iterator<Charset>() {
Iterator<String> i = ks.iterator();
public boolean hasNext() {
return i.hasNext();
}
public Charset next() {
String csn = i.next();
synchronized (AbstractCharsetProvider.this) {
return lookup(csn);
}
}
public void remove() {
throw new UnsupportedOperationException();
}
};
}
public final String[] aliases(String charsetName) {
synchronized (this) {
init();
return aliasNameMap.get(charsetName);
}
}
}
package java.time.chrono;
import static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH;
import static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR;
import static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_MONTH;
import static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_YEAR;
import static java.time.temporal.ChronoField.DAY_OF_MONTH;
import static java.time.temporal.ChronoField.DAY_OF_WEEK;
import static java.time.temporal.ChronoField.DAY_OF_YEAR;
import static java.time.temporal.ChronoField.EPOCH_DAY;
import static java.time.temporal.ChronoField.ERA;
import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
import static java.time.temporal.ChronoField.PROLEPTIC_MONTH;
import static java.time.temporal.ChronoField.YEAR;
import static java.time.temporal.ChronoField.YEAR_OF_ERA;
import static java.time.temporal.ChronoUnit.DAYS;
import static java.time.temporal.ChronoUnit.MONTHS;
import static java.time.temporal.ChronoUnit.WEEKS;
import static java.time.temporal.TemporalAdjusters.nextOrSame;
import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.time.DateTimeException;
import java.time.DayOfWeek;
import java.time.format.ResolverStyle;
import java.time.temporal.ChronoField;
import java.time.temporal.TemporalAdjusters;
import java.time.temporal.TemporalField;
import java.time.temporal.ValueRange;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import sun.util.logging.PlatformLogger;
public abstract class AbstractChronology implements Chronology {
private static final ConcurrentHashMap<String, Chronology> CHRONOS_BY_ID = new ConcurrentHashMap<>();
private static final ConcurrentHashMap<String, Chronology> CHRONOS_BY_TYPE = new ConcurrentHashMap<>();
static Chronology registerChrono(Chronology chrono) {
return registerChrono(chrono, chrono.getId());
}
static Chronology registerChrono(Chronology chrono, String id) {
Chronology prev = CHRONOS_BY_ID.putIfAbsent(id, chrono);
if (prev == null) {
String type = chrono.getCalendarType();
if (type != null) {
CHRONOS_BY_TYPE.putIfAbsent(type, chrono);
}
}
return prev;
}
private static boolean initCache() {
if (CHRONOS_BY_ID.get("ISO") == null) {
registerChrono(HijrahChronology.INSTANCE);
registerChrono(JapaneseChronology.INSTANCE);
registerChrono(MinguoChronology.INSTANCE);
registerChrono(ThaiBuddhistChronology.INSTANCE);
@SuppressWarnings("rawtypes")
ServiceLoader<AbstractChronology> loader =  ServiceLoader.load(AbstractChronology.class, null);
for (AbstractChronology chrono : loader) {
String id = chrono.getId();
if (id.equals("ISO") || registerChrono(chrono) != null) {
PlatformLogger logger = PlatformLogger.getLogger("java.time.chrono");
logger.warning("Ignoring duplicate Chronology, from ServiceLoader configuration "  + id);
}
}
registerChrono(IsoChronology.INSTANCE);
return true;
}
return false;
}
static Chronology ofLocale(Locale locale) {
Objects.requireNonNull(locale, "locale");
String type = locale.getUnicodeLocaleType("ca");
if (type == null || "iso".equals(type) || "iso8601".equals(type)) {
return IsoChronology.INSTANCE;
}
do {
Chronology chrono = CHRONOS_BY_TYPE.get(type);
if (chrono != null) {
return chrono;
}
} while (initCache());
@SuppressWarnings("rawtypes")
ServiceLoader<Chronology> loader = ServiceLoader.load(Chronology.class);
for (Chronology chrono : loader) {
if (type.equals(chrono.getCalendarType())) {
return chrono;
}
}
throw new DateTimeException("Unknown calendar system: " + type);
}
static Chronology of(String id) {
Objects.requireNonNull(id, "id");
do {
Chronology chrono = of0(id);
if (chrono != null) {
return chrono;
}
} while (initCache());
@SuppressWarnings("rawtypes")
ServiceLoader<Chronology> loader = ServiceLoader.load(Chronology.class);
for (Chronology chrono : loader) {
if (id.equals(chrono.getId()) || id.equals(chrono.getCalendarType())) {
return chrono;
}
}
throw new DateTimeException("Unknown chronology: " + id);
}
private static Chronology of0(String id) {
Chronology chrono = CHRONOS_BY_ID.get(id);
if (chrono == null) {
chrono = CHRONOS_BY_TYPE.get(id);
}
return chrono;
}
static Set<Chronology> getAvailableChronologies() {
initCache();               HashSet<Chronology> chronos = new HashSet<>(CHRONOS_BY_ID.values());
@SuppressWarnings("rawtypes")
ServiceLoader<Chronology> loader = ServiceLoader.load(Chronology.class);
for (Chronology chrono : loader) {
chronos.add(chrono);
}
return chronos;
}
protected AbstractChronology() {
}
@Override
public ChronoLocalDate resolveDate(Map<TemporalField, Long> fieldValues, ResolverStyle resolverStyle) {
if (fieldValues.containsKey(EPOCH_DAY)) {
return dateEpochDay(fieldValues.remove(EPOCH_DAY));
}
resolveProlepticMonth(fieldValues, resolverStyle);
ChronoLocalDate resolved = resolveYearOfEra(fieldValues, resolverStyle);
if (resolved != null) {
return resolved;
}
if (fieldValues.containsKey(YEAR)) {
if (fieldValues.containsKey(MONTH_OF_YEAR)) {
if (fieldValues.containsKey(DAY_OF_MONTH)) {
return resolveYMD(fieldValues, resolverStyle);
}
if (fieldValues.containsKey(ALIGNED_WEEK_OF_MONTH)) {
if (fieldValues.containsKey(ALIGNED_DAY_OF_WEEK_IN_MONTH)) {
return resolveYMAA(fieldValues, resolverStyle);
}
if (fieldValues.containsKey(DAY_OF_WEEK)) {
return resolveYMAD(fieldValues, resolverStyle);
}
}
}
if (fieldValues.containsKey(DAY_OF_YEAR)) {
return resolveYD(fieldValues, resolverStyle);
}
if (fieldValues.containsKey(ALIGNED_WEEK_OF_YEAR)) {
if (fieldValues.containsKey(ALIGNED_DAY_OF_WEEK_IN_YEAR)) {
return resolveYAA(fieldValues, resolverStyle);
}
if (fieldValues.containsKey(DAY_OF_WEEK)) {
return resolveYAD(fieldValues, resolverStyle);
}
}
}
return null;
}
void resolveProlepticMonth(Map<TemporalField, Long> fieldValues, ResolverStyle resolverStyle) {
Long pMonth = fieldValues.remove(PROLEPTIC_MONTH);
if (pMonth != null) {
if (resolverStyle != ResolverStyle.LENIENT) {
PROLEPTIC_MONTH.checkValidValue(pMonth);
}
ChronoLocalDate chronoDate = dateNow()
.with(DAY_OF_MONTH, 1).with(PROLEPTIC_MONTH, pMonth);
addFieldValue(fieldValues, MONTH_OF_YEAR, chronoDate.get(MONTH_OF_YEAR));
addFieldValue(fieldValues, YEAR, chronoDate.get(YEAR));
}
}
ChronoLocalDate resolveYearOfEra(Map<TemporalField, Long> fieldValues, ResolverStyle resolverStyle) {
Long yoeLong = fieldValues.remove(YEAR_OF_ERA);
if (yoeLong != null) {
Long eraLong = fieldValues.remove(ERA);
int yoe;
if (resolverStyle != ResolverStyle.LENIENT) {
yoe = range(YEAR_OF_ERA).checkValidIntValue(yoeLong, YEAR_OF_ERA);
} else {
yoe = Math.toIntExact(yoeLong);
}
if (eraLong != null) {
Era eraObj = eraOf(range(ERA).checkValidIntValue(eraLong, ERA));
addFieldValue(fieldValues, YEAR, prolepticYear(eraObj, yoe));
} else {
if (fieldValues.containsKey(YEAR)) {
int year = range(YEAR).checkValidIntValue(fieldValues.get(YEAR), YEAR);
ChronoLocalDate chronoDate = dateYearDay(year, 1);
addFieldValue(fieldValues, YEAR, prolepticYear(chronoDate.getEra(), yoe));
} else if (resolverStyle == ResolverStyle.STRICT) {
fieldValues.put(YEAR_OF_ERA, yoeLong);
} else {
List<Era> eras = eras();
if (eras.isEmpty()) {
addFieldValue(fieldValues, YEAR, yoe);
} else {
Era eraObj = eras.get(eras.size() - 1);
addFieldValue(fieldValues, YEAR, prolepticYear(eraObj, yoe));
}
}
}
} else if (fieldValues.containsKey(ERA)) {
range(ERA).checkValidValue(fieldValues.get(ERA), ERA);          }
return null;
}
ChronoLocalDate resolveYMD(Map<TemporalField, Long> fieldValues, ResolverStyle resolverStyle) {
int y = range(YEAR).checkValidIntValue(fieldValues.remove(YEAR), YEAR);
if (resolverStyle == ResolverStyle.LENIENT) {
long months = Math.subtractExact(fieldValues.remove(MONTH_OF_YEAR), 1);
long days = Math.subtractExact(fieldValues.remove(DAY_OF_MONTH), 1);
return date(y, 1, 1).plus(months, MONTHS).plus(days, DAYS);
}
int moy = range(MONTH_OF_YEAR).checkValidIntValue(fieldValues.remove(MONTH_OF_YEAR), MONTH_OF_YEAR);
ValueRange domRange = range(DAY_OF_MONTH);
int dom = domRange.checkValidIntValue(fieldValues.remove(DAY_OF_MONTH), DAY_OF_MONTH);
if (resolverStyle == ResolverStyle.SMART) {              try {
return date(y, moy, dom);
} catch (DateTimeException ex) {
return date(y, moy, 1).with(TemporalAdjusters.lastDayOfMonth());
}
}
return date(y, moy, dom);
}
ChronoLocalDate resolveYD(Map<TemporalField, Long> fieldValues, ResolverStyle resolverStyle) {
int y = range(YEAR).checkValidIntValue(fieldValues.remove(YEAR), YEAR);
if (resolverStyle == ResolverStyle.LENIENT) {
long days = Math.subtractExact(fieldValues.remove(DAY_OF_YEAR), 1);
return dateYearDay(y, 1).plus(days, DAYS);
}
int doy = range(DAY_OF_YEAR).checkValidIntValue(fieldValues.remove(DAY_OF_YEAR), DAY_OF_YEAR);
return dateYearDay(y, doy);      }
ChronoLocalDate resolveYMAA(Map<TemporalField, Long> fieldValues, ResolverStyle resolverStyle) {
int y = range(YEAR).checkValidIntValue(fieldValues.remove(YEAR), YEAR);
if (resolverStyle == ResolverStyle.LENIENT) {
long months = Math.subtractExact(fieldValues.remove(MONTH_OF_YEAR), 1);
long weeks = Math.subtractExact(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), 1);
long days = Math.subtractExact(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_MONTH), 1);
return date(y, 1, 1).plus(months, MONTHS).plus(weeks, WEEKS).plus(days, DAYS);
}
int moy = range(MONTH_OF_YEAR).checkValidIntValue(fieldValues.remove(MONTH_OF_YEAR), MONTH_OF_YEAR);
int aw = range(ALIGNED_WEEK_OF_MONTH).checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), ALIGNED_WEEK_OF_MONTH);
int ad = range(ALIGNED_DAY_OF_WEEK_IN_MONTH).checkValidIntValue(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_MONTH), ALIGNED_DAY_OF_WEEK_IN_MONTH);
ChronoLocalDate date = date(y, moy, 1).plus((aw - 1) * 7 + (ad - 1), DAYS);
if (resolverStyle == ResolverStyle.STRICT && date.get(MONTH_OF_YEAR) != moy) {
throw new DateTimeException("Strict mode rejected resolved date as it is in a different month");
}
return date;
}
ChronoLocalDate resolveYMAD(Map<TemporalField, Long> fieldValues, ResolverStyle resolverStyle) {
int y = range(YEAR).checkValidIntValue(fieldValues.remove(YEAR), YEAR);
if (resolverStyle == ResolverStyle.LENIENT) {
long months = Math.subtractExact(fieldValues.remove(MONTH_OF_YEAR), 1);
long weeks = Math.subtractExact(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), 1);
long dow = Math.subtractExact(fieldValues.remove(DAY_OF_WEEK), 1);
return resolveAligned(date(y, 1, 1), months, weeks, dow);
}
int moy = range(MONTH_OF_YEAR).checkValidIntValue(fieldValues.remove(MONTH_OF_YEAR), MONTH_OF_YEAR);
int aw = range(ALIGNED_WEEK_OF_MONTH).checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), ALIGNED_WEEK_OF_MONTH);
int dow = range(DAY_OF_WEEK).checkValidIntValue(fieldValues.remove(DAY_OF_WEEK), DAY_OF_WEEK);
ChronoLocalDate date = date(y, moy, 1).plus((aw - 1) * 7, DAYS).with(nextOrSame(DayOfWeek.of(dow)));
if (resolverStyle == ResolverStyle.STRICT && date.get(MONTH_OF_YEAR) != moy) {
throw new DateTimeException("Strict mode rejected resolved date as it is in a different month");
}
return date;
}
ChronoLocalDate resolveYAA(Map<TemporalField, Long> fieldValues, ResolverStyle resolverStyle) {
int y = range(YEAR).checkValidIntValue(fieldValues.remove(YEAR), YEAR);
if (resolverStyle == ResolverStyle.LENIENT) {
long weeks = Math.subtractExact(fieldValues.remove(ALIGNED_WEEK_OF_YEAR), 1);
long days = Math.subtractExact(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);
return dateYearDay(y, 1).plus(weeks, WEEKS).plus(days, DAYS);
}
int aw = range(ALIGNED_WEEK_OF_YEAR).checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_YEAR), ALIGNED_WEEK_OF_YEAR);
int ad = range(ALIGNED_DAY_OF_WEEK_IN_YEAR).checkValidIntValue(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_YEAR), ALIGNED_DAY_OF_WEEK_IN_YEAR);
ChronoLocalDate date = dateYearDay(y, 1).plus((aw - 1) * 7 + (ad - 1), DAYS);
if (resolverStyle == ResolverStyle.STRICT && date.get(YEAR) != y) {
throw new DateTimeException("Strict mode rejected resolved date as it is in a different year");
}
return date;
}
ChronoLocalDate resolveYAD(Map<TemporalField, Long> fieldValues, ResolverStyle resolverStyle) {
int y = range(YEAR).checkValidIntValue(fieldValues.remove(YEAR), YEAR);
if (resolverStyle == ResolverStyle.LENIENT) {
long weeks = Math.subtractExact(fieldValues.remove(ALIGNED_WEEK_OF_YEAR), 1);
long dow = Math.subtractExact(fieldValues.remove(DAY_OF_WEEK), 1);
return resolveAligned(dateYearDay(y, 1), 0, weeks, dow);
}
int aw = range(ALIGNED_WEEK_OF_YEAR).checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_YEAR), ALIGNED_WEEK_OF_YEAR);
int dow = range(DAY_OF_WEEK).checkValidIntValue(fieldValues.remove(DAY_OF_WEEK), DAY_OF_WEEK);
ChronoLocalDate date = dateYearDay(y, 1).plus((aw - 1) * 7, DAYS).with(nextOrSame(DayOfWeek.of(dow)));
if (resolverStyle == ResolverStyle.STRICT && date.get(YEAR) != y) {
throw new DateTimeException("Strict mode rejected resolved date as it is in a different year");
}
return date;
}
ChronoLocalDate resolveAligned(ChronoLocalDate base, long months, long weeks, long dow) {
ChronoLocalDate date = base.plus(months, MONTHS).plus(weeks, WEEKS);
if (dow > 7) {
date = date.plus((dow - 1) / 7, WEEKS);
dow = ((dow - 1) % 7) + 1;
} else if (dow < 1) {
date = date.plus(Math.subtractExact(dow,  7) / 7, WEEKS);
dow = ((dow + 6) % 7) + 1;
}
return date.with(nextOrSame(DayOfWeek.of((int) dow)));
}
void addFieldValue(Map<TemporalField, Long> fieldValues, ChronoField field, long value) {
Long old = fieldValues.get(field);          if (old != null && old.longValue() != value) {
throw new DateTimeException("Conflict found: " + field + " " + old + " differs from " + field + " " + value);
}
fieldValues.put(field, value);
}
@Override
public int compareTo(Chronology other) {
return getId().compareTo(other.getId());
}
@Override
public boolean equals(Object obj) {
if (this == obj) {
return true;
}
if (obj instanceof AbstractChronology) {
return compareTo((AbstractChronology) obj) == 0;
}
return false;
}
@Override
public int hashCode() {
return getClass().hashCode() ^ getId().hashCode();
}
@Override
public String toString() {
return getId();
}
@java.io.Serial
Object writeReplace() {
return new Ser(Ser.CHRONO_TYPE, (Serializable)this);
}
@java.io.Serial
private void readObject(ObjectInputStream s) throws ObjectStreamException {
throw new InvalidObjectException("Deserialization via serialization delegate");
}
void writeExternal(DataOutput out) throws IOException {
out.writeUTF(getId());
}
static Chronology readExternal(DataInput in) throws IOException {
String id = in.readUTF();
return Chronology.of(id);
}
}
package compiler.jvmci.common.testcases;
public abstract class AbstractClass {
public static final long initTime = System.currentTimeMillis();
public abstract void abstractMethod();
}
package compiler.jvmci.common.testcases;
public class AbstractClassExtender extends AbstractClass {
@Override
public void abstractMethod() {
}
@Override
protected void finalize() throws Throwable {
super.finalize();
}
}
package jdk.internal.loader;
import jdk.internal.access.JavaLangAccess;
import jdk.internal.access.SharedSecrets;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.Iterator;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiFunction;
import java.util.function.Supplier;
public abstract class AbstractClassLoaderValue<CLV extends AbstractClassLoaderValue<CLV, V>, V> {
AbstractClassLoaderValue() {}
public abstract Object key();
public <K> Sub<K> sub(K key) {
return new Sub<>(key);
}
public abstract boolean isEqualOrDescendantOf(AbstractClassLoaderValue<?, V> clv);
public V get(ClassLoader cl) {
Object val = AbstractClassLoaderValue.<CLV>map(cl).get(this);
try {
return extractValue(val);
} catch (Memoizer.RecursiveInvocationException e) {
throw e;
} catch (Throwable t) {
return null;
}
}
public V putIfAbsent(ClassLoader cl, V v) {
ConcurrentHashMap<CLV, Object> map = map(cl);
@SuppressWarnings("unchecked")
CLV clv = (CLV) this;
while (true) {
try {
Object val = map.putIfAbsent(clv, v);
return extractValue(val);
} catch (Memoizer.RecursiveInvocationException e) {
throw e;
} catch (Throwable t) {
}
}
}
public boolean remove(ClassLoader cl, Object v) {
return AbstractClassLoaderValue.<CLV>map(cl).remove(this, v);
}
public V computeIfAbsent(ClassLoader cl,
BiFunction<
? super ClassLoader,
? super CLV,
? extends V
> mappingFunction) throws IllegalStateException {
ConcurrentHashMap<CLV, Object> map = map(cl);
@SuppressWarnings("unchecked")
CLV clv = (CLV) this;
Memoizer<CLV, V> mv = null;
while (true) {
Object val = (mv == null) ? map.get(clv) : map.putIfAbsent(clv, mv);
if (val == null) {
if (mv == null) {
mv = new Memoizer<>(cl, clv, mappingFunction);
continue;
}
try {
V v = mv.get();
map.replace(clv, mv, v);
return v;
} catch (Throwable t) {
map.remove(clv, mv);
throw t;
}
} else {
try {
return extractValue(val);
} catch (Memoizer.RecursiveInvocationException e) {
throw e;
} catch (Throwable t) {
}
}
}
}
public void removeAll(ClassLoader cl) {
ConcurrentHashMap<CLV, Object> map = map(cl);
for (Iterator<CLV> i = map.keySet().iterator(); i.hasNext(); ) {
if (i.next().isEqualOrDescendantOf(this)) {
i.remove();
}
}
}
private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
@SuppressWarnings("unchecked")
private static <CLV extends AbstractClassLoaderValue<CLV, ?>>
ConcurrentHashMap<CLV, Object> map(ClassLoader cl) {
return (ConcurrentHashMap<CLV, Object>)
(cl == null ? BootLoader.getClassLoaderValueMap()
: JLA.createOrGetClassLoaderValueMap(cl));
}
@SuppressWarnings("unchecked")
private V extractValue(Object memoizerOrValue) {
if (memoizerOrValue instanceof Memoizer) {
return ((Memoizer<?, V>) memoizerOrValue).get();
} else {
return (V) memoizerOrValue;
}
}
private static final class Memoizer<CLV extends AbstractClassLoaderValue<CLV, V>, V>
implements Supplier<V> {
private final ClassLoader cl;
private final CLV clv;
private final BiFunction<? super ClassLoader, ? super CLV, ? extends V>
mappingFunction;
private volatile V v;
private volatile Throwable t;
private boolean inCall;
Memoizer(ClassLoader cl,
CLV clv,
BiFunction<? super ClassLoader, ? super CLV, ? extends V>
mappingFunction
) {
this.cl = cl;
this.clv = clv;
this.mappingFunction = mappingFunction;
}
@Override
public V get() throws RecursiveInvocationException {
V v = this.v;
if (v != null) return v;
Throwable t = this.t;
if (t == null) {
synchronized (this) {
if ((v = this.v) == null && (t = this.t) == null) {
if (inCall) {
throw new RecursiveInvocationException();
}
inCall = true;
try {
this.v = v = Objects.requireNonNull(
mappingFunction.apply(cl, clv));
} catch (Throwable x) {
this.t = t = x;
} finally {
inCall = false;
}
}
}
}
if (v != null) return v;
if (t instanceof Error) {
throw (Error) t;
} else if (t instanceof RuntimeException) {
throw (RuntimeException) t;
} else {
throw new UndeclaredThrowableException(t);
}
}
static class RecursiveInvocationException extends IllegalStateException {
@java.io.Serial
private static final long serialVersionUID = 1L;
RecursiveInvocationException() {
super("Recursive call");
}
}
}
public final class Sub<K> extends AbstractClassLoaderValue<Sub<K>, V> {
private final K key;
Sub(K key) {
this.key = key;
}
public AbstractClassLoaderValue<CLV, V> parent() {
return AbstractClassLoaderValue.this;
}
@Override
public K key() {
return key;
}
@Override
public boolean isEqualOrDescendantOf(AbstractClassLoaderValue<?, V> clv) {
return equals(Objects.requireNonNull(clv)) ||
parent().isEqualOrDescendantOf(clv);
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (!(o instanceof Sub)) return false;
@SuppressWarnings("unchecked")
Sub<?> that = (Sub<?>) o;
return this.parent().equals(that.parent()) &&
Objects.equals(this.key, that.key);
}
@Override
public int hashCode() {
return 31 * parent().hashCode() +
Objects.hashCode(key);
}
}
}
package crules;
import java.text.MessageFormat;
import java.util.Locale;
import java.util.ResourceBundle;
import com.sun.source.util.JavacTask;
import com.sun.tools.javac.api.BasicJavacTask;
import com.sun.tools.javac.code.Symtab;
import com.sun.tools.javac.model.JavacElements;
import com.sun.tools.javac.model.JavacTypes;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.tree.TreeScanner;
import com.sun.tools.javac.util.Context;
import com.sun.tools.javac.util.JCDiagnostic;
import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
import com.sun.tools.javac.util.Log;
import com.sun.tools.javac.util.Options;
import com.sun.tools.javac.util.RawDiagnosticFormatter;
import static com.sun.source.util.TaskEvent.Kind;
public abstract class AbstractCodingRulesAnalyzer {
private   final Log log;
private   final boolean rawDiagnostics;
private   final JCDiagnostic.Factory diags;
private   final Options options;
protected final Messages messages;
protected final Symtab syms;
protected final JavacElements elements;
protected final JavacTypes types;
protected TreeScanner treeVisitor;
protected Kind eventKind;
public AbstractCodingRulesAnalyzer(JavacTask task) {
BasicJavacTask impl = (BasicJavacTask)task;
Context context = impl.getContext();
log = Log.instance(context);
options = Options.instance(context);
rawDiagnostics = options.isSet("rawDiagnostics");
diags = JCDiagnostic.Factory.instance(context);
messages = new Messages();
syms = Symtab.instance(context);
elements = JavacElements.instance(context);
types = JavacTypes.instance(context);
}
protected class Messages {
ResourceBundle bundle;
Messages() {
String name = getClass().getPackage().getName() + ".resources.crules";
bundle = ResourceBundle.getBundle(name, Locale.ENGLISH);
}
public void error(JCTree tree, String code, Object... args) {
String msg;
if (rawDiagnostics) {
RawDiagnosticFormatter f = new RawDiagnosticFormatter(options);
msg = f.formatMessage(diags.create(DiagnosticType.FRAGMENT, log.currentSource(),
tree.pos(), code, args), null);
} else {
msg = (code == null) ? (String) args[0] : localize(code, args);
}
log.error(tree, "proc.messager", msg.toString());
}
private String localize(String code, Object... args) {
String msg = bundle.getString(code);
if (msg == null) {
StringBuilder sb = new StringBuilder();
sb.append("message file broken: code=").append(code);
if (args.length > 0) {
sb.append(" arguments={0}");
for (int i = 1; i < args.length; i++) {
sb.append(", {").append(i).append("}");
}
}
msg = sb.toString();
}
return MessageFormat.format(msg, args);
}
}
}
package java.util;
import jdk.internal.util.ArraysSupport;
public abstract class AbstractCollection<E> implements Collection<E> {
protected AbstractCollection() {
}
public abstract Iterator<E> iterator();
public abstract int size();
public boolean isEmpty() {
return size() == 0;
}
public boolean contains(Object o) {
Iterator<E> it = iterator();
if (o==null) {
while (it.hasNext())
if (it.next()==null)
return true;
} else {
while (it.hasNext())
if (o.equals(it.next()))
return true;
}
return false;
}
public Object[] toArray() {
Object[] r = new Object[size()];
Iterator<E> it = iterator();
for (int i = 0; i < r.length; i++) {
if (! it.hasNext())                 return Arrays.copyOf(r, i);
r[i] = it.next();
}
return it.hasNext() ? finishToArray(r, it) : r;
}
@SuppressWarnings("unchecked")
public <T> T[] toArray(T[] a) {
int size = size();
T[] r = a.length >= size ? a :
(T[])java.lang.reflect.Array
.newInstance(a.getClass().getComponentType(), size);
Iterator<E> it = iterator();
for (int i = 0; i < r.length; i++) {
if (! it.hasNext()) {                 if (a == r) {
r[i] = null;                 } else if (a.length < i) {
return Arrays.copyOf(r, i);
} else {
System.arraycopy(r, 0, a, 0, i);
if (a.length > i) {
a[i] = null;
}
}
return a;
}
r[i] = (T)it.next();
}
return it.hasNext() ? finishToArray(r, it) : r;
}
@SuppressWarnings("unchecked")
private static <T> T[] finishToArray(T[] r, Iterator<?> it) {
int len = r.length;
int i = len;
while (it.hasNext()) {
if (i == len) {
len = ArraysSupport.newLength(len,
1,
(len >> 1) + 1 );
r = Arrays.copyOf(r, len);
}
r[i++] = (T)it.next();
}
return (i == len) ? r : Arrays.copyOf(r, i);
}
public boolean add(E e) {
throw new UnsupportedOperationException();
}
public boolean remove(Object o) {
Iterator<E> it = iterator();
if (o==null) {
while (it.hasNext()) {
if (it.next()==null) {
it.remove();
return true;
}
}
} else {
while (it.hasNext()) {
if (o.equals(it.next())) {
it.remove();
return true;
}
}
}
return false;
}
public boolean containsAll(Collection<?> c) {
for (Object e : c)
if (!contains(e))
return false;
return true;
}
public boolean addAll(Collection<? extends E> c) {
boolean modified = false;
for (E e : c)
if (add(e))
modified = true;
return modified;
}
public boolean removeAll(Collection<?> c) {
Objects.requireNonNull(c);
boolean modified = false;
Iterator<?> it = iterator();
while (it.hasNext()) {
if (c.contains(it.next())) {
it.remove();
modified = true;
}
}
return modified;
}
public boolean retainAll(Collection<?> c) {
Objects.requireNonNull(c);
boolean modified = false;
Iterator<E> it = iterator();
while (it.hasNext()) {
if (!c.contains(it.next())) {
it.remove();
modified = true;
}
}
return modified;
}
public void clear() {
Iterator<E> it = iterator();
while (it.hasNext()) {
it.next();
it.remove();
}
}
public String toString() {
Iterator<E> it = iterator();
if (! it.hasNext())
return "[]";
StringBuilder sb = new StringBuilder();
sb.append('[');
for (;;) {
E e = it.next();
sb.append(e == this ? "(this Collection)" : e);
if (! it.hasNext())
return sb.append(']').toString();
sb.append(',').append(' ');
}
}
}
package javax.swing.colorchooser;
import java.awt.*;
import java.beans.BeanProperty;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import javax.swing.*;
@SuppressWarnings("serial") public abstract class AbstractColorChooserPanel extends JPanel {
public static final String TRANSPARENCY_ENABLED_PROPERTY
= "TransparencyEnabled";
private final PropertyChangeListener enabledListener = new PropertyChangeListener() {
public void propertyChange(PropertyChangeEvent event) {
Object value = event.getNewValue();
if (value instanceof Boolean) {
setEnabled((Boolean) value);
}
}
};
private JColorChooser chooser;
protected AbstractColorChooserPanel() {}
public abstract void updateChooser();
protected abstract void buildChooser();
public abstract String getDisplayName();
public int getMnemonic() {
return 0;
}
public int getDisplayedMnemonicIndex() {
return -1;
}
public abstract Icon getSmallDisplayIcon();
public abstract Icon getLargeDisplayIcon();
public void installChooserPanel(JColorChooser enclosingChooser) {
if (chooser != null) {
throw new RuntimeException ("This chooser panel is already installed");
}
chooser = enclosingChooser;
chooser.addPropertyChangeListener("enabled", enabledListener);
setEnabled(chooser.isEnabled());
buildChooser();
updateChooser();
}
public void uninstallChooserPanel(JColorChooser enclosingChooser) {
chooser.removePropertyChangeListener("enabled", enabledListener);
chooser = null;
}
public ColorSelectionModel getColorSelectionModel() {
return (this.chooser != null)
? this.chooser.getSelectionModel()
: null;
}
protected Color getColorFromModel() {
ColorSelectionModel model = getColorSelectionModel();
return (model != null)
? model.getSelectedColor()
: null;
}
void setSelectedColor(Color color) {
ColorSelectionModel model = getColorSelectionModel();
if (model != null) {
model.setSelectedColor(color);
}
}
@BeanProperty(description
= "Sets the transparency of a color selection on or off.")
public void setColorTransparencySelectionEnabled(boolean b){
}
public boolean isColorTransparencySelectionEnabled(){
return true;
}
public void paint(Graphics g) {
super.paint(g);
}
int getInt(Object key, int defaultValue) {
Object value = UIManager.get(key, getLocale());
if (value instanceof Integer) {
return ((Integer)value).intValue();
}
if (value instanceof String) {
try {
return Integer.parseInt((String)value);
} catch (NumberFormatException nfe) {}
}
return defaultValue;
}
}
package compiler.compilercontrol.share.scenario;
import compiler.compilercontrol.share.method.MethodDescriptor;
import compiler.compilercontrol.share.pool.PoolHelper;
import jdk.test.lib.util.Pair;
import java.lang.reflect.Executable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
public abstract class AbstractCommandBuilder
implements StateBuilder<CompileCommand> {
protected static final List<Pair<Executable, Callable<?>>> METHODS
= new PoolHelper().getAllMethods();
protected final List<CompileCommand> compileCommands = new ArrayList<>();
@Override
public void add(CompileCommand command) {
compileCommands.add(command);
CommandStateBuilder.getInstance().add(command);
}
@Override
public Map<Executable, State> getStates() {
return CommandStateBuilder.getInstance().getStates();
}
@Override
public List<CompileCommand> getCompileCommands() {
return Collections.unmodifiableList(compileCommands);
}
@Override
public boolean isValid() {
boolean isValid = true;
for (CompileCommand cmd : compileCommands) {
isValid &= cmd.isValid();
}
return isValid;
}
private static class CommandStateBuilder {
private static final CommandStateBuilder INSTANCE
= new CommandStateBuilder();
private final List<CompileCommand> optionCommands = new ArrayList<>();
private final List<CompileCommand> fileCommands = new ArrayList<>();
private CommandStateBuilder() { }
public static CommandStateBuilder getInstance() {
return INSTANCE;
}
public void add(CompileCommand command) {
switch (command.type) {
case OPTION:
optionCommands.add(command);
break;
case FILE:
fileCommands.add(command);
break;
default:
throw new Error("TESTBUG: wrong type: " + command.type);
}
}
public Map<Executable, State> getStates() {
List<CompileCommand> commandList = new ArrayList<>();
commandList.addAll(optionCommands);
commandList.addAll(fileCommands);
Map<Executable, State> states = new HashMap<>();
for (Pair<Executable, Callable<?>> pair : METHODS) {
Executable exec = pair.first;
State state = getState(commandList, exec);
states.put(exec, state);
}
return states;
}
private State getState(List<CompileCommand> commandList,
Executable exec) {
State state = new State();
MethodDescriptor execDesc = new MethodDescriptor(exec);
for (CompileCommand compileCommand : commandList) {
if (compileCommand.isValid()) {
CompileCommand cc = new CompileCommand(
compileCommand.command,
compileCommand.methodDescriptor,
null,
compileCommand.type);
MethodDescriptor md = cc.methodDescriptor;
if (execDesc.getCanonicalString().matches(md.getRegexp())) {
if (cc.command == Command.COMPILEONLY
&& !state.isCompilable()) {
} else {
state.apply(cc);
}
}
}
}
for (CompileCommand compileCommand : commandList) {
if (compileCommand.isValid()
&& (compileCommand.command == Command.COMPILEONLY)) {
MethodDescriptor md = compileCommand.methodDescriptor;
if (!execDesc.getCanonicalString().matches(md.getRegexp())
&& (!state.getCompilableOptional(
Scenario.Compiler.C2).isPresent())) {
state.setC1Compilable(false);
state.setC2Compilable(false);
}
}
}
return state;
}
}
}
package build.tools.jdwpgen;
import java.io.*;
class AbstractCommandNode extends AbstractNamedNode {
void document(PrintWriter writer) {
writer.println("<h3 id=\"" + context.whereC + "\">" + name +
" Command (" + nameNode.value() + ")</h3>");
writer.println(comment());
writer.println("<dl>");
for (Node node : components) {
node.document(writer);
}
writer.println("</dl>");
}
void documentIndex(PrintWriter writer) {
writer.print("        <li><a href=\"#" + context.whereC + "\">");
writer.println(name() + "</a> (" + nameNode.value() + ")");
}
}
package java.lang.invoke;
import java.util.*;
import jdk.internal.vm.annotation.Stable;
abstract class AbstractConstantGroup implements ConstantGroup {
protected final int size;
AbstractConstantGroup(int size) {
this.size = size;
}
@Override public final int size() {
return size;
}
public abstract Object get(int index) throws LinkageError;
public abstract Object get(int index, Object ifNotPresent);
public abstract boolean isPresent(int index);
@Override public String toString() {
return asList("*").toString();
}
static class AsIterator implements Iterator<Object> {
private final ConstantGroup self;
private final int end;
private final boolean resolving;
private final Object ifNotPresent;
private int index;
private AsIterator(ConstantGroup self, int start, int end,
boolean resolving, Object ifNotPresent) {
this.self = self;
this.end = end;
this.index = start;
this.resolving = resolving;
this.ifNotPresent = ifNotPresent;
}
AsIterator(ConstantGroup self, int start, int end) {
this(self, start, end, true, null);
}
AsIterator(ConstantGroup self, int start, int end,
Object ifNotPresent) {
this(self, start, end, false, ifNotPresent);
}
@Override
public boolean hasNext() {
return index < end;
}
@Override
public Object next() {
int i = bumpIndex();
if (resolving)
return self.get(i);
else
return self.get(i, ifNotPresent);
}
private int bumpIndex() {
int i = index;
if (i >= end)  throw new NoSuchElementException();
index = i+1;
return i;
}
}
static class SubGroup extends AbstractConstantGroup {
private final ConstantGroup self;          private final int offset;          SubGroup(ConstantGroup self, int start, int end) {
super(end - start);
this.self = self;
this.offset = start;
Objects.checkFromToIndex(start, end, size);
}
private int mapIndex(int index) {
return Objects.checkIndex(index, size) + offset;
}
@Override
public Object get(int index) {
return self.get(mapIndex(index));
}
@Override
public Object get(int index, Object ifNotPresent) {
return self.get(mapIndex(index), ifNotPresent);
}
@Override
public boolean isPresent(int index) {
return self.isPresent(mapIndex(index));
}
@Override
public ConstantGroup subGroup(int start, int end) {
Objects.checkFromToIndex(start, end, size);
return new SubGroup(self, offset + start, offset + end);
}
@Override
public List<Object> asList() {
return new AsList(self, offset, offset + size);
}
@Override
public List<Object> asList(Object ifNotPresent) {
return new AsList(self, offset, offset + size, ifNotPresent);
}
@Override
public int copyConstants(int start, int end,
Object[] buf, int pos) throws LinkageError {
Objects.checkFromToIndex(start, end, size);
return self.copyConstants(offset + start, offset + end,
buf, pos);
}
@Override
public int copyConstants(int start, int end,
Object[] buf, int pos,
Object ifNotPresent) {
Objects.checkFromToIndex(start, end, size);
return self.copyConstants(offset + start, offset + end,
buf, pos, ifNotPresent);
}
}
static class AsList extends AbstractList<Object> {
private final ConstantGroup self;
private final int size;
private final int offset;
private final boolean resolving;
private final Object ifNotPresent;
private AsList(ConstantGroup self, int start, int end,
boolean resolving, Object ifNotPresent) {
this.self = self;
this.size = end - start;
this.offset = start;
this.resolving = resolving;
this.ifNotPresent = ifNotPresent;
Objects.checkFromToIndex(start, end, self.size());
}
AsList(ConstantGroup self, int start, int end) {
this(self, start, end, true, null);
}
AsList(ConstantGroup self, int start, int end,
Object ifNotPresent) {
this(self, start, end, false, ifNotPresent);
}
private int mapIndex(int index) {
return Objects.checkIndex(index, size) + offset;
}
@Override public final int size() {
return size;
}
@Override public Object get(int index) {
if (resolving)
return self.get(mapIndex(index));
else
return self.get(mapIndex(index), ifNotPresent);
}
@Override
public Iterator<Object> iterator() {
if (resolving)
return new AsIterator(self, offset, offset + size);
else
return new AsIterator(self, offset, offset + size, ifNotPresent);
}
@Override public List<Object> subList(int start, int end) {
Objects.checkFromToIndex(start, end, size);
return new AsList(self, offset + start, offset + end,
resolving, ifNotPresent);
}
@Override public Object[] toArray() {
return toArray(new Object[size]);
}
@Override public <T> T[] toArray(T[] a) {
int pad = a.length - size;
if (pad < 0) {
pad = 0;
a = Arrays.copyOf(a, size);
}
if (resolving)
self.copyConstants(offset, offset + size, a, 0);
else
self.copyConstants(offset, offset + size, a, 0,
ifNotPresent);
if (pad > 0)  a[size] = null;
return a;
}
}
abstract static
class WithCache extends AbstractConstantGroup {
@Stable final Object[] cache;
WithCache(int size) {
super(size);
cache = new Object[size];
}
void initializeCache(List<Object> cacheContents, Object ifNotPresent) {
for (int i = 0; i < cache.length; i++) {
Object x = cacheContents.get(i);
if (x == ifNotPresent)
continue;                  if (x == null)
x = RESOLVED_TO_NULL;
cache[i] = x;
}
}
@Override public Object get(int i) {
Object x = cache[i];
if (x == null)  x = fillCache(i);
return unwrapNull(x);
}
@Override public Object get(int i, Object ifNotAvailable) {
Object x = cache[i];
if (x == null)  return ifNotAvailable;
return unwrapNull(x);
}
@Override
public boolean isPresent(int i) {
return cache[i] != null;
}
Object fillCache(int i) {
throw new NoSuchElementException("constant group does not contain element #"+i);
}
static Object wrapNull(Object x) {
return x == null ? RESOLVED_TO_NULL : x;
}
static Object unwrapNull(Object x) {
assert(x != null);
return x == RESOLVED_TO_NULL ? null : x;
}
static final Object RESOLVED_TO_NULL = new Object();
static final Object NOT_PRESENT = new Object();
}
static class BSCIWithCache<T> extends WithCache implements BootstrapCallInfo<T> {
private final MethodHandle bsm;
private final String name;
private final T type;
@Override public String toString() {
return bsm+"/"+name+":"+type+super.toString();
}
BSCIWithCache(MethodHandle bsm, String name, T type, int size) {
super(size);
this.type = type;
this.bsm = bsm;
this.name = name;
assert(type instanceof Class || type instanceof MethodType);
}
@Override public MethodHandle bootstrapMethod() { return bsm; }
@Override public String invocationName() { return name; }
@Override public T invocationType() { return type; }
}
}
package sun.management.counter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
public abstract class AbstractCounter implements Counter {
String name;
Units units;
Variability variability;
int flags;
int vectorLength;
class Flags {
static final int SUPPORTED = 0x1;
}
protected AbstractCounter(String name, Units units,
Variability variability, int flags,
int vectorLength) {
this.name = name;
this.units = units;
this.variability = variability;
this.flags = flags;
this.vectorLength = vectorLength;
}
protected AbstractCounter(String name, Units units,
Variability variability, int flags) {
this(name, units, variability, flags, 0);
}
public String getName() {
return name;
}
public Units getUnits() {
return units;
}
public Variability getVariability() {
return variability;
}
public boolean isVector() {
return vectorLength > 0;
}
public int getVectorLength() {
return vectorLength;
}
public boolean isInternal() {
return (flags & Flags.SUPPORTED) == 0;
}
public int getFlags() {
return flags;
}
public abstract Object getValue();
public String toString() {
String result = getName() + ": " + getValue() + " " + getUnits();
if (isInternal()) {
return result + " [INTERNAL]";
} else {
return result;
}
}
private static final long serialVersionUID = 6992337162326171013L;
}
package com.sun.media.sound;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Control;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.LineEvent;
import javax.sound.sampled.LineUnavailableException;
abstract class AbstractDataLine extends AbstractLine implements DataLine {
private final AudioFormat defaultFormat;
private final int defaultBufferSize;
protected final Object lock = new Object();
protected AudioFormat format;
protected int bufferSize;
private volatile boolean running;
private volatile boolean started;
private volatile boolean active;
protected AbstractDataLine(DataLine.Info info, AbstractMixer mixer, Control[] controls) {
this(info, mixer, controls, null, AudioSystem.NOT_SPECIFIED);
}
protected AbstractDataLine(DataLine.Info info, AbstractMixer mixer, Control[] controls, AudioFormat format, int bufferSize) {
super(info, mixer, controls);
if (format != null) {
defaultFormat = format;
} else {
defaultFormat = new AudioFormat(44100.0f, 16, 2, true, Platform.isBigEndian());
}
if (bufferSize > 0) {
defaultBufferSize = bufferSize;
} else {
defaultBufferSize = ((int) (defaultFormat.getFrameRate() / 2)) * defaultFormat.getFrameSize();
}
this.format = defaultFormat;
this.bufferSize = defaultBufferSize;
}
public final void open(AudioFormat format, int bufferSize) throws LineUnavailableException {
synchronized (mixer) {
if (!isOpen()) {
Toolkit.isFullySpecifiedAudioFormat(format);
mixer.open(this);
try {
implOpen(format, bufferSize);
setOpen(true);
} catch (LineUnavailableException e) {
mixer.close(this);
throw e;
}
} else {
if (!format.matches(getFormat())) {
throw new IllegalStateException("Line is already open with format " + getFormat() +
" and bufferSize " + getBufferSize());
}
if (bufferSize > 0) {
setBufferSize(bufferSize);
}
}
}
}
public final void open(AudioFormat format) throws LineUnavailableException {
open(format, AudioSystem.NOT_SPECIFIED);
}
@Override
public int available() {
return 0;
}
@Override
public void drain() {
}
@Override
public void flush() {
}
@Override
public final void start() {
synchronized(mixer) {
if (isOpen()) {
if (!isStartedRunning()) {
mixer.start(this);
implStart();
running = true;
}
}
}
synchronized(lock) {
lock.notifyAll();
}
}
@Override
public final void stop() {
synchronized(mixer) {
if (isOpen()) {
if (isStartedRunning()) {
implStop();
mixer.stop(this);
running = false;
if (started && (!isActive())) {
setStarted(false);
}
}
}
}
synchronized(lock) {
lock.notifyAll();
}
}
@Override
public final boolean isRunning() {
return started;
}
@Override
public final boolean isActive() {
return active;
}
@Override
public final long getMicrosecondPosition() {
long microseconds = getLongFramePosition();
if (microseconds != AudioSystem.NOT_SPECIFIED) {
microseconds = Toolkit.frames2micros(getFormat(), microseconds);
}
return microseconds;
}
@Override
public final AudioFormat getFormat() {
return format;
}
@Override
public final int getBufferSize() {
return bufferSize;
}
public final int setBufferSize(int newSize) {
return getBufferSize();
}
@Override
public final float getLevel() {
return (float)AudioSystem.NOT_SPECIFIED;
}
final boolean isStartedRunning() {
return running;
}
final void setActive(boolean active) {
this.active = active;
}
final void setStarted(boolean started) {
boolean sendEvents = false;
long position = getLongFramePosition();
if (this.started != started) {
this.started = started;
sendEvents = true;
}
if (sendEvents) {
if (started) {
sendEvents(new LineEvent(this, LineEvent.Type.START, position));
} else {
sendEvents(new LineEvent(this, LineEvent.Type.STOP, position));
}
}
}
final void setEOM() {
setStarted(false);
}
@Override
public final void open() throws LineUnavailableException {
open(format, bufferSize);
}
@Override
public final void close() {
synchronized (mixer) {
if (isOpen()) {
stop();
setOpen(false);
implClose();
mixer.close(this);
format = defaultFormat;
bufferSize = defaultBufferSize;
}
}
}
abstract void implOpen(AudioFormat format, int bufferSize) throws LineUnavailableException;
abstract void implClose();
abstract void implStart();
abstract void implStop();
}
package com.sun.org.apache.xerces.internal.impl.dv.xs;
import java.math.BigDecimal;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.Duration;
import javax.xml.datatype.XMLGregorianCalendar;
import com.sun.org.apache.xerces.internal.impl.Constants;
import com.sun.org.apache.xerces.internal.jaxp.datatype.DatatypeFactoryImpl;
import com.sun.org.apache.xerces.internal.xs.datatypes.XSDateTime;
public abstract class AbstractDateTimeDV extends TypeValidator {
private static final boolean DEBUG = false;
protected final static int YEAR = 2000;
protected final static int MONTH = 01;
protected final static int DAY = 01;
protected static final DatatypeFactory datatypeFactory = new DatatypeFactoryImpl();
@Override
public short getAllowedFacets() {
return (XSSimpleTypeDecl.FACET_PATTERN | XSSimpleTypeDecl.FACET_WHITESPACE | XSSimpleTypeDecl.FACET_ENUMERATION | XSSimpleTypeDecl.FACET_MAXINCLUSIVE | XSSimpleTypeDecl.FACET_MININCLUSIVE | XSSimpleTypeDecl.FACET_MAXEXCLUSIVE | XSSimpleTypeDecl.FACET_MINEXCLUSIVE);
}
@Override
public boolean isIdentical(Object value1, Object value2) {
if (!(value1 instanceof DateTimeData) || !(value2 instanceof DateTimeData)) {
return false;
}
DateTimeData v1 = (DateTimeData) value1;
DateTimeData v2 = (DateTimeData) value2;
if ((v1.timezoneHr == v2.timezoneHr) && (v1.timezoneMin == v2.timezoneMin)) {
return v1.equals(v2);
}
return false;
}
@Override
public int compare(Object value1, Object value2) {
return compareDates(((DateTimeData) value1),
((DateTimeData) value2), true);
}
protected short compareDates(DateTimeData date1, DateTimeData date2, boolean strict) {
if (date1.utc == date2.utc) {
return compareOrder(date1, date2);
}
short c1, c2;
DateTimeData tempDate = new DateTimeData(null, this);
if (date1.utc == 'Z') {
cloneDate(date2, tempDate);             tempDate.timezoneHr = 14;
tempDate.timezoneMin = 0;
tempDate.utc = '+';
normalize(tempDate);
c1 = compareOrder(date1, tempDate);
if (c1 == LESS_THAN) {
return c1;
}
cloneDate(date2, tempDate);             tempDate.timezoneHr = -14;
tempDate.timezoneMin = 0;
tempDate.utc = '-';
normalize(tempDate);
c2 = compareOrder(date1, tempDate);
if (c2 == GREATER_THAN) {
return c2;
}
return INDETERMINATE;
} else if (date2.utc == 'Z') {
cloneDate(date1, tempDate);             tempDate.timezoneHr = -14;
tempDate.timezoneMin = 0;
tempDate.utc = '-';
if (DEBUG) {
System.out.println("tempDate=" + dateToString(tempDate));
}
normalize(tempDate);
c1 = compareOrder(tempDate, date2);
if (DEBUG) {
System.out.println("date=" + dateToString(date2));
System.out.println("tempDate=" + dateToString(tempDate));
}
if (c1 == LESS_THAN) {
return c1;
}
cloneDate(date1, tempDate);             tempDate.timezoneHr = 14;
tempDate.timezoneMin = 0;
tempDate.utc = '+';
normalize(tempDate);
c2 = compareOrder(tempDate, date2);
if (DEBUG) {
System.out.println("tempDate=" + dateToString(tempDate));
}
if (c2 == GREATER_THAN) {
return c2;
}
return INDETERMINATE;
}
return INDETERMINATE;
}
protected short compareOrder(DateTimeData date1, DateTimeData date2) {
if (date1.position < 1) {
if (date1.year < date2.year) {
return -1;
}
if (date1.year > date2.year) {
return 1;
}
}
if (date1.position < 2) {
if (date1.month < date2.month) {
return -1;
}
if (date1.month > date2.month) {
return 1;
}
}
if (date1.day < date2.day) {
return -1;
}
if (date1.day > date2.day) {
return 1;
}
if (date1.hour < date2.hour) {
return -1;
}
if (date1.hour > date2.hour) {
return 1;
}
if (date1.minute < date2.minute) {
return -1;
}
if (date1.minute > date2.minute) {
return 1;
}
if (date1.second < date2.second) {
return -1;
}
if (date1.second > date2.second) {
return 1;
}
if (date1.utc < date2.utc) {
return -1;
}
if (date1.utc > date2.utc) {
return 1;
}
return 0;
}
protected void getTime(String buffer, int start, int end, DateTimeData data) throws RuntimeException {
int stop = start + 2;
data.hour = parseInt(buffer, start, stop);
if (buffer.charAt(stop++) != ':') {
throw new RuntimeException("Error in parsing time zone");
}
start = stop;
stop = stop + 2;
data.minute = parseInt(buffer, start, stop);
if (buffer.charAt(stop++) != ':') {
throw new RuntimeException("Error in parsing time zone");
}
int sign = findUTCSign(buffer, start, end);
start = stop;
stop = sign < 0 ? end : sign;
data.second = parseSecond(buffer, start, stop);
if (sign > 0) {
getTimeZone(buffer, data, sign, end);
}
}
protected int getDate(String buffer, int start, int end, DateTimeData date) throws RuntimeException {
start = getYearMonth(buffer, start, end, date);
if (buffer.charAt(start++) != '-') {
throw new RuntimeException("CCYY-MM must be followed by '-' sign");
}
int stop = start + 2;
date.day = parseInt(buffer, start, stop);
return stop;
}
protected int getYearMonth(String buffer, int start, int end, DateTimeData date) throws RuntimeException {
if (buffer.charAt(0) == '-') {
start++;
}
int i = indexOf(buffer, start, end, '-');
if (i == -1) {
throw new RuntimeException("Year separator is missing or misplaced");
}
int length = i - start;
if (length < 4) {
throw new RuntimeException("Year must have 'CCYY' format");
} else if (length > 4 && buffer.charAt(start) == '0') {
throw new RuntimeException("Leading zeros are required if the year value would otherwise have fewer than four digits; otherwise they are forbidden");
}
date.year = parseIntYear(buffer, i);
if (buffer.charAt(i) != '-') {
throw new RuntimeException("CCYY must be followed by '-' sign");
}
start = ++i;
i = start + 2;
date.month = parseInt(buffer, start, i);
return i;     }
protected void parseTimeZone(String buffer, int start, int end, DateTimeData date) throws RuntimeException {
if (start < end) {
if (!isNextCharUTCSign(buffer, start, end)) {
throw new RuntimeException("Error in month parsing");
} else {
getTimeZone(buffer, date, start, end);
}
}
}
protected void getTimeZone(String buffer, DateTimeData data, int sign, int end) throws RuntimeException {
data.utc = buffer.charAt(sign);
if (buffer.charAt(sign) == 'Z') {
if (end > (++sign)) {
throw new RuntimeException("Error in parsing time zone");
}
return;
}
if (sign <= (end - 6)) {
int negate = buffer.charAt(sign) == '-' ? -1 : 1;
int stop = ++sign + 2;
data.timezoneHr = negate * parseInt(buffer, sign, stop);
if (buffer.charAt(stop++) != ':') {
throw new RuntimeException("Error in parsing time zone");
}
data.timezoneMin = negate * parseInt(buffer, stop, stop + 2);
if (stop + 2 != end) {
throw new RuntimeException("Error in parsing time zone");
}
if (data.timezoneHr != 0 || data.timezoneMin != 0) {
data.normalized = false;
}
} else {
throw new RuntimeException("Error in parsing time zone");
}
if (DEBUG) {
System.out.println("time[hh]=" + data.timezoneHr + " time[mm]=" + data.timezoneMin);
}
}
protected int indexOf(String buffer, int start, int end, char ch) {
for (int i = start; i < end; i++) {
if (buffer.charAt(i) == ch) {
return i;
}
}
return -1;
}
protected void validateDateTime(DateTimeData data) {
if (!Constants.SCHEMA_1_1_SUPPORT && data.year == 0) {
throw new RuntimeException("The year \"0000\" is an illegal year value");
}
if (data.month < 1 || data.month > 12) {
throw new RuntimeException("The month must have values 1 to 12");
}
if (data.day > maxDayInMonthFor(data.year, data.month) || data.day < 1) {
throw new RuntimeException("The day must have values 1 to 31");
}
if (data.hour > 23 || data.hour < 0) {
if (data.hour == 24 && data.minute == 0 && data.second == 0) {
data.hour = 0;
if (++data.day > maxDayInMonthFor(data.year, data.month)) {
data.day = 1;
if (++data.month > 12) {
data.month = 1;
if (Constants.SCHEMA_1_1_SUPPORT) {
++data.year;
} else if (++data.year == 0) {
data.year = 1;
}
}
}
} else {
throw new RuntimeException("Hour must have values 0-23, unless 24:00:00");
}
}
if (data.minute > 59 || data.minute < 0) {
throw new RuntimeException("Minute must have values 0-59");
}
if (data.second >= 60 || data.second < 0) {
throw new RuntimeException("Second must have values 0-59");
}
if (data.timezoneHr > 14 || data.timezoneHr < -14) {
throw new RuntimeException("Time zone should have range -14:00 to +14:00");
} else {
if ((data.timezoneHr == 14 || data.timezoneHr == -14) && data.timezoneMin != 0) {
throw new RuntimeException("Time zone should have range -14:00 to +14:00");
} else if (data.timezoneMin > 59 || data.timezoneMin < -59) {
throw new RuntimeException("Minute must have values 0-59");
}
}
}
protected int findUTCSign(String buffer, int start, int end) {
int c;
for (int i = start; i < end; i++) {
c = buffer.charAt(i);
if (c == 'Z' || c == '+' || c == '-') {
return i;
}
}
return -1;
}
protected final boolean isNextCharUTCSign(String buffer, int start, int end) {
if (start < end) {
char c = buffer.charAt(start);
return (c == 'Z' || c == '+' || c == '-');
}
return false;
}
protected int parseInt(String buffer, int start, int end)
throws NumberFormatException {
int radix = 10;
int result = 0;
int digit = 0;
int limit = -Integer.MAX_VALUE;
int multmin = limit / radix;
int i = start;
do {
digit = getDigit(buffer.charAt(i));
if (digit < 0) {
throw new NumberFormatException("'" + buffer + "' has wrong format");
}
if (result < multmin) {
throw new NumberFormatException("'" + buffer + "' has wrong format");
}
result *= radix;
if (result < limit + digit) {
throw new NumberFormatException("'" + buffer + "' has wrong format");
}
result -= digit;
} while (++i < end);
return -result;
}
protected int parseIntYear(String buffer, int end) {
int radix = 10;
int result = 0;
boolean negative = false;
int i = 0;
int limit;
int multmin;
int digit = 0;
if (buffer.charAt(0) == '-') {
negative = true;
limit = Integer.MIN_VALUE;
i++;
} else {
limit = -Integer.MAX_VALUE;
}
multmin = limit / radix;
while (i < end) {
digit = getDigit(buffer.charAt(i++));
if (digit < 0) {
throw new NumberFormatException("'" + buffer + "' has wrong format");
}
if (result < multmin) {
throw new NumberFormatException("'" + buffer + "' has wrong format");
}
result *= radix;
if (result < limit + digit) {
throw new NumberFormatException("'" + buffer + "' has wrong format");
}
result -= digit;
}
if (negative) {
if (i > 1) {
return result;
} else {
throw new NumberFormatException("'" + buffer + "' has wrong format");
}
}
return -result;
}
protected void normalize(DateTimeData date) {
int negate = -1;
if (DEBUG) {
System.out.println("==>date.minute" + date.minute);
System.out.println("==>date.timezoneMin" + date.timezoneMin);
}
int temp = date.minute + negate * date.timezoneMin;
int carry = fQuotient(temp, 60);
date.minute = mod(temp, 60, carry);
if (DEBUG) {
System.out.println("==>carry: " + carry);
}
temp = date.hour + negate * date.timezoneHr + carry;
carry = fQuotient(temp, 24);
date.hour = mod(temp, 24, carry);
if (DEBUG) {
System.out.println("==>date.hour" + date.hour);
System.out.println("==>carry: " + carry);
}
date.day = date.day + carry;
while (true) {
temp = maxDayInMonthFor(date.year, date.month);
if (date.day < 1) {
date.day = date.day + maxDayInMonthFor(date.year, date.month - 1);
carry = -1;
} else if (date.day > temp) {
date.day = date.day - temp;
carry = 1;
} else {
break;
}
temp = date.month + carry;
date.month = modulo(temp, 1, 13);
date.year = date.year + fQuotient(temp, 1, 13);
if (date.year == 0 && !Constants.SCHEMA_1_1_SUPPORT) {
date.year = (date.timezoneHr < 0 || date.timezoneMin < 0) ? 1 : -1;
}
}
date.utc = 'Z';
}
protected void saveUnnormalized(DateTimeData date) {
date.unNormYear = date.year;
date.unNormMonth = date.month;
date.unNormDay = date.day;
date.unNormHour = date.hour;
date.unNormMinute = date.minute;
date.unNormSecond = date.second;
}
protected void resetDateObj(DateTimeData data) {
data.year = 0;
data.month = 0;
data.day = 0;
data.hour = 0;
data.minute = 0;
data.second = 0;
data.utc = 0;
data.timezoneHr = 0;
data.timezoneMin = 0;
}
protected int maxDayInMonthFor(int year, int month) {
if (month == 4 || month == 6 || month == 9 || month == 11) {
return 30;
} else if (month == 2) {
if (isLeapYear(year)) {
return 29;
} else {
return 28;
}
} else {
return 31;
}
}
private boolean isLeapYear(int year) {
return ((year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0)));
}
protected int mod(int a, int b, int quotient) {
return (a - quotient * b);
}
protected int fQuotient(int a, int b) {
return (int) Math.floor((float) a / b);
}
protected int modulo(int temp, int low, int high) {
int a = temp - low;
int b = high - low;
return (mod(a, b, fQuotient(a, b)) + low);
}
protected int fQuotient(int temp, int low, int high) {
return fQuotient(temp - low, high - low);
}
protected String dateToString(DateTimeData date) {
StringBuffer message = new StringBuffer(25);
append(message, date.year, 4);
message.append('-');
append(message, date.month, 2);
message.append('-');
append(message, date.day, 2);
message.append('T');
append(message, date.hour, 2);
message.append(':');
append(message, date.minute, 2);
message.append(':');
append(message, date.second);
append(message, (char) date.utc, 0);
return message.toString();
}
protected final void append(StringBuffer message, int value, int nch) {
if (value == Integer.MIN_VALUE) {
message.append(value);
return;
}
if (value < 0) {
message.append('-');
value = -value;
}
if (nch == 4) {
if (value < 10) {
message.append("000");
} else if (value < 100) {
message.append("00");
} else if (value < 1000) {
message.append('0');
}
message.append(value);
} else if (nch == 2) {
if (value < 10) {
message.append('0');
}
message.append(value);
} else {
if (value != 0) {
message.append((char) value);
}
}
}
protected final void append(StringBuffer message, double value) {
if (value < 0) {
message.append('-');
value = -value;
}
if (value < 10) {
message.append('0');
}
append2(message, value);
}
protected final void append2(StringBuffer message, double value) {
final int intValue = (int) value;
if (value == intValue) {
message.append(intValue);
} else {
append3(message, value);
}
}
private void append3(StringBuffer message, double value) {
String d = String.valueOf(value);
int eIndex = d.indexOf('E');
if (eIndex == -1) {
message.append(d);
return;
}
int exp;
if (value < 1) {
try {
exp = parseInt(d, eIndex + 2, d.length());
}                         catch (Exception e) {
message.append(d);
return;
}
message.append("0.");
for (int i = 1; i < exp; ++i) {
message.append('0');
}
int end = eIndex - 1;
while (end > 0) {
char c = d.charAt(end);
if (c != '0') {
break;
}
--end;
}
for (int i = 0; i <= end; ++i) {
char c = d.charAt(i);
if (c != '.') {
message.append(c);
}
}
} else {
try {
exp = parseInt(d, eIndex + 1, d.length());
}                         catch (Exception e) {
message.append(d);
return;
}
final int integerEnd = exp + 2;
for (int i = 0; i < eIndex; ++i) {
char c = d.charAt(i);
if (c != '.') {
if (i == integerEnd) {
message.append('.');
}
message.append(c);
}
}
for (int i = integerEnd - eIndex; i > 0; --i) {
message.append('0');
}
}
}
protected double parseSecond(String buffer, int start, int end)
throws NumberFormatException {
int dot = -1;
for (int i = start; i < end; i++) {
char ch = buffer.charAt(i);
if (ch == '.') {
dot = i;
} else if (ch > '9' || ch < '0') {
throw new NumberFormatException("'" + buffer + "' has wrong format");
}
}
if (dot == -1) {
if (start + 2 != end) {
throw new NumberFormatException("'" + buffer + "' has wrong format");
}
} else if (start + 2 != dot || dot + 1 == end) {
throw new NumberFormatException("'" + buffer + "' has wrong format");
}
return Double.parseDouble(buffer.substring(start, end));
}
private void cloneDate(DateTimeData finalValue, DateTimeData tempDate) {
tempDate.year = finalValue.year;
tempDate.month = finalValue.month;
tempDate.day = finalValue.day;
tempDate.hour = finalValue.hour;
tempDate.minute = finalValue.minute;
tempDate.second = finalValue.second;
tempDate.utc = finalValue.utc;
tempDate.timezoneHr = finalValue.timezoneHr;
tempDate.timezoneMin = finalValue.timezoneMin;
}
static final class DateTimeData implements XSDateTime {
int year, month, day, hour, minute, utc;
double second;
int timezoneHr, timezoneMin;
private String originalValue;
boolean normalized = true;
int unNormYear;
int unNormMonth;
int unNormDay;
int unNormHour;
int unNormMinute;
double unNormSecond;
int position;
final AbstractDateTimeDV type;
private volatile String canonical;
public DateTimeData(String originalValue, AbstractDateTimeDV type) {
this.originalValue = originalValue;
this.type = type;
}
public DateTimeData(int year, int month, int day, int hour, int minute,
double second, int utc, String originalValue, boolean normalized, AbstractDateTimeDV type) {
this.year = year;
this.month = month;
this.day = day;
this.hour = hour;
this.minute = minute;
this.second = second;
this.utc = utc;
this.type = type;
this.originalValue = originalValue;
}
@Override
public boolean equals(Object obj) {
if (!(obj instanceof DateTimeData)) {
return false;
}
return type.compareDates(this, (DateTimeData) obj, true) == 0;
}
@Override
public int hashCode() {
final DateTimeData tempDate = new DateTimeData(null, type);
type.cloneDate(this, tempDate);
type.normalize(tempDate);
return type.dateToString(tempDate).hashCode();
}
@Override
public String toString() {
if (canonical == null) {
canonical = type.dateToString(this);
}
return canonical;
}
@Override
public int getYears() {
if (type instanceof DurationDV) {
return 0;
}
return normalized ? year : unNormYear;
}
@Override
public int getMonths() {
if (type instanceof DurationDV) {
return year * 12 + month;
}
return normalized ? month : unNormMonth;
}
@Override
public int getDays() {
if (type instanceof DurationDV) {
return 0;
}
return normalized ? day : unNormDay;
}
@Override
public int getHours() {
if (type instanceof DurationDV) {
return 0;
}
return normalized ? hour : unNormHour;
}
@Override
public int getMinutes() {
if (type instanceof DurationDV) {
return 0;
}
return normalized ? minute : unNormMinute;
}
@Override
public double getSeconds() {
if (type instanceof DurationDV) {
return day * 24 * 60 * 60 + hour * 60 * 60 + minute * 60 + second;
}
return normalized ? second : unNormSecond;
}
@Override
public boolean hasTimeZone() {
return utc != 0;
}
@Override
public int getTimeZoneHours() {
return timezoneHr;
}
@Override
public int getTimeZoneMinutes() {
return timezoneMin;
}
@Override
public String getLexicalValue() {
return originalValue;
}
@Override
public XSDateTime normalize() {
if (!normalized) {
DateTimeData dt = (DateTimeData) this.clone();
dt.normalized = true;
return dt;
}
return this;
}
@Override
public boolean isNormalized() {
return normalized;
}
@Override
public Object clone() {
DateTimeData dt = new DateTimeData(this.year, this.month, this.day, this.hour,
this.minute, this.second, this.utc, this.originalValue, this.normalized, this.type);
dt.canonical = this.canonical;
dt.position = position;
dt.timezoneHr = this.timezoneHr;
dt.timezoneMin = this.timezoneMin;
dt.unNormYear = this.unNormYear;
dt.unNormMonth = this.unNormMonth;
dt.unNormDay = this.unNormDay;
dt.unNormHour = this.unNormHour;
dt.unNormMinute = this.unNormMinute;
dt.unNormSecond = this.unNormSecond;
return dt;
}
@Override
public XMLGregorianCalendar getXMLGregorianCalendar() {
return type.getXMLGregorianCalendar(this);
}
@Override
public Duration getDuration() {
return type.getDuration(this);
}
}
protected XMLGregorianCalendar getXMLGregorianCalendar(DateTimeData data) {
return null;
}
protected Duration getDuration(DateTimeData data) {
return null;
}
protected final BigDecimal getFractionalSecondsAsBigDecimal(DateTimeData data) {
final StringBuffer buf = new StringBuffer();
append3(buf, data.unNormSecond);
String value = buf.toString();
final int index = value.indexOf('.');
if (index == -1) {
return null;
}
value = value.substring(index);
final BigDecimal _val = new BigDecimal(value);
if (_val.compareTo(BigDecimal.valueOf(0)) == 0) {
return null;
}
return _val;
}
}
package jdk.jfr.internal.dcmd;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import jdk.jfr.FlightRecorder;
import jdk.jfr.Recording;
import jdk.jfr.internal.JVM;
import jdk.jfr.internal.LogLevel;
import jdk.jfr.internal.LogTag;
import jdk.jfr.internal.Logger;
import jdk.jfr.internal.SecuritySupport;
import jdk.jfr.internal.SecuritySupport.SafePath;
import jdk.jfr.internal.Utils;
abstract class AbstractDCmd {
private final StringBuilder currentLine = new StringBuilder(80);
private final List<String> lines = new ArrayList<>();
private String source;
public abstract String[] printHelp();
public abstract Argument[] getArgumentInfos();
protected abstract void execute(ArgumentParser parser) throws DCmdException;
public final String[] execute(String source, String arg, char delimiter) throws DCmdException {
this.source = source;
try {
boolean log = Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG);
if (log) {
Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, "Executing " + this.getClass().getSimpleName() + ": " + arg);
}
ArgumentParser parser = new ArgumentParser(getArgumentInfos(), arg, delimiter);
parser.parse();
if (log) {
Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, "DCMD options: " + parser.getOptions());
if (parser.hasExtendedOptions()) {
Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, "JFC options: " + parser.getExtendedOptions());
}
}
execute(parser);
return getResult();
}
catch (IllegalArgumentException iae) {
DCmdException e = new DCmdException(iae.getMessage());
e.addSuppressed(iae);
throw e;
}
}
protected final FlightRecorder getFlightRecorder() {
return FlightRecorder.getFlightRecorder();
}
protected final String[] getResult() {
return lines.toArray(new String[lines.size()]);
}
protected void logWarning(String message) {
if (source.equals("internal")) {             Logger.log(LogTag.JFR_START, LogLevel.WARN, message);
} else {             println("Warning! " + message);
}
}
public String getPid() {
return JVM.getJVM().getPid();
}
protected final SafePath resolvePath(Recording recording, String filename) throws InvalidPathException {
if (filename == null) {
return makeGenerated(recording, Paths.get("."));
}
Path path = Paths.get(filename);
if (Files.isDirectory(path)) {
return makeGenerated(recording, path);
}
return new SafePath(path.toAbsolutePath().normalize());
}
private SafePath makeGenerated(Recording recording, Path directory) {
return new SafePath(directory.toAbsolutePath().resolve(Utils.makeFilename(recording)).normalize());
}
protected final Recording findRecording(String name) throws DCmdException {
try {
return findRecordingById(Integer.parseInt(name));
} catch (NumberFormatException nfe) {
return findRecordingByName(name);
}
}
protected final void reportOperationComplete(String actionPrefix, String name, SafePath file) {
print(actionPrefix);
print(" recording");
if (name != null) {
print(" \"" + name + "\"");
}
if (file != null) {
print(",");
try {
print(" ");
long bytes = SecuritySupport.getFileSize(file);
printBytes(bytes);
} catch (IOException e) {
}
println(" written to:");
println();
printPath(file);
} else {
println(".");
}
}
protected final List<Recording> getRecordings() {
List<Recording> list = new ArrayList<>(getFlightRecorder().getRecordings());
list.sort(Comparator.comparingLong(Recording::getId));
return list;
}
static String quoteIfNeeded(String text) {
if (text.contains(" ")) {
return "\\\"" + text + "\\\"";
} else {
return text;
}
}
protected final void println() {
lines.add(currentLine.toString());
currentLine.setLength(0);
}
protected final void print(String s) {
currentLine.append(s);
}
protected final void print(String s, Object... args) {
currentLine.append(args.length > 0 ? String.format(s, args) : s);
}
protected final void println(String s, Object... args) {
print(s, args);
println();
}
protected final void printBytes(long bytes) {
print(Utils.formatBytes(bytes));
}
protected final void printTimespan(Duration timespan, String separator) {
print(Utils.formatTimespan(timespan, separator));
}
protected final void printPath(SafePath path) {
if (path == null) {
print("N/A");
return;
}
try {
printPath(SecuritySupport.getAbsolutePath(path).toPath());
} catch (IOException ioe) {
printPath(path.toPath());
}
}
protected final void printPath(Path path) {
try {
println(path.toAbsolutePath().toString());
} catch (SecurityException e) {
println(path.toString());
}
}
private Recording findRecordingById(int id) throws DCmdException {
for (Recording r : getFlightRecorder().getRecordings()) {
if (r.getId() == id) {
return r;
}
}
throw new DCmdException("Could not find %d.\n\nUse JFR.check without options to see list of all available recordings.", id);
}
private Recording findRecordingByName(String name) throws DCmdException {
for (Recording recording : getFlightRecorder().getRecordings()) {
if (name.equals(recording.getName())) {
return recording;
}
}
throw new DCmdException("Could not find %s.\n\nUse JFR.check without options to see list of all available recordings.", name);
}
protected final String exampleRepository() {
if ("\r\n".equals(System.lineSeparator())) {
return "C:\\Repositories";
} else {
return "/Repositories";
}
}
protected final String exampleFilename() {
if ("\r\n".equals(System.lineSeparator())) {
return "C:\\Users\\user\\recording.jfr";
} else {
return "/recordings/recording.jfr";
}
}
protected final String exampleDirectory() {
if ("\r\n".equals(System.lineSeparator())) {
return "C:\\Directory\\recordings";
} else {
return "/directory/recordings";
}
}
static String expandFilename(String filename) {
if (filename == null || filename.indexOf('%') == -1) {
return filename;
}
String pid = null;
String time = null;
StringBuilder sb = new StringBuilder();
for (int i = 0; i < filename.length(); i++) {
char c = filename.charAt(i);
if (c == '%' && i < filename.length() - 1) {
char nc = filename.charAt(i + 1);
if (nc == '%') {                     sb.append('%');
i++;
} else if (nc == 'p') {
if (pid == null) {
pid = JVM.getJVM().getPid();
}
sb.append(pid);
i++;
} else if (nc == 't') {
if (time == null) {
time = Utils.formatDateTime(LocalDateTime.now());
}
sb.append(time);
i++;
} else {
sb.append('%');
}
} else {
sb.append(c);
}
}
return sb.toString();
}
}
package sun.net.www.protocol.https;
import java.net.Authenticator;
import java.net.URL;
import java.net.Proxy;
import java.net.SecureCacheResponse;
import java.security.Principal;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.io.IOException;
import java.util.List;
import java.util.Optional;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLPeerUnverifiedException;
import sun.net.www.http.*;
import sun.net.www.protocol.http.HttpURLConnection;
import sun.net.www.protocol.http.HttpCallerInfo;
public abstract class AbstractDelegateHttpsURLConnection extends
HttpURLConnection {
protected AbstractDelegateHttpsURLConnection(URL url,
sun.net.www.protocol.http.Handler handler) throws IOException {
this(url, null, handler);
}
protected AbstractDelegateHttpsURLConnection(URL url, Proxy p,
sun.net.www.protocol.http.Handler handler) throws IOException {
super(url, p, handler);
}
protected abstract javax.net.ssl.SSLSocketFactory getSSLSocketFactory();
protected abstract javax.net.ssl.HostnameVerifier getHostnameVerifier();
public void setNewClient (URL url)
throws IOException {
setNewClient (url, false);
}
public void setNewClient (URL url, boolean useCache)
throws IOException {
int readTimeout = getReadTimeout();
http = HttpsClient.New (getSSLSocketFactory(),
url,
getHostnameVerifier(),
null,
-1,
useCache,
getConnectTimeout(),
this);
http.setReadTimeout(readTimeout);
((HttpsClient)http).afterConnect();
}
public void setProxiedClient (URL url, String proxyHost, int proxyPort)
throws IOException {
setProxiedClient(url, proxyHost, proxyPort, false);
}
public void setProxiedClient (URL url, String proxyHost, int proxyPort,
boolean useCache) throws IOException {
proxiedConnect(url, proxyHost, proxyPort, useCache);
if (!http.isCachedConnection()) {
doTunneling();
}
((HttpsClient)http).afterConnect();
}
protected void proxiedConnect(URL url, String proxyHost, int proxyPort,
boolean useCache) throws IOException {
if (connected)
return;
int readTimeout = getReadTimeout();
http = HttpsClient.New (getSSLSocketFactory(),
url,
getHostnameVerifier(),
proxyHost,
proxyPort,
useCache,
getConnectTimeout(),
this);
http.setReadTimeout(readTimeout);
connected = true;
}
public boolean isConnected() {
return connected;
}
public void setConnected(boolean conn) {
connected = conn;
}
public void connect() throws IOException {
if (connected)
return;
plainConnect();
if (cachedResponse != null) {
return;
}
if (!http.isCachedConnection() && http.needsTunneling()) {
doTunneling();
}
((HttpsClient)http).afterConnect();
}
protected HttpClient getNewHttpClient(URL url, Proxy p, int connectTimeout)
throws IOException {
return HttpsClient.New(getSSLSocketFactory(), url,
getHostnameVerifier(), p, true, connectTimeout,
this);
}
protected HttpClient getNewHttpClient(URL url, Proxy p, int connectTimeout,
boolean useCache)
throws IOException {
return HttpsClient.New(getSSLSocketFactory(), url,
getHostnameVerifier(), p,
useCache, connectTimeout, this);
}
public String getCipherSuite () {
if (cachedResponse != null) {
return ((SecureCacheResponse)cachedResponse).getCipherSuite();
}
if (http == null) {
throw new IllegalStateException("connection not yet open");
} else {
return ((HttpsClient)http).getCipherSuite ();
}
}
public java.security.cert.Certificate[] getLocalCertificates() {
if (cachedResponse != null) {
List<java.security.cert.Certificate> l = ((SecureCacheResponse)cachedResponse).getLocalCertificateChain();
if (l == null) {
return null;
} else {
return l.toArray(new java.security.cert.Certificate[0]);
}
}
if (http == null) {
throw new IllegalStateException("connection not yet open");
} else {
return (((HttpsClient)http).getLocalCertificates ());
}
}
public java.security.cert.Certificate[] getServerCertificates()
throws SSLPeerUnverifiedException {
if (cachedResponse != null) {
List<java.security.cert.Certificate> l =
((SecureCacheResponse)cachedResponse)
.getServerCertificateChain();
if (l == null) {
return null;
} else {
return l.toArray(new java.security.cert.Certificate[0]);
}
}
if (http == null) {
throw new IllegalStateException("connection not yet open");
} else {
return (((HttpsClient)http).getServerCertificates ());
}
}
Principal getPeerPrincipal()
throws SSLPeerUnverifiedException
{
if (cachedResponse != null) {
return ((SecureCacheResponse)cachedResponse).getPeerPrincipal();
}
if (http == null) {
throw new IllegalStateException("connection not yet open");
} else {
return (((HttpsClient)http).getPeerPrincipal());
}
}
Principal getLocalPrincipal()
{
if (cachedResponse != null) {
return ((SecureCacheResponse)cachedResponse).getLocalPrincipal();
}
if (http == null) {
throw new IllegalStateException("connection not yet open");
} else {
return (((HttpsClient)http).getLocalPrincipal());
}
}
SSLSession getSSLSession() {
if (cachedResponse != null) {
Optional<SSLSession> option =
((SecureCacheResponse)cachedResponse).getSSLSession();
if (option.isPresent()) {
return option.orElseThrow();
}
}
if (http == null) {
throw new IllegalStateException("connection not yet open");
}
return ((HttpsClient)http).getSSLSession();
}
private boolean useExtendedCallerInfo(URL url) {
HttpsClient https = (HttpsClient)http;
if (https.getSSLSession() == null) {
return false;
}
String prop = http.getSpnegoCBT();
if (prop.equals("never")) {
return false;
}
String target = url.getHost();
if (prop.startsWith("domain:")) {
String[] domains = prop.substring(7).split(",");
for (String domain : domains) {
if (target.equalsIgnoreCase(domain)) {
return true;
}
if (domain.startsWith("*.") && target.regionMatches(
true, target.length() - domain.length() + 1, domain, 1, domain.length() - 1)) {
return true;
}
}
return false;
}
return true;
}
@Override
protected HttpCallerInfo getHttpCallerInfo(URL url, String proxy, int port,
Authenticator authenticator)
{
if (!useExtendedCallerInfo(url)) {
return super.getHttpCallerInfo(url, proxy, port, authenticator);
}
HttpsClient https = (HttpsClient)http;
try {
Certificate[] certs = https.getServerCertificates();
if (certs[0] instanceof X509Certificate x509Cert) {
return new HttpCallerInfo(url, proxy, port, x509Cert, authenticator);
}
} catch (SSLPeerUnverifiedException e) {
}
return super.getHttpCallerInfo(url, proxy, port, authenticator);
}
@Override
protected HttpCallerInfo getHttpCallerInfo(URL url, Authenticator authenticator)
{
if (!useExtendedCallerInfo(url)) {
return super.getHttpCallerInfo(url, authenticator);
}
HttpsClient https = (HttpsClient)http;
try {
Certificate[] certs = https.getServerCertificates();
if (certs[0] instanceof X509Certificate x509Cert) {
return new HttpCallerInfo(url, x509Cert, authenticator);
}
} catch (SSLPeerUnverifiedException e) {
}
return super.getHttpCallerInfo(url, authenticator);
}
}
package com.sun.tools.javac.util;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Collection;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import javax.tools.JavaFileObject;
import com.sun.tools.javac.api.DiagnosticFormatter;
import com.sun.tools.javac.api.DiagnosticFormatter.Configuration.DiagnosticPart;
import com.sun.tools.javac.api.DiagnosticFormatter.Configuration.MultilineLimit;
import com.sun.tools.javac.api.DiagnosticFormatter.PositionKind;
import com.sun.tools.javac.api.Formattable;
import com.sun.tools.javac.code.Lint.LintCategory;
import com.sun.tools.javac.code.Printer;
import com.sun.tools.javac.code.Source;
import com.sun.tools.javac.code.Symbol;
import com.sun.tools.javac.code.Type;
import com.sun.tools.javac.code.Type.CapturedType;
import com.sun.tools.javac.file.PathFileObject;
import com.sun.tools.javac.jvm.Profile;
import com.sun.tools.javac.jvm.Target;
import com.sun.tools.javac.main.Option;
import com.sun.tools.javac.tree.JCTree.*;
import com.sun.tools.javac.tree.Pretty;
import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticType.*;
public abstract class AbstractDiagnosticFormatter implements DiagnosticFormatter<JCDiagnostic> {
protected JavacMessages messages;
private SimpleConfiguration config;
protected int depth = 0;
private List<Type> allCaptured = List.nil();
protected AbstractDiagnosticFormatter(JavacMessages messages, SimpleConfiguration config) {
this.messages = messages;
this.config = config;
}
public String formatKind(JCDiagnostic d, Locale l) {
switch (d.getType()) {
case FRAGMENT: return "";
case NOTE:     return localize(l, "compiler.note.note");
case WARNING:  return localize(l, "compiler.warn.warning");
case ERROR:    return localize(l, "compiler.err.error");
default:
throw new AssertionError("Unknown diagnostic type: " + d.getType());
}
}
@Override
public String format(JCDiagnostic d, Locale locale) {
allCaptured = List.nil();
return formatDiagnostic(d, locale);
}
protected abstract String formatDiagnostic(JCDiagnostic d, Locale locale);
public String formatPosition(JCDiagnostic d, PositionKind pk,Locale l) {
Assert.check(d.getPosition() != Position.NOPOS);
return String.valueOf(getPosition(d, pk));
}
private long getPosition(JCDiagnostic d, PositionKind pk) {
switch (pk) {
case START: return d.getIntStartPosition();
case END: return d.getIntEndPosition();
case LINE: return d.getLineNumber();
case COLUMN: return d.getColumnNumber();
case OFFSET: return d.getIntPosition();
default:
throw new AssertionError("Unknown diagnostic position: " + pk);
}
}
public String formatSource(JCDiagnostic d, boolean fullname, Locale l) {
JavaFileObject fo = d.getSource();
if (fo == null)
throw new IllegalArgumentException();         if (fullname)
return fo.getName();
else if (fo instanceof PathFileObject pathFileObject)
return pathFileObject.getShortName();
else
return PathFileObject.getSimpleName(fo);
}
protected Collection<String> formatArguments(JCDiagnostic d, Locale l) {
ListBuffer<String> buf = new ListBuffer<>();
for (Object o : d.getArgs()) {
buf.append(formatArgument(d, o, l));
}
return buf.toList();
}
protected String formatArgument(JCDiagnostic d, Object arg, Locale l) {
if (arg instanceof JCDiagnostic diagnostic) {
String s = null;
depth++;
try {
JCDiagnostic rewrittenDiagnostic = null;
if (diagnostic.hasRewriter()) {
rewrittenDiagnostic = diagnostic.rewrite();
}
s = formatMessage(rewrittenDiagnostic != null ? rewrittenDiagnostic : diagnostic, l);
}
finally {
depth--;
}
return s;
}
else if (arg instanceof JCExpression expression) {
return expr2String(expression);
}
else if (arg instanceof Iterable<?> iterable && !(arg instanceof Path)) {
return formatIterable(d, iterable, l);
}
else if (arg instanceof Type type) {
return printer.visit(type, l);
}
else if (arg instanceof Symbol symbol) {
return printer.visit(symbol, l);
}
else if (arg instanceof JavaFileObject javaFileObject) {
return javaFileObject.getName();
}
else if (arg instanceof Profile profile) {
return profile.name;
}
else if (arg instanceof Option option) {
return option.primaryName;
}
else if (arg instanceof Formattable formattable) {
return formattable.toString(l, messages);
}
else if (arg instanceof Target target) {
return target.name;
}
else if (arg instanceof Source source) {
return source.name;
}
else if (arg instanceof Tag tag) {
return messages.getLocalizedString(l, "compiler.misc.tree.tag." +
StringUtils.toLowerCase(tag.name()));
}
else {
return String.valueOf(arg);
}
}
private String expr2String(JCExpression tree) {
switch(tree.getTag()) {
case PARENS:
return expr2String(((JCParens)tree).expr);
case LAMBDA:
case REFERENCE:
case CONDEXPR:
return Pretty.toSimpleString(tree);
default:
Assert.error("unexpected tree kind " + tree.getKind());
return null;
}
}
protected String formatIterable(JCDiagnostic d, Iterable<?> it, Locale l) {
StringBuilder sbuf = new StringBuilder();
String sep = "";
for (Object o : it) {
sbuf.append(sep);
sbuf.append(formatArgument(d, o, l));
sep = ",";
}
return sbuf.toString();
}
protected List<String> formatSubdiagnostics(JCDiagnostic d, Locale l) {
List<String> subdiagnostics = List.nil();
int maxDepth = config.getMultilineLimit(MultilineLimit.DEPTH);
if (maxDepth == -1 || depth < maxDepth) {
depth++;
try {
int maxCount = config.getMultilineLimit(MultilineLimit.LENGTH);
int count = 0;
for (JCDiagnostic d2 : d.getSubdiagnostics()) {
if (maxCount == -1 || count < maxCount) {
subdiagnostics = subdiagnostics.append(formatSubdiagnostic(d, d2, l));
count++;
}
else
break;
}
}
finally {
depth--;
}
}
return subdiagnostics;
}
protected String formatSubdiagnostic(JCDiagnostic parent, JCDiagnostic sub, Locale l) {
return formatMessage(sub, l);
}
protected String formatSourceLine(JCDiagnostic d, int nSpaces) {
StringBuilder buf = new StringBuilder();
DiagnosticSource source = d.getDiagnosticSource();
int pos = d.getIntPosition();
if (d.getIntPosition() == Position.NOPOS)
throw new AssertionError();
String line = (source == null ? null : source.getLine(pos));
if (line == null)
return "";
buf.append(indent(line, nSpaces));
int col = source.getColumnNumber(pos, false);
if (config.isCaretEnabled()) {
buf.append("\n");
for (int i = 0; i < col - 1; i++)  {
buf.append((line.charAt(i) == '\t') ? "\t" : " ");
}
buf.append(indent("^", nSpaces));
}
return buf.toString();
}
protected String formatLintCategory(JCDiagnostic d, Locale l) {
LintCategory lc = d.getLintCategory();
if (lc == null)
return "";
return localize(l, "compiler.warn.lintOption", lc.option);
}
protected String localize(Locale l, String key, Object... args) {
return messages.getLocalizedString(l, key, args);
}
public boolean displaySource(JCDiagnostic d) {
return config.getVisible().contains(DiagnosticPart.SOURCE) &&
d.getType() != FRAGMENT &&
d.getIntPosition() != Position.NOPOS;
}
public boolean isRaw() {
return false;
}
protected String indentString(int nSpaces) {
String spaces = "                        ";
if (nSpaces <= spaces.length())
return spaces.substring(0, nSpaces);
else {
StringBuilder buf = new StringBuilder();
for (int i = 0 ; i < nSpaces ; i++)
buf.append(" ");
return buf.toString();
}
}
protected String indent(String s, int nSpaces) {
String indent = indentString(nSpaces);
StringBuilder buf = new StringBuilder();
String nl = "";
for (String line : s.split("\n")) {
buf.append(nl);
buf.append(indent + line);
nl = "\n";
}
return buf.toString();
}
public SimpleConfiguration getConfiguration() {
return config;
}
public static class SimpleConfiguration implements Configuration {
protected Map<MultilineLimit, Integer> multilineLimits;
protected EnumSet<DiagnosticPart> visibleParts;
protected boolean caretEnabled;
public SimpleConfiguration(Set<DiagnosticPart> parts) {
multilineLimits = new HashMap<>();
setVisible(parts);
setMultilineLimit(MultilineLimit.DEPTH, -1);
setMultilineLimit(MultilineLimit.LENGTH, -1);
setCaretEnabled(true);
}
@SuppressWarnings("fallthrough")
public SimpleConfiguration(Options options, Set<DiagnosticPart> parts) {
this(parts);
String showSource = null;
if ((showSource = options.get("diags.showSource")) != null) {
if (showSource.equals("true"))
setVisiblePart(DiagnosticPart.SOURCE, true);
else if (showSource.equals("false"))
setVisiblePart(DiagnosticPart.SOURCE, false);
}
String diagOpts = options.get("diags.formatterOptions");
if (diagOpts != null) {                Collection<String> args = Arrays.asList(diagOpts.split(","));
if (args.contains("short")) {
setVisiblePart(DiagnosticPart.DETAILS, false);
setVisiblePart(DiagnosticPart.SUBDIAGNOSTICS, false);
}
if (args.contains("source"))
setVisiblePart(DiagnosticPart.SOURCE, true);
if (args.contains("-source"))
setVisiblePart(DiagnosticPart.SOURCE, false);
}
String multiPolicy = null;
if ((multiPolicy = options.get("diags.multilinePolicy")) != null) {
if (multiPolicy.equals("disabled"))
setVisiblePart(DiagnosticPart.SUBDIAGNOSTICS, false);
else if (multiPolicy.startsWith("limit:")) {
String limitString = multiPolicy.substring("limit:".length());
String[] limits = limitString.split(":");
try {
switch (limits.length) {
case 2: {
if (!limits[1].equals("*"))
setMultilineLimit(MultilineLimit.DEPTH, Integer.parseInt(limits[1]));
}
case 1: {
if (!limits[0].equals("*"))
setMultilineLimit(MultilineLimit.LENGTH, Integer.parseInt(limits[0]));
}
}
}
catch(NumberFormatException ex) {
setMultilineLimit(MultilineLimit.DEPTH, -1);
setMultilineLimit(MultilineLimit.LENGTH, -1);
}
}
}
String showCaret = null;
if (((showCaret = options.get("diags.showCaret")) != null) &&
showCaret.equals("false"))
setCaretEnabled(false);
else
setCaretEnabled(true);
}
public int getMultilineLimit(MultilineLimit limit) {
return multilineLimits.get(limit);
}
public EnumSet<DiagnosticPart> getVisible() {
return EnumSet.copyOf(visibleParts);
}
public void setMultilineLimit(MultilineLimit limit, int value) {
multilineLimits.put(limit, value < -1 ? -1 : value);
}
public void setVisible(Set<DiagnosticPart> diagParts) {
visibleParts = EnumSet.copyOf(diagParts);
}
public void setVisiblePart(DiagnosticPart diagParts, boolean enabled) {
if (enabled)
visibleParts.add(diagParts);
else
visibleParts.remove(diagParts);
}
public void setCaretEnabled(boolean caretEnabled) {
this.caretEnabled = caretEnabled;
}
public boolean isCaretEnabled() {
return caretEnabled;
}
}
public Printer getPrinter() {
return printer;
}
public void setPrinter(Printer printer) {
this.printer = printer;
}
protected Printer printer = new Printer() {
@Override
protected String localize(Locale locale, String key, Object... args) {
return AbstractDiagnosticFormatter.this.localize(locale, key, args);
}
@Override
protected String capturedVarId(CapturedType t, Locale locale) {
return "" + (allCaptured.indexOf(t) + 1);
}
@Override
public String visitCapturedType(CapturedType t, Locale locale) {
if (!allCaptured.contains(t)) {
allCaptured = allCaptured.append(t);
}
return super.visitCapturedType(t, locale);
}
};
}
package jdk.javadoc.internal.doclets.toolkit;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.function.Function;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import jdk.javadoc.doclet.Doclet;
import jdk.javadoc.doclet.DocletEnvironment;
import jdk.javadoc.doclet.StandardDoclet;
import jdk.javadoc.internal.doclets.formats.html.HtmlDoclet;
import jdk.javadoc.internal.doclets.toolkit.builders.AbstractBuilder;
import jdk.javadoc.internal.doclets.toolkit.builders.BuilderFactory;
import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;
import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
import jdk.javadoc.internal.doclets.toolkit.util.UncheckedDocletException;
import jdk.javadoc.internal.doclets.toolkit.util.InternalException;
import jdk.javadoc.internal.doclets.toolkit.util.ElementListWriter;
import jdk.javadoc.internal.doclets.toolkit.util.ResourceIOException;
import jdk.javadoc.internal.doclets.toolkit.util.SimpleDocletException;
import jdk.javadoc.internal.doclets.toolkit.util.Utils;
import static javax.tools.Diagnostic.Kind.*;
public abstract class AbstractDoclet implements Doclet {
private BaseConfiguration configuration;
protected Messages messages;
protected Utils utils;
private static final String TOOLKIT_DOCLET_NAME =
jdk.javadoc.internal.doclets.formats.html.HtmlDoclet.class.getName();
private boolean isValidDoclet() {
if (!getClass().getName().equals(TOOLKIT_DOCLET_NAME)) {
messages.error("doclet.Toolkit_Usage_Violation",
TOOLKIT_DOCLET_NAME);
return false;
}
return true;
}
@Override
public boolean run(DocletEnvironment docEnv) {
configuration = getConfiguration();
configuration.initConfiguration(docEnv, getResourceKeyMapper(docEnv));
utils = configuration.utils;
messages = configuration.getMessages();
BaseOptions options = configuration.getOptions();
if (!isValidDoclet()) {
return false;
}
try {
try {
startGeneration();
return true;
} catch (UncheckedDocletException e) {
throw (DocletException) e.getCause();
}
} catch (DocFileIOException e) {
switch (e.mode) {
case READ:
messages.error("doclet.exception.read.file",
e.fileName.getPath(), e.getCause());
break;
case WRITE:
messages.error("doclet.exception.write.file",
e.fileName.getPath(), e.getCause());
}
dumpStack(options.dumpOnError(), e);
} catch (ResourceIOException e) {
messages.error("doclet.exception.read.resource",
e.resource.getPath(), e.getCause());
dumpStack(options.dumpOnError(), e);
} catch (SimpleDocletException e) {
configuration.reporter.print(ERROR, e.getMessage());
dumpStack(options.dumpOnError(), e);
} catch (InternalException e) {
configuration.reporter.print(ERROR, e.getMessage());
reportInternalError(e.getCause());
} catch (DocletException | RuntimeException | Error e) {
messages.error("doclet.internal.exception", e);
reportInternalError(e);
}
return false;
}
protected Function<String, String> getResourceKeyMapper(DocletEnvironment docEnv) {
return null;
}
private void reportInternalError(Throwable t) {
if (getClass().equals(StandardDoclet.class) || getClass().equals(HtmlDoclet.class)) {
System.err.println(configuration.getDocResources().getText("doclet.internal.report.bug"));
}
dumpStack(true, t);
}
private void dumpStack(boolean enabled, Throwable t) {
if (enabled && t != null) {
t.printStackTrace(System.err);
}
}
@Override
public SourceVersion getSupportedSourceVersion() {
return SourceVersion.RELEASE_9;
}
public abstract BaseConfiguration getConfiguration();
private void startGeneration() throws DocletException {
if (configuration.getSpecifiedModuleElements().isEmpty() &&
configuration.getIncludedTypeElements().isEmpty()) {
messages.error("doclet.No_Public_Classes_To_Document");
return;
}
if (!configuration.setOptions()) {
return;
}
messages.notice("doclet.build_version",
configuration.getDocletVersion());
ClassTree classTree = new ClassTree(configuration);
generateClassFiles(classTree);
ElementListWriter.generate(configuration);
generatePackageFiles(classTree);
generateModuleFiles();
generateOtherFiles(classTree);
configuration.tagletManager.printReport();
}
protected void generateOtherFiles(ClassTree classTree) throws DocletException {
BuilderFactory builderFactory = configuration.getBuilderFactory();
AbstractBuilder constantsSummaryBuilder = builderFactory.getConstantsSummaryBuilder();
constantsSummaryBuilder.build();
AbstractBuilder serializedFormBuilder = builderFactory.getSerializedFormBuilder();
serializedFormBuilder.build();
}
protected abstract void generateModuleFiles() throws DocletException;
protected abstract void generatePackageFiles(ClassTree classTree) throws DocletException;
protected abstract void generateClassFiles(SortedSet<TypeElement> arr, ClassTree classTree)
throws DocletException;
protected void generateClassFiles(ClassTree classTree)
throws DocletException {
SortedSet<TypeElement> classes = new TreeSet<>(utils.comparators.makeGeneralPurposeComparator());
for (PackageElement pkg : configuration.typeElementCatalog.packages()) {
classes.addAll(configuration.typeElementCatalog.allClasses(pkg));
}
SortedSet<PackageElement> packages = new TreeSet<>(utils.comparators.makePackageComparator());
packages.addAll(configuration.getSpecifiedPackageElements());
configuration.modulePackages.values().stream().forEach(packages::addAll);
for (PackageElement pkg : packages) {
classes.addAll(utils.getAllClasses(pkg));
}
generateClassFiles(classes, classTree);
}
}
package javax.swing.text;
import java.awt.font.TextAttribute;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectInputValidation;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Serial;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.text.Bidi;
import java.util.ArrayList;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.EventListener;
import java.util.Hashtable;
import java.util.Vector;
import javax.swing.UIManager;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.UndoableEditEvent;
import javax.swing.event.UndoableEditListener;
import javax.swing.tree.TreeNode;
import javax.swing.undo.AbstractUndoableEdit;
import javax.swing.undo.CannotRedoException;
import javax.swing.undo.CannotUndoException;
import javax.swing.undo.CompoundEdit;
import javax.swing.undo.UndoableEdit;
import sun.font.BidiUtils;
import sun.swing.SwingUtilities2;
import sun.swing.text.UndoableEditLockSupport;
@SuppressWarnings("serial") public abstract class AbstractDocument implements Document, Serializable {
protected AbstractDocument(Content data) {
this(data, StyleContext.getDefaultStyleContext());
}
protected AbstractDocument(Content data, AttributeContext context) {
this.data = data;
this.context = context;
bidiRoot = new BidiRootElement();
if (defaultI18NProperty == null) {
@SuppressWarnings("removal")
String o = java.security.AccessController.doPrivileged(
new java.security.PrivilegedAction<String>() {
public String run() {
return System.getProperty(I18NProperty);
}
}
);
if (o != null) {
defaultI18NProperty = Boolean.valueOf(o);
} else {
defaultI18NProperty = Boolean.FALSE;
}
}
putProperty( I18NProperty, defaultI18NProperty);
writeLock();
try {
Element[] p = new Element[1];
p[0] = new BidiElement( bidiRoot, 0, 1, 0 );
bidiRoot.replace(0,0,p);
} finally {
writeUnlock();
}
}
public Dictionary<Object,Object> getDocumentProperties() {
if (documentProperties == null) {
documentProperties = new Hashtable<Object, Object>(2);
}
return documentProperties;
}
public void setDocumentProperties(Dictionary<Object,Object> x) {
documentProperties = x;
}
protected void fireInsertUpdate(DocumentEvent e) {
notifyingListeners = true;
try {
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==DocumentListener.class) {
((DocumentListener)listeners[i+1]).insertUpdate(e);
}
}
} finally {
notifyingListeners = false;
}
}
protected void fireChangedUpdate(DocumentEvent e) {
notifyingListeners = true;
try {
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==DocumentListener.class) {
((DocumentListener)listeners[i+1]).changedUpdate(e);
}
}
} finally {
notifyingListeners = false;
}
}
protected void fireRemoveUpdate(DocumentEvent e) {
notifyingListeners = true;
try {
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==DocumentListener.class) {
((DocumentListener)listeners[i+1]).removeUpdate(e);
}
}
} finally {
notifyingListeners = false;
}
}
protected void fireUndoableEditUpdate(UndoableEditEvent e) {
if (e.getEdit() instanceof DefaultDocumentEvent) {
e = new UndoableEditEvent(e.getSource(),
new DefaultDocumentEventUndoableWrapper(
(DefaultDocumentEvent)e.getEdit()));
}
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==UndoableEditListener.class) {
((UndoableEditListener)listeners[i+1]).undoableEditHappened(e);
}
}
}
public <T extends EventListener> T[] getListeners(Class<T> listenerType) {
return listenerList.getListeners(listenerType);
}
public int getAsynchronousLoadPriority() {
Integer loadPriority = (Integer)
getProperty(AbstractDocument.AsyncLoadPriority);
if (loadPriority != null) {
return loadPriority.intValue();
}
return -1;
}
public void setAsynchronousLoadPriority(int p) {
Integer loadPriority = (p >= 0) ? Integer.valueOf(p) : null;
putProperty(AbstractDocument.AsyncLoadPriority, loadPriority);
}
public void setDocumentFilter(DocumentFilter filter) {
documentFilter = filter;
}
public DocumentFilter getDocumentFilter() {
return documentFilter;
}
public void render(Runnable r) {
readLock();
try {
r.run();
} finally {
readUnlock();
}
}
public int getLength() {
return data.length() - 1;
}
public void addDocumentListener(DocumentListener listener) {
listenerList.add(DocumentListener.class, listener);
}
public void removeDocumentListener(DocumentListener listener) {
listenerList.remove(DocumentListener.class, listener);
}
public DocumentListener[] getDocumentListeners() {
return listenerList.getListeners(DocumentListener.class);
}
public void addUndoableEditListener(UndoableEditListener listener) {
listenerList.add(UndoableEditListener.class, listener);
}
public void removeUndoableEditListener(UndoableEditListener listener) {
listenerList.remove(UndoableEditListener.class, listener);
}
public UndoableEditListener[] getUndoableEditListeners() {
return listenerList.getListeners(UndoableEditListener.class);
}
public final Object getProperty(Object key) {
return getDocumentProperties().get(key);
}
public final void putProperty(Object key, Object value) {
if (value != null) {
getDocumentProperties().put(key, value);
} else {
getDocumentProperties().remove(key);
}
if( key == TextAttribute.RUN_DIRECTION
&& Boolean.TRUE.equals(getProperty(I18NProperty)) )
{
writeLock();
try {
DefaultDocumentEvent e
= new DefaultDocumentEvent(0, getLength(),
DocumentEvent.EventType.INSERT);
updateBidi( e );
} finally {
writeUnlock();
}
}
}
public void remove(int offs, int len) throws BadLocationException {
DocumentFilter filter = getDocumentFilter();
writeLock();
try {
if (filter != null) {
filter.remove(getFilterBypass(), offs, len);
}
else {
handleRemove(offs, len);
}
} finally {
writeUnlock();
}
}
void handleRemove(int offs, int len) throws BadLocationException {
if (len > 0) {
if (offs < 0 || (offs + len) > getLength()) {
throw new BadLocationException("Invalid remove",
getLength() + 1);
}
DefaultDocumentEvent chng =
new DefaultDocumentEvent(offs, len, DocumentEvent.EventType.REMOVE);
boolean isComposedTextElement;
isComposedTextElement = Utilities.isComposedTextElement(this, offs);
removeUpdate(chng);
UndoableEdit u = data.remove(offs, len);
if (u != null) {
chng.addEdit(u);
}
postRemoveUpdate(chng);
chng.end();
fireRemoveUpdate(chng);
if ((u != null) && !isComposedTextElement) {
fireUndoableEditUpdate(new UndoableEditEvent(this, chng));
}
}
}
public void replace(int offset, int length, String text,
AttributeSet attrs) throws BadLocationException {
if (length == 0 && (text == null || text.length() == 0)) {
return;
}
DocumentFilter filter = getDocumentFilter();
writeLock();
try {
if (filter != null) {
filter.replace(getFilterBypass(), offset, length, text,
attrs);
}
else {
if (length > 0) {
remove(offset, length);
}
if (text != null && text.length() > 0) {
insertString(offset, text, attrs);
}
}
} finally {
writeUnlock();
}
}
public void insertString(int offs, String str, AttributeSet a) throws BadLocationException {
if ((str == null) || (str.length() == 0)) {
return;
}
if (offs > getLength()) {
throw new BadLocationException("Invalid insert", getLength());
}
DocumentFilter filter = getDocumentFilter();
writeLock();
try {
if (filter != null) {
filter.insertString(getFilterBypass(), offs, str, a);
} else {
handleInsertString(offs, str, a);
}
} finally {
writeUnlock();
}
}
private void handleInsertString(int offs, String str, AttributeSet a)
throws BadLocationException {
if ((str == null) || (str.length() == 0)) {
return;
}
UndoableEdit u = data.insertString(offs, str);
DefaultDocumentEvent e =
new DefaultDocumentEvent(offs, str.length(), DocumentEvent.EventType.INSERT);
if (u != null) {
e.addEdit(u);
}
if( getProperty(I18NProperty).equals( Boolean.FALSE ) ) {
Object d = getProperty(TextAttribute.RUN_DIRECTION);
if ((d != null) && (d.equals(TextAttribute.RUN_DIRECTION_RTL))) {
putProperty( I18NProperty, Boolean.TRUE);
} else {
char[] chars = str.toCharArray();
if (SwingUtilities2.isComplexLayout(chars, 0, chars.length)) {
putProperty( I18NProperty, Boolean.TRUE);
}
}
}
insertUpdate(e, a);
e.end();
fireInsertUpdate(e);
if (u != null && (a == null || !a.isDefined(StyleConstants.ComposedTextAttribute))) {
fireUndoableEditUpdate(new UndoableEditEvent(this, e));
}
}
public String getText(int offset, int length) throws BadLocationException {
if (length < 0) {
throw new BadLocationException("Length must be positive", length);
}
String str = data.getString(offset, length);
return str;
}
public void getText(int offset, int length, Segment txt) throws BadLocationException {
if (length < 0) {
throw new BadLocationException("Length must be positive", length);
}
data.getChars(offset, length, txt);
}
public synchronized Position createPosition(int offs) throws BadLocationException {
return data.createPosition(offs);
}
public final Position getStartPosition() {
Position p;
try {
p = createPosition(0);
} catch (BadLocationException bl) {
p = null;
}
return p;
}
public final Position getEndPosition() {
Position p;
try {
p = createPosition(data.length());
} catch (BadLocationException bl) {
p = null;
}
return p;
}
public Element[] getRootElements() {
Element[] elems = new Element[2];
elems[0] = getDefaultRootElement();
elems[1] = getBidiRootElement();
return elems;
}
public abstract Element getDefaultRootElement();
private DocumentFilter.FilterBypass getFilterBypass() {
if (filterBypass == null) {
filterBypass = new DefaultFilterBypass();
}
return filterBypass;
}
public Element getBidiRootElement() {
return bidiRoot;
}
static boolean isLeftToRight(Document doc, int p0, int p1) {
if (Boolean.TRUE.equals(doc.getProperty(I18NProperty))) {
if (doc instanceof AbstractDocument) {
AbstractDocument adoc = (AbstractDocument) doc;
Element bidiRoot = adoc.getBidiRootElement();
int index = bidiRoot.getElementIndex(p0);
Element bidiElem = bidiRoot.getElement(index);
if (bidiElem.getEndOffset() >= p1) {
AttributeSet bidiAttrs = bidiElem.getAttributes();
return ((StyleConstants.getBidiLevel(bidiAttrs) % 2) == 0);
}
}
}
return true;
}
public abstract Element getParagraphElement(int pos);
protected final AttributeContext getAttributeContext() {
return context;
}
protected void insertUpdate(DefaultDocumentEvent chng, AttributeSet attr) {
if( getProperty(I18NProperty).equals( Boolean.TRUE ) )
updateBidi( chng );
if (chng.type == DocumentEvent.EventType.INSERT &&
chng.getLength() > 0 &&
!Boolean.TRUE.equals(getProperty(MultiByteProperty))) {
Segment segment = SegmentCache.getSharedSegment();
try {
getText(chng.getOffset(), chng.getLength(), segment);
segment.first();
do {
if ((int)segment.current() > 255) {
putProperty(MultiByteProperty, Boolean.TRUE);
break;
}
} while (segment.next() != Segment.DONE);
} catch (BadLocationException ble) {
}
SegmentCache.releaseSharedSegment(segment);
}
}
protected void removeUpdate(DefaultDocumentEvent chng) {
}
protected void postRemoveUpdate(DefaultDocumentEvent chng) {
if( getProperty(I18NProperty).equals( Boolean.TRUE ) )
updateBidi( chng );
}
void updateBidi( DefaultDocumentEvent chng ) {
int firstPStart;
int lastPEnd;
if( chng.type == DocumentEvent.EventType.INSERT
|| chng.type == DocumentEvent.EventType.CHANGE )
{
int chngStart = chng.getOffset();
int chngEnd =  chngStart + chng.getLength();
firstPStart = getParagraphElement(chngStart).getStartOffset();
lastPEnd = getParagraphElement(chngEnd).getEndOffset();
} else if( chng.type == DocumentEvent.EventType.REMOVE ) {
Element paragraph = getParagraphElement( chng.getOffset() );
firstPStart = paragraph.getStartOffset();
lastPEnd = paragraph.getEndOffset();
} else {
throw new Error("Internal error: unknown event type.");
}
byte[] levels = calculateBidiLevels( firstPStart, lastPEnd );
ArrayList<Element> newElements = new ArrayList<Element>();
int firstSpanStart = firstPStart;
int removeFromIndex = 0;
if( firstSpanStart > 0 ) {
int prevElemIndex = bidiRoot.getElementIndex(firstPStart-1);
removeFromIndex = prevElemIndex;
Element prevElem = bidiRoot.getElement(prevElemIndex);
int prevLevel=StyleConstants.getBidiLevel(prevElem.getAttributes());
if( prevLevel==levels[0] ) {
firstSpanStart = prevElem.getStartOffset();
} else if( prevElem.getEndOffset() > firstPStart ) {
newElements.add(new BidiElement(bidiRoot,
prevElem.getStartOffset(),
firstPStart, prevLevel));
} else {
removeFromIndex++;
}
}
int firstSpanEnd = 0;
while((firstSpanEnd<levels.length) && (levels[firstSpanEnd]==levels[0]))
firstSpanEnd++;
int lastSpanEnd = lastPEnd;
Element newNextElem = null;
int removeToIndex = bidiRoot.getElementCount() - 1;
if( lastSpanEnd <= getLength() ) {
int nextElemIndex = bidiRoot.getElementIndex( lastPEnd );
removeToIndex = nextElemIndex;
Element nextElem = bidiRoot.getElement( nextElemIndex );
int nextLevel = StyleConstants.getBidiLevel(nextElem.getAttributes());
if( nextLevel == levels[levels.length-1] ) {
lastSpanEnd = nextElem.getEndOffset();
} else if( nextElem.getStartOffset() < lastPEnd ) {
newNextElem = new BidiElement(bidiRoot, lastPEnd,
nextElem.getEndOffset(),
nextLevel);
} else {
removeToIndex--;
}
}
int lastSpanStart = levels.length;
while( (lastSpanStart>firstSpanEnd)
&& (levels[lastSpanStart-1]==levels[levels.length-1]) )
lastSpanStart--;
if((firstSpanEnd==lastSpanStart)&&(levels[0]==levels[levels.length-1])){
newElements.add(new BidiElement(bidiRoot, firstSpanStart,
lastSpanEnd, levels[0]));
} else {
newElements.add(new BidiElement(bidiRoot, firstSpanStart,
firstSpanEnd+firstPStart,
levels[0]));
for( int i=firstSpanEnd; i<lastSpanStart; ) {
int j;
for( j=i;  (j<levels.length) && (levels[j] == levels[i]); j++ );
newElements.add(new BidiElement(bidiRoot, firstPStart+i,
firstPStart+j,
(int)levels[i]));
i=j;
}
newElements.add(new BidiElement(bidiRoot,
lastSpanStart+firstPStart,
lastSpanEnd,
levels[levels.length-1]));
}
if( newNextElem != null )
newElements.add( newNextElem );
int removedElemCount = 0;
if( bidiRoot.getElementCount() > 0 ) {
removedElemCount = removeToIndex - removeFromIndex + 1;
}
Element[] removedElems = new Element[removedElemCount];
for( int i=0; i<removedElemCount; i++ ) {
removedElems[i] = bidiRoot.getElement(removeFromIndex+i);
}
Element[] addedElems = newElements.toArray(new Element[0]);
ElementEdit ee = new ElementEdit( bidiRoot, removeFromIndex,
removedElems, addedElems );
chng.addEdit( ee );
bidiRoot.replace( removeFromIndex, removedElems.length, addedElems );
}
private byte[] calculateBidiLevels( int firstPStart, int lastPEnd ) {
byte[] levels = new byte[ lastPEnd - firstPStart ];
int  levelsEnd = 0;
Boolean defaultDirection = null;
Object d = getProperty(TextAttribute.RUN_DIRECTION);
if (d instanceof Boolean) {
defaultDirection = (Boolean) d;
}
for(int o=firstPStart; o<lastPEnd; ) {
Element p = getParagraphElement( o );
int pStart = p.getStartOffset();
int pEnd = p.getEndOffset();
Boolean direction = defaultDirection;
d = p.getAttributes().getAttribute(TextAttribute.RUN_DIRECTION);
if (d instanceof Boolean) {
direction = (Boolean) d;
}
Segment seg = SegmentCache.getSharedSegment();
try {
getText(pStart, pEnd-pStart, seg);
} catch (BadLocationException e ) {
throw new Error("Internal error: " + e.toString());
}
Bidi bidiAnalyzer;
int bidiflag = Bidi.DIRECTION_DEFAULT_LEFT_TO_RIGHT;
if (direction != null) {
if (TextAttribute.RUN_DIRECTION_LTR.equals(direction)) {
bidiflag = Bidi.DIRECTION_LEFT_TO_RIGHT;
} else {
bidiflag = Bidi.DIRECTION_RIGHT_TO_LEFT;
}
}
bidiAnalyzer = new Bidi(seg.array, seg.offset, null, 0, seg.count,
bidiflag);
BidiUtils.getLevels(bidiAnalyzer, levels, levelsEnd);
levelsEnd += bidiAnalyzer.getLength();
o =  p.getEndOffset();
SegmentCache.releaseSharedSegment(seg);
}
if( levelsEnd != levels.length )
throw new Error("levelsEnd assertion failed.");
return levels;
}
public void dump(PrintStream out) {
Element root = getDefaultRootElement();
if (root instanceof AbstractElement) {
((AbstractElement)root).dump(out, 0);
}
bidiRoot.dump(out,0);
}
protected final Content getContent() {
return data;
}
protected Element createLeafElement(Element parent, AttributeSet a, int p0, int p1) {
return new LeafElement(parent, a, p0, p1);
}
protected Element createBranchElement(Element parent, AttributeSet a) {
return new BranchElement(parent, a);
}
protected final synchronized Thread getCurrentWriter() {
return currWriter;
}
protected final synchronized void writeLock() {
try {
while ((numReaders > 0) || (currWriter != null)) {
if (Thread.currentThread() == currWriter) {
if (notifyingListeners) {
throw new IllegalStateException(
"Attempt to mutate in notification");
}
numWriters++;
return;
}
wait();
}
currWriter = Thread.currentThread();
numWriters = 1;
} catch (InterruptedException e) {
throw new Error("Interrupted attempt to acquire write lock");
}
}
protected final synchronized void writeUnlock() {
if (--numWriters <= 0) {
numWriters = 0;
currWriter = null;
notifyAll();
}
}
public final synchronized void readLock() {
try {
while (currWriter != null) {
if (currWriter == Thread.currentThread()) {
return;
}
wait();
}
numReaders += 1;
} catch (InterruptedException e) {
throw new Error("Interrupted attempt to acquire read lock");
}
}
public final synchronized void readUnlock() {
if (currWriter == Thread.currentThread()) {
return;
}
if (numReaders <= 0) {
throw new StateInvariantError(BAD_LOCK_STATE);
}
numReaders -= 1;
notify();
}
@Serial
@SuppressWarnings("unchecked")
private void readObject(ObjectInputStream s)
throws ClassNotFoundException, IOException
{
ObjectInputStream.GetField f = s.readFields();
documentProperties =
(Dictionary<Object, Object>) f.get("documentProperties", null);
listenerList = new EventListenerList();
data = (Content) f.get("data", null);
context = (AttributeContext) f.get("context", null);
documentFilter = (DocumentFilter) f.get("documentFilter", null);
bidiRoot = new BidiRootElement();
try {
writeLock();
Element[] p = new Element[1];
p[0] = new BidiElement( bidiRoot, 0, 1, 0 );
bidiRoot.replace(0,0,p);
} finally {
writeUnlock();
}
s.registerValidation(new ObjectInputValidation() {
public void validateObject() {
try {
writeLock();
DefaultDocumentEvent e = new DefaultDocumentEvent
(0, getLength(),
DocumentEvent.EventType.INSERT);
updateBidi( e );
}
finally {
writeUnlock();
}
}
}, 0);
}
private transient int numReaders;
private transient Thread currWriter;
private transient int numWriters;
private transient boolean notifyingListeners;
private static Boolean defaultI18NProperty;
private Dictionary<Object,Object> documentProperties = null;
protected EventListenerList listenerList = new EventListenerList();
private Content data;
private AttributeContext context;
private transient BranchElement bidiRoot;
private DocumentFilter documentFilter;
private transient DocumentFilter.FilterBypass filterBypass;
private static final String BAD_LOCK_STATE = "document lock failure";
protected static final String BAD_LOCATION = "document location failure";
public static final String ParagraphElementName = "paragraph";
public static final String ContentElementName = "content";
public static final String SectionElementName = "section";
public static final String BidiElementName = "bidi level";
public static final String ElementNameAttribute = "$ename";
static final String I18NProperty = "i18n";
static final Object MultiByteProperty = "multiByte";
static final String AsyncLoadPriority = "load priority";
public interface Content {
public Position createPosition(int offset) throws BadLocationException;
public int length();
public UndoableEdit insertString(int where, String str) throws BadLocationException;
public UndoableEdit remove(int where, int nitems) throws BadLocationException;
public String getString(int where, int len) throws BadLocationException;
public void getChars(int where, int len, Segment txt) throws BadLocationException;
}
public interface AttributeContext {
public AttributeSet addAttribute(AttributeSet old, Object name, Object value);
public AttributeSet addAttributes(AttributeSet old, AttributeSet attr);
public AttributeSet removeAttribute(AttributeSet old, Object name);
public AttributeSet removeAttributes(AttributeSet old, Enumeration<?> names);
public AttributeSet removeAttributes(AttributeSet old, AttributeSet attrs);
public AttributeSet getEmptySet();
public void reclaim(AttributeSet a);
}
@SuppressWarnings("serial")     public abstract class AbstractElement implements Element, MutableAttributeSet, Serializable, TreeNode {
public AbstractElement(Element parent, AttributeSet a) {
this.parent = parent;
attributes = getAttributeContext().getEmptySet();
if (a != null) {
addAttributes(a);
}
}
private void indent(PrintWriter out, int n) {
for (int i = 0; i < n; i++) {
out.print("  ");
}
}
public void dump(PrintStream psOut, int indentAmount) {
PrintWriter out;
try {
out = new PrintWriter(new OutputStreamWriter(psOut,"JavaEsc"),
true);
} catch (UnsupportedEncodingException e){
out = new PrintWriter(psOut,true);
}
indent(out, indentAmount);
if (getName() == null) {
out.print("<??");
} else {
out.print("<" + getName());
}
if (getAttributeCount() > 0) {
out.println("");
Enumeration<?> names = attributes.getAttributeNames();
while (names.hasMoreElements()) {
Object name = names.nextElement();
indent(out, indentAmount + 1);
out.println(name + "=" + getAttribute(name));
}
indent(out, indentAmount);
}
out.println(">");
if (isLeaf()) {
indent(out, indentAmount+1);
out.print("[" + getStartOffset() + "," + getEndOffset() + "]");
Content c = getContent();
try {
String contentStr = c.getString(getStartOffset(),
getEndOffset() - getStartOffset());
if (contentStr.length() > 40) {
contentStr = contentStr.substring(0, 40) + "...";
}
out.println("["+contentStr+"]");
} catch (BadLocationException e) {
}
} else {
int n = getElementCount();
for (int i = 0; i < n; i++) {
AbstractElement e = (AbstractElement) getElement(i);
e.dump(psOut, indentAmount+1);
}
}
}
public int getAttributeCount() {
return attributes.getAttributeCount();
}
public boolean isDefined(Object attrName) {
return attributes.isDefined(attrName);
}
public boolean isEqual(AttributeSet attr) {
return attributes.isEqual(attr);
}
public AttributeSet copyAttributes() {
return attributes.copyAttributes();
}
public Object getAttribute(Object attrName) {
Object value = attributes.getAttribute(attrName);
if (value == null) {
AttributeSet a = (parent != null) ? parent.getAttributes() : null;
if (a != null) {
value = a.getAttribute(attrName);
}
}
return value;
}
public Enumeration<?> getAttributeNames() {
return attributes.getAttributeNames();
}
public boolean containsAttribute(Object name, Object value) {
return attributes.containsAttribute(name, value);
}
public boolean containsAttributes(AttributeSet attrs) {
return attributes.containsAttributes(attrs);
}
public AttributeSet getResolveParent() {
AttributeSet a = attributes.getResolveParent();
if ((a == null) && (parent != null)) {
a = parent.getAttributes();
}
return a;
}
public void addAttribute(Object name, Object value) {
checkForIllegalCast();
AttributeContext context = getAttributeContext();
attributes = context.addAttribute(attributes, name, value);
}
public void addAttributes(AttributeSet attr) {
checkForIllegalCast();
AttributeContext context = getAttributeContext();
attributes = context.addAttributes(attributes, attr);
}
public void removeAttribute(Object name) {
checkForIllegalCast();
AttributeContext context = getAttributeContext();
attributes = context.removeAttribute(attributes, name);
}
public void removeAttributes(Enumeration<?> names) {
checkForIllegalCast();
AttributeContext context = getAttributeContext();
attributes = context.removeAttributes(attributes, names);
}
public void removeAttributes(AttributeSet attrs) {
checkForIllegalCast();
AttributeContext context = getAttributeContext();
if (attrs == this) {
attributes = context.getEmptySet();
} else {
attributes = context.removeAttributes(attributes, attrs);
}
}
public void setResolveParent(AttributeSet parent) {
checkForIllegalCast();
AttributeContext context = getAttributeContext();
if (parent != null) {
attributes =
context.addAttribute(attributes, StyleConstants.ResolveAttribute,
parent);
} else {
attributes =
context.removeAttribute(attributes, StyleConstants.ResolveAttribute);
}
}
private void checkForIllegalCast() {
Thread t = getCurrentWriter();
if ((t == null) || (t != Thread.currentThread())) {
throw new StateInvariantError("Illegal cast to MutableAttributeSet");
}
}
public Document getDocument() {
return AbstractDocument.this;
}
public Element getParentElement() {
return parent;
}
public AttributeSet getAttributes() {
return this;
}
public String getName() {
if (attributes.isDefined(ElementNameAttribute)) {
return (String) attributes.getAttribute(ElementNameAttribute);
}
return null;
}
public abstract int getStartOffset();
public abstract int getEndOffset();
public abstract Element getElement(int index);
public abstract int getElementCount();
public abstract int getElementIndex(int offset);
public abstract boolean isLeaf();
public TreeNode getChildAt(int childIndex) {
return (TreeNode)getElement(childIndex);
}
public int getChildCount() {
return getElementCount();
}
public TreeNode getParent() {
return (TreeNode)getParentElement();
}
public int getIndex(TreeNode node) {
for(int counter = getChildCount() - 1; counter >= 0; counter--)
if(getChildAt(counter) == node)
return counter;
return -1;
}
public abstract boolean getAllowsChildren();
public abstract Enumeration<TreeNode> children();
@Serial
private void writeObject(ObjectOutputStream s) throws IOException {
s.defaultWriteObject();
StyleContext.writeAttributeSet(s, attributes);
}
@Serial
private void readObject(ObjectInputStream s)
throws ClassNotFoundException, IOException
{
s.defaultReadObject();
MutableAttributeSet attr = new SimpleAttributeSet();
StyleContext.readAttributeSet(s, attr);
AttributeContext context = getAttributeContext();
attributes = context.addAttributes(SimpleAttributeSet.EMPTY, attr);
}
private Element parent;
private transient AttributeSet attributes;
}
@SuppressWarnings("serial")     public class BranchElement extends AbstractElement {
public BranchElement(Element parent, AttributeSet a) {
super(parent, a);
children = new AbstractElement[1];
nchildren = 0;
lastIndex = -1;
}
public Element positionToElement(int pos) {
int index = getElementIndex(pos);
Element child = children[index];
int p0 = child.getStartOffset();
int p1 = child.getEndOffset();
if ((pos >= p0) && (pos < p1)) {
return child;
}
return null;
}
public void replace(int offset, int length, Element[] elems) {
int delta = elems.length - length;
int src = offset + length;
int nmove = nchildren - src;
int dest = src + delta;
if ((nchildren + delta) >= children.length) {
int newLength = Math.max(2*children.length, nchildren + delta);
AbstractElement[] newChildren = new AbstractElement[newLength];
System.arraycopy(children, 0, newChildren, 0, offset);
System.arraycopy(elems, 0, newChildren, offset, elems.length);
System.arraycopy(children, src, newChildren, dest, nmove);
children = newChildren;
} else {
System.arraycopy(children, src, children, dest, nmove);
System.arraycopy(elems, 0, children, offset, elems.length);
}
nchildren = nchildren + delta;
}
public String toString() {
return "BranchElement(" + getName() + ") " + getStartOffset() + "," +
getEndOffset() + "\n";
}
public String getName() {
String nm = super.getName();
if (nm == null) {
nm = ParagraphElementName;
}
return nm;
}
public int getStartOffset() {
return children[0].getStartOffset();
}
public int getEndOffset() {
Element child =
(nchildren > 0) ? children[nchildren - 1] : children[0];
return child.getEndOffset();
}
public Element getElement(int index) {
if (index < nchildren) {
return children[index];
}
return null;
}
public int getElementCount()  {
return nchildren;
}
public int getElementIndex(int offset) {
int index;
int lower = 0;
int upper = nchildren - 1;
int mid = 0;
int p0 = getStartOffset();
int p1;
if (nchildren == 0) {
return 0;
}
if (offset >= getEndOffset()) {
return nchildren - 1;
}
if ((lastIndex >= lower) && (lastIndex <= upper)) {
Element lastHit = children[lastIndex];
p0 = lastHit.getStartOffset();
p1 = lastHit.getEndOffset();
if ((offset >= p0) && (offset < p1)) {
return lastIndex;
}
if (offset < p0) {
upper = lastIndex;
} else  {
lower = lastIndex;
}
}
while (lower <= upper) {
mid = lower + ((upper - lower) / 2);
Element elem = children[mid];
p0 = elem.getStartOffset();
p1 = elem.getEndOffset();
if ((offset >= p0) && (offset < p1)) {
index = mid;
lastIndex = index;
return index;
} else if (offset < p0) {
upper = mid - 1;
} else {
lower = mid + 1;
}
}
if (offset < p0) {
index = mid;
} else {
index = mid + 1;
}
lastIndex = index;
return index;
}
public boolean isLeaf() {
return false;
}
public boolean getAllowsChildren() {
return true;
}
public Enumeration<TreeNode> children() {
if(nchildren == 0)
return null;
Vector<TreeNode> tempVector = new Vector<>(nchildren);
for(int counter = 0; counter < nchildren; counter++)
tempVector.addElement(children[counter]);
return tempVector.elements();
}
private AbstractElement[] children;
private int nchildren;
private int lastIndex;
}
@SuppressWarnings("serial")     public class LeafElement extends AbstractElement {
public LeafElement(Element parent, AttributeSet a, int offs0, int offs1) {
super(parent, a);
try {
p0 = createPosition(offs0);
p1 = createPosition(offs1);
} catch (BadLocationException e) {
p0 = null;
p1 = null;
throw new StateInvariantError("Can't create Position references");
}
}
public String toString() {
return "LeafElement(" + getName() + ") " + p0 + "," + p1 + "\n";
}
public int getStartOffset() {
return p0.getOffset();
}
public int getEndOffset() {
return p1.getOffset();
}
public String getName() {
String nm = super.getName();
if (nm == null) {
nm = ContentElementName;
}
return nm;
}
public int getElementIndex(int pos) {
return -1;
}
public Element getElement(int index) {
return null;
}
public int getElementCount()  {
return 0;
}
public boolean isLeaf() {
return true;
}
public boolean getAllowsChildren() {
return false;
}
@Override
public Enumeration<TreeNode> children() {
return null;
}
@Serial
private void writeObject(ObjectOutputStream s) throws IOException {
s.defaultWriteObject();
s.writeInt(p0.getOffset());
s.writeInt(p1.getOffset());
}
@Serial
private void readObject(ObjectInputStream s)
throws ClassNotFoundException, IOException
{
s.defaultReadObject();
int off0 = s.readInt();
int off1 = s.readInt();
try {
p0 = createPosition(off0);
p1 = createPosition(off1);
} catch (BadLocationException e) {
p0 = null;
p1 = null;
throw new IOException("Can't restore Position references");
}
}
private transient Position p0;
private transient Position p1;
}
class BidiRootElement extends BranchElement {
BidiRootElement() {
super( null, null );
}
public String getName() {
return "bidi root";
}
}
class BidiElement extends LeafElement {
BidiElement(Element parent, int start, int end, int level) {
super(parent, new SimpleAttributeSet(), start, end);
addAttribute(StyleConstants.BidiLevel, Integer.valueOf(level));
}
public String getName() {
return BidiElementName;
}
int getLevel() {
Integer o = (Integer) getAttribute(StyleConstants.BidiLevel);
if (o != null) {
return o.intValue();
}
return 0;          }
boolean isLeftToRight() {
return ((getLevel() % 2) == 0);
}
}
public class DefaultDocumentEvent extends CompoundEdit implements DocumentEvent {
public DefaultDocumentEvent(int offs, int len, DocumentEvent.EventType type) {
super();
offset = offs;
length = len;
this.type = type;
}
public String toString() {
return edits.toString();
}
public boolean addEdit(UndoableEdit anEdit) {
if ((changeLookup == null) && (edits.size() > 10)) {
changeLookup = new Hashtable<Element, ElementChange>();
int n = edits.size();
for (int i = 0; i < n; i++) {
Object o = edits.elementAt(i);
if (o instanceof DocumentEvent.ElementChange) {
DocumentEvent.ElementChange ec = (DocumentEvent.ElementChange) o;
changeLookup.put(ec.getElement(), ec);
}
}
}
if ((changeLookup != null) && (anEdit instanceof DocumentEvent.ElementChange)) {
DocumentEvent.ElementChange ec = (DocumentEvent.ElementChange) anEdit;
changeLookup.put(ec.getElement(), ec);
}
return super.addEdit(anEdit);
}
public void redo() throws CannotRedoException {
writeLock();
try {
super.redo();
UndoRedoDocumentEvent ev = new UndoRedoDocumentEvent(this, false);
if (type == DocumentEvent.EventType.INSERT) {
fireInsertUpdate(ev);
} else if (type == DocumentEvent.EventType.REMOVE) {
fireRemoveUpdate(ev);
} else {
fireChangedUpdate(ev);
}
} finally {
writeUnlock();
}
}
public void undo() throws CannotUndoException {
writeLock();
try {
super.undo();
UndoRedoDocumentEvent ev = new UndoRedoDocumentEvent(this, true);
if (type == DocumentEvent.EventType.REMOVE) {
fireInsertUpdate(ev);
} else if (type == DocumentEvent.EventType.INSERT) {
fireRemoveUpdate(ev);
} else {
fireChangedUpdate(ev);
}
} finally {
writeUnlock();
}
}
public boolean isSignificant() {
return true;
}
public String getPresentationName() {
DocumentEvent.EventType type = getType();
if(type == DocumentEvent.EventType.INSERT)
return UIManager.getString("AbstractDocument.additionText");
if(type == DocumentEvent.EventType.REMOVE)
return UIManager.getString("AbstractDocument.deletionText");
return UIManager.getString("AbstractDocument.styleChangeText");
}
public String getUndoPresentationName() {
return UIManager.getString("AbstractDocument.undoText") + " " +
getPresentationName();
}
public String getRedoPresentationName() {
return UIManager.getString("AbstractDocument.redoText") + " " +
getPresentationName();
}
public DocumentEvent.EventType getType() {
return type;
}
public int getOffset() {
return offset;
}
public int getLength() {
return length;
}
public Document getDocument() {
return AbstractDocument.this;
}
public DocumentEvent.ElementChange getChange(Element elem) {
if (changeLookup != null) {
return changeLookup.get(elem);
}
int n = edits.size();
for (int i = 0; i < n; i++) {
Object o = edits.elementAt(i);
if (o instanceof DocumentEvent.ElementChange) {
DocumentEvent.ElementChange c = (DocumentEvent.ElementChange) o;
if (elem.equals(c.getElement())) {
return c;
}
}
}
return null;
}
private int offset;
private int length;
private Hashtable<Element, ElementChange> changeLookup;
private DocumentEvent.EventType type;
}
class DefaultDocumentEventUndoableWrapper extends DefaultDocumentEvent implements
UndoableEdit, UndoableEditLockSupport
{
final DefaultDocumentEvent dde;
public DefaultDocumentEventUndoableWrapper(DefaultDocumentEvent dde) {
super(dde.getOffset(),dde.getLength(),dde.type);
this.dde = dde;
}
@Override
public void undo() throws CannotUndoException {
dde.undo();
}
@Override
public boolean canUndo() {
return dde.canUndo();
}
@Override
public void redo() throws CannotRedoException {
dde.redo();
}
@Override
public boolean canRedo() {
return dde.canRedo();
}
@Override
public void die() {
dde.die();
}
@Override
public boolean addEdit(UndoableEdit anEdit) {
return dde.addEdit(anEdit);
}
@Override
public boolean replaceEdit(UndoableEdit anEdit) {
return dde.replaceEdit(anEdit);
}
@Override
public boolean isSignificant() {
return dde.isSignificant();
}
@Override
public String getPresentationName() {
return dde.getPresentationName();
}
@Override
public String getUndoPresentationName() {
return dde.getUndoPresentationName();
}
@Override
public String getRedoPresentationName() {
return dde.getRedoPresentationName();
}
@Override
public void lockEdit() {
((AbstractDocument)dde.getDocument()).writeLock();
}
@Override
public void unlockEdit() {
((AbstractDocument)dde.getDocument()).writeUnlock();
}
}
class UndoRedoDocumentEvent implements DocumentEvent {
private DefaultDocumentEvent src = null;
private EventType type = null;
public UndoRedoDocumentEvent(DefaultDocumentEvent src, boolean isUndo) {
this.src = src;
if(isUndo) {
if(src.getType().equals(EventType.INSERT)) {
type = EventType.REMOVE;
} else if(src.getType().equals(EventType.REMOVE)) {
type = EventType.INSERT;
} else {
type = src.getType();
}
} else {
type = src.getType();
}
}
public DefaultDocumentEvent getSource() {
return src;
}
public int getOffset() {
return src.getOffset();
}
public int getLength() {
return src.getLength();
}
public Document getDocument() {
return src.getDocument();
}
public DocumentEvent.EventType getType() {
return type;
}
public DocumentEvent.ElementChange getChange(Element elem) {
return src.getChange(elem);
}
}
public static class ElementEdit extends AbstractUndoableEdit implements DocumentEvent.ElementChange {
public ElementEdit(Element e, int index, Element[] removed, Element[] added) {
super();
this.e = e;
this.index = index;
this.removed = removed;
this.added = added;
}
public Element getElement() {
return e;
}
public int getIndex() {
return index;
}
public Element[] getChildrenRemoved() {
return removed;
}
public Element[] getChildrenAdded() {
return added;
}
public void redo() throws CannotRedoException {
super.redo();
Element[] tmp = removed;
removed = added;
added = tmp;
((AbstractDocument.BranchElement)e).replace(index, removed.length, added);
}
public void undo() throws CannotUndoException {
super.undo();
((AbstractDocument.BranchElement)e).replace(index, added.length, removed);
Element[] tmp = removed;
removed = added;
added = tmp;
}
private Element e;
private int index;
private Element[] removed;
private Element[] added;
}
private class DefaultFilterBypass extends DocumentFilter.FilterBypass {
public Document getDocument() {
return AbstractDocument.this;
}
public void remove(int offset, int length) throws
BadLocationException {
handleRemove(offset, length);
}
public void insertString(int offset, String string,
AttributeSet attr) throws
BadLocationException {
handleInsertString(offset, string, attr);
}
public void replace(int offset, int length, String text,
AttributeSet attrs) throws BadLocationException {
handleRemove(offset, length);
handleInsertString(offset, text, attrs);
}
}
}
package com.sun.org.apache.xerces.internal.parsers;
import com.sun.org.apache.xerces.internal.dom.AttrImpl;
import com.sun.org.apache.xerces.internal.dom.CoreDocumentImpl;
import com.sun.org.apache.xerces.internal.dom.DOMErrorImpl;
import com.sun.org.apache.xerces.internal.dom.DOMMessageFormatter;
import com.sun.org.apache.xerces.internal.dom.DeferredDocumentImpl;
import com.sun.org.apache.xerces.internal.dom.DocumentImpl;
import com.sun.org.apache.xerces.internal.dom.DocumentTypeImpl;
import com.sun.org.apache.xerces.internal.dom.ElementDefinitionImpl;
import com.sun.org.apache.xerces.internal.dom.ElementImpl;
import com.sun.org.apache.xerces.internal.dom.ElementNSImpl;
import com.sun.org.apache.xerces.internal.dom.EntityImpl;
import com.sun.org.apache.xerces.internal.dom.EntityReferenceImpl;
import com.sun.org.apache.xerces.internal.dom.NodeImpl;
import com.sun.org.apache.xerces.internal.dom.NotationImpl;
import com.sun.org.apache.xerces.internal.dom.PSVIAttrNSImpl;
import com.sun.org.apache.xerces.internal.dom.PSVIDocumentImpl;
import com.sun.org.apache.xerces.internal.dom.PSVIElementNSImpl;
import com.sun.org.apache.xerces.internal.dom.TextImpl;
import com.sun.org.apache.xerces.internal.impl.Constants;
import com.sun.org.apache.xerces.internal.impl.dv.XSSimpleType;
import com.sun.org.apache.xerces.internal.util.DOMErrorHandlerWrapper;
import com.sun.org.apache.xerces.internal.utils.ObjectFactory;
import com.sun.org.apache.xerces.internal.xni.Augmentations;
import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
import com.sun.org.apache.xerces.internal.xni.QName;
import com.sun.org.apache.xerces.internal.xni.XMLAttributes;
import com.sun.org.apache.xerces.internal.xni.XMLLocator;
import com.sun.org.apache.xerces.internal.xni.XMLResourceIdentifier;
import com.sun.org.apache.xerces.internal.xni.XMLString;
import com.sun.org.apache.xerces.internal.xni.XNIException;
import com.sun.org.apache.xerces.internal.xni.parser.XMLParserConfiguration;
import com.sun.org.apache.xerces.internal.xs.AttributePSVI;
import com.sun.org.apache.xerces.internal.xs.ElementPSVI;
import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
import java.util.Locale;
import java.util.Stack;
import jdk.xml.internal.JdkXmlUtils;
import org.w3c.dom.Attr;
import org.w3c.dom.CDATASection;
import org.w3c.dom.Comment;
import org.w3c.dom.DOMError;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Element;
import org.w3c.dom.EntityReference;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.ProcessingInstruction;
import org.w3c.dom.Text;
import org.w3c.dom.ls.LSParserFilter;
import org.w3c.dom.traversal.NodeFilter;
import org.xml.sax.SAXException;
public class AbstractDOMParser extends AbstractXMLDocumentParser {
protected static final String NAMESPACES =
Constants.SAX_FEATURE_PREFIX+Constants.NAMESPACES_FEATURE;
protected static final String CREATE_ENTITY_REF_NODES =
Constants.XERCES_FEATURE_PREFIX + Constants.CREATE_ENTITY_REF_NODES_FEATURE;
protected static final String INCLUDE_COMMENTS_FEATURE =
Constants.XERCES_FEATURE_PREFIX + Constants.INCLUDE_COMMENTS_FEATURE;
protected static final String CREATE_CDATA_NODES_FEATURE =
Constants.XERCES_FEATURE_PREFIX + Constants.CREATE_CDATA_NODES_FEATURE;
protected static final String INCLUDE_IGNORABLE_WHITESPACE =
Constants.XERCES_FEATURE_PREFIX + Constants.INCLUDE_IGNORABLE_WHITESPACE;
protected static final String DEFER_NODE_EXPANSION =
Constants.XERCES_FEATURE_PREFIX + Constants.DEFER_NODE_EXPANSION_FEATURE;
private static final String[] RECOGNIZED_FEATURES = {
NAMESPACES,
CREATE_ENTITY_REF_NODES,
INCLUDE_COMMENTS_FEATURE,
CREATE_CDATA_NODES_FEATURE,
INCLUDE_IGNORABLE_WHITESPACE,
DEFER_NODE_EXPANSION
};
protected static final String DOCUMENT_CLASS_NAME =
Constants.XERCES_PROPERTY_PREFIX + Constants.DOCUMENT_CLASS_NAME_PROPERTY;
protected static final String  CURRENT_ELEMENT_NODE=
Constants.XERCES_PROPERTY_PREFIX + Constants.CURRENT_ELEMENT_NODE_PROPERTY;
private static final String[] RECOGNIZED_PROPERTIES = {
DOCUMENT_CLASS_NAME,
CURRENT_ELEMENT_NODE,
};
protected static final String DEFAULT_DOCUMENT_CLASS_NAME =
"com.sun.org.apache.xerces.internal.dom.DocumentImpl";
protected static final String CORE_DOCUMENT_CLASS_NAME =
"com.sun.org.apache.xerces.internal.dom.CoreDocumentImpl";
protected static final String PSVI_DOCUMENT_CLASS_NAME =
"com.sun.org.apache.xerces.internal.dom.PSVIDocumentImpl";
static final class Abort extends RuntimeException {
private static final long serialVersionUID = 1687848994976808490L;
static final Abort INSTANCE = new Abort();
private Abort() {}
public Throwable fillInStackTrace() {
return this;
}
}
private static final boolean DEBUG_EVENTS = false;
private static final boolean DEBUG_BASEURI = false;
protected DOMErrorHandlerWrapper fErrorHandler = null;
protected boolean fInDTD;
protected boolean fCreateEntityRefNodes;
protected boolean fIncludeIgnorableWhitespace;
protected boolean fIncludeComments;
protected boolean fCreateCDATANodes;
protected Document fDocument;
protected CoreDocumentImpl fDocumentImpl;
protected boolean fStorePSVI;
protected String  fDocumentClassName;
protected DocumentType fDocumentType;
protected Node fCurrentNode;
protected CDATASection fCurrentCDATASection;
protected EntityImpl fCurrentEntityDecl;
protected int fDeferredEntityDecl;
protected final StringBuilder fStringBuilder = new StringBuilder (50);
protected StringBuilder fInternalSubset;
protected boolean              fDeferNodeExpansion;
protected boolean              fNamespaceAware;
protected DeferredDocumentImpl fDeferredDocumentImpl;
protected int                  fDocumentIndex;
protected int                  fDocumentTypeIndex;
protected int                  fCurrentNodeIndex;
protected int                  fCurrentCDATASectionIndex;
protected boolean fInDTDExternalSubset;
protected Node fRoot;
protected boolean fInCDATASection;
protected boolean fFirstChunk = false;
protected boolean fFilterReject = false;
protected final Stack<String> fBaseURIStack = new Stack<>();
protected int fRejectedElementDepth = 0;
protected Stack<Boolean> fSkippedElemStack = null;
protected boolean fInEntityRef = false;
private final QName fAttrQName = new QName();
private XMLLocator fLocator;
protected LSParserFilter fDOMFilter = null;
protected AbstractDOMParser (XMLParserConfiguration config) {
super (config);
fConfiguration.addRecognizedFeatures (RECOGNIZED_FEATURES);
fConfiguration.setFeature (CREATE_ENTITY_REF_NODES, true);
fConfiguration.setFeature (INCLUDE_IGNORABLE_WHITESPACE, true);
fConfiguration.setFeature (DEFER_NODE_EXPANSION, true);
fConfiguration.setFeature (INCLUDE_COMMENTS_FEATURE, true);
fConfiguration.setFeature (CREATE_CDATA_NODES_FEATURE, true);
fConfiguration.addRecognizedProperties (RECOGNIZED_PROPERTIES);
fConfiguration.setProperty (DOCUMENT_CLASS_NAME,
DEFAULT_DOCUMENT_CLASS_NAME);
}
protected String getDocumentClassName () {
return fDocumentClassName;
}
protected void setDocumentClassName (String documentClassName) {
if (documentClassName == null) {
documentClassName = DEFAULT_DOCUMENT_CLASS_NAME;
}
if (!documentClassName.equals(DEFAULT_DOCUMENT_CLASS_NAME) &&
!documentClassName.equals(PSVI_DOCUMENT_CLASS_NAME)) {
try {
Class<?> _class = ObjectFactory.findProviderClass (documentClassName, true);
if (!Document.class.isAssignableFrom (_class)) {
throw new IllegalArgumentException (
DOMMessageFormatter.formatMessage(
DOMMessageFormatter.DOM_DOMAIN,
"InvalidDocumentClassName", new Object [] {documentClassName}));
}
}
catch (ClassNotFoundException e) {
throw new IllegalArgumentException (
DOMMessageFormatter.formatMessage(
DOMMessageFormatter.DOM_DOMAIN,
"MissingDocumentClassName", new Object [] {documentClassName}));
}
}
fDocumentClassName = documentClassName;
if (!documentClassName.equals (DEFAULT_DOCUMENT_CLASS_NAME)) {
fDeferNodeExpansion = false;
}
}
public Document getDocument () {
return fDocument;
}
public final void dropDocumentReferences() {
fDocument = null;
fDocumentImpl = null;
fDeferredDocumentImpl = null;
fDocumentType = null;
fCurrentNode = null;
fCurrentCDATASection = null;
fCurrentEntityDecl = null;
fRoot = null;
}
public void reset () throws XNIException {
super.reset ();
fCreateEntityRefNodes =
fConfiguration.getFeature (CREATE_ENTITY_REF_NODES);
fIncludeIgnorableWhitespace =
fConfiguration.getFeature (INCLUDE_IGNORABLE_WHITESPACE);
fDeferNodeExpansion =
fConfiguration.getFeature (DEFER_NODE_EXPANSION);
fNamespaceAware = fConfiguration.getFeature (NAMESPACES);
fIncludeComments = fConfiguration.getFeature (INCLUDE_COMMENTS_FEATURE);
fCreateCDATANodes = fConfiguration.getFeature (CREATE_CDATA_NODES_FEATURE);
setDocumentClassName ((String)
fConfiguration.getProperty (DOCUMENT_CLASS_NAME));
fDocument = null;
fDocumentImpl = null;
fStorePSVI = false;
fDocumentType = null;
fDocumentTypeIndex = -1;
fDeferredDocumentImpl = null;
fCurrentNode = null;
fStringBuilder.setLength (0);
fRoot = null;
fInDTD = false;
fInDTDExternalSubset = false;
fInCDATASection = false;
fFirstChunk = false;
fCurrentCDATASection = null;
fCurrentCDATASectionIndex = -1;
fBaseURIStack.removeAllElements ();
}
public void setLocale (Locale locale) {
fConfiguration.setLocale (locale);
}
public void startGeneralEntity (String name,
XMLResourceIdentifier identifier,
String encoding, Augmentations augs)
throws XNIException {
if (DEBUG_EVENTS) {
System.out.println ("==>startGeneralEntity ("+name+")");
if (DEBUG_BASEURI) {
System.out.println ("   expandedSystemId( **baseURI): " +
identifier == null ? null : identifier.getExpandedSystemId());
System.out.println ("   baseURI:" +
identifier == null ? null : identifier.getBaseSystemId());
}
}
if (!fDeferNodeExpansion) {
if (fFilterReject) {
return;
}
setCharacterData (true);
EntityReference er = fDocument.createEntityReference (name);
if (fDocumentImpl != null) {
EntityReferenceImpl erImpl =(EntityReferenceImpl)er;
erImpl.setBaseURI (identifier == null ? null : identifier.getExpandedSystemId());
if (fDocumentType != null) {
NamedNodeMap entities = fDocumentType.getEntities ();
fCurrentEntityDecl = (EntityImpl) entities.getNamedItem (name);
if (fCurrentEntityDecl != null) {
fCurrentEntityDecl.setInputEncoding (encoding);
}
}
erImpl.needsSyncChildren (false);
}
fInEntityRef = true;
fCurrentNode.appendChild (er);
if (!fCreateEntityRefNodes) {
fCurrentNode = er;
} else {
((NodeImpl)er).setReadOnly (true, true);
}
}
else {
int er = fDeferredDocumentImpl.createDeferredEntityReference (name,
identifier == null ? null : identifier.getExpandedSystemId ());
if (fDocumentTypeIndex != -1) {
int node = fDeferredDocumentImpl.getLastChild (fDocumentTypeIndex, false);
while (node != -1) {
short nodeType = fDeferredDocumentImpl.getNodeType (node, false);
if (nodeType == Node.ENTITY_NODE) {
String nodeName =
fDeferredDocumentImpl.getNodeName (node, false);
if (nodeName.equals (name)) {
fDeferredEntityDecl = node;
fDeferredDocumentImpl.setInputEncoding (node, encoding);
break;
}
}
node = fDeferredDocumentImpl.getRealPrevSibling (node, false);
}
}
fDeferredDocumentImpl.appendChild (fCurrentNodeIndex, er);
if (!fCreateEntityRefNodes) {
fCurrentNodeIndex = er;
}
}
}
public void textDecl (String version, String encoding, Augmentations augs) throws XNIException {
if (fInDTD){
return;
}
if (!fDeferNodeExpansion) {
if (fCurrentEntityDecl != null && !fFilterReject) {
fCurrentEntityDecl.setXmlEncoding (encoding);
if (version != null)
fCurrentEntityDecl.setXmlVersion (version);
}
}
else {
if (fDeferredEntityDecl !=-1) {
fDeferredDocumentImpl.setEntityInfo (fDeferredEntityDecl, version, encoding);
}
}
}
@SuppressWarnings("fallthrough")     public void comment (XMLString text, Augmentations augs) throws XNIException {
if (fInDTD) {
if (fInternalSubset != null && !fInDTDExternalSubset) {
fInternalSubset.append ("<!--");
if (text.length > 0) {
fInternalSubset.append (text.ch, text.offset, text.length);
}
fInternalSubset.append ("-->");
}
return;
}
if (!fIncludeComments || fFilterReject) {
return;
}
if (!fDeferNodeExpansion) {
Comment comment = fDocument.createComment (text.toString ());
setCharacterData (false);
fCurrentNode.appendChild (comment);
if (fDOMFilter !=null && !fInEntityRef &&
(fDOMFilter.getWhatToShow () & NodeFilter.SHOW_COMMENT)!= 0) {
short code = fDOMFilter.acceptNode (comment);
switch (code) {
case LSParserFilter.FILTER_INTERRUPT:{
throw Abort.INSTANCE;
}
case LSParserFilter.FILTER_REJECT:{
}
case LSParserFilter.FILTER_SKIP: {
fCurrentNode.removeChild (comment);
fFirstChunk = true;
return;
}
default: {
}
}
}
}
else {
int comment =
fDeferredDocumentImpl.createDeferredComment (text.toString ());
fDeferredDocumentImpl.appendChild (fCurrentNodeIndex, comment);
}
}
@SuppressWarnings("fallthrough")     public void processingInstruction (String target, XMLString data, Augmentations augs)
throws XNIException {
if (fInDTD) {
if (fInternalSubset != null && !fInDTDExternalSubset) {
fInternalSubset.append ("<?");
fInternalSubset.append (target);
if (data.length > 0) {
fInternalSubset.append (' ').append (data.ch, data.offset, data.length);
}
fInternalSubset.append ("?>");
}
return;
}
if (DEBUG_EVENTS) {
System.out.println ("==>processingInstruction ("+target+")");
}
if (!fDeferNodeExpansion) {
if (fFilterReject) {
return;
}
ProcessingInstruction pi =
fDocument.createProcessingInstruction (target, data.toString ());
setCharacterData (false);
fCurrentNode.appendChild (pi);
if (fDOMFilter !=null && !fInEntityRef &&
(fDOMFilter.getWhatToShow () & NodeFilter.SHOW_PROCESSING_INSTRUCTION)!= 0) {
short code = fDOMFilter.acceptNode (pi);
switch (code) {
case LSParserFilter.FILTER_INTERRUPT:{
throw Abort.INSTANCE;
}
case LSParserFilter.FILTER_REJECT:{
}
case LSParserFilter.FILTER_SKIP: {
fCurrentNode.removeChild (pi);
fFirstChunk = true;
return;
}
default: {
}
}
}
}
else {
int pi = fDeferredDocumentImpl.
createDeferredProcessingInstruction (target, data.toString ());
fDeferredDocumentImpl.appendChild (fCurrentNodeIndex, pi);
}
}
public void startDocument (XMLLocator locator, String encoding,
NamespaceContext namespaceContext, Augmentations augs)
throws XNIException {
fLocator = locator;
if (!fDeferNodeExpansion) {
if (fDocumentClassName.equals (DEFAULT_DOCUMENT_CLASS_NAME)) {
fDocument = new DocumentImpl ();
fDocumentImpl = (CoreDocumentImpl)fDocument;
fDocumentImpl.setStrictErrorChecking (false);
fDocumentImpl.setInputEncoding (encoding);
fDocumentImpl.setDocumentURI (locator.getExpandedSystemId ());
}
else if (fDocumentClassName.equals (PSVI_DOCUMENT_CLASS_NAME)) {
fDocument = new PSVIDocumentImpl();
fDocumentImpl = (CoreDocumentImpl)fDocument;
fStorePSVI = true;
fDocumentImpl.setStrictErrorChecking (false);
fDocumentImpl.setInputEncoding (encoding);
fDocumentImpl.setDocumentURI (locator.getExpandedSystemId ());
}
else {
try {
Class<?> documentClass = ObjectFactory.findProviderClass (fDocumentClassName, true);
fDocument = (Document)documentClass.getConstructor().newInstance();
Class<?> defaultDocClass =
ObjectFactory.findProviderClass (CORE_DOCUMENT_CLASS_NAME, true);
if (defaultDocClass.isAssignableFrom (documentClass)) {
fDocumentImpl = (CoreDocumentImpl)fDocument;
Class<?> psviDocClass = ObjectFactory.findProviderClass (PSVI_DOCUMENT_CLASS_NAME, true);
if (psviDocClass.isAssignableFrom (documentClass)) {
fStorePSVI = true;
}
fDocumentImpl.setStrictErrorChecking (false);
fDocumentImpl.setInputEncoding (encoding);
if (locator != null) {
fDocumentImpl.setDocumentURI (locator.getExpandedSystemId ());
}
}
}
catch (ClassNotFoundException e) {
}
catch (Exception e) {
throw new RuntimeException (
DOMMessageFormatter.formatMessage(
DOMMessageFormatter.DOM_DOMAIN,
"CannotCreateDocumentClass",
new Object [] {fDocumentClassName}));
}
}
fCurrentNode = fDocument;
}
else {
fDeferredDocumentImpl = new DeferredDocumentImpl (fNamespaceAware);
fDocument = fDeferredDocumentImpl;
fDocumentIndex = fDeferredDocumentImpl.createDeferredDocument ();
fDeferredDocumentImpl.setInputEncoding (encoding);
fDeferredDocumentImpl.setDocumentURI (locator.getExpandedSystemId ());
fCurrentNodeIndex = fDocumentIndex;
}
}
public void xmlDecl (String version, String encoding, String standalone,
Augmentations augs)
throws XNIException {
if (!fDeferNodeExpansion) {
if (fDocumentImpl != null) {
if (version != null)
fDocumentImpl.setXmlVersion (version);
fDocumentImpl.setXmlEncoding (encoding);
fDocumentImpl.setXmlStandalone ("yes".equals (standalone));
}
}
else {
if (version != null)
fDeferredDocumentImpl.setXmlVersion (version);
fDeferredDocumentImpl.setXmlEncoding (encoding);
fDeferredDocumentImpl.setXmlStandalone ("yes".equals (standalone));
}
}
public void doctypeDecl (String rootElement,
String publicId, String systemId, Augmentations augs)
throws XNIException {
if (!fDeferNodeExpansion) {
if (fDocumentImpl != null) {
fDocumentType = fDocumentImpl.createDocumentType (
rootElement, publicId, systemId);
fCurrentNode.appendChild (fDocumentType);
}
}
else {
fDocumentTypeIndex = fDeferredDocumentImpl.
createDeferredDocumentType (rootElement, publicId, systemId);
fDeferredDocumentImpl.appendChild (fCurrentNodeIndex, fDocumentTypeIndex);
}
}
public void startElement (QName element, XMLAttributes attributes, Augmentations augs)
throws XNIException {
if (DEBUG_EVENTS) {
System.out.println ("==>startElement ("+element.rawname+")");
}
if (!fDeferNodeExpansion) {
if (fFilterReject) {
++fRejectedElementDepth;
return;
}
Element el = createElementNode (element);
int attrCount = attributes.getLength ();
boolean seenSchemaDefault = false;
for (int i = 0; i < attrCount; i++) {
attributes.getName (i, fAttrQName);
Attr attr = createAttrNode (fAttrQName);
String attrValue = attributes.getValue (i);
AttributePSVI attrPSVI =(AttributePSVI) attributes.getAugmentations (i).getItem (Constants.ATTRIBUTE_PSVI);
if (fStorePSVI && attrPSVI != null){
((PSVIAttrNSImpl) attr).setPSVI (attrPSVI);
}
attr.setValue (attrValue);
boolean specified = attributes.isSpecified(i);
if (!specified && (seenSchemaDefault || (fAttrQName.uri != null &&
fAttrQName.uri != NamespaceContext.XMLNS_URI && fAttrQName.prefix == null))) {
el.setAttributeNodeNS(attr);
seenSchemaDefault = true;
}
else {
el.setAttributeNode(attr);
}
if (fDocumentImpl != null) {
AttrImpl attrImpl = (AttrImpl) attr;
Object type = null;
boolean id = false;
if (attrPSVI != null && fNamespaceAware) {
type = attrPSVI.getMemberTypeDefinition ();
if (type == null) {
type = attrPSVI.getTypeDefinition ();
if (type != null) {
id = ((XSSimpleType) type).isIDType ();
attrImpl.setType (type);
}
}
else {
id = ((XSSimpleType) type).isIDType ();
attrImpl.setType (type);
}
}
else {
boolean isDeclared = Boolean.TRUE.equals (attributes.getAugmentations (i).getItem (Constants.ATTRIBUTE_DECLARED));
if (isDeclared) {
type = attributes.getType (i);
id = "ID".equals (type);
}
attrImpl.setType (type);
}
if (id) {
((ElementImpl) el).setIdAttributeNode (attr, true);
}
attrImpl.setSpecified (specified);
}
}
setCharacterData (false);
if (augs != null) {
ElementPSVI elementPSVI = (ElementPSVI)augs.getItem (Constants.ELEMENT_PSVI);
if (elementPSVI != null && fNamespaceAware) {
XSTypeDefinition type = elementPSVI.getMemberTypeDefinition ();
if (type == null) {
type = elementPSVI.getTypeDefinition ();
}
((ElementNSImpl)el).setType (type);
}
}
if (fDOMFilter != null && !fInEntityRef) {
if (fRoot == null) {
fRoot = el;
} else {
short code = fDOMFilter.startElement(el);
switch (code) {
case LSParserFilter.FILTER_INTERRUPT :
{
throw Abort.INSTANCE;
}
case LSParserFilter.FILTER_REJECT :
{
fFilterReject = true;
fRejectedElementDepth = 0;
return;
}
case LSParserFilter.FILTER_SKIP :
{
fFirstChunk = true;
fSkippedElemStack.push(Boolean.TRUE);
return;
}
default :
{
if (!fSkippedElemStack.isEmpty()) {
fSkippedElemStack.push(Boolean.FALSE);
}
}
}
}
}
fCurrentNode.appendChild (el);
fCurrentNode = el;
}
else {
int el = fDeferredDocumentImpl.createDeferredElement (fNamespaceAware ?
element.uri : null, element.rawname);
Object type = null;
int attrCount = attributes.getLength ();
for (int i = attrCount - 1; i >= 0; --i) {
AttributePSVI attrPSVI = (AttributePSVI)attributes.getAugmentations (i).getItem (Constants.ATTRIBUTE_PSVI);
boolean id = false;
if (attrPSVI != null && fNamespaceAware) {
type = attrPSVI.getMemberTypeDefinition ();
if (type == null) {
type = attrPSVI.getTypeDefinition ();
if (type != null){
id = ((XSSimpleType) type).isIDType ();
}
}
else {
id = ((XSSimpleType) type).isIDType ();
}
}
else {
boolean isDeclared = Boolean.TRUE.equals (attributes.getAugmentations (i).getItem (Constants.ATTRIBUTE_DECLARED));
if (isDeclared) {
type = attributes.getType (i);
id = "ID".equals (type);
}
}
fDeferredDocumentImpl.setDeferredAttribute (
el,
attributes.getQName (i),
attributes.getURI (i),
attributes.getValue (i),
attributes.isSpecified (i),
id,
type);
}
fDeferredDocumentImpl.appendChild (fCurrentNodeIndex, el);
fCurrentNodeIndex = el;
}
}
public void emptyElement (QName element, XMLAttributes attributes, Augmentations augs)
throws XNIException {
startElement (element, attributes, augs);
endElement (element, augs);
}
public void characters (XMLString text, Augmentations augs) throws XNIException {
if (DEBUG_EVENTS) {
System.out.println ("==>characters(): "+text.toString ());
}
if (!fDeferNodeExpansion) {
if (fFilterReject) {
return;
}
if (fInCDATASection && fCreateCDATANodes) {
if (fCurrentCDATASection == null) {
fCurrentCDATASection =
fDocument.createCDATASection (text.toString ());
fCurrentNode.appendChild (fCurrentCDATASection);
fCurrentNode = fCurrentCDATASection;
}
else {
fCurrentCDATASection.appendData (text.toString ());
}
}
else if (!fInDTD) {
if (text.length == 0) {
return;
}
Node child = fCurrentNode.getLastChild ();
if (child != null && child.getNodeType () == Node.TEXT_NODE) {
if (fFirstChunk) {
if (fDocumentImpl != null) {
fStringBuilder.append (((TextImpl)child).removeData ());
} else {
fStringBuilder.append (((Text)child).getData ());
((Text)child).setNodeValue (null);
}
fFirstChunk = false;
}
if (text.length > 0) {
fStringBuilder.append (text.ch, text.offset, text.length);
}
}
else {
fFirstChunk = true;
Text textNode = fDocument.createTextNode (text.toString());
fCurrentNode.appendChild (textNode);
}
}
}
else {
if (fInCDATASection && fCreateCDATANodes) {
if (fCurrentCDATASectionIndex == -1) {
int cs = fDeferredDocumentImpl.
createDeferredCDATASection (text.toString ());
fDeferredDocumentImpl.appendChild (fCurrentNodeIndex, cs);
fCurrentCDATASectionIndex = cs;
fCurrentNodeIndex = cs;
}
else {
int txt = fDeferredDocumentImpl.
createDeferredTextNode (text.toString (), false);
fDeferredDocumentImpl.appendChild (fCurrentNodeIndex, txt);
}
} else if (!fInDTD) {
if (text.length == 0) {
return;
}
String value = text.toString ();
int txt = fDeferredDocumentImpl.
createDeferredTextNode (value, false);
fDeferredDocumentImpl.appendChild (fCurrentNodeIndex, txt);
}
}
}
public void ignorableWhitespace (XMLString text, Augmentations augs) throws XNIException {
if (!fIncludeIgnorableWhitespace || fFilterReject) {
return;
}
if (!fDeferNodeExpansion) {
Node child = fCurrentNode.getLastChild ();
if (child != null && child.getNodeType () == Node.TEXT_NODE) {
Text textNode = (Text)child;
textNode.appendData (text.toString ());
}
else {
Text textNode = fDocument.createTextNode (text.toString ());
if (fDocumentImpl != null) {
TextImpl textNodeImpl = (TextImpl)textNode;
textNodeImpl.setIgnorableWhitespace (true);
}
fCurrentNode.appendChild (textNode);
}
}
else {
int txt = fDeferredDocumentImpl.
createDeferredTextNode (text.toString (), true);
fDeferredDocumentImpl.appendChild (fCurrentNodeIndex, txt);
}
}
public void endElement (QName element, Augmentations augs) throws XNIException {
if (DEBUG_EVENTS) {
System.out.println ("==>endElement ("+element.rawname+")");
}
if (!fDeferNodeExpansion) {
if (augs != null && fDocumentImpl != null && (fNamespaceAware || fStorePSVI)) {
ElementPSVI elementPSVI = (ElementPSVI) augs.getItem(Constants.ELEMENT_PSVI);
if (elementPSVI != null) {
if (fNamespaceAware) {
XSTypeDefinition type = elementPSVI.getMemberTypeDefinition();
if (type == null) {
type = elementPSVI.getTypeDefinition();
}
((ElementNSImpl)fCurrentNode).setType(type);
}
if (fStorePSVI) {
((PSVIElementNSImpl)fCurrentNode).setPSVI (elementPSVI);
}
}
}
if (fDOMFilter != null) {
if (fFilterReject) {
if (fRejectedElementDepth-- == 0) {
fFilterReject = false;
}
return;
}
if (!fSkippedElemStack.isEmpty()) {
if (fSkippedElemStack.pop() == Boolean.TRUE) {
return;
}
}
setCharacterData (false);
if ((fCurrentNode != fRoot) && !fInEntityRef && (fDOMFilter.getWhatToShow () & NodeFilter.SHOW_ELEMENT)!=0) {
short code = fDOMFilter.acceptNode (fCurrentNode);
switch (code) {
case LSParserFilter.FILTER_INTERRUPT:{
throw Abort.INSTANCE;
}
case LSParserFilter.FILTER_REJECT:{
Node parent = fCurrentNode.getParentNode ();
parent.removeChild (fCurrentNode);
fCurrentNode = parent;
return;
}
case LSParserFilter.FILTER_SKIP: {
fFirstChunk = true;
Node parent = fCurrentNode.getParentNode ();
NodeList ls = fCurrentNode.getChildNodes ();
int length = ls.getLength ();
for (int i=0;i<length;i++) {
parent.appendChild (ls.item (0));
}
parent.removeChild (fCurrentNode);
fCurrentNode = parent;
return;
}
default: { }
}
}
fCurrentNode = fCurrentNode.getParentNode ();
}             else {
setCharacterData (false);
fCurrentNode = fCurrentNode.getParentNode ();
}
}
else {
if (augs != null) {
ElementPSVI elementPSVI = (ElementPSVI) augs.getItem(Constants.ELEMENT_PSVI);
if (elementPSVI != null) {
XSTypeDefinition type = elementPSVI.getMemberTypeDefinition();
if (type == null) {
type = elementPSVI.getTypeDefinition();
}
fDeferredDocumentImpl.setTypeInfo(fCurrentNodeIndex, type);
}
}
fCurrentNodeIndex =
fDeferredDocumentImpl.getParentNode (fCurrentNodeIndex, false);
}
}
public void startCDATA (Augmentations augs) throws XNIException {
fInCDATASection = true;
if (!fDeferNodeExpansion) {
if (fFilterReject) {
return;
}
if (fCreateCDATANodes) {
setCharacterData (false);
}
}
}
@SuppressWarnings("fallthrough")     public void endCDATA (Augmentations augs) throws XNIException {
fInCDATASection = false;
if (!fDeferNodeExpansion) {
if (fFilterReject) {
return;
}
if (fCurrentCDATASection !=null) {
if (fDOMFilter !=null && !fInEntityRef &&
(fDOMFilter.getWhatToShow () & NodeFilter.SHOW_CDATA_SECTION)!= 0) {
short code = fDOMFilter.acceptNode (fCurrentCDATASection);
switch (code) {
case LSParserFilter.FILTER_INTERRUPT:{
throw Abort.INSTANCE;
}
case LSParserFilter.FILTER_REJECT:{
}
case LSParserFilter.FILTER_SKIP: {
Node parent = fCurrentNode.getParentNode ();
parent.removeChild (fCurrentCDATASection);
fCurrentNode = parent;
return;
}
default: {
}
}
}
fCurrentNode = fCurrentNode.getParentNode ();
fCurrentCDATASection = null;
}
}
else {
if (fCurrentCDATASectionIndex !=-1) {
fCurrentNodeIndex =
fDeferredDocumentImpl.getParentNode (fCurrentNodeIndex, false);
fCurrentCDATASectionIndex = -1;
}
}
}
public void endDocument (Augmentations augs) throws XNIException {
if (!fDeferNodeExpansion) {
if (fDocumentImpl != null) {
if (fLocator != null) {
if (fLocator.getEncoding() != null)
fDocumentImpl.setInputEncoding (fLocator.getEncoding());
}
fDocumentImpl.setStrictErrorChecking (true);
}
fCurrentNode = null;
}
else {
if (fLocator != null) {
if (fLocator.getEncoding() != null)
fDeferredDocumentImpl.setInputEncoding (fLocator.getEncoding());
}
fCurrentNodeIndex = -1;
}
}
public void endGeneralEntity (String name, Augmentations augs) throws XNIException {
if (DEBUG_EVENTS) {
System.out.println ("==>endGeneralEntity: ("+name+")");
}
if (!fDeferNodeExpansion) {
if (fFilterReject) {
return;
}
setCharacterData (true);
if (fDocumentType != null) {
NamedNodeMap entities = fDocumentType.getEntities ();
fCurrentEntityDecl = (EntityImpl) entities.getNamedItem (name);
if (fCurrentEntityDecl != null) {
if (fCurrentEntityDecl != null && fCurrentEntityDecl.getFirstChild () == null) {
fCurrentEntityDecl.setReadOnly (false, true);
Node child = fCurrentNode.getFirstChild ();
while (child != null) {
Node copy = child.cloneNode (true);
fCurrentEntityDecl.appendChild (copy);
child = child.getNextSibling ();
}
fCurrentEntityDecl.setReadOnly (true, true);
}
fCurrentEntityDecl = null;
}
}
fInEntityRef = false;
boolean removeEntityRef = false;
if (fCreateEntityRefNodes) {
if (fDocumentImpl != null) {
((NodeImpl)fCurrentNode).setReadOnly (true, true);
}
if (fDOMFilter !=null &&
(fDOMFilter.getWhatToShow () & NodeFilter.SHOW_ENTITY_REFERENCE)!= 0) {
short code = fDOMFilter.acceptNode (fCurrentNode);
switch (code) {
case LSParserFilter.FILTER_INTERRUPT:{
throw Abort.INSTANCE;
}
case LSParserFilter.FILTER_REJECT:{
Node parent = fCurrentNode.getParentNode ();
parent.removeChild (fCurrentNode);
fCurrentNode = parent;
return;
}
case LSParserFilter.FILTER_SKIP: {
fFirstChunk = true;
removeEntityRef = true;
break;
}
default: {
fCurrentNode = fCurrentNode.getParentNode ();
}
}
} else {
fCurrentNode = fCurrentNode.getParentNode ();
}
}
if (!fCreateEntityRefNodes || removeEntityRef) {
NodeList children = fCurrentNode.getChildNodes ();
Node parent = fCurrentNode.getParentNode ();
int length = children.getLength ();
if (length > 0) {
Node node = fCurrentNode.getPreviousSibling ();
Node child = children.item (0);
if (node != null && node.getNodeType () == Node.TEXT_NODE &&
child.getNodeType () == Node.TEXT_NODE) {
((Text)node).appendData (child.getNodeValue ());
fCurrentNode.removeChild (child);
} else {
node = parent.insertBefore (child, fCurrentNode);
handleBaseURI (node);
}
for (int i=1;i <length;i++) {
node = parent.insertBefore (children.item (0), fCurrentNode);
handleBaseURI (node);
}
}                 parent.removeChild (fCurrentNode);
fCurrentNode = parent;
}
}
else {
if (fDocumentTypeIndex != -1) {
int node = fDeferredDocumentImpl.getLastChild (fDocumentTypeIndex, false);
while (node != -1) {
short nodeType = fDeferredDocumentImpl.getNodeType (node, false);
if (nodeType == Node.ENTITY_NODE) {
String nodeName =
fDeferredDocumentImpl.getNodeName (node, false);
if (nodeName.equals (name)) {
fDeferredEntityDecl = node;
break;
}
}
node = fDeferredDocumentImpl.getRealPrevSibling (node, false);
}
}
if (fDeferredEntityDecl != -1 &&
fDeferredDocumentImpl.getLastChild (fDeferredEntityDecl, false) == -1) {
int prevIndex = -1;
int childIndex = fDeferredDocumentImpl.getLastChild (fCurrentNodeIndex, false);
while (childIndex != -1) {
int cloneIndex = fDeferredDocumentImpl.cloneNode (childIndex, true);
fDeferredDocumentImpl.insertBefore (fDeferredEntityDecl, cloneIndex, prevIndex);
prevIndex = cloneIndex;
childIndex = fDeferredDocumentImpl.getRealPrevSibling (childIndex, false);
}
}
if (fCreateEntityRefNodes) {
fCurrentNodeIndex =
fDeferredDocumentImpl.getParentNode (fCurrentNodeIndex,
false);
} else {
int childIndex = fDeferredDocumentImpl.getLastChild (fCurrentNodeIndex, false);
int parentIndex =
fDeferredDocumentImpl.getParentNode (fCurrentNodeIndex,
false);
int prevIndex = fCurrentNodeIndex;
int lastChild = childIndex;
int sibling = -1;
while (childIndex != -1) {
handleBaseURI (childIndex);
sibling = fDeferredDocumentImpl.getRealPrevSibling (childIndex, false);
fDeferredDocumentImpl.insertBefore (parentIndex, childIndex, prevIndex);
prevIndex = childIndex;
childIndex = sibling;
}
if(lastChild != -1)
fDeferredDocumentImpl.setAsLastChild (parentIndex, lastChild);
else{
sibling = fDeferredDocumentImpl.getRealPrevSibling (prevIndex, false);
fDeferredDocumentImpl.setAsLastChild (parentIndex, sibling);
}
fCurrentNodeIndex = parentIndex;
}
fDeferredEntityDecl = -1;
}
}
protected final void handleBaseURI (Node node){
if (fDocumentImpl != null) {
String baseURI = null;
short nodeType = node.getNodeType ();
if (nodeType == Node.ELEMENT_NODE) {
if (fNamespaceAware) {
if (((Element)node).getAttributeNodeNS ("http:                        return;
}
} else if (((Element)node).getAttributeNode ("xml:base") != null) {
return;
}
baseURI = ((EntityReferenceImpl)fCurrentNode).getBaseURI ();
if (baseURI !=null && !baseURI.equals (fDocumentImpl.getDocumentURI ())) {
if (fNamespaceAware) {
((Element)node).setAttributeNS ("http:                    } else {
((Element)node).setAttribute ("xml:base", baseURI);
}
}
}
else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {
baseURI = ((EntityReferenceImpl)fCurrentNode).getBaseURI ();
if (baseURI !=null && fErrorHandler != null) {
DOMErrorImpl error = new DOMErrorImpl ();
error.fType = "pi-base-uri-not-preserved";
error.fRelatedData = baseURI;
error.fSeverity = DOMError.SEVERITY_WARNING;
fErrorHandler.getErrorHandler ().handleError (error);
}
}
}
}
protected final void handleBaseURI (int node){
short nodeType = fDeferredDocumentImpl.getNodeType (node, false);
if (nodeType == Node.ELEMENT_NODE) {
String baseURI = fDeferredDocumentImpl.getNodeValueString (fCurrentNodeIndex, false);
if (baseURI == null) {
baseURI = fDeferredDocumentImpl.getDeferredEntityBaseURI (fDeferredEntityDecl);
}
if (baseURI !=null && !baseURI.equals (fDeferredDocumentImpl.getDocumentURI ())) {
fDeferredDocumentImpl.setDeferredAttribute (node,
"xml:base",
"http:                baseURI,
true,
false,
null);
}
}
else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {
String baseURI = fDeferredDocumentImpl.getNodeValueString (fCurrentNodeIndex, false);
if (baseURI == null) {
baseURI = fDeferredDocumentImpl.getDeferredEntityBaseURI (fDeferredEntityDecl);
}
if (baseURI != null && fErrorHandler != null) {
DOMErrorImpl error = new DOMErrorImpl ();
error.fType = "pi-base-uri-not-preserved";
error.fRelatedData = baseURI;
error.fSeverity = DOMError.SEVERITY_WARNING;
fErrorHandler.getErrorHandler ().handleError (error);
}
}
}
public void startDTD (XMLLocator locator, Augmentations augs) throws XNIException {
if (DEBUG_EVENTS) {
System.out.println ("==>startDTD");
if (DEBUG_BASEURI) {
System.out.println ("   expandedSystemId: "+locator.getExpandedSystemId ());
System.out.println ("   baseURI:"+ locator.getBaseSystemId ());
}
}
fInDTD = true;
if (locator != null) {
fBaseURIStack.push (locator.getBaseSystemId ());
}
if (fDeferNodeExpansion || fDocumentImpl != null) {
fInternalSubset = new StringBuilder (1024);
}
}
public void endDTD (Augmentations augs) throws XNIException {
if (DEBUG_EVENTS) {
System.out.println ("==>endDTD()");
}
fInDTD = false;
if (!fBaseURIStack.isEmpty ()) {
fBaseURIStack.pop ();
}
String internalSubset = fInternalSubset != null && fInternalSubset.length () > 0
? fInternalSubset.toString () : null;
if (fDeferNodeExpansion) {
if (internalSubset != null) {
fDeferredDocumentImpl.setInternalSubset (fDocumentTypeIndex, internalSubset);
}
}
else if (fDocumentImpl != null) {
if (internalSubset != null) {
((DocumentTypeImpl)fDocumentType).setInternalSubset (internalSubset);
}
}
}
public void startConditional (short type, Augmentations augs) throws XNIException  {
}
public void endConditional (Augmentations augs) throws XNIException {
}
public void startExternalSubset (XMLResourceIdentifier identifier,
Augmentations augs) throws XNIException {
if (DEBUG_EVENTS) {
System.out.println ("==>startExternalSubset");
if (DEBUG_BASEURI) {
System.out.println ("   expandedSystemId: "+identifier.getExpandedSystemId ());
System.out.println ("   baseURI:"+ identifier.getBaseSystemId ());
}
}
fBaseURIStack.push (identifier.getBaseSystemId ());
fInDTDExternalSubset = true;
}
public void endExternalSubset (Augmentations augs) throws XNIException {
fInDTDExternalSubset = false;
fBaseURIStack.pop ();
}
public void internalEntityDecl (String name, XMLString text,
XMLString nonNormalizedText,
Augmentations augs) throws XNIException {
if (DEBUG_EVENTS) {
System.out.println ("==>internalEntityDecl: "+name);
if (DEBUG_BASEURI) {
System.out.println ("   baseURI:"+ fBaseURIStack.peek ());
}
}
if (fInternalSubset != null && !fInDTDExternalSubset) {
fInternalSubset.append ("<!ENTITY ");
if (name.startsWith ("%")) {
fInternalSubset.append ("% ");
fInternalSubset.append (name.substring (1));
}
else {
fInternalSubset.append (name);
}
fInternalSubset.append (' ');
String value = nonNormalizedText.toString ();
boolean singleQuote = value.indexOf ('\'') == -1;
fInternalSubset.append (singleQuote ? '\'' : '"');
fInternalSubset.append (value);
fInternalSubset.append (singleQuote ? '\'' : '"');
fInternalSubset.append (">\n");
}
if(name.startsWith ("%"))
return;
if (fDocumentType != null) {
NamedNodeMap entities = fDocumentType.getEntities ();
EntityImpl entity = (EntityImpl)entities.getNamedItem (name);
if (entity == null) {
entity = (EntityImpl)fDocumentImpl.createEntity (name);
entity.setBaseURI (fBaseURIStack.peek ());
entities.setNamedItem (entity);
}
}
if (fDocumentTypeIndex != -1) {
boolean found = false;
int node = fDeferredDocumentImpl.getLastChild (fDocumentTypeIndex, false);
while (node != -1) {
short nodeType = fDeferredDocumentImpl.getNodeType (node, false);
if (nodeType == Node.ENTITY_NODE) {
String nodeName = fDeferredDocumentImpl.getNodeName (node, false);
if (nodeName.equals (name)) {
found = true;
break;
}
}
node = fDeferredDocumentImpl.getRealPrevSibling (node, false);
}
if (!found) {
int entityIndex =
fDeferredDocumentImpl.createDeferredEntity (name, null, null, null, fBaseURIStack.peek ());
fDeferredDocumentImpl.appendChild (fDocumentTypeIndex, entityIndex);
}
}
}
public void externalEntityDecl (String name, XMLResourceIdentifier identifier,
Augmentations augs) throws XNIException {
if (DEBUG_EVENTS) {
System.out.println ("==>externalEntityDecl: "+name);
if (DEBUG_BASEURI) {
System.out.println ("   expandedSystemId:"+ identifier.getExpandedSystemId ());
System.out.println ("   baseURI:"+ identifier.getBaseSystemId ());
}
}
String publicId = identifier.getPublicId ();
String literalSystemId = identifier.getLiteralSystemId ();
if (fInternalSubset != null && !fInDTDExternalSubset) {
fInternalSubset.append ("<!ENTITY ");
if (name.startsWith ("%")) {
fInternalSubset.append ("% ");
fInternalSubset.append (name.substring (1));
}
else {
fInternalSubset.append (name);
}
fInternalSubset.append (JdkXmlUtils.getDTDExternalDecl(publicId, literalSystemId));
fInternalSubset.append (">\n");
}
if(name.startsWith ("%"))
return;
if (fDocumentType != null) {
NamedNodeMap entities = fDocumentType.getEntities ();
EntityImpl entity = (EntityImpl)entities.getNamedItem (name);
if (entity == null) {
entity = (EntityImpl)fDocumentImpl.createEntity (name);
entity.setPublicId (publicId);
entity.setSystemId (literalSystemId);
entity.setBaseURI (identifier.getBaseSystemId ());
entities.setNamedItem (entity);
}
}
if (fDocumentTypeIndex != -1) {
boolean found = false;
int nodeIndex = fDeferredDocumentImpl.getLastChild (fDocumentTypeIndex, false);
while (nodeIndex != -1) {
short nodeType = fDeferredDocumentImpl.getNodeType (nodeIndex, false);
if (nodeType == Node.ENTITY_NODE) {
String nodeName = fDeferredDocumentImpl.getNodeName (nodeIndex, false);
if (nodeName.equals (name)) {
found = true;
break;
}
}
nodeIndex = fDeferredDocumentImpl.getRealPrevSibling (nodeIndex, false);
}
if (!found) {
int entityIndex = fDeferredDocumentImpl.createDeferredEntity (
name, publicId, literalSystemId, null, identifier.getBaseSystemId ());
fDeferredDocumentImpl.appendChild (fDocumentTypeIndex, entityIndex);
}
}
}
public void startParameterEntity (String name,
XMLResourceIdentifier identifier,
String encoding,
Augmentations augs) throws XNIException {
if (DEBUG_EVENTS) {
System.out.println ("==>startParameterEntity: "+name);
if (DEBUG_BASEURI) {
System.out.println ("   expandedSystemId: "+identifier.getExpandedSystemId ());
System.out.println ("   baseURI:"+ identifier.getBaseSystemId ());
}
}
if (augs != null && fInternalSubset != null &&
!fInDTDExternalSubset &&
Boolean.TRUE.equals(augs.getItem(Constants.ENTITY_SKIPPED))) {
fInternalSubset.append(name).append(";\n");
}
fBaseURIStack.push (identifier.getExpandedSystemId ());
}
public void endParameterEntity (String name, Augmentations augs) throws XNIException {
if (DEBUG_EVENTS) {
System.out.println ("==>endParameterEntity: "+name);
}
fBaseURIStack.pop ();
}
public void unparsedEntityDecl (String name, XMLResourceIdentifier identifier,
String notation, Augmentations augs)
throws XNIException {
if (DEBUG_EVENTS) {
System.out.println ("==>unparsedEntityDecl: "+name);
if (DEBUG_BASEURI) {
System.out.println ("   expandedSystemId:"+ identifier.getExpandedSystemId ());
System.out.println ("   baseURI:"+ identifier.getBaseSystemId ());
}
}
String publicId = identifier.getPublicId ();
String literalSystemId = identifier.getLiteralSystemId ();
if (fInternalSubset != null && !fInDTDExternalSubset) {
fInternalSubset.append ("<!ENTITY ");
fInternalSubset.append (name);
fInternalSubset.append (JdkXmlUtils.getDTDExternalDecl(publicId, literalSystemId));
fInternalSubset.append (" NDATA ");
fInternalSubset.append (notation);
fInternalSubset.append (">\n");
}
if (fDocumentType != null) {
NamedNodeMap entities = fDocumentType.getEntities ();
EntityImpl entity = (EntityImpl)entities.getNamedItem (name);
if (entity == null) {
entity = (EntityImpl)fDocumentImpl.createEntity (name);
entity.setPublicId (publicId);
entity.setSystemId (literalSystemId);
entity.setNotationName (notation);
entity.setBaseURI (identifier.getBaseSystemId ());
entities.setNamedItem (entity);
}
}
if (fDocumentTypeIndex != -1) {
boolean found = false;
int nodeIndex = fDeferredDocumentImpl.getLastChild (fDocumentTypeIndex, false);
while (nodeIndex != -1) {
short nodeType = fDeferredDocumentImpl.getNodeType (nodeIndex, false);
if (nodeType == Node.ENTITY_NODE) {
String nodeName = fDeferredDocumentImpl.getNodeName (nodeIndex, false);
if (nodeName.equals (name)) {
found = true;
break;
}
}
nodeIndex = fDeferredDocumentImpl.getRealPrevSibling (nodeIndex, false);
}
if (!found) {
int entityIndex = fDeferredDocumentImpl.createDeferredEntity (
name, publicId, literalSystemId, notation, identifier.getBaseSystemId ());
fDeferredDocumentImpl.appendChild (fDocumentTypeIndex, entityIndex);
}
}
}
public void notationDecl (String name, XMLResourceIdentifier identifier,
Augmentations augs) throws XNIException {
String publicId = identifier.getPublicId ();
String literalSystemId = identifier.getLiteralSystemId ();
if (fInternalSubset != null && !fInDTDExternalSubset) {
fInternalSubset.append ("<!NOTATION ");
fInternalSubset.append (name);
fInternalSubset.append (JdkXmlUtils.getDTDExternalDecl(publicId, literalSystemId));
fInternalSubset.append (">\n");
}
if (fDocumentImpl !=null && fDocumentType != null) {
NamedNodeMap notations = fDocumentType.getNotations ();
if (notations.getNamedItem (name) == null) {
NotationImpl notation = (NotationImpl)fDocumentImpl.createNotation (name);
notation.setPublicId (publicId);
notation.setSystemId (literalSystemId);
notation.setBaseURI (identifier.getBaseSystemId ());
notations.setNamedItem (notation);
}
}
if (fDocumentTypeIndex != -1) {
boolean found = false;
int nodeIndex = fDeferredDocumentImpl.getLastChild (fDocumentTypeIndex, false);
while (nodeIndex != -1) {
short nodeType = fDeferredDocumentImpl.getNodeType (nodeIndex, false);
if (nodeType == Node.NOTATION_NODE) {
String nodeName = fDeferredDocumentImpl.getNodeName (nodeIndex, false);
if (nodeName.equals (name)) {
found = true;
break;
}
}
nodeIndex = fDeferredDocumentImpl.getPrevSibling (nodeIndex, false);
}
if (!found) {
int notationIndex = fDeferredDocumentImpl.createDeferredNotation (
name, publicId, literalSystemId, identifier.getBaseSystemId ());
fDeferredDocumentImpl.appendChild (fDocumentTypeIndex, notationIndex);
}
}
}
public void ignoredCharacters (XMLString text, Augmentations augs) throws XNIException {
}
public void elementDecl (String name, String contentModel, Augmentations augs)
throws XNIException {
if (fInternalSubset != null && !fInDTDExternalSubset) {
fInternalSubset.append ("<!ELEMENT ");
fInternalSubset.append (name);
fInternalSubset.append (' ');
fInternalSubset.append (contentModel);
fInternalSubset.append (">\n");
}
}
public void attributeDecl (String elementName, String attributeName,
String type, String[] enumeration,
String defaultType, XMLString defaultValue,
XMLString nonNormalizedDefaultValue, Augmentations augs) throws XNIException {
if (fInternalSubset != null && !fInDTDExternalSubset) {
fInternalSubset.append ("<!ATTLIST ");
fInternalSubset.append (elementName);
fInternalSubset.append (' ');
fInternalSubset.append (attributeName);
fInternalSubset.append (' ');
if (type.equals ("ENUMERATION")) {
fInternalSubset.append ('(');
for (int i = 0; i < enumeration.length; i++) {
if (i > 0) {
fInternalSubset.append ('|');
}
fInternalSubset.append (enumeration[i]);
}
fInternalSubset.append (')');
}
else {
fInternalSubset.append (type);
}
if (defaultType != null) {
fInternalSubset.append (' ');
fInternalSubset.append (defaultType);
}
if (defaultValue != null) {
fInternalSubset.append (" '");
for (int i = 0; i < defaultValue.length; i++) {
char c = defaultValue.ch[defaultValue.offset + i];
if (c == '\'') {
fInternalSubset.append ("&apos;");
}
else {
fInternalSubset.append (c);
}
}
fInternalSubset.append ('\'');
}
fInternalSubset.append (">\n");
}
if (fDeferredDocumentImpl != null) {
if (defaultValue != null) {
int elementDefIndex  = fDeferredDocumentImpl.lookupElementDefinition (elementName);
if (elementDefIndex == -1) {
elementDefIndex = fDeferredDocumentImpl.createDeferredElementDefinition (elementName);
fDeferredDocumentImpl.appendChild (fDocumentTypeIndex, elementDefIndex);
}
boolean nsEnabled = fNamespaceAware;
String namespaceURI = null;
if (nsEnabled) {
if (attributeName.startsWith("xmlns:") ||
attributeName.equals("xmlns")) {
namespaceURI = NamespaceContext.XMLNS_URI;
}
else if (attributeName.startsWith("xml:")) {
namespaceURI = NamespaceContext.XML_URI;
}
}
int attrIndex = fDeferredDocumentImpl.createDeferredAttribute (
attributeName, namespaceURI, defaultValue.toString(), false);
if ("ID".equals (type)) {
fDeferredDocumentImpl.setIdAttribute (attrIndex);
}
fDeferredDocumentImpl.appendChild (elementDefIndex, attrIndex);
}
}
else if (fDocumentImpl != null) {
if (defaultValue != null) {
NamedNodeMap elements = ((DocumentTypeImpl)fDocumentType).getElements ();
ElementDefinitionImpl elementDef = (ElementDefinitionImpl)elements.getNamedItem (elementName);
if (elementDef == null) {
elementDef = fDocumentImpl.createElementDefinition (elementName);
((DocumentTypeImpl)fDocumentType).getElements ().setNamedItem (elementDef);
}
boolean nsEnabled = fNamespaceAware;
AttrImpl attr;
if (nsEnabled) {
String namespaceURI = null;
if (attributeName.startsWith("xmlns:") ||
attributeName.equals("xmlns")) {
namespaceURI = NamespaceContext.XMLNS_URI;
}
else if (attributeName.startsWith("xml:")) {
namespaceURI = NamespaceContext.XML_URI;
}
attr = (AttrImpl)fDocumentImpl.createAttributeNS (namespaceURI,
attributeName);
}
else {
attr = (AttrImpl)fDocumentImpl.createAttribute (attributeName);
}
attr.setValue (defaultValue.toString ());
attr.setSpecified (false);
attr.setIdAttribute ("ID".equals (type));
if (nsEnabled){
elementDef.getAttributes ().setNamedItemNS (attr);
}
else {
elementDef.getAttributes ().setNamedItem (attr);
}
}
}
}
public void startAttlist (String elementName, Augmentations augs) throws XNIException {
}
public void endAttlist (Augmentations augs) throws XNIException {
}
protected Element createElementNode (QName element) {
Element el = null;
if (fNamespaceAware) {
if (fDocumentImpl != null) {
el = fDocumentImpl.createElementNS (element.uri, element.rawname,
element.localpart);
}
else {
el = fDocument.createElementNS (element.uri, element.rawname);
}
}
else {
el = fDocument.createElement (element.rawname);
}
return el;
}
protected Attr createAttrNode (QName attrQName) {
Attr attr = null;
if (fNamespaceAware) {
if (fDocumentImpl != null) {
attr = fDocumentImpl.createAttributeNS (attrQName.uri,
attrQName.rawname,
attrQName.localpart);
}
else {
attr = fDocument.createAttributeNS (attrQName.uri,
attrQName.rawname);
}
}
else {
attr = fDocument.createAttribute (attrQName.rawname);
}
return attr;
}
@SuppressWarnings("fallthrough")     protected void  setCharacterData (boolean sawChars){
fFirstChunk = sawChars;
Node child = fCurrentNode.getLastChild ();
if (child != null) {
if (fStringBuilder.length () > 0) {
if (child.getNodeType () == Node.TEXT_NODE) {
if (fDocumentImpl != null) {
((TextImpl)child).replaceData (fStringBuilder.toString ());
}
else {
((Text)child).setData (fStringBuilder.toString ());
}
}
fStringBuilder.setLength (0);
}
if (fDOMFilter !=null && !fInEntityRef) {
if ( (child.getNodeType () == Node.TEXT_NODE ) &&
((fDOMFilter.getWhatToShow () & NodeFilter.SHOW_TEXT)!= 0) ) {
short code = fDOMFilter.acceptNode (child);
switch (code) {
case LSParserFilter.FILTER_INTERRUPT:{
throw Abort.INSTANCE;
}
case LSParserFilter.FILTER_REJECT:{
}
case LSParserFilter.FILTER_SKIP: {
fCurrentNode.removeChild (child);
return;
}
default: {
}
}
}
}
}     }
public void abort () {
throw Abort.INSTANCE;
}
}
package org.jcp.xml.dsig.internal.dom;
import java.security.Key;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.SignatureException;
import java.security.spec.AlgorithmParameterSpec;
import javax.xml.crypto.MarshalException;
import javax.xml.crypto.dom.DOMCryptoContext;
import javax.xml.crypto.dsig.SignatureMethod;
import javax.xml.crypto.dsig.SignedInfo;
import javax.xml.crypto.dsig.XMLSignature;
import javax.xml.crypto.dsig.XMLSignatureException;
import javax.xml.crypto.dsig.XMLSignContext;
import javax.xml.crypto.dsig.XMLValidateContext;
import javax.xml.crypto.dsig.spec.SignatureMethodParameterSpec;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
abstract class AbstractDOMSignatureMethod extends DOMStructure
implements SignatureMethod {
enum Type { DSA, RSA, ECDSA, HMAC }
abstract boolean verify(Key key, SignedInfo si, byte[] sig,
XMLValidateContext context)
throws InvalidKeyException, SignatureException, XMLSignatureException;
abstract byte[] sign(Key key, SignedInfo si, XMLSignContext context)
throws InvalidKeyException, XMLSignatureException;
abstract String getJCAAlgorithm();
abstract Type getAlgorithmType();
@Override
public void marshal(Node parent, String dsPrefix, DOMCryptoContext context)
throws MarshalException
{
Document ownerDoc = DOMUtils.getOwnerDocument(parent);
Element smElem = DOMUtils.createElement(ownerDoc, "SignatureMethod",
XMLSignature.XMLNS, dsPrefix);
DOMUtils.setAttribute(smElem, "Algorithm", getAlgorithm());
if (getParameterSpec() != null) {
marshalParams(smElem, dsPrefix);
}
parent.appendChild(smElem);
}
void marshalParams(Element parent, String paramsPrefix)
throws MarshalException
{
throw new MarshalException("no parameters should " +
"be specified for the " + getAlgorithm() +
" SignatureMethod algorithm");
}
SignatureMethodParameterSpec unmarshalParams(Element paramsElem)
throws MarshalException
{
throw new MarshalException("no parameters should " +
"be specified for the " + getAlgorithm() +
" SignatureMethod algorithm");
}
void checkParams(SignatureMethodParameterSpec params)
throws InvalidAlgorithmParameterException
{
if (params != null) {
throw new InvalidAlgorithmParameterException("no parameters " +
"should be specified for the " + getAlgorithm() +
" SignatureMethod algorithm");
}
}
@Override
public boolean equals(Object o)
{
if (this == o) {
return true;
}
if (!(o instanceof SignatureMethod)) {
return false;
}
SignatureMethod osm = (SignatureMethod)o;
return getAlgorithm().equals(osm.getAlgorithm()) &&
paramsEqual(osm.getParameterSpec());
}
@Override
public int hashCode() {
int result = 17;
result = 31 * result + getAlgorithm().hashCode();
AlgorithmParameterSpec spec = getParameterSpec();
if (spec != null) {
result = 31 * result + spec.hashCode();
}
return result;
}
boolean paramsEqual(AlgorithmParameterSpec spec)
{
return getParameterSpec() == spec;
}
}
package sun.security.provider;
import sun.security.util.Debug;
import java.security.*;
import java.util.Arrays;
import java.util.Objects;
import static java.security.DrbgParameters.Capability.*;
public abstract class AbstractDrbg {
protected static final Debug debug = Debug.getInstance(
"securerandom", "drbg");
private boolean instantiated;
protected volatile int reseedCounter;
protected static final int DEFAULT_STRENGTH = 128;
protected String mechName = "DRBG";
protected int highestSupportedSecurityStrength = 256;
protected boolean supportPredictionResistance = true;
protected boolean supportReseeding = true;
protected int minLength;
protected int maxLength = Integer.MAX_VALUE;
protected int maxPersonalizationStringLength = Integer.MAX_VALUE;
protected int maxAdditionalInputLength = Integer.MAX_VALUE;
protected int maxNumberOfBytesPerRequest = Integer.MAX_VALUE;
protected int reseedInterval = Integer.MAX_VALUE;
protected String algorithm;
protected int securityStrength;
protected int requestedInstantiationSecurityStrength = -1;
protected byte[] personalizationString;
private boolean predictionResistanceFlag;
protected boolean usedf;
protected byte[] nonce;
private byte[] requestedNonce;
protected String requestedAlgorithm;
private EntropySource es;
protected abstract void chooseAlgorithmAndStrength();
protected abstract void initEngine();
protected abstract void instantiateAlgorithm(byte[] ei);
protected abstract void generateAlgorithm(
byte[] result, byte[] additionalInput);
protected void reseedAlgorithm(
byte[] ei, byte[] additionalInput) {
throw new UnsupportedOperationException("No reseed function");
}
protected final void engineNextBytes(byte[] result) {
engineNextBytes(result, DrbgParameters.nextBytes(
-1, predictionResistanceFlag, null));
}
protected final void engineNextBytes(
byte[] result, SecureRandomParameters params) {
Objects.requireNonNull(result);
if (debug != null) {
debug.println(this, "nextBytes");
}
if (params instanceof DrbgParameters.NextBytes) {
DrbgParameters.NextBytes dp = (DrbgParameters.NextBytes) params;
if (result.length > maxNumberOfBytesPerRequest) {
}
if (dp.getStrength() > securityStrength) {
throw new IllegalArgumentException("strength too high: "
+ dp.getStrength());
}
byte[] ai = dp.getAdditionalInput();
if (ai != null && ai.length > maxAdditionalInputLength) {
throw new IllegalArgumentException("ai too long: "
+ ai.length);
}
boolean pr = dp.getPredictionResistance();
if (!predictionResistanceFlag && pr) {
throw new IllegalArgumentException("pr not available");
}
instantiateIfNecessary(null);
if (reseedCounter < 0 || reseedCounter > reseedInterval || pr) {
synchronized (this) {
if (reseedCounter < 0 || reseedCounter > reseedInterval
|| pr) {
reseedAlgorithm(getEntropyInput(pr), ai);
ai = null;
}
}
}
generateAlgorithm(result, ai);
} else {
throw new IllegalArgumentException("unknown params type:"
+ params.getClass());
}
}
public final void engineReseed(SecureRandomParameters params) {
if (debug != null) {
debug.println(this, "reseed with params");
}
if (!supportReseeding) {
throw new UnsupportedOperationException("Reseed not supported");
}
if (params == null) {
params = DrbgParameters.reseed(predictionResistanceFlag, null);
}
if (params instanceof DrbgParameters.Reseed) {
DrbgParameters.Reseed dp = (DrbgParameters.Reseed) params;
boolean pr = dp.getPredictionResistance();
if (!predictionResistanceFlag && pr) {
throw new IllegalArgumentException("pr not available");
}
byte[] ai = dp.getAdditionalInput();
if (ai != null && ai.length > maxAdditionalInputLength) {
throw new IllegalArgumentException("ai too long: "
+ ai.length);
}
instantiateIfNecessary(null);
reseedAlgorithm(getEntropyInput(pr), ai);
} else {
throw new IllegalArgumentException("unknown params type: "
+ params.getClass());
}
}
public final byte[] engineGenerateSeed(int numBytes) {
byte[] b = new byte[numBytes];
SeedGenerator.generateSeed(b);
return b;
}
public final synchronized void engineSetSeed(byte[] input) {
if (debug != null) {
debug.println(this, "setSeed");
}
if (input.length < minLength) {
input = Arrays.copyOf(input, minLength);
} else if (input.length > maxLength) {
input = Arrays.copyOf(input, maxLength);
}
if (!instantiated) {
instantiateIfNecessary(input);
} else {
reseedAlgorithm(input, null);
}
}
private byte[] getEntropyInput(boolean isPr) {
return getEntropyInput(minLength, minLength, maxLength, isPr);
}
private byte[] getEntropyInput(int minEntropy, int minLength,
int maxLength, boolean pr) {
if (debug != null) {
debug.println(this, "getEntropy(" + minEntropy + "," + minLength +
"," + maxLength + "," + pr + ")");
}
EntropySource esNow = es;
if (esNow == null) {
esNow = pr ? SeederHolder.prseeder : SeederHolder.seeder;
}
return esNow.getEntropy(minEntropy, minLength, maxLength, pr);
}
private static final EntropySource defaultES =
(minE, minLen, maxLen, pr) -> {
byte[] result = new byte[minLen];
SeedGenerator.generateSeed(result);
return result;
};
private static class SeederHolder {
static final EntropySource prseeder;
static final EntropySource seeder;
static {
prseeder = defaultES;
HashDrbg first = new HashDrbg(new MoreDrbgParameters(
prseeder, null, "SHA-256", null, false,
DrbgParameters.instantiation(
256, NONE,
SeedGenerator.getSystemEntropy())));
seeder = (entropy, minLen, maxLen, pr) -> {
if (pr) {
throw new IllegalArgumentException("pr not supported");
}
byte[] result = new byte[minLen];
first.engineNextBytes(result);
return result;
};
}
}
protected AbstractDrbg() {
}
protected AbstractDrbg(SecureRandomParameters params) {
}
protected SecureRandomParameters engineGetParameters() {
return DrbgParameters.instantiation(
securityStrength,
predictionResistanceFlag ? PR_AND_RESEED :
(supportReseeding ? RESEED_ONLY : NONE),
personalizationString);
}
protected final void configure(SecureRandomParameters params) {
if (debug != null) {
debug.println(this, "configure " + this + " with " + params);
}
if (params == null) {
params = DrbgParameters.instantiation(-1, RESEED_ONLY, null);
}
if (params instanceof MoreDrbgParameters) {
MoreDrbgParameters m = (MoreDrbgParameters)params;
this.requestedNonce = m.nonce;
this.es = m.es;
this.requestedAlgorithm = m.algorithm;
this.usedf = m.usedf;
params = DrbgParameters.instantiation(m.strength,
m.capability, m.personalizationString);
}
if (params != null) {
if (params instanceof DrbgParameters.Instantiation) {
DrbgParameters.Instantiation inst =
(DrbgParameters.Instantiation) params;
if (inst.getStrength() > highestSupportedSecurityStrength) {
throw new IllegalArgumentException("strength too big: "
+ inst.getStrength());
}
if (inst.getCapability().supportsPredictionResistance()
&& !supportPredictionResistance) {
throw new IllegalArgumentException("pr not supported");
}
byte[] ps = inst.getPersonalizationString();
if (ps != null && ps.length > maxPersonalizationStringLength) {
throw new IllegalArgumentException("ps too long: "
+ ps.length);
}
if (inst.getCapability().supportsReseeding()
&& !supportReseeding) {
throw new IllegalArgumentException("reseed not supported");
}
this.personalizationString = ps;
this.predictionResistanceFlag =
inst.getCapability().supportsPredictionResistance();
this.requestedInstantiationSecurityStrength = inst.getStrength();
} else {
throw new IllegalArgumentException("unknown params: "
+ params.getClass());
}
}
chooseAlgorithmAndStrength();
instantiated = false;
if (debug != null) {
debug.println(this, "configured " + this);
}
}
private synchronized void instantiateIfNecessary(byte[] entropy) {
if (!instantiated) {
if (entropy == null) {
entropy = getEntropyInput(predictionResistanceFlag);
}
if (requestedNonce != null) {
nonce = requestedNonce;
} else {
nonce = NonceProvider.next();
}
initEngine();
instantiateAlgorithm(entropy);
instantiated = true;
}
}
private static class NonceProvider {
private static final byte[] block = new byte[16];
private static synchronized byte[] next() {
int k = 15;
while ((k >= 0) && (++block[k] == 0)) {
k--;
}
return block.clone();
}
}
protected static int getStandardStrength(int input) {
if (input <= 112) return 112;
if (input <= 128) return 128;
if (input <= 192) return 192;
if (input <= 256) return 256;
throw new IllegalArgumentException("input too big: " + input);
}
@Override
public String toString() {
return mechName + ","  + algorithm
+ "," + securityStrength + ","
+ (predictionResistanceFlag ? "pr_and_reseed"
: (supportReseeding ? "reseed_only" : "none"));
}
}
package javax.lang.model.util;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.RecordComponentElement;
import static javax.lang.model.SourceVersion.*;
@SupportedSourceVersion(RELEASE_20)
public abstract class AbstractElementVisitor14<R, P> extends AbstractElementVisitor9<R, P> {
protected AbstractElementVisitor14(){
super();
}
@Override
public abstract R visitRecordComponent(RecordComponentElement e, P p);
}
package javax.lang.model.util;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import static javax.lang.model.SourceVersion.*;
@SupportedSourceVersion(RELEASE_6)
public abstract class AbstractElementVisitor6<R, P> implements ElementVisitor<R, P> {
@Deprecated(since="9")
protected AbstractElementVisitor6(){}
public final R visit(Element e, P p) {
return e.accept(this, p);
}
public final R visit(Element e) {
return e.accept(this, null);
}
@Override
public R visitUnknown(Element e, P p) {
throw new UnknownElementException(e, p);
}
@Override
public R visitModule(ModuleElement e, P p) {
return ElementVisitor.super.visitModule(e, p);
}
@Override
public R visitRecordComponent(RecordComponentElement e, P p) {
return ElementVisitor.super.visitRecordComponent(e, p);
}
}
package javax.lang.model.util;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import static javax.lang.model.SourceVersion.*;
@SupportedSourceVersion(RELEASE_7)
public abstract class AbstractElementVisitor7<R, P> extends AbstractElementVisitor6<R, P> {
@Deprecated(since="12")
protected AbstractElementVisitor7(){
super();     }
}
package javax.lang.model.util;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import static javax.lang.model.SourceVersion.*;
@SupportedSourceVersion(RELEASE_8)
public abstract class AbstractElementVisitor8<R, P> extends AbstractElementVisitor7<R, P> {
@SuppressWarnings("deprecation")     protected AbstractElementVisitor8(){
super();
}
}
package javax.lang.model.util;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.ModuleElement;
import static javax.lang.model.SourceVersion.*;
@SupportedSourceVersion(RELEASE_14)
public abstract class AbstractElementVisitor9<R, P> extends AbstractElementVisitor8<R, P> {
protected AbstractElementVisitor9(){
super();
}
@Override
public abstract R visitModule(ModuleElement e, P p);
}
package jdk.jfr.internal.consumer;
import java.io.IOException;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.time.Duration;
import java.time.Instant;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Consumer;
import jdk.jfr.Configuration;
import jdk.jfr.EventType;
import jdk.jfr.consumer.EventStream;
import jdk.jfr.consumer.MetadataEvent;
import jdk.jfr.consumer.RecordedEvent;
import jdk.jfr.internal.LogLevel;
import jdk.jfr.internal.LogTag;
import jdk.jfr.internal.Logger;
import jdk.jfr.internal.SecuritySupport;
public abstract class AbstractEventStream implements EventStream {
private static final AtomicLong counter = new AtomicLong();
private final CountDownLatch terminated = new CountDownLatch(1);
private final Runnable flushOperation = () -> dispatcher().runFlushActions();
@SuppressWarnings("removal")
private final AccessControlContext accessControllerContext;
private final StreamConfiguration streamConfiguration = new StreamConfiguration();
private final List<Configuration> configurations;
private final ParserState parserState = new ParserState();
private volatile Thread thread;
private Dispatcher dispatcher;
private boolean daemon = false;
AbstractEventStream(@SuppressWarnings("removal") AccessControlContext acc, List<Configuration> configurations) throws IOException {
this.accessControllerContext = Objects.requireNonNull(acc);
this.configurations = configurations;
}
@Override
public abstract void start();
@Override
public abstract void startAsync();
@Override
public abstract void close();
protected final Dispatcher dispatcher() {
if (streamConfiguration.hasChanged()) {             synchronized (streamConfiguration) {
dispatcher = new Dispatcher(streamConfiguration);
streamConfiguration.setChanged(false);
if (Logger.shouldLog(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG)) {
Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG, dispatcher.toString());
}
}
}
return dispatcher;
}
@Override
public final void setOrdered(boolean ordered) {
streamConfiguration.setOrdered(ordered);
}
@Override
public final void setReuse(boolean reuse) {
streamConfiguration.setReuse(reuse);
}
public final void setDaemon(boolean daemon) {
this.daemon = daemon;
}
@Override
public final void setStartTime(Instant startTime) {
Objects.requireNonNull(startTime, "startTime");
synchronized (streamConfiguration) {
if (streamConfiguration.started) {
throw new IllegalStateException("Stream is already started");
}
if (startTime.isBefore(Instant.EPOCH)) {
startTime = Instant.EPOCH;
}
streamConfiguration.setStartTime(startTime);
}
}
@Override
public final void setEndTime(Instant endTime) {
Objects.requireNonNull(endTime, "endTime");
synchronized (streamConfiguration) {
if (streamConfiguration.started) {
throw new IllegalStateException("Stream is already started");
}
streamConfiguration.setEndTime(endTime);
}
}
@Override
public final void onEvent(Consumer<RecordedEvent> action) {
Objects.requireNonNull(action, "action");
streamConfiguration.addEventAction(action);
}
@Override
public final void onEvent(String eventName, Consumer<RecordedEvent> action) {
Objects.requireNonNull(eventName, "eventName");
Objects.requireNonNull(action, "action");
streamConfiguration.addEventAction(eventName, action);
}
@Override
public final void onFlush(Runnable action) {
Objects.requireNonNull(action, "action");
streamConfiguration.addFlushAction(action);
}
@Override
public final void onClose(Runnable action) {
Objects.requireNonNull(action, "action");
streamConfiguration.addCloseAction(action);
}
@Override
public final void onError(Consumer<Throwable> action) {
Objects.requireNonNull(action, "action");
streamConfiguration.addErrorAction(action);
}
@Override
public final boolean remove(Object action) {
Objects.requireNonNull(action, "action");
return streamConfiguration.remove(action);
}
@Override
public final void awaitTermination() throws InterruptedException {
awaitTermination(Duration.ofMillis(0));
}
@Override
public final void awaitTermination(Duration timeout) throws InterruptedException {
Objects.requireNonNull(timeout, "timeout");
if (timeout.isNegative()) {
throw new IllegalArgumentException("timeout value is negative");
}
long nanos;
try {
nanos = timeout.toNanos();
} catch (ArithmeticException a) {
nanos = Long.MAX_VALUE;
}
if (nanos == 0) {
terminated.await();
} else {
terminated.await(nanos, TimeUnit.NANOSECONDS);
}
}
protected abstract void process() throws IOException;
protected abstract boolean isRecording();
protected final void closeParser() {
parserState.close();
}
protected final boolean isClosed() {
return parserState.isClosed();
}
protected final ParserState parserState() {
return parserState;
}
public final void startAsync(long startNanos) {
startInternal(startNanos);
Runnable r = () -> run(accessControllerContext);
thread = SecuritySupport.createThreadWitNoPermissions(nextThreadName(), r);
SecuritySupport.setDaemonThread(thread, daemon);
thread.start();
}
public final void start(long startNanos) {
startInternal(startNanos);
thread = Thread.currentThread();
run(accessControllerContext);
}
protected final Runnable getFlushOperation() {
return flushOperation;
}
protected final void onFlush() {
Runnable r = getFlushOperation();
if (r != null) {
r.run();
}
}
private void startInternal(long startNanos) {
synchronized (streamConfiguration) {
if (streamConfiguration.started) {
throw new IllegalStateException("Event stream can only be started once");
}
if (isRecording() && streamConfiguration.startTime == null) {
streamConfiguration.setStartNanos(startNanos);
}
streamConfiguration.setStarted(true);
}
}
private void execute() {
try {
process();
} catch (IOException ioe) {
} finally {
Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG, "Execution of stream ended.");
try {
close();
} finally {
terminated.countDown();
}
}
}
@SuppressWarnings("removal")
private void run(AccessControlContext accessControlContext) {
AccessController.doPrivileged(new PrivilegedAction<Void>() {
@Override
public Void run() {
execute();
return null;
}
}, accessControlContext);
}
private String nextThreadName() {
return "JFR Event Stream " + counter.incrementAndGet();
}
@Override
public void onMetadata(Consumer<MetadataEvent> action) {
Objects.requireNonNull(action, "action");
synchronized (streamConfiguration) {
if (streamConfiguration.started) {
throw new IllegalStateException("Stream is already started");
}
}
streamConfiguration.addMetadataAction(action);
}
protected final void onMetadata(ChunkParser parser) {
if (parser.hasStaleMetadata()) {
if (dispatcher.hasMetadataHandler()) {
List<EventType> ce = parser.getEventTypes();
List<EventType> pe = parser.getPreviousEventTypes();
if (ce != pe) {
MetadataEvent me = JdkJfrConsumer.instance().newMetadataEvent(pe, ce, configurations);
dispatcher.runMetadataActions(me);
}
parser.setStaleMetadata(false);
}
}
}
}
package jdk.javadoc.internal.doclets.formats.html;
import java.util.List;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.ExecutableType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.SimpleTypeVisitor14;
import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
import jdk.javadoc.internal.doclets.formats.html.markup.TagName;
import jdk.javadoc.internal.doclets.toolkit.Content;
import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
import static jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo.Kind.EXECUTABLE_MEMBER_PARAM;
import static jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo.Kind.MEMBER;
import static jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo.Kind.MEMBER_DEPRECATED_PREVIEW;
import static jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo.Kind.MEMBER_TYPE_PARAMS;
import static jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo.Kind.RECEIVER_TYPE;
import static jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo.Kind.THROWS_TYPE;
public abstract class AbstractExecutableMemberWriter extends AbstractMemberWriter {
public AbstractExecutableMemberWriter(SubWriterHolderWriter writer, TypeElement typeElement) {
super(writer, typeElement);
}
public AbstractExecutableMemberWriter(SubWriterHolderWriter writer) {
super(writer);
}
protected Content getTypeParameters(ExecutableElement member) {
HtmlLinkInfo linkInfo = new HtmlLinkInfo(configuration, MEMBER_TYPE_PARAMS, member);
return writer.getTypeParameterLinks(linkInfo);
}
@Override
protected Content getSummaryLink(Element member) {
Content content = new ContentBuilder();
content.add(utils.getFullyQualifiedName(member));
if (!utils.isConstructor(member)) {
content.add(".");
content.add(member.getSimpleName());
}
String signature = utils.flatSignature((ExecutableElement) member, typeElement);
if (signature.length() > 2) {
content.add(new HtmlTree(TagName.WBR));
}
content.add(signature);
return writer.getDocLink(MEMBER_DEPRECATED_PREVIEW, utils.getEnclosingTypeElement(member),
member, content, null, false);
}
@Override
protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement te, Element member,
Content target) {
ExecutableElement ee = (ExecutableElement)member;
Content memberLink = writer.getDocLink(context, te, ee, name(ee), HtmlStyle.memberNameLink);
var code = HtmlTree.CODE(memberLink);
addParameters(ee, code);
target.add(code);
}
@Override
protected void addInheritedSummaryLink(TypeElement te, Element member, Content target) {
target.add(writer.getDocLink(MEMBER, te, member, name(member)));
}
protected void addParam(VariableElement param, TypeMirror paramType, boolean isVarArg,
Content target) {
Content link = writer.getLink(new HtmlLinkInfo(configuration, EXECUTABLE_MEMBER_PARAM,
paramType).varargs(isVarArg));
target.add(link);
if(name(param).length() > 0) {
target.add(Entity.NO_BREAK_SPACE);
target.add(name(param));
}
}
protected void addReceiver(ExecutableElement member, TypeMirror rcvrType, Content target) {
var info = new HtmlLinkInfo(configuration, RECEIVER_TYPE, rcvrType);
info.linkToSelf = false;
target.add(writer.getLink(info));
target.add(Entity.NO_BREAK_SPACE);
if (member.getKind() == ElementKind.CONSTRUCTOR) {
target.add(utils.getTypeName(rcvrType, false));
target.add(".");
}
target.add("this");
}
protected boolean isAnnotatedReceiver(TypeMirror receiverType) {
return new SimpleTypeVisitor14<Boolean, Void>() {
@Override
protected Boolean defaultAction(TypeMirror e, Void unused) {
return utils.isAnnotated(e);
}
@Override
public Boolean visitDeclared(DeclaredType t, Void unused) {
if (super.visitDeclared(t, unused) || visit(t.getEnclosingType())) {
return true;
}
for (var e : t.getTypeArguments()) {
if (visit(e)) {
return true;
}
}
return false;
}
}.visit(receiverType);
}
protected void addParameters(ExecutableElement member, Content target) {
Content params = getParameters(member, false);
if (params.charCount() > 2) {
target.add(new HtmlTree(TagName.WBR));
}
target.add(params);
}
protected Content getParameters(ExecutableElement member, boolean includeAnnotations) {
Content result = new ContentBuilder();
result.add("(");
String sep = "";
List<? extends VariableElement> parameters = member.getParameters();
TypeMirror rcvrType = member.getReceiverType();
if (includeAnnotations && rcvrType != null && isAnnotatedReceiver(rcvrType)) {
addReceiver(member, rcvrType, result);
sep = "," + DocletConstants.NL + " ";
}
int paramstart;
ExecutableType instMeth = utils.asInstantiatedMethodType(typeElement, member);
for (paramstart = 0; paramstart < parameters.size(); paramstart++) {
result.add(sep);
VariableElement param = parameters.get(paramstart);
TypeMirror paramType = instMeth.getParameterTypes().get(paramstart);
if (param.getKind() != ElementKind.INSTANCE_INIT) {
if (includeAnnotations) {
Content annotationInfo = writer.getAnnotationInfo(param, false);
if (!annotationInfo.isEmpty()) {
result.add(annotationInfo)
.add(DocletConstants.NL)
.add(" ");
}
}
addParam(param, paramType,
(paramstart == parameters.size() - 1) && member.isVarArgs(), result);
break;
}
}
for (int i = paramstart + 1; i < parameters.size(); i++) {
result.add(",");
result.add(DocletConstants.NL);
result.add(" ");
if (includeAnnotations) {
Content annotationInfo = writer.getAnnotationInfo(parameters.get(i), false);
if (!annotationInfo.isEmpty()) {
result.add(annotationInfo)
.add(DocletConstants.NL)
.add(" ");
}
}
addParam(parameters.get(i), instMeth.getParameterTypes().get(i),
(i == parameters.size() - 1) && member.isVarArgs(),
result);
}
result.add(")");
return result;
}
protected Content getExceptions(ExecutableElement member) {
List<? extends TypeMirror> exceptions = utils.asInstantiatedMethodType(typeElement, member).getThrownTypes();
Content result = new ContentBuilder();
for (TypeMirror t : exceptions) {
if (!result.isEmpty()) {
result.add(",");
result.add(DocletConstants.NL);
}
Content link = writer.getLink(new HtmlLinkInfo(configuration, THROWS_TYPE, t));
result.add(link);
}
return result;
}
protected TypeElement implementsMethodInIntfac(ExecutableElement method,
List<TypeElement> intfacs) {
for (TypeElement intf : intfacs) {
List<ExecutableElement> methods = utils.getMethods(intf);
if (!methods.isEmpty()) {
for (ExecutableElement md : methods) {
if (name(md).equals(name(method)) &&
md.toString().equals(method.toString())) {
return intf;
}
}
}
}
return null;
}
}
package java.util.concurrent;
import static java.util.concurrent.TimeUnit.NANOSECONDS;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
public abstract class AbstractExecutorService implements ExecutorService {
public AbstractExecutorService() {}
protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
return new FutureTask<T>(runnable, value);
}
protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
return new FutureTask<T>(callable);
}
public Future<?> submit(Runnable task) {
if (task == null) throw new NullPointerException();
RunnableFuture<Void> ftask = newTaskFor(task, null);
execute(ftask);
return ftask;
}
public <T> Future<T> submit(Runnable task, T result) {
if (task == null) throw new NullPointerException();
RunnableFuture<T> ftask = newTaskFor(task, result);
execute(ftask);
return ftask;
}
public <T> Future<T> submit(Callable<T> task) {
if (task == null) throw new NullPointerException();
RunnableFuture<T> ftask = newTaskFor(task);
execute(ftask);
return ftask;
}
private <T> T doInvokeAny(Collection<? extends Callable<T>> tasks,
boolean timed, long nanos)
throws InterruptedException, ExecutionException, TimeoutException {
if (tasks == null)
throw new NullPointerException();
int ntasks = tasks.size();
if (ntasks == 0)
throw new IllegalArgumentException();
ArrayList<Future<T>> futures = new ArrayList<>(ntasks);
ExecutorCompletionService<T> ecs =
new ExecutorCompletionService<T>(this);
try {
ExecutionException ee = null;
final long deadline = timed ? System.nanoTime() + nanos : 0L;
Iterator<? extends Callable<T>> it = tasks.iterator();
futures.add(ecs.submit(it.next()));
--ntasks;
int active = 1;
for (;;) {
Future<T> f = ecs.poll();
if (f == null) {
if (ntasks > 0) {
--ntasks;
futures.add(ecs.submit(it.next()));
++active;
}
else if (active == 0)
break;
else if (timed) {
f = ecs.poll(nanos, NANOSECONDS);
if (f == null)
throw new TimeoutException();
nanos = deadline - System.nanoTime();
}
else
f = ecs.take();
}
if (f != null) {
--active;
try {
return f.get();
} catch (ExecutionException eex) {
ee = eex;
} catch (RuntimeException rex) {
ee = new ExecutionException(rex);
}
}
}
if (ee == null)
ee = new ExecutionException();
throw ee;
} finally {
cancelAll(futures);
}
}
public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
throws InterruptedException, ExecutionException {
try {
return doInvokeAny(tasks, false, 0);
} catch (TimeoutException cannotHappen) {
assert false;
return null;
}
}
public <T> T invokeAny(Collection<? extends Callable<T>> tasks,
long timeout, TimeUnit unit)
throws InterruptedException, ExecutionException, TimeoutException {
return doInvokeAny(tasks, true, unit.toNanos(timeout));
}
public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
throws InterruptedException {
if (tasks == null)
throw new NullPointerException();
ArrayList<Future<T>> futures = new ArrayList<>(tasks.size());
try {
for (Callable<T> t : tasks) {
RunnableFuture<T> f = newTaskFor(t);
futures.add(f);
execute(f);
}
for (int i = 0, size = futures.size(); i < size; i++) {
Future<T> f = futures.get(i);
if (!f.isDone()) {
try { f.get(); }
catch (CancellationException | ExecutionException ignore) {}
}
}
return futures;
} catch (Throwable t) {
cancelAll(futures);
throw t;
}
}
public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
long timeout, TimeUnit unit)
throws InterruptedException {
if (tasks == null)
throw new NullPointerException();
final long nanos = unit.toNanos(timeout);
final long deadline = System.nanoTime() + nanos;
ArrayList<Future<T>> futures = new ArrayList<>(tasks.size());
int j = 0;
timedOut: try {
for (Callable<T> t : tasks)
futures.add(newTaskFor(t));
final int size = futures.size();
for (int i = 0; i < size; i++) {
if (((i == 0) ? nanos : deadline - System.nanoTime()) <= 0L)
break timedOut;
execute((Runnable)futures.get(i));
}
for (; j < size; j++) {
Future<T> f = futures.get(j);
if (!f.isDone()) {
try { f.get(deadline - System.nanoTime(), NANOSECONDS); }
catch (CancellationException | ExecutionException ignore) {}
catch (TimeoutException timedOut) {
break timedOut;
}
}
}
return futures;
} catch (Throwable t) {
cancelAll(futures);
throw t;
}
cancelAll(futures, j);
return futures;
}
private static <T> void cancelAll(ArrayList<Future<T>> futures) {
cancelAll(futures, 0);
}
private static <T> void cancelAll(ArrayList<Future<T>> futures, int j) {
for (int size = futures.size(); j < size; j++)
futures.get(j).cancel(true);
}
}
package sun.nio.fs;
import java.nio.file.Path;
import java.nio.file.LinkOption;
import java.nio.file.spi.FileSystemProvider;
import java.io.IOException;
import java.util.Map;
public abstract class AbstractFileSystemProvider extends FileSystemProvider {
protected AbstractFileSystemProvider() { }
private static String[] split(String attribute) {
String[] s = new String[2];
int pos = attribute.indexOf(':');
if (pos == -1) {
s[0] = "basic";
s[1] = attribute;
} else {
s[0] = attribute.substring(0, pos++);
s[1] = (pos == attribute.length()) ? "" : attribute.substring(pos);
}
return s;
}
abstract DynamicFileAttributeView getFileAttributeView(Path file,
String name,
LinkOption... options);
@Override
public final void setAttribute(Path file,
String attribute,
Object value,
LinkOption... options)
throws IOException
{
String[] s = split(attribute);
if (s[0].isEmpty())
throw new IllegalArgumentException(attribute);
DynamicFileAttributeView view = getFileAttributeView(file, s[0], options);
if (view == null)
throw new UnsupportedOperationException("View '" + s[0] + "' not available");
view.setAttribute(s[1], value);
}
@Override
public final Map<String,Object> readAttributes(Path file, String attributes, LinkOption... options)
throws IOException
{
String[] s = split(attributes);
if (s[0].isEmpty())
throw new IllegalArgumentException(attributes);
DynamicFileAttributeView view = getFileAttributeView(file, s[0], options);
if (view == null)
throw new UnsupportedOperationException("View '" + s[0] + "' not available");
return view.readAttributes(s[1].split(","));
}
abstract boolean implDelete(Path file, boolean failIfNotExists) throws IOException;
@Override
public final void delete(Path file) throws IOException {
implDelete(file, true);
}
@Override
public final boolean deleteIfExists(Path file) throws IOException {
return implDelete(file, false);
}
public abstract byte[] getSunPathForSocketFile(Path path);
}
package sun.nio.fs;
import java.net.FileNameMap;
import java.net.URLConnection;
import java.nio.file.Path;
import java.nio.file.spi.FileTypeDetector;
import java.util.Locale;
import java.io.IOException;
public abstract class AbstractFileTypeDetector
extends FileTypeDetector
{
protected AbstractFileTypeDetector() {
super();
}
protected final String getExtension(String name) {
String ext = "";
if (name != null && !name.isEmpty()) {
int dot = name.indexOf('.');
if ((dot >= 0) && (dot < name.length() - 1)) {
ext = name.substring(dot + 1);
}
}
return ext;
}
@Override
public final String probeContentType(Path file) throws IOException {
if (file == null)
throw new NullPointerException("'file' is null");
String result = implProbeContentType(file);
if (result == null) {
Path fileName = file.getFileName();
if (fileName != null) {
FileNameMap fileNameMap = URLConnection.getFileNameMap();
result = fileNameMap.getContentTypeFor(fileName.toString());
}
}
return (result == null) ? null : parse(result);
}
protected abstract String implProbeContentType(Path file)
throws IOException;
private static String parse(String s) {
int slash = s.indexOf('/');
int semicolon = s.indexOf(';');
if (slash < 0)
return null;          String type = s.substring(0, slash).trim().toLowerCase(Locale.ENGLISH);
if (!isValidToken(type))
return null;          String subtype = (semicolon < 0) ? s.substring(slash + 1) :
s.substring(slash + 1, semicolon);
subtype = subtype.trim().toLowerCase(Locale.ENGLISH);
if (!isValidToken(subtype))
return null;          StringBuilder sb = new StringBuilder(type.length() + subtype.length() + 1);
sb.append(type);
sb.append('/');
sb.append(subtype);
return sb.toString();
}
private static final String TSPECIALS = "()<>@,;:/[]?=\\\"";
private static boolean isTokenChar(char c) {
return (c > 040) && (c < 0177) && (TSPECIALS.indexOf(c) < 0);
}
private static boolean isValidToken(String s) {
int len = s.length();
if (len == 0)
return false;
for (int i = 0; i < len; i++) {
if (!isTokenChar(s.charAt(i)))
return false;
}
return true;
}
}
package javax.swing.text.rtf;
import java.io.*;
import java.lang.*;
abstract class AbstractFilter extends OutputStream
{
protected char[] translationTable;
protected boolean[] specialsTable;
static final char[] latin1TranslationTable;
static final boolean[] noSpecialsTable;
static final boolean[] allSpecialsTable;
static {
int i;
noSpecialsTable = new boolean[256];
for (i = 0; i < 256; i++)
noSpecialsTable[i] = false;
allSpecialsTable = new boolean[256];
for (i = 0; i < 256; i++)
allSpecialsTable[i] = true;
latin1TranslationTable = new char[256];
for (i = 0; i < 256; i++)
latin1TranslationTable[i] = (char)i;
}
public void readFromStream(InputStream in)
throws IOException
{
in.transferTo(this);
}
public void readFromReader(Reader in)
throws IOException
{
char[] buf;
int count;
buf = new char[2048];
while(true) {
count = in.read(buf);
if (count < 0)
break;
for (int i = 0; i < count; i++) {
this.write(buf[i]);
}
}
}
public AbstractFilter()
{
translationTable = latin1TranslationTable;
specialsTable = noSpecialsTable;
}
public void write(int b)
throws IOException
{
if (b < 0)
b += 256;
if (specialsTable[b])
writeSpecial(b);
else {
char ch = translationTable[b];
if (ch != (char)0)
write(ch);
}
}
public void write(byte[] buf, int off, int len)
throws IOException
{
StringBuilder accumulator = null;
while (len > 0) {
short b = (short)buf[off];
if (b < 0)
b += 256;
if (specialsTable[b]) {
if (accumulator != null) {
write(accumulator.toString());
accumulator = null;
}
writeSpecial(b);
} else {
char ch = translationTable[b];
if (ch != (char)0) {
if (accumulator == null)
accumulator = new StringBuilder();
accumulator.append(ch);
}
}
len --;
off ++;
}
if (accumulator != null)
write(accumulator.toString());
}
public void write(String s)
throws IOException
{
int index, length;
length = s.length();
for(index = 0; index < length; index ++) {
write(s.charAt(index));
}
}
protected abstract void write(char ch) throws IOException;
protected abstract void writeSpecial(int b) throws IOException;
}
package com.sun.beans.finder;
import java.lang.reflect.Executable;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.Map;
abstract class AbstractFinder<T extends Executable> {
private final Class<?>[] args;
protected AbstractFinder(Class<?>[] args) {
this.args = args;
}
protected boolean isValid(T method) {
return Modifier.isPublic(method.getModifiers());
}
final T find(T[] methods) throws NoSuchMethodException {
Map<T, Class<?>[]> map = new HashMap<T, Class<?>[]>();
T oldMethod = null;
Class<?>[] oldParams = null;
boolean ambiguous = false;
for (T newMethod : methods) {
if (isValid(newMethod)) {
Class<?>[] newParams = newMethod.getParameterTypes();
if (newParams.length == this.args.length) {
PrimitiveWrapperMap.replacePrimitivesWithWrappers(newParams);
if (isAssignable(newParams, this.args)) {
if (oldMethod == null) {
oldMethod = newMethod;
oldParams = newParams;
} else {
boolean useNew = isAssignable(oldParams, newParams);
boolean useOld = isAssignable(newParams, oldParams);
if (useOld && useNew) {
useNew = !newMethod.isSynthetic();
useOld = !oldMethod.isSynthetic();
}
if (useOld == useNew) {
ambiguous = true;
} else if (useNew) {
oldMethod = newMethod;
oldParams = newParams;
ambiguous = false;
}
}
}
}
if (newMethod.isVarArgs()) {
int length = newParams.length - 1;
if (length <= this.args.length) {
Class<?>[] array = new Class<?>[this.args.length];
System.arraycopy(newParams, 0, array, 0, length);
if (length < this.args.length) {
Class<?> type = newParams[length].getComponentType();
if (type.isPrimitive()) {
type = PrimitiveWrapperMap.getType(type.getName());
}
for (int i = length; i < this.args.length; i++) {
array[i] = type;
}
}
map.put(newMethod, array);
}
}
}
}
for (T newMethod : methods) {
Class<?>[] newParams = map.get(newMethod);
if (newParams != null) {
if (isAssignable(newParams, this.args)) {
if (oldMethod == null) {
oldMethod = newMethod;
oldParams = newParams;
} else {
boolean useNew = isAssignable(oldParams, newParams);
boolean useOld = isAssignable(newParams, oldParams);
if (useOld && useNew) {
useNew = !newMethod.isSynthetic();
useOld = !oldMethod.isSynthetic();
}
if (useOld == useNew) {
if (oldParams == map.get(oldMethod)) {
ambiguous = true;
}
} else if (useNew) {
oldMethod = newMethod;
oldParams = newParams;
ambiguous = false;
}
}
}
}
}
if (ambiguous) {
throw new NoSuchMethodException("Ambiguous methods are found");
}
if (oldMethod == null) {
throw new NoSuchMethodException("Method is not found");
}
return oldMethod;
}
private boolean isAssignable(Class<?>[] min, Class<?>[] max) {
for (int i = 0; i < this.args.length; i++) {
if (null != this.args[i]) {
if (!min[i].isAssignableFrom(max[i])) {
return false;
}
}
}
return true;
}
}
package build.tools.generatenimbus;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import java.util.ArrayList;
import java.util.List;
class AbstractGradient extends Paint {
public enum CycleMethod {
NO_CYCLE, REFLECT, REPEAT
}
private ArrayList<GradientStop> stops;
public List<GradientStop> getStops() { return stops; }
AbstractGradient(XMLStreamReader reader) throws XMLStreamException {
stops = new ArrayList<>();
while (reader.hasNext()) {
int eventType = reader.next();
switch (eventType) {
case XMLStreamReader.START_ELEMENT:
switch (reader.getLocalName()) {
case "stop":
stops.add(new GradientStop(reader));
break;
}
break;
case XMLStreamReader.END_ELEMENT:
switch (reader.getLocalName()) {
case "stop":
break;
default:
return;
}
break;
}
}
}
}
package build.tools.jdwpgen;
import java.io.*;
abstract class AbstractGroupNode extends AbstractTypeListNode {
void document(PrintWriter writer) {
for (Node node : components) {
node.document(writer);
}
}
String javaType() {
return name();
}
void genJava(PrintWriter writer, int depth) {
genJavaClass(writer, depth);
}
void genJavaWriteMethod(PrintWriter writer, int depth) {
genJavaWriteMethod(writer, depth, "private ");
}
void genJavaWriteMethod(PrintWriter writer, int depth, String modifier) {
writer.println();
indent(writer, depth);
writer.print(modifier);
writer.println("void write(PacketStream ps) {");
genJavaWrites(writer, depth+1);
indent(writer, depth);
writer.println("}");
}
void genJavaClassSpecifics(PrintWriter writer, int depth) {
switch (context.state) {
case Context.readingReply:
genJavaReadingClassBody(writer, depth, name());
break;
case Context.writingCommand:
genJavaWritingClassBody(writer, depth, name());
genJavaWriteMethod(writer, depth);
break;
default:
error("Group in outer");
break;
}
}
public void genJavaDeclaration(PrintWriter writer, int depth) {
writer.println();
genJavaComment(writer, depth);
indent(writer, depth);
writer.print("final ");
writer.print(name());
writer.print(" a" + name());
writer.println(";");
}
public String javaParam() {
return name() + " a" + name();
}
public void genJavaWrite(PrintWriter writer, int depth,
String writeLabel) {
genJavaDebugWrite(writer, depth, writeLabel, "\"\"");
indent(writer, depth);
writer.println(writeLabel + ".write(ps);");
}
String javaRead() {
error("Internal - Should not call AbstractGroupNode.javaRead()");
return "";
}
public void genJavaRead(PrintWriter writer, int depth,
String readLabel) {
genJavaDebugRead(writer, depth, readLabel, "\"\"");
indent(writer, depth);
writer.print(readLabel);
writer.print(" = new ");
writer.print(name());
writer.println("(vm, ps);");
}
}
package sun.security.provider;
import sun.security.util.HexDumpEncoder;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
public abstract class AbstractHashDrbg extends AbstractDrbg {
protected int outLen;
protected int seedLen;
private static int alg2strength(String algorithm) {
switch (algorithm.toUpperCase(Locale.ROOT)) {
case "SHA-224":
case "SHA-512/224":
return 192;
case "SHA-256":
case "SHA-512/256":
case "SHA-384":
case "SHA-512":
return 256;
default:
throw new IllegalArgumentException(algorithm +
" not supported in Hash_DBRG");
}
}
protected void chooseAlgorithmAndStrength() {
if (requestedAlgorithm != null) {
algorithm = requestedAlgorithm.toUpperCase(Locale.ROOT);
int supportedStrength = alg2strength(algorithm);
if (requestedInstantiationSecurityStrength >= 0) {
int tryStrength = getStandardStrength(
requestedInstantiationSecurityStrength);
if (tryStrength > supportedStrength) {
throw new IllegalArgumentException(algorithm +
" does not support strength " +
requestedInstantiationSecurityStrength);
}
this.securityStrength = tryStrength;
} else {
this.securityStrength = DEFAULT_STRENGTH > supportedStrength ?
supportedStrength : DEFAULT_STRENGTH;
}
} else {
int tryStrength = (requestedInstantiationSecurityStrength < 0) ?
DEFAULT_STRENGTH : requestedInstantiationSecurityStrength;
tryStrength = getStandardStrength(tryStrength);
algorithm = "SHA-256";
this.securityStrength = tryStrength;
}
switch (algorithm.toUpperCase(Locale.ROOT)) {
case "SHA-224":
case "SHA-512/224":
this.seedLen = 440 / 8;
this.outLen = 224 / 8;
break;
case "SHA-256":
case "SHA-512/256":
this.seedLen = 440 / 8;
this.outLen = 256 / 8;
break;
case "SHA-384":
this.seedLen = 888 / 8;
this.outLen = 384 / 8;
break;
case "SHA-512":
this.seedLen = 888 / 8;
this.outLen = 512 / 8;
break;
default:
throw new IllegalArgumentException(algorithm +
" not supported in Hash_DBRG");
}
this.minLength = this.securityStrength / 8;
}
@Override
public void instantiateAlgorithm(byte[] entropy) {
if (debug != null) {
debug.println(this, "instantiate");
}
List<byte[]> inputs = new ArrayList<>(3);
inputs.add(entropy);
inputs.add(nonce);
if (personalizationString != null) {
inputs.add(personalizationString);
}
hashReseedInternal(inputs);
}
@Override
protected void reseedAlgorithm(
byte[] ei,
byte[] additionalInput) {
if (debug != null) {
debug.println(this, "reseedAlgorithm\n" +
new HexDumpEncoder().encodeBuffer(ei) + "\n" +
((additionalInput == null) ? "" :
new HexDumpEncoder().encodeBuffer(additionalInput)));
}
List<byte[]> inputs = new ArrayList<>(2);
inputs.add(ei);
if (additionalInput != null) {
inputs.add(additionalInput);
}
hashReseedInternal(inputs);
}
protected abstract void hashReseedInternal(List<byte[]> inputs);
}
package sun.jvm.hotspot.utilities;
import java.io.*;
import sun.jvm.hotspot.debugger.*;
import sun.jvm.hotspot.gc.shared.OopStorage;
import sun.jvm.hotspot.oops.*;
import sun.jvm.hotspot.runtime.*;
public abstract class AbstractHeapGraphWriter implements HeapGraphWriter {
protected void write() throws IOException {
javaLangClass = "java/lang/Class";
javaLangString = "java/lang/String";
javaLangThread = "java/lang/Thread";
ObjectHeap heap = VM.getVM().getObjectHeap();
try {
heap.iterate(new DefaultHeapVisitor() {
public void prologue(long usedSize) {
try {
writeHeapHeader();
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public boolean doObj(Oop oop) {
try {
writeHeapRecordPrologue(calculateOopDumpRecordSize(oop));
if (oop instanceof TypeArray) {
writePrimitiveArray((TypeArray)oop);
} else if (oop instanceof ObjArray) {
Klass klass = oop.getKlass();
ObjArrayKlass oak = (ObjArrayKlass) klass;
Klass bottomType = oak.getBottomKlass();
if (bottomType instanceof InstanceKlass ||
bottomType instanceof TypeArrayKlass) {
writeObjectArray((ObjArray)oop);
} else {
writeInternalObject(oop);
}
} else if (oop instanceof Instance) {
Instance instance = (Instance) oop;
Klass klass = instance.getKlass();
Symbol name = klass.getName();
if (name.equals(javaLangString)) {
writeString(instance);
} else if (name.equals(javaLangClass)) {
writeClass(instance);
} else if (name.equals(javaLangThread)) {
writeThread(instance);
} else {
klass = klass.getSuper();
while (klass != null) {
name = klass.getName();
if (name.equals(javaLangThread)) {
writeThread(instance);
return false;
}
klass = klass.getSuper();
}
writeInstance(instance);
}
} else {
writeInternalObject(oop);
}
writeHeapRecordEpilogue();
} catch (IOException exp) {
throw new RuntimeException(exp);
}
return false;
}
public void epilogue() {
try {
writeHeapFooter();
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
});
writeHeapRecordPrologue();
writeJavaThreads();
writeGlobalJNIHandles();
} catch (RuntimeException re) {
handleRuntimeException(re);
}
}
protected abstract int calculateOopDumpRecordSize(Oop oop) throws IOException;
protected void writeJavaThreads() throws IOException {
Threads threads = VM.getVM().getThreads();
for (int i = 0; i < threads.getNumberOfThreads(); i++) {
JavaThread jt = threads.getJavaThreadAt(i);
if (jt.getThreadObj() != null) {
writeJavaThread(jt, i + 1);
}
}
}
protected void writeJavaThread(JavaThread jt, int index)
throws IOException {
}
protected void writeGlobalJNIHandles() throws IOException {
JNIHandles handles = VM.getVM().getJNIHandles();
OopStorage blk = handles.globalHandles();
if (blk != null) {
try {
blk.oopsDo(new AddressVisitor() {
public void visitAddress(Address handleAddr) {
try {
if (handleAddr != null) {
writeGlobalJNIHandle(handleAddr);
}
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void visitCompOopAddress(Address handleAddr) {
throw new RuntimeException("Should not reach here. JNIHandles are not compressed");
}
});
} catch (RuntimeException re) {
handleRuntimeException(re);
}
}
}
protected void writeGlobalJNIHandle(Address handleAddr) throws IOException {
}
protected void writeHeapHeader() throws IOException {
}
protected void writeInternalObject(Oop oop) throws IOException {
}
protected void writePrimitiveArray(TypeArray array) throws IOException {
writeObject(array);
}
protected void writeObjectArray(ObjArray array) throws IOException {
writeObject(array);
}
protected void writeInstance(Instance instance) throws IOException {
writeObject(instance);
}
protected void writeString(Instance instance) throws IOException {
writeInstance(instance);
}
protected void writeClass(Instance instance) throws IOException {
writeInstance(instance);
}
protected void writeThread(Instance instance) throws IOException {
writeInstance(instance);
}
protected void writeObject(Oop oop) throws IOException {
writeObjectHeader(oop);
writeObjectFields(oop);
writeObjectFooter(oop);
}
protected void writeObjectHeader(Oop oop) throws IOException {
}
protected void writeObjectFields(final Oop oop) throws IOException {
try {
oop.iterate(new DefaultOopVisitor() {
public void doOop(OopField field, boolean isVMField) {
try {
writeReferenceField(oop, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doByte(ByteField field, boolean isVMField) {
try {
writeByteField(oop, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doChar(CharField field, boolean isVMField) {
try {
writeCharField(oop, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doBoolean(BooleanField field, boolean vField) {
try {
writeBooleanField(oop, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doShort(ShortField field, boolean isVMField) {
try {
writeShortField(oop, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doInt(IntField field, boolean isVMField) {
try {
writeIntField(oop, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doLong(LongField field, boolean isVMField) {
try {
writeLongField(oop, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doFloat(FloatField field, boolean isVMField) {
try {
writeFloatField(oop, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doDouble(DoubleField field, boolean vField) {
try {
writeDoubleField(oop, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
}, false);
} catch (RuntimeException re) {
handleRuntimeException(re);
}
}
protected void writeObjectFields(final InstanceKlass oop) throws IOException {
try {
oop.iterateStaticFields(new DefaultOopVisitor() {
public void doOop(OopField field, boolean isVMField) {
try {
writeReferenceField(null, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doByte(ByteField field, boolean isVMField) {
try {
writeByteField(null, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doChar(CharField field, boolean isVMField) {
try {
writeCharField(null, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doBoolean(BooleanField field, boolean vField) {
try {
writeBooleanField(null, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doShort(ShortField field, boolean isVMField) {
try {
writeShortField(null, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doInt(IntField field, boolean isVMField) {
try {
writeIntField(null, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doLong(LongField field, boolean isVMField) {
try {
writeLongField(null, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doFloat(FloatField field, boolean isVMField) {
try {
writeFloatField(null, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
public void doDouble(DoubleField field, boolean vField) {
try {
writeDoubleField(null, field);
} catch (IOException exp) {
throw new RuntimeException(exp);
}
}
});
} catch (RuntimeException re) {
handleRuntimeException(re);
}
}
protected void writeReferenceField(Oop oop, OopField field)
throws IOException {
}
protected void writeByteField(Oop oop, ByteField field)
throws IOException {
}
protected void writeCharField(Oop oop, CharField field)
throws IOException {
}
protected void writeBooleanField(Oop oop, BooleanField field)
throws IOException {
}
protected void writeShortField(Oop oop, ShortField field)
throws IOException {
}
protected void writeIntField(Oop oop, IntField field)
throws IOException {
}
protected void writeLongField(Oop oop, LongField field)
throws IOException {
}
protected void writeFloatField(Oop oop, FloatField field)
throws IOException {
}
protected void writeDoubleField(Oop oop, DoubleField field)
throws IOException {
}
protected void writeObjectFooter(Oop oop) throws IOException {
}
protected void writeHeapFooter() throws IOException {
}
protected void writeHeapRecordPrologue() throws IOException {
}
protected void writeHeapRecordPrologue(int size) throws IOException {
}
protected void writeHeapRecordEpilogue() throws IOException {
}
protected void handleRuntimeException(RuntimeException re)
throws IOException {
Throwable cause = re.getCause();
if (cause instanceof IOException io) {
throw io;
} else {
throw re;
}
}
protected boolean isJavaVisible(Oop oop) {
if (oop instanceof Instance || oop instanceof TypeArray) {
return true;
} else if (oop instanceof ObjArray) {
ObjArrayKlass oak = (ObjArrayKlass) oop.getKlass();
Klass bottomKlass = oak.getBottomKlass();
return bottomKlass instanceof InstanceKlass ||
bottomKlass instanceof TypeArrayKlass;
} else {
return false;
}
}
protected String javaLangClass;
protected String javaLangString;
protected String javaLangThread;
}
package compiler.lib.ir_framework;
import compiler.lib.ir_framework.shared.TestRunException;
import compiler.lib.ir_framework.test.TestVM;
import jdk.test.lib.Utils;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Random;
import java.util.stream.Collectors;
abstract public class AbstractInfo {
private static final Random RANDOM = Utils.getRandomInstance();
protected final Class<?> testClass;
private boolean onWarmUp = true;
AbstractInfo(Class<?> testClass) {
this.testClass = testClass;
}
public static Random getRandom() {
return RANDOM;
}
public boolean isWarmUp() {
return onWarmUp;
}
public Method getMethod(Class<?> c, String name, Class<?>... args) {
try {
return c.getMethod(name, args);
} catch (NoSuchMethodException e) {
String parameters = args == null || args.length == 0 ? "" :
" with arguments [" + Arrays.stream(args).map(Class::getName).collect(Collectors.joining(",")) + "]";
throw new TestRunException("Could not find method " + name + " in " + c + parameters, e);
}
}
public Method getTestClassMethod(String name, Class<?>... args) {
return getMethod(testClass, name, args);
}
public boolean isC2CompilationEnabled() {
return TestVM.USE_COMPILER && !TestVM.TEST_C1;
}
public void setWarmUpFinished() {
onWarmUp = false;
}
}
package jdk.internal.org.objectweb.asm.tree;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import jdk.internal.org.objectweb.asm.MethodVisitor;
public abstract class AbstractInsnNode {
public static final int INSN = 0;
public static final int INT_INSN = 1;
public static final int VAR_INSN = 2;
public static final int TYPE_INSN = 3;
public static final int FIELD_INSN = 4;
public static final int METHOD_INSN = 5;
public static final int INVOKE_DYNAMIC_INSN = 6;
public static final int JUMP_INSN = 7;
public static final int LABEL = 8;
public static final int LDC_INSN = 9;
public static final int IINC_INSN = 10;
public static final int TABLESWITCH_INSN = 11;
public static final int LOOKUPSWITCH_INSN = 12;
public static final int MULTIANEWARRAY_INSN = 13;
public static final int FRAME = 14;
public static final int LINE = 15;
protected int opcode;
public List<TypeAnnotationNode> visibleTypeAnnotations;
public List<TypeAnnotationNode> invisibleTypeAnnotations;
AbstractInsnNode previousInsn;
AbstractInsnNode nextInsn;
int index;
protected AbstractInsnNode(final int opcode) {
this.opcode = opcode;
this.index = -1;
}
public int getOpcode() {
return opcode;
}
public abstract int getType();
public AbstractInsnNode getPrevious() {
return previousInsn;
}
public AbstractInsnNode getNext() {
return nextInsn;
}
public abstract void accept(MethodVisitor methodVisitor);
protected final void acceptAnnotations(final MethodVisitor methodVisitor) {
if (visibleTypeAnnotations != null) {
for (int i = 0, n = visibleTypeAnnotations.size(); i < n; ++i) {
TypeAnnotationNode typeAnnotation = visibleTypeAnnotations.get(i);
typeAnnotation.accept(
methodVisitor.visitInsnAnnotation(
typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, true));
}
}
if (invisibleTypeAnnotations != null) {
for (int i = 0, n = invisibleTypeAnnotations.size(); i < n; ++i) {
TypeAnnotationNode typeAnnotation = invisibleTypeAnnotations.get(i);
typeAnnotation.accept(
methodVisitor.visitInsnAnnotation(
typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, false));
}
}
}
public abstract AbstractInsnNode clone(Map<LabelNode, LabelNode> clonedLabels);
static LabelNode clone(final LabelNode label, final Map<LabelNode, LabelNode> clonedLabels) {
return clonedLabels.get(label);
}
static LabelNode[] clone(
final List<LabelNode> labels, final Map<LabelNode, LabelNode> clonedLabels) {
LabelNode[] clones = new LabelNode[labels.size()];
for (int i = 0, n = clones.length; i < n; ++i) {
clones[i] = clonedLabels.get(labels.get(i));
}
return clones;
}
protected final AbstractInsnNode cloneAnnotations(final AbstractInsnNode insnNode) {
if (insnNode.visibleTypeAnnotations != null) {
this.visibleTypeAnnotations = new ArrayList<>();
for (int i = 0, n = insnNode.visibleTypeAnnotations.size(); i < n; ++i) {
TypeAnnotationNode sourceAnnotation = insnNode.visibleTypeAnnotations.get(i);
TypeAnnotationNode cloneAnnotation =
new TypeAnnotationNode(
sourceAnnotation.typeRef, sourceAnnotation.typePath, sourceAnnotation.desc);
sourceAnnotation.accept(cloneAnnotation);
this.visibleTypeAnnotations.add(cloneAnnotation);
}
}
if (insnNode.invisibleTypeAnnotations != null) {
this.invisibleTypeAnnotations = new ArrayList<>();
for (int i = 0, n = insnNode.invisibleTypeAnnotations.size(); i < n; ++i) {
TypeAnnotationNode sourceAnnotation = insnNode.invisibleTypeAnnotations.get(i);
TypeAnnotationNode cloneAnnotation =
new TypeAnnotationNode(
sourceAnnotation.typeRef, sourceAnnotation.typePath, sourceAnnotation.desc);
sourceAnnotation.accept(cloneAnnotation);
this.invisibleTypeAnnotations.add(cloneAnnotation);
}
}
return this;
}
}
package java.nio.channels.spi;
import java.io.IOException;
import java.nio.channels.AsynchronousCloseException;
import java.nio.channels.Channel;
import java.nio.channels.ClosedByInterruptException;
import java.nio.channels.InterruptibleChannel;
import jdk.internal.access.SharedSecrets;
import sun.nio.ch.Interruptible;
public abstract class AbstractInterruptibleChannel
implements Channel, InterruptibleChannel
{
private final Object closeLock = new Object();
private volatile boolean closed;
protected AbstractInterruptibleChannel() { }
public final void close() throws IOException {
synchronized (closeLock) {
if (closed)
return;
closed = true;
implCloseChannel();
}
}
protected abstract void implCloseChannel() throws IOException;
public final boolean isOpen() {
return !closed;
}
private Interruptible interruptor;
private volatile Thread interrupted;
protected final void begin() {
if (interruptor == null) {
interruptor = new Interruptible() {
public void interrupt(Thread target) {
synchronized (closeLock) {
if (closed)
return;
closed = true;
interrupted = target;
try {
AbstractInterruptibleChannel.this.implCloseChannel();
} catch (IOException x) { }
}
}};
}
blockedOn(interruptor);
Thread me = Thread.currentThread();
if (me.isInterrupted())
interruptor.interrupt(me);
}
protected final void end(boolean completed)
throws AsynchronousCloseException
{
blockedOn(null);
Thread interrupted = this.interrupted;
if (interrupted != null && interrupted == Thread.currentThread()) {
this.interrupted = null;
throw new ClosedByInterruptException();
}
if (!completed && closed)
throw new AsynchronousCloseException();
}
static void blockedOn(Interruptible intr) {                 SharedSecrets.getJavaLangAccess().blockedOn(intr);
}
}
package jdk.dynalink.beans;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.reflect.Constructor;
import java.lang.reflect.Executable;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import jdk.dynalink.CallSiteDescriptor;
import jdk.dynalink.NamedOperation;
import jdk.dynalink.Namespace;
import jdk.dynalink.NamespaceOperation;
import jdk.dynalink.Operation;
import jdk.dynalink.StandardNamespace;
import jdk.dynalink.StandardOperation;
import jdk.dynalink.beans.GuardedInvocationComponent.ValidationType;
import jdk.dynalink.internal.InternalTypeUtilities;
import jdk.dynalink.linker.GuardedInvocation;
import jdk.dynalink.linker.GuardingDynamicLinker;
import jdk.dynalink.linker.LinkRequest;
import jdk.dynalink.linker.LinkerServices;
import jdk.dynalink.linker.support.Guards;
import jdk.dynalink.linker.support.Lookup;
import jdk.internal.reflect.CallerSensitive;
abstract class AbstractJavaLinker implements GuardingDynamicLinker {
final Class<?> clazz;
private final MethodHandle classGuard;
private final MethodHandle assignableGuard;
private final Map<String, AnnotatedDynamicMethod> propertyGetters = new HashMap<>();
private final Map<String, DynamicMethod> propertySetters = new HashMap<>();
private final Map<String, DynamicMethod> methods = new HashMap<>();
AbstractJavaLinker(final Class<?> clazz, final MethodHandle classGuard) {
this(clazz, classGuard, classGuard);
}
AbstractJavaLinker(final Class<?> clazz, final MethodHandle classGuard, final MethodHandle assignableGuard) {
this.clazz = clazz;
this.classGuard = classGuard;
this.assignableGuard = assignableGuard;
final FacetIntrospector introspector = createFacetIntrospector();
for (final Method rcg: introspector.getRecordComponentGetters()) {
setPropertyGetter(rcg, 0);
}
for(final Method method: introspector.getMethods()) {
final String name = method.getName();
addMember(name, method, methods);
if(name.startsWith("get") && name.length() > 3 && method.getParameterTypes().length == 0) {
setPropertyGetter(method, 3);
} else if(name.startsWith("is") && name.length() > 2 && method.getParameterTypes().length == 0 &&
method.getReturnType() == boolean.class) {
setPropertyGetter(method, 2);
} else if(name.startsWith("set") && name.length() > 3 && method.getParameterTypes().length == 1) {
addMember(decapitalize(name.substring(3)), method, propertySetters);
}
}
for(final Field field: introspector.getFields()) {
final String name = field.getName();
setPropertyGetter(name, introspector.unreflectGetter(field), ValidationType.EXACT_CLASS);
if(!(Modifier.isFinal(field.getModifiers()) || propertySetters.containsKey(name))) {
addMember(name, new SimpleDynamicMethod(introspector.unreflectSetter(field), clazz, name),
propertySetters);
}
}
for(final Map.Entry<String, MethodHandle> innerClassSpec: introspector.getInnerClassGetters().entrySet()) {
setPropertyGetter(innerClassSpec.getKey(), innerClassSpec.getValue(), ValidationType.EXACT_CLASS);
}
}
private static String decapitalize(final String str) {
assert str != null;
if(str.isEmpty()) {
return str;
}
final char c0 = str.charAt(0);
if(Character.isLowerCase(c0)) {
return str;
}
if(str.length() > 1 && Character.isUpperCase(str.charAt(1))) {
return str;
}
final char[] c = str.toCharArray();
c[0] = Character.toLowerCase(c0);
return new String(c);
}
abstract FacetIntrospector createFacetIntrospector();
Set<String> getReadablePropertyNames() {
return getUnmodifiableKeys(propertyGetters);
}
Set<String> getWritablePropertyNames() {
return getUnmodifiableKeys(propertySetters);
}
Set<String> getMethodNames() {
return getUnmodifiableKeys(methods);
}
private static Set<String> getUnmodifiableKeys(final Map<String, ?> m) {
return Collections.unmodifiableSet(m.keySet());
}
private void setPropertyGetter(final String name, final SingleDynamicMethod handle, final ValidationType validationType) {
if (!propertyGetters.containsKey(name)) {
propertyGetters.put(name, new AnnotatedDynamicMethod(handle, validationType));
}
}
private void setPropertyGetter(final Method getter, final int prefixLen) {
setPropertyGetter(decapitalize(getter.getName().substring(prefixLen)), createDynamicMethod(
getMostGenericGetter(getter)), ValidationType.INSTANCE_OF);
}
void setPropertyGetter(final String name, final MethodHandle handle, final ValidationType validationType) {
setPropertyGetter(name, new SimpleDynamicMethod(handle, clazz, name), validationType);
}
private void addMember(final String name, final Executable m, final Map<String, DynamicMethod> methodMap) {
addMember(name, createDynamicMethod(m), methodMap);
}
private void addMember(final String name, final SingleDynamicMethod method, final Map<String, DynamicMethod> methodMap) {
final DynamicMethod existingMethod = methodMap.get(name);
final DynamicMethod newMethod = mergeMethods(method, existingMethod, clazz, name);
if(newMethod != existingMethod) {
methodMap.put(name, newMethod);
}
}
static DynamicMethod createDynamicMethod(final Iterable<? extends Executable> members, final Class<?> clazz, final String name) {
DynamicMethod dynMethod = null;
for(final Executable method: members) {
dynMethod = mergeMethods(createDynamicMethod(method), dynMethod, clazz, name);
}
return dynMethod;
}
private static SingleDynamicMethod createDynamicMethod(final Executable m) {
if (m.isAnnotationPresent(CallerSensitive.class)) {
return new CallerSensitiveDynamicMethod(m);
}
final MethodHandle mh;
try {
mh = unreflectSafely(m);
} catch (final IllegalAccessError e) {
return new CallerSensitiveDynamicMethod(m);
}
return new SimpleDynamicMethod(mh, m.getDeclaringClass(), m.getName(), m instanceof Constructor);
}
private static MethodHandle unreflectSafely(final Executable m) {
if(m instanceof Method) {
final Method reflMethod = (Method)m;
final MethodHandle handle = Lookup.PUBLIC.unreflect(reflMethod);
if(Modifier.isStatic(reflMethod.getModifiers())) {
return StaticClassIntrospector.editStaticMethodHandle(handle);
}
return handle;
}
return StaticClassIntrospector.editConstructorMethodHandle(Lookup.PUBLIC.unreflectConstructor((Constructor<?>)m));
}
private static DynamicMethod mergeMethods(final SingleDynamicMethod method, final DynamicMethod existing, final Class<?> clazz, final String name) {
if(existing == null) {
return method;
} else if(existing.contains(method)) {
return existing;
} else if(existing instanceof SingleDynamicMethod) {
final OverloadedDynamicMethod odm = new OverloadedDynamicMethod(clazz, name);
odm.addMethod(((SingleDynamicMethod)existing));
odm.addMethod(method);
return odm;
} else if(existing instanceof OverloadedDynamicMethod) {
((OverloadedDynamicMethod)existing).addMethod(method);
return existing;
}
throw new AssertionError();
}
@Override
public GuardedInvocation getGuardedInvocation(final LinkRequest request, final LinkerServices linkerServices)
throws Exception {
final MissingMemberHandlerFactory missingMemberHandlerFactory;
final LinkerServices directLinkerServices;
if (linkerServices instanceof LinkerServicesWithMissingMemberHandlerFactory) {
final LinkerServicesWithMissingMemberHandlerFactory lswmmhf = ((LinkerServicesWithMissingMemberHandlerFactory)linkerServices);
missingMemberHandlerFactory = lswmmhf.missingMemberHandlerFactory;
directLinkerServices = lswmmhf.linkerServices;
} else {
missingMemberHandlerFactory = null;
directLinkerServices = linkerServices;
}
final GuardedInvocationComponent gic = getGuardedInvocationComponent(
new ComponentLinkRequest(request, directLinkerServices,
missingMemberHandlerFactory));
return gic != null ? gic.getGuardedInvocation() : null;
}
static final class ComponentLinkRequest {
final LinkRequest linkRequest;
final LinkerServices linkerServices;
final MissingMemberHandlerFactory missingMemberHandlerFactory;
final Operation baseOperation;
final List<Namespace> namespaces;
final Object name;
ComponentLinkRequest(final LinkRequest linkRequest,
final LinkerServices linkerServices,
final MissingMemberHandlerFactory missingMemberHandlerFactory) {
this.linkRequest = linkRequest;
this.linkerServices = linkerServices;
this.missingMemberHandlerFactory = missingMemberHandlerFactory;
final Operation namedOp = linkRequest.getCallSiteDescriptor().getOperation();
this.name = NamedOperation.getName(namedOp);
final Operation namespaceOp = NamedOperation.getBaseOperation(namedOp);
this.baseOperation = NamespaceOperation.getBaseOperation(namespaceOp);
this.namespaces = Arrays.asList(NamespaceOperation.getNamespaces(namespaceOp));
}
private ComponentLinkRequest(final LinkRequest linkRequest,
final LinkerServices linkerServices,
final MissingMemberHandlerFactory missingMemberHandlerFactory,
final Operation baseOperation, final List<Namespace> namespaces, final Object name) {
this.linkRequest = linkRequest;
this.linkerServices = linkerServices;
this.missingMemberHandlerFactory = missingMemberHandlerFactory;
this.baseOperation = baseOperation;
this.namespaces = namespaces;
this.name = name;
}
CallSiteDescriptor getDescriptor() {
return linkRequest.getCallSiteDescriptor();
}
ComponentLinkRequest popNamespace() {
return new ComponentLinkRequest(linkRequest, linkerServices,
missingMemberHandlerFactory, baseOperation,
namespaces.subList(1, namespaces.size()), name);
}
}
protected GuardedInvocationComponent getGuardedInvocationComponent(final ComponentLinkRequest req)
throws Exception {
if (req.namespaces.isEmpty()) {
return null;
}
final Namespace ns = req.namespaces.get(0);
final Operation op = req.baseOperation;
if (op == StandardOperation.GET) {
if (ns == StandardNamespace.PROPERTY) {
return getPropertyGetter(req.popNamespace());
} else if (ns == StandardNamespace.METHOD) {
return getMethodGetter(req.popNamespace());
}
} else if (op == StandardOperation.SET && ns == StandardNamespace.PROPERTY) {
return getPropertySetter(req.popNamespace());
}
return getNextComponent(req.popNamespace());
}
GuardedInvocationComponent getNextComponent(final ComponentLinkRequest req) throws Exception {
if (req.namespaces.isEmpty()) {
return createNoSuchMemberHandler(req.missingMemberHandlerFactory,
req.linkRequest, req.linkerServices);
}
final GuardedInvocationComponent gic = getGuardedInvocationComponent(req);
if (gic != null) {
return gic;
}
return getNextComponent(req.popNamespace());
}
private GuardedInvocationComponent createNoSuchMemberHandler(
final MissingMemberHandlerFactory missingMemberHandlerFactory,
final LinkRequest linkRequest, final LinkerServices linkerServices) throws Exception {
if (missingMemberHandlerFactory == null) {
return null;
}
final MethodHandle handler = missingMemberHandlerFactory.createMissingMemberHandler(linkRequest, linkerServices);
if (handler == null) {
return null;
}
final MethodType type = linkRequest.getCallSiteDescriptor().getMethodType();
assert handler.type().changeReturnType(type.returnType()).equals(type);
return getClassGuardedInvocationComponent(handler, type);
}
MethodHandle getClassGuard(final MethodType type) {
return Guards.asType(classGuard, type);
}
GuardedInvocationComponent getClassGuardedInvocationComponent(final MethodHandle invocation, final MethodType type) {
return new GuardedInvocationComponent(invocation, getClassGuard(type), clazz, ValidationType.EXACT_CLASS);
}
abstract SingleDynamicMethod getConstructorMethod(final String signature);
private MethodHandle getAssignableGuard(final MethodType type) {
return Guards.asType(assignableGuard, type);
}
private GuardedInvocation createGuardedDynamicMethodInvocation(final CallSiteDescriptor callSiteDescriptor,
final LinkerServices linkerServices, final String methodName, final Map<String, DynamicMethod> methodMap){
final MethodHandle inv = getDynamicMethodInvocation(callSiteDescriptor, linkerServices, methodName, methodMap);
return inv == null ? null : new GuardedInvocation(inv, getClassGuard(callSiteDescriptor.getMethodType()));
}
private MethodHandle getDynamicMethodInvocation(final CallSiteDescriptor callSiteDescriptor,
final LinkerServices linkerServices, final String methodName, final Map<String, DynamicMethod> methodMap) {
final DynamicMethod dynaMethod = getDynamicMethod(methodName, methodMap);
return dynaMethod != null ? dynaMethod.getInvocation(callSiteDescriptor, linkerServices) : null;
}
private DynamicMethod getDynamicMethod(final String methodName, final Map<String, DynamicMethod> methodMap) {
final DynamicMethod dynaMethod = methodMap.get(methodName);
return dynaMethod != null ? dynaMethod : getExplicitSignatureDynamicMethod(methodName, methodMap);
}
private SingleDynamicMethod getExplicitSignatureDynamicMethod(final String fullName,
final Map<String, DynamicMethod> methodsMap) {
final int lastChar = fullName.length() - 1;
if(fullName.charAt(lastChar) != ')') {
return null;
}
final int openBrace = fullName.indexOf('(');
if(openBrace == -1) {
return null;
}
final String name = fullName.substring(0, openBrace);
final String signature = fullName.substring(openBrace + 1, lastChar);
final DynamicMethod simpleNamedMethod = methodsMap.get(name);
if(simpleNamedMethod == null) {
if (name.isEmpty()) {
return getConstructorMethod(signature);
}
return null;
}
return simpleNamedMethod.getMethodForExactParamTypes(signature);
}
private static final MethodHandle IS_METHOD_HANDLE_NOT_NULL = Guards.isNotNull().asType(MethodType.methodType(
boolean.class, MethodHandle.class));
private static final MethodHandle CONSTANT_NULL_DROP_METHOD_HANDLE = MethodHandles.dropArguments(
MethodHandles.constant(Object.class, null), 0, MethodHandle.class);
private GuardedInvocationComponent getPropertySetter(final ComponentLinkRequest req) throws Exception {
if (req.name == null) {
return getUnnamedPropertySetter(req);
}
return getNamedPropertySetter(req);
}
private GuardedInvocationComponent getUnnamedPropertySetter(final ComponentLinkRequest req) throws Exception {
final CallSiteDescriptor callSiteDescriptor = req.getDescriptor();
assertParameterCount(callSiteDescriptor, 3);
final MethodType origType = callSiteDescriptor.getMethodType();
final MethodType type = origType.returnType() == void.class ? origType : origType.changeReturnType(Object.class);
final LinkerServices linkerServices = req.linkerServices;
final MethodType setterType = type.dropParameterTypes(1, 2);
final MethodHandle boundGetter = MethodHandles.insertArguments(getPropertySetterHandle, 0,
callSiteDescriptor.changeMethodType(setterType), linkerServices);
final MethodHandle typedGetter = linkerServices.asType(boundGetter, type.changeReturnType(
MethodHandle.class));
final MethodHandle invokeHandle = MethodHandles.exactInvoker(setterType);
final MethodHandle invokeHandleFolded = MethodHandles.dropArguments(invokeHandle, 2, type.parameterType(
1));
final GuardedInvocationComponent nextComponent = getNextComponent(req);
final MethodHandle fallbackFolded;
if (nextComponent == null) {
fallbackFolded = MethodHandles.dropArguments(CONSTANT_NULL_DROP_METHOD_HANDLE, 1,
type.parameterList()).asType(type.insertParameterTypes(0, MethodHandle.class));
} else {
fallbackFolded = MethodHandles.dropArguments(nextComponent.getGuardedInvocation().getInvocation(),
0, MethodHandle.class);
}
final MethodHandle compositeSetter = MethodHandles.foldArguments(MethodHandles.guardWithTest(
IS_METHOD_HANDLE_NOT_NULL, invokeHandleFolded, fallbackFolded), typedGetter);
if(nextComponent == null) {
return getClassGuardedInvocationComponent(compositeSetter, type);
}
return nextComponent.compose(compositeSetter, getClassGuard(type), clazz, ValidationType.EXACT_CLASS);
}
private GuardedInvocationComponent getNamedPropertySetter(final ComponentLinkRequest req) throws Exception {
final CallSiteDescriptor callSiteDescriptor = req.getDescriptor();
assertParameterCount(callSiteDescriptor, 2);
final GuardedInvocation gi = createGuardedDynamicMethodInvocation(callSiteDescriptor, req.linkerServices,
req.name.toString(), propertySetters);
if(gi != null) {
return new GuardedInvocationComponent(gi, clazz, ValidationType.EXACT_CLASS);
}
return getNextComponent(req);
}
private static final Lookup privateLookup = new Lookup(MethodHandles.lookup());
private static final MethodHandle IS_ANNOTATED_METHOD_NOT_NULL = Guards.isNotNull().asType(MethodType.methodType(
boolean.class, AnnotatedDynamicMethod.class));
private static final MethodHandle CONSTANT_NULL_DROP_ANNOTATED_METHOD = MethodHandles.dropArguments(
MethodHandles.constant(Object.class, null), 0, AnnotatedDynamicMethod.class);
private static final MethodHandle GET_ANNOTATED_METHOD = privateLookup.findVirtual(AnnotatedDynamicMethod.class,
"getTarget", MethodType.methodType(MethodHandle.class, CallSiteDescriptor.class, LinkerServices.class));
private static final MethodHandle GETTER_INVOKER = MethodHandles.invoker(MethodType.methodType(Object.class, Object.class));
private GuardedInvocationComponent getPropertyGetter(final ComponentLinkRequest req) throws Exception {
if (req.name == null) {
return getUnnamedPropertyGetter(req);
}
return getNamedPropertyGetter(req);
}
private GuardedInvocationComponent getUnnamedPropertyGetter(final ComponentLinkRequest req) throws Exception {
final CallSiteDescriptor callSiteDescriptor = req.getDescriptor();
final MethodType type = callSiteDescriptor.getMethodType().changeReturnType(Object.class);
assertParameterCount(callSiteDescriptor, 2);
final LinkerServices linkerServices = req.linkerServices;
final MethodHandle typedGetter = linkerServices.asType(getPropertyGetterHandle, type.changeReturnType(
AnnotatedDynamicMethod.class));
final MethodHandle callSiteBoundMethodGetter = MethodHandles.insertArguments(
GET_ANNOTATED_METHOD, 1, callSiteDescriptor, linkerServices);
final MethodHandle callSiteBoundInvoker = MethodHandles.filterArguments(GETTER_INVOKER, 0,
callSiteBoundMethodGetter);
final MethodHandle invokeHandleTyped = linkerServices.asType(callSiteBoundInvoker,
MethodType.methodType(type.returnType(), AnnotatedDynamicMethod.class, type.parameterType(0)));
final MethodHandle invokeHandleFolded = MethodHandles.dropArguments(invokeHandleTyped, 2,
type.parameterType(1));
final GuardedInvocationComponent nextComponent = getNextComponent(req);
final MethodHandle fallbackFolded;
if(nextComponent == null) {
fallbackFolded = MethodHandles.dropArguments(CONSTANT_NULL_DROP_ANNOTATED_METHOD, 1,
type.parameterList()).asType(type.insertParameterTypes(0, AnnotatedDynamicMethod.class));
} else {
final MethodHandle nextInvocation = nextComponent.getGuardedInvocation().getInvocation();
final MethodType nextType = nextInvocation.type();
fallbackFolded = MethodHandles.dropArguments(nextInvocation.asType(
nextType.changeReturnType(Object.class)), 0, AnnotatedDynamicMethod.class);
}
final MethodHandle compositeGetter = MethodHandles.foldArguments(MethodHandles.guardWithTest(
IS_ANNOTATED_METHOD_NOT_NULL, invokeHandleFolded, fallbackFolded), typedGetter);
if(nextComponent == null) {
return getClassGuardedInvocationComponent(compositeGetter, type);
}
return nextComponent.compose(compositeGetter, getClassGuard(type), clazz, ValidationType.EXACT_CLASS);
}
private GuardedInvocationComponent getNamedPropertyGetter(final ComponentLinkRequest req) throws Exception {
final CallSiteDescriptor callSiteDescriptor = req.getDescriptor();
assertParameterCount(callSiteDescriptor, 1);
final AnnotatedDynamicMethod annGetter = propertyGetters.get(req.name.toString());
if(annGetter == null) {
return getNextComponent(req);
}
final MethodHandle getter = annGetter.getInvocation(req);
final ValidationType validationType = annGetter.validationType;
return new GuardedInvocationComponent(getter, getGuard(validationType,
callSiteDescriptor.getMethodType()), clazz, validationType);
}
private MethodHandle getGuard(final ValidationType validationType, final MethodType methodType) {
switch(validationType) {
case EXACT_CLASS: {
return getClassGuard(methodType);
}
case INSTANCE_OF: {
return getAssignableGuard(methodType);
}
case IS_ARRAY: {
return Guards.isArray(0, methodType);
}
case NONE: {
return null;
}
default: {
throw new AssertionError();
}
}
}
private static final MethodHandle IS_DYNAMIC_METHOD = Guards.isInstance(DynamicMethod.class,
MethodType.methodType(boolean.class, Object.class));
private static final MethodHandle OBJECT_IDENTITY = MethodHandles.identity(Object.class);
private GuardedInvocationComponent getMethodGetter(final ComponentLinkRequest req) throws Exception {
if (req.name == null) {
return getUnnamedMethodGetter(req);
}
return getNamedMethodGetter(req);
}
private static MethodType getMethodGetterType(final ComponentLinkRequest req) {
return req.getDescriptor().getMethodType().changeReturnType(Object.class);
}
private GuardedInvocationComponent getUnnamedMethodGetter(final ComponentLinkRequest req) throws Exception {
assertParameterCount(req.getDescriptor(), 2);
final GuardedInvocationComponent nextComponent = getNextComponent(req);
final LinkerServices linkerServices = req.linkerServices;
final MethodType type = getMethodGetterType(req);
if(nextComponent == null) {
return getClassGuardedInvocationComponent(linkerServices.asType(getDynamicMethod, type), type);
}
final MethodHandle typedGetter = linkerServices.asType(getDynamicMethod, type);
final MethodHandle returnMethodHandle = linkerServices.asType(MethodHandles.dropArguments(
OBJECT_IDENTITY, 1, type.parameterList()), type.insertParameterTypes(0, Object.class));
final MethodHandle nextComponentInvocation = nextComponent.getGuardedInvocation().getInvocation();
assert nextComponentInvocation.type().changeReturnType(type.returnType()).equals(type);
final MethodHandle nextCombinedInvocation = MethodHandles.dropArguments(nextComponentInvocation, 0,
Object.class);
final MethodHandle compositeGetter = MethodHandles.foldArguments(MethodHandles.guardWithTest(
IS_DYNAMIC_METHOD, returnMethodHandle,
nextCombinedInvocation.asType(nextCombinedInvocation.type().changeReturnType(Object.class))),
typedGetter);
return nextComponent.compose(compositeGetter, getClassGuard(type), clazz, ValidationType.EXACT_CLASS);
}
private GuardedInvocationComponent getNamedMethodGetter(final ComponentLinkRequest req)
throws Exception {
assertParameterCount(req.getDescriptor(), 1);
final DynamicMethod method = getDynamicMethod(req.name.toString());
if(method == null) {
return getNextComponent(req);
}
final MethodType type = getMethodGetterType(req);
return getClassGuardedInvocationComponent(req.linkerServices.asType(MethodHandles.dropArguments(
MethodHandles.constant(Object.class, method), 0, type.parameterType(0)), type), type);
}
static class MethodPair {
final MethodHandle method1;
final MethodHandle method2;
MethodPair(final MethodHandle method1, final MethodHandle method2) {
this.method1 = method1;
this.method2 = method2;
}
MethodHandle guardWithTest(final MethodHandle test) {
return MethodHandles.guardWithTest(test, method1, method2);
}
}
static MethodPair matchReturnTypes(final MethodHandle m1, final MethodHandle m2) {
final MethodType type1 = m1.type();
final MethodType type2 = m2.type();
final Class<?> commonRetType = InternalTypeUtilities.getCommonLosslessConversionType(type1.returnType(),
type2.returnType());
return new MethodPair(
m1.asType(type1.changeReturnType(commonRetType)),
m2.asType(type2.changeReturnType(commonRetType)));
}
private static void assertParameterCount(final CallSiteDescriptor descriptor, final int paramCount) {
if(descriptor.getMethodType().parameterCount() != paramCount) {
throw new BootstrapMethodError(descriptor.getOperation() + " must have exactly " + paramCount + " parameters.");
}
}
private static final MethodHandle GET_PROPERTY_GETTER_HANDLE = MethodHandles.dropArguments(privateLookup.findOwnSpecial(
"getPropertyGetterHandle", Object.class, Object.class), 1, Object.class);
private final MethodHandle getPropertyGetterHandle = GET_PROPERTY_GETTER_HANDLE.bindTo(this);
@SuppressWarnings("unused")
private Object getPropertyGetterHandle(final Object id) {
return propertyGetters.get(String.valueOf(id));
}
private static final MethodHandle GET_PROPERTY_SETTER_HANDLE = MethodHandles.dropArguments(MethodHandles.dropArguments(
privateLookup.findOwnSpecial("getPropertySetterHandle", MethodHandle.class, CallSiteDescriptor.class,
LinkerServices.class, Object.class), 3, Object.class), 5, Object.class);
private final MethodHandle getPropertySetterHandle = GET_PROPERTY_SETTER_HANDLE.bindTo(this);
@SuppressWarnings("unused")
private MethodHandle getPropertySetterHandle(final CallSiteDescriptor setterDescriptor, final LinkerServices linkerServices,
final Object id) {
return getDynamicMethodInvocation(setterDescriptor, linkerServices, String.valueOf(id), propertySetters);
}
private static final MethodHandle GET_DYNAMIC_METHOD = MethodHandles.dropArguments(privateLookup.findOwnSpecial(
"getDynamicMethod", Object.class, Object.class), 1, Object.class);
private final MethodHandle getDynamicMethod = GET_DYNAMIC_METHOD.bindTo(this);
@SuppressWarnings("unused")
private Object getDynamicMethod(final Object name) {
return getDynamicMethod(String.valueOf(name), methods);
}
DynamicMethod getDynamicMethod(final String name) {
return getDynamicMethod(name, methods);
}
private static Method getMostGenericGetter(final Method getter) {
return getMostGenericGetter(getter.getName(), getter.getDeclaringClass());
}
private static Method getMostGenericGetter(final String name, final Class<?> declaringClass) {
if(declaringClass == null) {
return null;
}
for(final Class<?> itf: declaringClass.getInterfaces()) {
final Method itfGetter = getMostGenericGetter(name, itf);
if(itfGetter != null) {
return itfGetter;
}
}
final Method superGetter = getMostGenericGetter(name, declaringClass.getSuperclass());
if(superGetter != null) {
return superGetter;
}
if(!CheckRestrictedPackage.isRestrictedClass(declaringClass)) {
try {
return declaringClass.getMethod(name);
} catch(final NoSuchMethodException e) {
}
}
return null;
}
private static final class AnnotatedDynamicMethod {
private final SingleDynamicMethod method;
final ValidationType validationType;
AnnotatedDynamicMethod(final SingleDynamicMethod method, final ValidationType validationType) {
this.method = method;
this.validationType = validationType;
}
MethodHandle getInvocation(final ComponentLinkRequest req) {
return method.getInvocation(req.getDescriptor(), req.linkerServices);
}
@SuppressWarnings("unused")
MethodHandle getTarget(final CallSiteDescriptor desc, final LinkerServices linkerServices) {
final MethodHandle inv = linkerServices.filterInternalObjects(method.getTarget(desc));
assert inv != null;
return inv;
}
}
}
package jdk.vm.ci.meta;
public abstract class AbstractJavaProfile<T extends AbstractProfiledItem<U>, U> {
private final double notRecordedProbability;
private final T[] pitems;
@SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "caller transfers ownership of the `pitems` array parameter")
public AbstractJavaProfile(double notRecordedProbability, T[] pitems) {
this.pitems = pitems;
assert !Double.isNaN(notRecordedProbability);
this.notRecordedProbability = notRecordedProbability;
assert isSorted();
assert totalProbablility() >= 0 && totalProbablility() <= 1.0001 : totalProbablility() + " " + this;
}
private double totalProbablility() {
double total = notRecordedProbability;
for (T item : pitems) {
total += item.probability;
}
return total;
}
private boolean isSorted() {
for (int i = 1; i < pitems.length; i++) {
if (pitems[i - 1].getProbability() < pitems[i].getProbability()) {
return false;
}
}
return true;
}
public double getNotRecordedProbability() {
return notRecordedProbability;
}
protected T[] getItems() {
return pitems;
}
public T findEntry(ResolvedJavaType type) {
if (pitems != null) {
for (T pt : pitems) {
if (pt.getItem().equals(type)) {
return pt;
}
}
}
return null;
}
@Override
public String toString() {
StringBuilder builder = new StringBuilder();
builder.append(this.getClass().getName());
builder.append("[");
if (pitems != null) {
for (T pt : pitems) {
builder.append(pt.toString());
builder.append(", ");
}
}
builder.append(this.notRecordedProbability);
builder.append("]");
return builder.toString();
}
public boolean isIncluded(U item) {
if (this.getNotRecordedProbability() > 0.0) {
return true;
} else {
for (int i = 0; i < getItems().length; i++) {
T pitem = getItems()[i];
U curType = pitem.getItem();
if (curType == item) {
return true;
}
}
}
return false;
}
@Override
public boolean equals(Object obj) {
if (obj == this) {
return true;
}
if (!(obj instanceof AbstractJavaProfile)) {
return false;
}
AbstractJavaProfile<?, ?> that = (AbstractJavaProfile<?, ?>) obj;
if (that.notRecordedProbability != notRecordedProbability) {
return false;
}
if (that.pitems.length != pitems.length) {
return false;
}
for (int i = 0; i < pitems.length; ++i) {
if (!pitems[i].equals(that.pitems[i])) {
return false;
}
}
return true;
}
@Override
public int hashCode() {
return (int) Double.doubleToLongBits(notRecordedProbability) + pitems.length * 13;
}
}
package jdk.jfr.events;
import jdk.jfr.Enabled;
import jdk.jfr.Event;
import jdk.jfr.Registered;
import jdk.jfr.StackTrace;
@Registered(false)
@Enabled(false)
@StackTrace(false)
abstract class AbstractJDKEvent extends Event {
}
package com.sun.tools.jdi;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.InternalException;
import com.sun.jdi.VirtualMachine;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
import com.sun.jdi.connect.LaunchingConnector;
import com.sun.jdi.connect.VMStartException;
import com.sun.jdi.connect.spi.Connection;
import com.sun.jdi.connect.spi.TransportService;
abstract class AbstractLauncher extends ConnectorImpl
implements LaunchingConnector
{
public abstract VirtualMachine
launch(Map<String, ? extends Connector.Argument> arguments)
throws IOException, IllegalConnectorArgumentsException,
VMStartException;
public abstract String name();
public abstract String description();
ThreadGroup grp;
AbstractLauncher() {
super();
grp = Thread.currentThread().getThreadGroup();
ThreadGroup parent = null;
while ((parent = grp.getParent()) != null) {
grp = parent;
}
}
String[] tokenizeCommand(String command, char quote) {
String quoteStr = String.valueOf(quote);
StringTokenizer tokenizer = new StringTokenizer(command,
quote + " \t\r\n\f",
true);
String quoted = null;
String pending = null;
List<String> tokenList = new ArrayList<>();
while (tokenizer.hasMoreTokens()) {
String token = tokenizer.nextToken();
if (quoted != null) {
if (token.equals(quoteStr)) {
tokenList.add(quoted);
quoted = null;
} else {
quoted += token;
}
} else if (pending != null) {
if (token.equals(quoteStr)) {
quoted = pending;
} else if ((token.length() == 1) &&
Character.isWhitespace(token.charAt(0))) {
tokenList.add(pending);
} else {
throw new InternalException("Unexpected token: " + token);
}
pending = null;
} else {
if (token.equals(quoteStr)) {
quoted = "";
} else if ((token.length() == 1) &&
Character.isWhitespace(token.charAt(0))) {
} else {
pending = token;
}
}
}
if (pending != null) {
tokenList.add(pending);
}
if (quoted != null) {
tokenList.add(quoted);
}
String[] tokenArray = new String[tokenList.size()];
for (int i = 0; i < tokenList.size(); i++) {
tokenArray[i] = tokenList.get(i);
}
return tokenArray;
}
protected VirtualMachine launch(String[] commandArray, String address,
TransportService.ListenKey listenKey,
TransportService ts)
throws IOException, VMStartException {
Helper helper = new Helper(commandArray, address, listenKey, ts);
helper.launchAndAccept();
VirtualMachineManager manager =
Bootstrap.virtualMachineManager();
return manager.createVirtualMachine(helper.connection(),
helper.process());
}
private class Helper {
@SuppressWarnings("unused")
private final String address;
private TransportService.ListenKey listenKey;
private TransportService ts;
private final String[] commandArray;
private Process process = null;
private Connection connection = null;
private IOException acceptException = null;
private boolean exited = false;
Helper(String[] commandArray, String address, TransportService.ListenKey listenKey,
TransportService ts) {
this.commandArray = commandArray;
this.address = address;
this.listenKey = listenKey;
this.ts = ts;
}
String commandString() {
String str = "";
for (int i = 0; i < commandArray.length; i++) {
if (i > 0) {
str += " ";
}
str += commandArray[i];
}
return str;
}
synchronized void launchAndAccept() throws
IOException, VMStartException {
process = Runtime.getRuntime().exec(commandArray);
Thread acceptingThread = acceptConnection();
Thread monitoringThread = monitorTarget();
try {
while ((connection == null) &&
(acceptException == null) &&
!exited) {
wait();
}
if (exited) {
throw new VMStartException(
"VM initialization failed for: " + commandString(), process);
}
if (acceptException != null) {
throw acceptException;
}
} catch (InterruptedException e) {
throw new InterruptedIOException("Interrupted during accept");
} finally {
acceptingThread.interrupt();
monitoringThread.interrupt();
}
}
Process process() {
return process;
}
Connection connection() {
return connection;
}
synchronized void notifyOfExit() {
exited = true;
notify();
}
synchronized void notifyOfConnection(Connection connection) {
this.connection = connection;
notify();
}
synchronized void notifyOfAcceptException(IOException acceptException) {
this.acceptException = acceptException;
notify();
}
Thread monitorTarget() {
Thread thread = new Thread(grp, "launched target monitor") {
public void run() {
try {
process.waitFor();
notifyOfExit();
} catch (InterruptedException e) {
}
}
};
thread.setDaemon(true);
thread.start();
return thread;
}
Thread acceptConnection() {
Thread thread = new Thread(grp, "connection acceptor") {
public void run() {
try {
Connection connection = ts.accept(listenKey, 0, 0);
notifyOfConnection(connection);
} catch (InterruptedIOException e) {
} catch (IOException e) {
notifyOfAcceptException(e);
}
}
};
thread.setDaemon(true);
thread.start();
return thread;
}
}
}
package java.lang.foreign;
import java.util.Objects;
import java.util.Optional;
import jdk.internal.foreign.Utils;
import jdk.internal.vm.annotation.ForceInline;
import jdk.internal.vm.annotation.Stable;
abstract non-sealed class AbstractLayout implements MemoryLayout {
private final long size;
final long alignment;
private final Optional<String> name;
@Stable
long cachedSize;
public AbstractLayout(long size, long alignment, Optional<String> name) {
this.size = size;
this.alignment = alignment;
this.name = name;
}
@Override
public AbstractLayout withName(String name) {
Objects.requireNonNull(name);
return dup(alignment, Optional.of(name));
}
@Override
public final Optional<String> name() {
return name;
}
abstract AbstractLayout dup(long alignment, Optional<String> name);
@Override
public AbstractLayout withBitAlignment(long alignmentBits) {
checkAlignment(alignmentBits);
return dup(alignmentBits, name);
}
void checkAlignment(long alignmentBitCount) {
if (((alignmentBitCount & (alignmentBitCount - 1)) != 0L) ||                 (alignmentBitCount < 8)) {             throw new IllegalArgumentException("Invalid alignment: " + alignmentBitCount);
}
}
static void checkSize(long size) {
checkSize(size, false);
}
static void checkSize(long size, boolean includeZero) {
if (size < 0 || (!includeZero && size == 0)) {
throw new IllegalArgumentException("Invalid size for layout: " + size);
}
}
@Override
public final long bitAlignment() {
return alignment;
}
@Override
@ForceInline
public long byteSize() {
if (cachedSize == 0) {
cachedSize = Utils.bitsToBytesOrThrow(bitSize(),
() -> new UnsupportedOperationException("Cannot compute byte size; bit size is not a multiple of 8"));
}
return cachedSize;
}
@Override
public long bitSize() {
return size;
}
String decorateLayoutString(String s) {
if (name().isPresent()) {
s = String.format("%s(%s)", s, name().get());
}
if (!hasNaturalAlignment()) {
s = alignment + "%" + s;
}
return s;
}
boolean hasNaturalAlignment() {
return size == alignment;
}
@Override
public boolean isPadding() {
return this instanceof PaddingLayout;
}
@Override
public int hashCode() {
return Objects.hash(name, size, alignment);
}
@Override
public boolean equals(Object other) {
if (this == other) {
return true;
}
return other instanceof AbstractLayout otherLayout &&
name.equals(otherLayout.name) &&
size == otherLayout.size &&
alignment == otherLayout.alignment;
}
public abstract String toString();
}
package javax.swing.tree;
import javax.swing.event.TreeModelEvent;
import java.awt.Rectangle;
import java.beans.BeanProperty;
import java.util.Enumeration;
@SuppressWarnings("serial") public abstract class AbstractLayoutCache implements RowMapper {
protected NodeDimensions     nodeDimensions;
protected TreeModel          treeModel;
protected TreeSelectionModel treeSelectionModel;
protected boolean            rootVisible;
protected int                rowHeight;
protected AbstractLayoutCache() {}
public void setNodeDimensions(NodeDimensions nd) {
this.nodeDimensions = nd;
}
public NodeDimensions getNodeDimensions() {
return nodeDimensions;
}
public void setModel(TreeModel newModel) {
treeModel = newModel;
}
public TreeModel getModel() {
return treeModel;
}
@BeanProperty(description
= "Whether or not the root node from the TreeModel is visible.")
public void setRootVisible(boolean rootVisible) {
this.rootVisible = rootVisible;
}
public boolean isRootVisible() {
return rootVisible;
}
@BeanProperty(description
= "The height of each cell.")
public void setRowHeight(int rowHeight) {
this.rowHeight = rowHeight;
}
public int getRowHeight() {
return rowHeight;
}
public void setSelectionModel(TreeSelectionModel newLSM) {
if(treeSelectionModel != null)
treeSelectionModel.setRowMapper(null);
treeSelectionModel = newLSM;
if(treeSelectionModel != null)
treeSelectionModel.setRowMapper(this);
}
public TreeSelectionModel getSelectionModel() {
return treeSelectionModel;
}
public int getPreferredHeight() {
int           rowCount = getRowCount();
if(rowCount > 0) {
Rectangle     bounds = getBounds(getPathForRow(rowCount - 1),
null);
if(bounds != null)
return bounds.y + bounds.height;
}
return 0;
}
public int getPreferredWidth(Rectangle bounds) {
int           rowCount = getRowCount();
if(rowCount > 0) {
TreePath      firstPath;
int           endY;
if(bounds == null) {
firstPath = getPathForRow(0);
endY = Integer.MAX_VALUE;
}
else {
firstPath = getPathClosestTo(bounds.x, bounds.y);
endY = bounds.height + bounds.y;
}
Enumeration<TreePath> paths = getVisiblePathsFrom(firstPath);
if(paths != null && paths.hasMoreElements()) {
Rectangle   pBounds = getBounds(paths.nextElement(),
null);
int         width;
if(pBounds != null) {
width = pBounds.x + pBounds.width;
if (pBounds.y >= endY) {
return width;
}
}
else
width = 0;
while (pBounds != null && paths.hasMoreElements()) {
pBounds = getBounds(paths.nextElement(),
pBounds);
if (pBounds != null && pBounds.y < endY) {
width = Math.max(width, pBounds.x + pBounds.width);
}
else {
pBounds = null;
}
}
return width;
}
}
return 0;
}
public abstract boolean isExpanded(TreePath path);
public abstract Rectangle getBounds(TreePath path, Rectangle placeIn);
public abstract TreePath getPathForRow(int row);
public abstract int getRowForPath(TreePath path);
public abstract TreePath getPathClosestTo(int x, int y);
public abstract Enumeration<TreePath> getVisiblePathsFrom(TreePath path);
public abstract int getVisibleChildCount(TreePath path);
public abstract void setExpandedState(TreePath path, boolean isExpanded);
public abstract boolean getExpandedState(TreePath path);
public abstract int getRowCount();
public abstract void invalidateSizes();
public abstract void invalidatePathBounds(TreePath path);
public abstract void treeNodesChanged(TreeModelEvent e);
public abstract void treeNodesInserted(TreeModelEvent e);
public abstract void treeNodesRemoved(TreeModelEvent e);
public abstract void treeStructureChanged(TreeModelEvent e);
public int[] getRowsForPaths(TreePath[] paths) {
if(paths == null)
return null;
int               numPaths = paths.length;
int[]             rows = new int[numPaths];
for(int counter = 0; counter < numPaths; counter++)
rows[counter] = getRowForPath(paths[counter]);
return rows;
}
protected Rectangle getNodeDimensions(Object value, int row, int depth,
boolean expanded,
Rectangle placeIn) {
NodeDimensions            nd = getNodeDimensions();
if(nd != null) {
return nd.getNodeDimensions(value, row, depth, expanded, placeIn);
}
return null;
}
protected boolean isFixedRowHeight() {
return (rowHeight > 0);
}
public abstract static class NodeDimensions {
protected NodeDimensions() {}
public abstract Rectangle getNodeDimensions(Object value, int row,
int depth,
boolean expanded,
Rectangle bounds);
}
}
package com.sun.jndi.ldap;
import com.sun.jndi.toolkit.ctx.Continuation;
import java.util.NoSuchElementException;
import java.util.Vector;
import javax.naming.*;
import javax.naming.directory.Attributes;
import javax.naming.ldap.Control;
abstract class AbstractLdapNamingEnumeration<T extends NameClassPair>
implements NamingEnumeration<T>, ReferralEnumeration<T> {
protected Name listArg;
private boolean cleaned = false;
private LdapResult res;
private LdapClient enumClnt;
private Continuation cont;      private Vector<LdapEntry> entries = null;
private int limit = 0;
private int posn = 0;
protected LdapCtx homeCtx;
private LdapReferralException refEx = null;
private NamingException errEx = null;
AbstractLdapNamingEnumeration(LdapCtx homeCtx, LdapResult answer, Name listArg,
Continuation cont) throws NamingException {
if ((answer.status != LdapClient.LDAP_SUCCESS) &&
(answer.status != LdapClient.LDAP_SIZE_LIMIT_EXCEEDED) &&
(answer.status != LdapClient.LDAP_TIME_LIMIT_EXCEEDED) &&
(answer.status != LdapClient.LDAP_ADMIN_LIMIT_EXCEEDED) &&
(answer.status != LdapClient.LDAP_REFERRAL) &&
(answer.status != LdapClient.LDAP_PARTIAL_RESULTS)) {
NamingException e = new NamingException(
LdapClient.getErrorMessage(
answer.status, answer.errorMessage));
throw cont.fillInException(e);
}
res = answer;
entries = answer.entries;
limit = (entries == null) ? 0 : entries.size();             this.listArg = listArg;
this.cont = cont;
if (answer.refEx != null) {
refEx = answer.refEx;
}
this.homeCtx = homeCtx;
homeCtx.incEnumCount();
enumClnt = homeCtx.clnt;     }
@Override
public final T nextElement() {
try {
return next();
} catch (NamingException e) {
cleanup();
return null;
}
}
@Override
public final boolean hasMoreElements() {
try {
return hasMore();
} catch (NamingException e) {
cleanup();
return false;
}
}
private void getNextBatch() throws NamingException {
res = homeCtx.getSearchReply(enumClnt, res);
if (res == null) {
limit = posn = 0;
return;
}
entries = res.entries;
limit = (entries == null) ? 0 : entries.size();         posn = 0;
if ((res.status != LdapClient.LDAP_SUCCESS) ||
((res.status == LdapClient.LDAP_SUCCESS) &&
(res.referrals != null))) {
try {
homeCtx.processReturnCode(res, listArg);
} catch (LimitExceededException | PartialResultException e) {
setNamingException(e);
}
}
if (res.refEx != null) {
if (refEx == null) {
refEx = res.refEx;
} else {
refEx = refEx.appendUnprocessedReferrals(res.refEx);
}
res.refEx = null;         }
if (res.resControls != null) {
homeCtx.respCtls = res.resControls;
}
}
private boolean more = true;      private boolean hasMoreCalled = false;
@Override
public final boolean hasMore() throws NamingException {
if (hasMoreCalled) {
return more;
}
hasMoreCalled = true;
if (!more) {
return false;
} else {
return (more = hasMoreImpl());
}
}
@Override
public final T next() throws NamingException {
if (!hasMoreCalled) {
hasMore();
}
hasMoreCalled = false;
return nextImpl();
}
private boolean hasMoreImpl() throws NamingException {
if (posn == limit) {
getNextBatch();
}
if (posn < limit) {
return true;
} else {
try {
return hasMoreReferrals();
} catch (LdapReferralException |
LimitExceededException |
PartialResultException e) {
cleanup();
throw e;
} catch (NamingException e) {
cleanup();
PartialResultException pre = new PartialResultException();
pre.setRootCause(e);
throw pre;
}
}
}
private T nextImpl() throws NamingException {
try {
return nextAux();
} catch (NamingException e) {
cleanup();
throw cont.fillInException(e);
}
}
private T nextAux() throws NamingException {
if (posn == limit) {
getNextBatch();          }
if (posn >= limit) {
cleanup();
throw new NoSuchElementException("invalid enumeration handle");
}
LdapEntry result = entries.elementAt(posn++);
return createItem(result.DN, result.attributes, result.respCtls);
}
protected final String getAtom(String dn) {
try {
Name parsed = new LdapName(dn);
return parsed.get(parsed.size() - 1);
} catch (NamingException e) {
return dn;
}
}
protected abstract T createItem(String dn, Attributes attrs,
Vector<Control> respCtls) throws NamingException;
@Override
public void appendUnprocessedReferrals(LdapReferralException ex) {
if (refEx != null) {
refEx = refEx.appendUnprocessedReferrals(ex);
} else {
refEx = ex.appendUnprocessedReferrals(refEx);
}
}
final void setNamingException(NamingException e) {
errEx = e;
}
protected abstract AbstractLdapNamingEnumeration<? extends NameClassPair> getReferredResults(
LdapReferralContext refCtx) throws NamingException;
protected final boolean hasMoreReferrals() throws NamingException {
if ((refEx != null) && !(errEx instanceof LimitExceededException) &&
(refEx.hasMoreReferrals() || refEx.hasMoreReferralExceptions())) {
if (homeCtx.handleReferrals == LdapClient.LDAP_REF_THROW) {
throw (NamingException)(refEx.fillInStackTrace());
}
while (true) {
LdapReferralContext refCtx =
(LdapReferralContext)refEx.getReferralContext(
homeCtx.envprops, homeCtx.reqCtls);
try {
update(getReferredResults(refCtx));
break;
} catch (LdapReferralException re) {
var namingException = re.getNamingException();
if (namingException instanceof LimitExceededException) {
errEx = namingException;
break;
} else if (errEx == null) {
errEx = namingException;
}
refEx = re;
continue;
} finally {
refCtx.close();
}
}
return hasMoreImpl();
} else {
cleanup();
if (errEx != null) {
throw errEx;
}
return (false);
}
}
protected void update(AbstractLdapNamingEnumeration<? extends NameClassPair> ne) {
homeCtx.decEnumCount();
homeCtx = ne.homeCtx;
enumClnt = ne.enumClnt;
ne.homeCtx = null;
posn = ne.posn;
limit = ne.limit;
res = ne.res;
entries = ne.entries;
refEx = ne.refEx;
listArg = ne.listArg;
if (errEx == null || ne.errEx instanceof LimitExceededException) {
errEx = ne.errEx;
}
}
@SuppressWarnings("removal")
protected final void finalize() {
cleanup();
}
protected final void cleanup() {
if (cleaned) return;
if(enumClnt != null) {
enumClnt.clearSearchReply(res, homeCtx.reqCtls);
}
enumClnt = null;
cleaned = true;
if (homeCtx != null) {
homeCtx.decEnumCount();
homeCtx = null;
}
}
@Override
public final void close() {
cleanup();
}
}
package build.tools.cldrconverter;
import build.tools.cldrconverter.CLDRConverter.DraftType;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.helpers.DefaultHandler;
abstract class AbstractLDMLHandler<V> extends DefaultHandler {
static final Map<String, String> DAY_OF_WEEK_MAP = new HashMap<>();
static {
DAY_OF_WEEK_MAP.put("sun", "1");
DAY_OF_WEEK_MAP.put("mon", "2");
DAY_OF_WEEK_MAP.put("tue", "3");
DAY_OF_WEEK_MAP.put("wed", "4");
DAY_OF_WEEK_MAP.put("thu", "5");
DAY_OF_WEEK_MAP.put("fri", "6");
DAY_OF_WEEK_MAP.put("sat", "7");
}
private Map<String, V> data = new HashMap<>();
Container currentContainer = new Container("$ROOT", null);
AbstractLDMLHandler() {
}
Map<String, V> getData() {
return data;
}
V put(String key, V value) {
return data.put(key, value);
}
V get(String key) {
return data.get(key);
}
Set<String> keySet() {
return data.keySet();
}
boolean isIgnored(Attributes attributes) {
if (attributes.getValue("alt") != null) {
return true;
}
String draftValue = attributes.getValue("draft");
if (draftValue != null) {
return DraftType.getDefault().ordinal() > DraftType.forKeyword(draftValue).ordinal();
}
return false;
}
void pushContainer(String qName, Attributes attributes) {
if (isIgnored(attributes) || currentContainer instanceof IgnoredContainer) {
currentContainer = new IgnoredContainer(qName, currentContainer);
} else {
currentContainer = new Container(qName, currentContainer);
}
}
void pushIgnoredContainer(String qName) {
currentContainer = new IgnoredContainer(qName, currentContainer);
}
void pushKeyContainer(String qName, Attributes attributes, String key) {
if (!pushIfIgnored(qName, attributes)) {
currentContainer = new KeyContainer(qName, currentContainer, key);
}
}
void pushStringEntry(String qName, Attributes attributes, String key) {
if (!pushIfIgnored(qName, attributes)) {
currentContainer = new StringEntry(qName, currentContainer, key);
}
}
void pushAliasEntry(String qName, Attributes attributes, String key) {
if (!pushIfIgnored(qName, attributes)) {
currentContainer = new AliasEntry(qName, currentContainer, key);
}
}
void pushStringEntry(String qName, Attributes attributes, String key, String value) {
if (!pushIfIgnored(qName, attributes)) {
currentContainer = new StringEntry(qName, currentContainer, key, value);
}
}
void pushStringArrayEntry(String qName, Attributes attributes, String key, int length) {
if (!pushIfIgnored(qName, attributes)) {
currentContainer = new StringArrayEntry(qName, currentContainer, key, length);
}
}
void pushStringArrayElement(String qName, Attributes attributes, int index) {
if (!pushIfIgnored(qName, attributes)) {
currentContainer = new StringArrayElement(qName, currentContainer, index);
}
}
void pushStringListEntry(String qName, Attributes attributes, String key) {
if (!pushIfIgnored(qName, attributes)) {
currentContainer = new StringListEntry(qName, currentContainer, key);
}
}
void pushStringListElement(String qName, Attributes attributes, int index, String count) {
if (!pushIfIgnored(qName, attributes)) {
currentContainer = new StringListElement(qName, currentContainer, index, count);
}
}
private boolean pushIfIgnored(String qName, Attributes attributes) {
if (isIgnored(attributes) || currentContainer instanceof IgnoredContainer) {
pushIgnoredContainer(qName);
return true;
}
return false;
}
String getContainerKey() {
Container current = currentContainer;
while (current != null) {
if (current instanceof KeyContainer) {
return ((KeyContainer) current).getKey();
}
current = current.getParent();
}
return null;
}
@Override
public void characters(char[] ch, int start, int length) throws SAXException {
currentContainer.addCharacters(ch, start, length);
}
@SuppressWarnings(value = "CallToThreadDumpStack")
@Override
public void warning(SAXParseException e) throws SAXException {
e.printStackTrace();
}
@SuppressWarnings(value = "CallToThreadDumpStack")
@Override
public void error(SAXParseException e) throws SAXException {
e.printStackTrace();
}
@SuppressWarnings(value = "CallToThreadDumpStack")
@Override
public void fatalError(SAXParseException e) throws SAXException {
e.printStackTrace();
super.fatalError(e);
}
}
package com.sun.media.sound;
import java.util.Map;
import java.util.Vector;
import java.util.WeakHashMap;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Control;
import javax.sound.sampled.Line;
import javax.sound.sampled.LineEvent;
import javax.sound.sampled.LineListener;
import javax.sound.sampled.LineUnavailableException;
abstract class AbstractLine implements Line {
protected final Line.Info info;
protected Control[] controls;
AbstractMixer mixer;
private volatile boolean open;
private final Vector<Object> listeners = new Vector<>();
private static final Map<ThreadGroup, EventDispatcher> dispatchers =
new WeakHashMap<>();
protected AbstractLine(Line.Info info, AbstractMixer mixer, Control[] controls) {
if (controls == null) {
controls = new Control[0];
}
this.info = info;
this.mixer = mixer;
this.controls = controls;
}
@Override
public final Line.Info getLineInfo() {
return info;
}
@Override
public final boolean isOpen() {
return open;
}
@Override
public final void addLineListener(LineListener listener) {
synchronized(listeners) {
if ( ! (listeners.contains(listener)) ) {
listeners.addElement(listener);
}
}
}
@Override
public final void removeLineListener(LineListener listener) {
listeners.removeElement(listener);
}
@Override
public final Control[] getControls() {
Control[] returnedArray = new Control[controls.length];
for (int i = 0; i < controls.length; i++) {
returnedArray[i] = controls[i];
}
return returnedArray;
}
@Override
public final boolean isControlSupported(Control.Type controlType) {
if (controlType == null) {
return false;
}
for (int i = 0; i < controls.length; i++) {
if (controlType == controls[i].getType()) {
return true;
}
}
return false;
}
@Override
public final Control getControl(Control.Type controlType) {
if (controlType != null) {
for (int i = 0; i < controls.length; i++) {
if (controlType == controls[i].getType()) {
return controls[i];
}
}
}
throw new IllegalArgumentException("Unsupported control type: " + controlType);
}
final void setOpen(boolean open) {
boolean sendEvents = false;
long position = getLongFramePosition();
if (this.open != open) {
this.open = open;
sendEvents = true;
}
if (sendEvents) {
if (open) {
sendEvents(new LineEvent(this, LineEvent.Type.OPEN, position));
} else {
sendEvents(new LineEvent(this, LineEvent.Type.CLOSE, position));
}
}
}
final void sendEvents(LineEvent event) {
getEventDispatcher().sendAudioEvents(event, listeners);
}
public final int getFramePosition() {
return (int) getLongFramePosition();
}
public long getLongFramePosition() {
return AudioSystem.NOT_SPECIFIED;
}
final AbstractMixer getMixer() {
return mixer;
}
final EventDispatcher getEventDispatcher() {
final ThreadGroup tg = Thread.currentThread().getThreadGroup();
synchronized (dispatchers) {
EventDispatcher eventDispatcher = dispatchers.get(tg);
if (eventDispatcher == null) {
eventDispatcher = new EventDispatcher();
dispatchers.put(tg, eventDispatcher);
eventDispatcher.start();
}
return eventDispatcher;
}
}
@Override
public abstract void open() throws LineUnavailableException;
@Override
public abstract void close();
}
package jdk.internal.foreign.abi;
import jdk.internal.foreign.SystemLookup;
import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;
import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;
import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;
import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.MemorySession;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodType;
import java.util.Objects;
public abstract sealed class AbstractLinker implements Linker permits LinuxAArch64Linker, MacOsAArch64Linker,
SysVx64Linker, Windowsx64Linker {
private final SoftReferenceCache<FunctionDescriptor, MethodHandle> DOWNCALL_CACHE = new SoftReferenceCache<>();
@Override
public MethodHandle downcallHandle(FunctionDescriptor function) {
Objects.requireNonNull(function);
return DOWNCALL_CACHE.get(function, fd -> {
MethodType type = SharedUtils.inferMethodType(fd, false);
MethodHandle handle = arrangeDowncall(type, fd);
handle = SharedUtils.maybeInsertAllocator(handle);
return handle;
});
}
protected abstract MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function);
@Override
public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession scope) {
Objects.requireNonNull(scope);
Objects.requireNonNull(target);
Objects.requireNonNull(function);
SharedUtils.checkExceptions(target);
MethodType type = SharedUtils.inferMethodType(function, true);
if (!type.equals(target.type())) {
throw new IllegalArgumentException("Wrong method handle type: " + target.type());
}
return arrangeUpcall(target, target.type(), function, scope);
}
protected abstract MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType,
FunctionDescriptor function, MemorySession scope);
@Override
public SystemLookup defaultLookup() {
return SystemLookup.getInstance();
}
}
package java.util;
import java.util.function.Consumer;
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
protected AbstractList() {
}
public boolean add(E e) {
add(size(), e);
return true;
}
public abstract E get(int index);
public E set(int index, E element) {
throw new UnsupportedOperationException();
}
public void add(int index, E element) {
throw new UnsupportedOperationException();
}
public E remove(int index) {
throw new UnsupportedOperationException();
}
public int indexOf(Object o) {
ListIterator<E> it = listIterator();
if (o==null) {
while (it.hasNext())
if (it.next()==null)
return it.previousIndex();
} else {
while (it.hasNext())
if (o.equals(it.next()))
return it.previousIndex();
}
return -1;
}
public int lastIndexOf(Object o) {
ListIterator<E> it = listIterator(size());
if (o==null) {
while (it.hasPrevious())
if (it.previous()==null)
return it.nextIndex();
} else {
while (it.hasPrevious())
if (o.equals(it.previous()))
return it.nextIndex();
}
return -1;
}
public void clear() {
removeRange(0, size());
}
public boolean addAll(int index, Collection<? extends E> c) {
rangeCheckForAdd(index);
boolean modified = false;
for (E e : c) {
add(index++, e);
modified = true;
}
return modified;
}
public Iterator<E> iterator() {
return new Itr();
}
public ListIterator<E> listIterator() {
return listIterator(0);
}
public ListIterator<E> listIterator(final int index) {
rangeCheckForAdd(index);
return new ListItr(index);
}
private class Itr implements Iterator<E> {
int cursor = 0;
int lastRet = -1;
int expectedModCount = modCount;
public boolean hasNext() {
return cursor != size();
}
public E next() {
checkForComodification();
try {
int i = cursor;
E next = get(i);
lastRet = i;
cursor = i + 1;
return next;
} catch (IndexOutOfBoundsException e) {
checkForComodification();
throw new NoSuchElementException(e);
}
}
public void remove() {
if (lastRet < 0)
throw new IllegalStateException();
checkForComodification();
try {
AbstractList.this.remove(lastRet);
if (lastRet < cursor)
cursor--;
lastRet = -1;
expectedModCount = modCount;
} catch (IndexOutOfBoundsException e) {
throw new ConcurrentModificationException();
}
}
final void checkForComodification() {
if (modCount != expectedModCount)
throw new ConcurrentModificationException();
}
}
private class ListItr extends Itr implements ListIterator<E> {
ListItr(int index) {
cursor = index;
}
public boolean hasPrevious() {
return cursor != 0;
}
public E previous() {
checkForComodification();
try {
int i = cursor - 1;
E previous = get(i);
lastRet = cursor = i;
return previous;
} catch (IndexOutOfBoundsException e) {
checkForComodification();
throw new NoSuchElementException(e);
}
}
public int nextIndex() {
return cursor;
}
public int previousIndex() {
return cursor-1;
}
public void set(E e) {
if (lastRet < 0)
throw new IllegalStateException();
checkForComodification();
try {
AbstractList.this.set(lastRet, e);
expectedModCount = modCount;
} catch (IndexOutOfBoundsException ex) {
throw new ConcurrentModificationException();
}
}
public void add(E e) {
checkForComodification();
try {
int i = cursor;
AbstractList.this.add(i, e);
lastRet = -1;
cursor = i + 1;
expectedModCount = modCount;
} catch (IndexOutOfBoundsException ex) {
throw new ConcurrentModificationException();
}
}
}
public List<E> subList(int fromIndex, int toIndex) {
subListRangeCheck(fromIndex, toIndex, size());
return (this instanceof RandomAccess ?
new RandomAccessSubList<>(this, fromIndex, toIndex) :
new SubList<>(this, fromIndex, toIndex));
}
static void subListRangeCheck(int fromIndex, int toIndex, int size) {
if (fromIndex < 0)
throw new IndexOutOfBoundsException("fromIndex = " + fromIndex);
if (toIndex > size)
throw new IndexOutOfBoundsException("toIndex = " + toIndex);
if (fromIndex > toIndex)
throw new IllegalArgumentException("fromIndex(" + fromIndex +
") > toIndex(" + toIndex + ")");
}
public boolean equals(Object o) {
if (o == this)
return true;
if (!(o instanceof List))
return false;
ListIterator<E> e1 = listIterator();
ListIterator<?> e2 = ((List<?>) o).listIterator();
while (e1.hasNext() && e2.hasNext()) {
E o1 = e1.next();
Object o2 = e2.next();
if (!(o1==null ? o2==null : o1.equals(o2)))
return false;
}
return !(e1.hasNext() || e2.hasNext());
}
public int hashCode() {
int hashCode = 1;
for (E e : this)
hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());
return hashCode;
}
protected void removeRange(int fromIndex, int toIndex) {
ListIterator<E> it = listIterator(fromIndex);
for (int i=0, n=toIndex-fromIndex; i<n; i++) {
it.next();
it.remove();
}
}
protected transient int modCount = 0;
private void rangeCheckForAdd(int index) {
if (index < 0 || index > size())
throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}
private String outOfBoundsMsg(int index) {
return "Index: "+index+", Size: "+size();
}
static final class RandomAccessSpliterator<E> implements Spliterator<E> {
private final List<E> list;
private int index;         private int fence;
private final AbstractList<E> alist;
private int expectedModCount;
RandomAccessSpliterator(List<E> list) {
assert list instanceof RandomAccess;
this.list = list;
this.index = 0;
this.fence = -1;
this.alist = list instanceof AbstractList ? (AbstractList<E>) list : null;
this.expectedModCount = alist != null ? alist.modCount : 0;
}
private RandomAccessSpliterator(RandomAccessSpliterator<E> parent,
int origin, int fence) {
this.list = parent.list;
this.index = origin;
this.fence = fence;
this.alist = parent.alist;
this.expectedModCount = parent.expectedModCount;
}
private int getFence() {             int hi;
List<E> lst = list;
if ((hi = fence) < 0) {
if (alist != null) {
expectedModCount = alist.modCount;
}
hi = fence = lst.size();
}
return hi;
}
public Spliterator<E> trySplit() {
int hi = getFence(), lo = index, mid = (lo + hi) >>> 1;
return (lo >= mid) ? null :                     new RandomAccessSpliterator<>(this, lo, index = mid);
}
public boolean tryAdvance(Consumer<? super E> action) {
if (action == null)
throw new NullPointerException();
int hi = getFence(), i = index;
if (i < hi) {
index = i + 1;
action.accept(get(list, i));
checkAbstractListModCount(alist, expectedModCount);
return true;
}
return false;
}
public void forEachRemaining(Consumer<? super E> action) {
Objects.requireNonNull(action);
List<E> lst = list;
int hi = getFence();
int i = index;
index = hi;
for (; i < hi; i++) {
action.accept(get(lst, i));
}
checkAbstractListModCount(alist, expectedModCount);
}
public long estimateSize() {
return (long) (getFence() - index);
}
public int characteristics() {
return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
}
private static <E> E get(List<E> list, int i) {
try {
return list.get(i);
} catch (IndexOutOfBoundsException ex) {
throw new ConcurrentModificationException();
}
}
static void checkAbstractListModCount(AbstractList<?> alist, int expectedModCount) {
if (alist != null && alist.modCount != expectedModCount) {
throw new ConcurrentModificationException();
}
}
}
private static class SubList<E> extends AbstractList<E> {
private final AbstractList<E> root;
private final SubList<E> parent;
private final int offset;
protected int size;
public SubList(AbstractList<E> root, int fromIndex, int toIndex) {
this.root = root;
this.parent = null;
this.offset = fromIndex;
this.size = toIndex - fromIndex;
this.modCount = root.modCount;
}
protected SubList(SubList<E> parent, int fromIndex, int toIndex) {
this.root = parent.root;
this.parent = parent;
this.offset = parent.offset + fromIndex;
this.size = toIndex - fromIndex;
this.modCount = root.modCount;
}
public E set(int index, E element) {
Objects.checkIndex(index, size);
checkForComodification();
return root.set(offset + index, element);
}
public E get(int index) {
Objects.checkIndex(index, size);
checkForComodification();
return root.get(offset + index);
}
public int size() {
checkForComodification();
return size;
}
public void add(int index, E element) {
rangeCheckForAdd(index);
checkForComodification();
root.add(offset + index, element);
updateSizeAndModCount(1);
}
public E remove(int index) {
Objects.checkIndex(index, size);
checkForComodification();
E result = root.remove(offset + index);
updateSizeAndModCount(-1);
return result;
}
protected void removeRange(int fromIndex, int toIndex) {
checkForComodification();
root.removeRange(offset + fromIndex, offset + toIndex);
updateSizeAndModCount(fromIndex - toIndex);
}
public boolean addAll(Collection<? extends E> c) {
return addAll(size, c);
}
public boolean addAll(int index, Collection<? extends E> c) {
rangeCheckForAdd(index);
int cSize = c.size();
if (cSize==0)
return false;
checkForComodification();
root.addAll(offset + index, c);
updateSizeAndModCount(cSize);
return true;
}
public Iterator<E> iterator() {
return listIterator();
}
public ListIterator<E> listIterator(int index) {
checkForComodification();
rangeCheckForAdd(index);
return new ListIterator<E>() {
private final ListIterator<E> i =
root.listIterator(offset + index);
public boolean hasNext() {
return nextIndex() < size;
}
public E next() {
if (hasNext())
return i.next();
else
throw new NoSuchElementException();
}
public boolean hasPrevious() {
return previousIndex() >= 0;
}
public E previous() {
if (hasPrevious())
return i.previous();
else
throw new NoSuchElementException();
}
public int nextIndex() {
return i.nextIndex() - offset;
}
public int previousIndex() {
return i.previousIndex() - offset;
}
public void remove() {
i.remove();
updateSizeAndModCount(-1);
}
public void set(E e) {
i.set(e);
}
public void add(E e) {
i.add(e);
updateSizeAndModCount(1);
}
};
}
public List<E> subList(int fromIndex, int toIndex) {
subListRangeCheck(fromIndex, toIndex, size);
return new SubList<>(this, fromIndex, toIndex);
}
private void rangeCheckForAdd(int index) {
if (index < 0 || index > size)
throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}
private String outOfBoundsMsg(int index) {
return "Index: "+index+", Size: "+size;
}
private void checkForComodification() {
if (root.modCount != this.modCount)
throw new ConcurrentModificationException();
}
private void updateSizeAndModCount(int sizeChange) {
SubList<E> slist = this;
do {
slist.size += sizeChange;
slist.modCount = root.modCount;
slist = slist.parent;
} while (slist != null);
}
}
private static class RandomAccessSubList<E>
extends SubList<E> implements RandomAccess {
RandomAccessSubList(AbstractList<E> root,
int fromIndex, int toIndex) {
super(root, fromIndex, toIndex);
}
RandomAccessSubList(RandomAccessSubList<E> parent,
int fromIndex, int toIndex) {
super(parent, fromIndex, toIndex);
}
public List<E> subList(int fromIndex, int toIndex) {
subListRangeCheck(fromIndex, toIndex, size);
return new RandomAccessSubList<>(this, fromIndex, toIndex);
}
}
}
package javax.swing;
import javax.swing.event.*;
import java.io.Serializable;
import java.util.EventListener;
@SuppressWarnings("serial") public abstract class AbstractListModel<E> implements ListModel<E>, Serializable
{
protected EventListenerList listenerList = new EventListenerList();
protected AbstractListModel() {}
public void addListDataListener(ListDataListener l) {
listenerList.add(ListDataListener.class, l);
}
public void removeListDataListener(ListDataListener l) {
listenerList.remove(ListDataListener.class, l);
}
public ListDataListener[] getListDataListeners() {
return listenerList.getListeners(ListDataListener.class);
}
protected void fireContentsChanged(Object source, int index0, int index1)
{
Object[] listeners = listenerList.getListenerList();
ListDataEvent e = null;
for (int i = listeners.length - 2; i >= 0; i -= 2) {
if (listeners[i] == ListDataListener.class) {
if (e == null) {
e = new ListDataEvent(source, ListDataEvent.CONTENTS_CHANGED, index0, index1);
}
((ListDataListener)listeners[i+1]).contentsChanged(e);
}
}
}
protected void fireIntervalAdded(Object source, int index0, int index1)
{
Object[] listeners = listenerList.getListenerList();
ListDataEvent e = null;
for (int i = listeners.length - 2; i >= 0; i -= 2) {
if (listeners[i] == ListDataListener.class) {
if (e == null) {
e = new ListDataEvent(source, ListDataEvent.INTERVAL_ADDED, index0, index1);
}
((ListDataListener)listeners[i+1]).intervalAdded(e);
}
}
}
protected void fireIntervalRemoved(Object source, int index0, int index1)
{
Object[] listeners = listenerList.getListenerList();
ListDataEvent e = null;
for (int i = listeners.length - 2; i >= 0; i -= 2) {
if (listeners[i] == ListDataListener.class) {
if (e == null) {
e = new ListDataEvent(source, ListDataEvent.INTERVAL_REMOVED, index0, index1);
}
((ListDataListener)listeners[i+1]).intervalRemoved(e);
}
}
}
public <T extends EventListener> T[] getListeners(Class<T> listenerType) {
return listenerList.getListeners(listenerType);
}
}
package com.sun.tools.javac.util;
import java.util.HashMap;
import java.util.Map;
import javax.tools.JavaFileObject;
import com.sun.tools.javac.code.Lint.LintCategory;
import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
import com.sun.tools.javac.util.JCDiagnostic.Error;
import com.sun.tools.javac.util.JCDiagnostic.Note;
import com.sun.tools.javac.util.JCDiagnostic.Warning;
import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
import com.sun.tools.javac.util.JCDiagnostic.SimpleDiagnosticPosition;
public abstract class AbstractLog {
public final JCDiagnostic.Factory diags;
protected DiagnosticSource source;
protected Map<JavaFileObject, DiagnosticSource> sourceMap;
AbstractLog(JCDiagnostic.Factory diags) {
this.diags = diags;
sourceMap = new HashMap<>();
}
public JavaFileObject useSource(JavaFileObject file) {
JavaFileObject prev = (source == null ? null : source.getFile());
source = getSource(file);
return prev;
}
protected DiagnosticSource getSource(JavaFileObject file) {
if (file == null)
return DiagnosticSource.NO_SOURCE;
DiagnosticSource s = sourceMap.get(file);
if (s == null) {
s = new DiagnosticSource(file, this);
sourceMap.put(file, s);
}
return s;
}
public DiagnosticSource currentSource() {
return source;
}
public void error(String key, Object ... args) {
error(diags.errorKey(key, args));
}
public void error(Error errorKey) {
report(diags.error(null, source, null, errorKey));
}
public void error(DiagnosticPosition pos, Error errorKey) {
report(diags.error(null, source, pos, errorKey));
}
public void error(DiagnosticFlag flag, DiagnosticPosition pos, Error errorKey) {
report(diags.error(flag, source, pos, errorKey));
}
public void error(int pos, String key, Object ... args) {
error(pos, diags.errorKey(key, args));
}
public void error(int pos, Error errorKey) {
report(diags.error(null, source, wrap(pos), errorKey));
}
public void error(DiagnosticFlag flag, int pos, Error errorKey) {
report(diags.error(flag, source, wrap(pos), errorKey));
}
public void warning(Warning warningKey) {
report(diags.warning(null, source, null, warningKey));
}
public void warning(LintCategory lc, Warning warningKey) {
report(diags.warning(lc, null, null, warningKey));
}
public void warning(DiagnosticPosition pos, Warning warningKey) {
report(diags.warning(null, source, pos, warningKey));
}
public void warning(LintCategory lc, DiagnosticPosition pos, Warning warningKey) {
report(diags.warning(lc, source, pos, warningKey));
}
public void warning(int pos, Warning warningKey) {
report(diags.warning(null, source, wrap(pos), warningKey));
}
public void mandatoryWarning(DiagnosticPosition pos, Warning warningKey) {
report(diags.mandatoryWarning(null, source, pos, warningKey));
}
public void mandatoryWarning(LintCategory lc, DiagnosticPosition pos, Warning warningKey) {
report(diags.mandatoryWarning(lc, source, pos, warningKey));
}
public void note(Note noteKey) {
report(diags.note(source, null, noteKey));
}
public void note(DiagnosticPosition pos, Note noteKey) {
report(diags.note(source, pos, noteKey));
}
public void note(int pos, Note noteKey) {
report(diags.note(source, wrap(pos), noteKey));
}
public void note(JavaFileObject file, Note noteKey) {
report(diags.note(getSource(file), null, noteKey));
}
public void mandatoryNote(final JavaFileObject file, Note noteKey) {
report(diags.mandatoryNote(getSource(file), noteKey));
}
protected abstract void report(JCDiagnostic diagnostic);
protected abstract void directError(String key, Object... args);
private DiagnosticPosition wrap(int pos) {
return (pos == Position.NOPOS ? null : new SimpleDiagnosticPosition(pos));
}
}
package jdk.internal.logger;
import java.util.ResourceBundle;
import java.util.function.Supplier;
import java.lang.System.Logger;
import java.lang.System.Logger.Level;
import sun.util.logging.PlatformLogger;
abstract class AbstractLoggerWrapper<L extends Logger>
implements Logger, PlatformLogger.Bridge, PlatformLogger.ConfigurableBridge {
AbstractLoggerWrapper() { }
abstract L wrapped();
abstract PlatformLogger.Bridge platformProxy();
L getWrapped() {
return wrapped();
}
@Override
public final String getName() {
return wrapped().getName();
}
@Override
public boolean isLoggable(Level level) {
return wrapped().isLoggable(level);
}
@Override
public void log(Level level, String msg) {
wrapped().log(level, msg);
}
@Override
public void log(Level level,
Supplier<String> msgSupplier) {
wrapped().log(level, msgSupplier);
}
@Override
public void log(Level level, Object obj) {
wrapped().log(level, obj);
}
@Override
public void log(Level level,
String msg, Throwable thrown) {
wrapped().log(level, msg, thrown);
}
@Override
public void log(Level level, Supplier<String> msgSupplier, Throwable thrown) {
wrapped().log(level, msgSupplier, thrown);
}
@Override
public void log(Level level,
String format, Object... params) {
wrapped().log(level, format, params);
}
@Override
public void log(Level level, ResourceBundle bundle,
String key, Throwable thrown) {
wrapped().log(level, bundle, key, thrown);
}
@Override
public void log(Level level, ResourceBundle bundle,
String format, Object... params) {
wrapped().log(level, bundle, format, params);
}
@Override
public boolean isLoggable(PlatformLogger.Level level) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null) return isLoggable(level.systemLevel());
else return platformProxy.isLoggable(level);
}
@Override
public boolean isEnabled() {
final PlatformLogger.Bridge platformProxy = platformProxy();
return platformProxy == null || platformProxy.isEnabled();
}
@Override
public void log(PlatformLogger.Level level, String msg) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null)  {
wrapped().log(level.systemLevel(), msg);
} else {
platformProxy.log(level, msg);
}
}
@Override
public void log(PlatformLogger.Level level, String msg, Throwable thrown) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null)  {
wrapped().log(level.systemLevel(), msg, thrown);
} else {
platformProxy.log(level, msg, thrown);
}
}
@Override
public void log(PlatformLogger.Level level, String msg, Object... params) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null)  {
wrapped().log(level.systemLevel(), msg, params);
} else {
platformProxy.log(level, msg, params);
}
}
@Override
public void log(PlatformLogger.Level level, Supplier<String> msgSupplier) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null)  {
wrapped().log(level.systemLevel(),msgSupplier);
} else {
platformProxy.log(level,msgSupplier);
}
}
@Override
public void log(PlatformLogger.Level level, Throwable thrown,
Supplier<String> msgSupplier) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null)  {
wrapped().log(level.systemLevel(), msgSupplier, thrown);
} else {
platformProxy.log(level, thrown, msgSupplier);
}
}
@Override
public void logp(PlatformLogger.Level level, String sourceClass,
String sourceMethod, String msg) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null)  {
if (sourceClass == null && sourceMethod == null) {                 wrapped().log(level.systemLevel(), msg);
} else {
Level systemLevel = level.systemLevel();
Logger wrapped = wrapped();
if (wrapped.isLoggable(systemLevel)) {
sourceClass  = sourceClass  == null ? "" : sourceClass;
sourceMethod = sourceMethod == null ? "" : sourceMethod;
msg = msg == null ? "" : msg;
wrapped.log(systemLevel, String.format("[%s %s] %s",
sourceClass, sourceMethod, msg));
}
}
} else {
platformProxy.logp(level, sourceClass, sourceMethod, msg);
}
}
@Override
public void logp(PlatformLogger.Level level, String sourceClass,
String sourceMethod, Supplier<String> msgSupplier) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null) {             if (sourceClass == null && sourceMethod == null) {
wrapped().log(level.systemLevel(), msgSupplier);
} else {
Level systemLevel = level.systemLevel();
Logger wrapped = wrapped();
if (wrapped.isLoggable(systemLevel)) {
final String sClass  = sourceClass  == null ? "" : sourceClass;
final String sMethod = sourceMethod == null ? "" : sourceMethod;
wrapped.log(systemLevel, () -> String.format("[%s %s] %s",
sClass, sMethod, msgSupplier.get()));
}
}
} else {
platformProxy.logp(level, sourceClass, sourceMethod, msgSupplier);
}
}
@Override
public void logp(PlatformLogger.Level level, String sourceClass,
String sourceMethod, String msg, Object... params) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null) {             if (sourceClass == null && sourceMethod == null) {
wrapped().log(level.systemLevel(), msg, params);
} else {
Level systemLevel = level.systemLevel();
Logger wrapped = wrapped();
if (wrapped.isLoggable(systemLevel)) {
sourceClass  = sourceClass  == null ? "" : sourceClass;
sourceMethod = sourceMethod == null ? "" : sourceMethod;
msg = msg == null ? "" : msg;
wrapped.log(systemLevel, String.format("[%s %s] %s",
sourceClass, sourceMethod, msg), params);
}
}
} else {
platformProxy.logp(level, sourceClass, sourceMethod, msg, params);
}
}
@Override
public void logp(PlatformLogger.Level level, String sourceClass,
String sourceMethod, String msg, Throwable thrown) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null) {             if (sourceClass == null && sourceMethod == null) {
wrapped().log(level.systemLevel(), msg, thrown);
} else {
Level systemLevel = level.systemLevel();
Logger wrapped = wrapped();
if (wrapped.isLoggable(systemLevel)) {
sourceClass  = sourceClass  == null ? "" : sourceClass;
sourceMethod = sourceMethod == null ? "" : sourceMethod;
msg = msg == null ? "" : msg;
wrapped.log(systemLevel, String.format("[%s %s] %s",
sourceClass, sourceMethod, msg), thrown);
}
}
} else {
platformProxy.logp(level, sourceClass, sourceMethod, msg, thrown);
}
}
@Override
public void logp(PlatformLogger.Level level, String sourceClass,
String sourceMethod, Throwable thrown,
Supplier<String> msgSupplier) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null)  {             if (sourceClass == null && sourceMethod == null) {
wrapped().log(level.systemLevel(), msgSupplier, thrown);
} else {
Level systemLevel = level.systemLevel();
Logger wrapped = wrapped();
if (wrapped.isLoggable(systemLevel)) {
final String sClass  = sourceClass  == null ? "" : sourceClass;
final String sMethod = sourceMethod == null ? "" : sourceMethod;
wrapped.log(systemLevel,  () -> String.format("[%s %s] %s",
sClass, sMethod, msgSupplier.get()), thrown);
}
}
} else {
platformProxy.logp(level, sourceClass, sourceMethod,
thrown, msgSupplier);
}
}
@Override
public void logrb(PlatformLogger.Level level, String sourceClass,
String sourceMethod, ResourceBundle bundle,
String msg, Object... params) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null)  {             if (bundle != null || sourceClass == null && sourceMethod == null) {
wrapped().log(level.systemLevel(), bundle, msg, params);
} else {
Level systemLevel = level.systemLevel();
Logger wrapped = wrapped();
if (wrapped.isLoggable(systemLevel)) {
sourceClass  = sourceClass  == null ? "" : sourceClass;
sourceMethod = sourceMethod == null ? "" : sourceMethod;
msg = msg == null ? "" : msg;
wrapped.log(systemLevel, bundle, String.format("[%s %s] %s",
sourceClass, sourceMethod, msg), params);
}
}
} else {
platformProxy.logrb(level, sourceClass, sourceMethod,
bundle, msg, params);
}
}
@Override
public void logrb(PlatformLogger.Level level, String sourceClass,
String sourceMethod, ResourceBundle bundle, String msg,
Throwable thrown) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null)  {             if (bundle != null || sourceClass == null && sourceMethod == null) {
wrapped().log(level.systemLevel(), bundle, msg, thrown);
} else {
Level systemLevel = level.systemLevel();
Logger wrapped = wrapped();
if (wrapped.isLoggable(systemLevel)) {
sourceClass  = sourceClass  == null ? "" : sourceClass;
sourceMethod = sourceMethod == null ? "" : sourceMethod;
msg = msg == null ? "" : msg;
wrapped.log(systemLevel, bundle, String.format("[%s %s] %s",
sourceClass, sourceMethod, msg), thrown);
}
}
} else {
platformProxy.logrb(level, sourceClass, sourceMethod, bundle,
msg, thrown);
}
}
@Override
public void logrb(PlatformLogger.Level level, ResourceBundle bundle,
String msg, Throwable thrown) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null)  {
wrapped().log(level.systemLevel(), bundle, msg, thrown);
} else {
platformProxy.logrb(level, bundle, msg, thrown);
}
}
@Override
public void logrb(PlatformLogger.Level level, ResourceBundle bundle,
String msg, Object... params) {
final PlatformLogger.Bridge platformProxy = platformProxy();
if (platformProxy == null)  {
wrapped().log(level.systemLevel(), bundle, msg, params);
} else {
platformProxy.logrb(level, bundle, msg, params);
}
}
@Override
public LoggerConfiguration getLoggerConfiguration() {
final PlatformLogger.Bridge platformProxy = platformProxy();
return platformProxy == null ? null
: PlatformLogger.ConfigurableBridge
.getLoggerConfiguration(platformProxy);
}
}
package java.util;
public abstract class AbstractMap<K,V> implements Map<K,V> {
protected AbstractMap() {
}
public int size() {
return entrySet().size();
}
public boolean isEmpty() {
return size() == 0;
}
public boolean containsValue(Object value) {
Iterator<Entry<K,V>> i = entrySet().iterator();
if (value==null) {
while (i.hasNext()) {
Entry<K,V> e = i.next();
if (e.getValue()==null)
return true;
}
} else {
while (i.hasNext()) {
Entry<K,V> e = i.next();
if (value.equals(e.getValue()))
return true;
}
}
return false;
}
public boolean containsKey(Object key) {
Iterator<Map.Entry<K,V>> i = entrySet().iterator();
if (key==null) {
while (i.hasNext()) {
Entry<K,V> e = i.next();
if (e.getKey()==null)
return true;
}
} else {
while (i.hasNext()) {
Entry<K,V> e = i.next();
if (key.equals(e.getKey()))
return true;
}
}
return false;
}
public V get(Object key) {
Iterator<Entry<K,V>> i = entrySet().iterator();
if (key==null) {
while (i.hasNext()) {
Entry<K,V> e = i.next();
if (e.getKey()==null)
return e.getValue();
}
} else {
while (i.hasNext()) {
Entry<K,V> e = i.next();
if (key.equals(e.getKey()))
return e.getValue();
}
}
return null;
}
public V put(K key, V value) {
throw new UnsupportedOperationException();
}
public V remove(Object key) {
Iterator<Entry<K,V>> i = entrySet().iterator();
Entry<K,V> correctEntry = null;
if (key==null) {
while (correctEntry==null && i.hasNext()) {
Entry<K,V> e = i.next();
if (e.getKey()==null)
correctEntry = e;
}
} else {
while (correctEntry==null && i.hasNext()) {
Entry<K,V> e = i.next();
if (key.equals(e.getKey()))
correctEntry = e;
}
}
V oldValue = null;
if (correctEntry !=null) {
oldValue = correctEntry.getValue();
i.remove();
}
return oldValue;
}
public void putAll(Map<? extends K, ? extends V> m) {
for (Map.Entry<? extends K, ? extends V> e : m.entrySet())
put(e.getKey(), e.getValue());
}
public void clear() {
entrySet().clear();
}
transient Set<K>        keySet;
transient Collection<V> values;
public Set<K> keySet() {
Set<K> ks = keySet;
if (ks == null) {
ks = new AbstractSet<K>() {
public Iterator<K> iterator() {
return new Iterator<K>() {
private Iterator<Entry<K,V>> i = entrySet().iterator();
public boolean hasNext() {
return i.hasNext();
}
public K next() {
return i.next().getKey();
}
public void remove() {
i.remove();
}
};
}
public int size() {
return AbstractMap.this.size();
}
public boolean isEmpty() {
return AbstractMap.this.isEmpty();
}
public void clear() {
AbstractMap.this.clear();
}
public boolean contains(Object k) {
return AbstractMap.this.containsKey(k);
}
};
keySet = ks;
}
return ks;
}
public Collection<V> values() {
Collection<V> vals = values;
if (vals == null) {
vals = new AbstractCollection<V>() {
public Iterator<V> iterator() {
return new Iterator<V>() {
private Iterator<Entry<K,V>> i = entrySet().iterator();
public boolean hasNext() {
return i.hasNext();
}
public V next() {
return i.next().getValue();
}
public void remove() {
i.remove();
}
};
}
public int size() {
return AbstractMap.this.size();
}
public boolean isEmpty() {
return AbstractMap.this.isEmpty();
}
public void clear() {
AbstractMap.this.clear();
}
public boolean contains(Object v) {
return AbstractMap.this.containsValue(v);
}
};
values = vals;
}
return vals;
}
public abstract Set<Entry<K,V>> entrySet();
public boolean equals(Object o) {
if (o == this)
return true;
if (!(o instanceof Map<?, ?> m))
return false;
if (m.size() != size())
return false;
try {
for (Entry<K, V> e : entrySet()) {
K key = e.getKey();
V value = e.getValue();
if (value == null) {
if (!(m.get(key) == null && m.containsKey(key)))
return false;
} else {
if (!value.equals(m.get(key)))
return false;
}
}
} catch (ClassCastException | NullPointerException unused) {
return false;
}
return true;
}
public int hashCode() {
int h = 0;
for (Entry<K, V> entry : entrySet())
h += entry.hashCode();
return h;
}
public String toString() {
Iterator<Entry<K,V>> i = entrySet().iterator();
if (! i.hasNext())
return "{}";
StringBuilder sb = new StringBuilder();
sb.append('{');
for (;;) {
Entry<K,V> e = i.next();
K key = e.getKey();
V value = e.getValue();
sb.append(key   == this ? "(this Map)" : key);
sb.append('=');
sb.append(value == this ? "(this Map)" : value);
if (! i.hasNext())
return sb.append('}').toString();
sb.append(',').append(' ');
}
}
protected Object clone() throws CloneNotSupportedException {
AbstractMap<?,?> result = (AbstractMap<?,?>)super.clone();
result.keySet = null;
result.values = null;
return result;
}
private static boolean eq(Object o1, Object o2) {
return o1 == null ? o2 == null : o1.equals(o2);
}
public static class SimpleEntry<K,V>
implements Entry<K,V>, java.io.Serializable
{
@java.io.Serial
private static final long serialVersionUID = -8499721149061103585L;
@SuppressWarnings("serial")         private final K key;
@SuppressWarnings("serial")         private V value;
public SimpleEntry(K key, V value) {
this.key   = key;
this.value = value;
}
public SimpleEntry(Entry<? extends K, ? extends V> entry) {
this.key   = entry.getKey();
this.value = entry.getValue();
}
public K getKey() {
return key;
}
public V getValue() {
return value;
}
public V setValue(V value) {
V oldValue = this.value;
this.value = value;
return oldValue;
}
public boolean equals(Object o) {
return o instanceof Map.Entry<?, ?> e
&& eq(key, e.getKey())
&& eq(value, e.getValue());
}
public int hashCode() {
return (key   == null ? 0 :   key.hashCode()) ^
(value == null ? 0 : value.hashCode());
}
public String toString() {
return key + "=" + value;
}
}
public static class SimpleImmutableEntry<K,V>
implements Entry<K,V>, java.io.Serializable
{
@java.io.Serial
private static final long serialVersionUID = 7138329143949025153L;
@SuppressWarnings("serial")         private final K key;
@SuppressWarnings("serial")         private final V value;
public SimpleImmutableEntry(K key, V value) {
this.key   = key;
this.value = value;
}
public SimpleImmutableEntry(Entry<? extends K, ? extends V> entry) {
this.key   = entry.getKey();
this.value = entry.getValue();
}
public K getKey() {
return key;
}
public V getValue() {
return value;
}
public V setValue(V value) {
throw new UnsupportedOperationException();
}
public boolean equals(Object o) {
return o instanceof Map.Entry<?, ?> e
&& eq(key, e.getKey())
&& eq(value, e.getValue());
}
public int hashCode() {
return (key   == null ? 0 :   key.hashCode()) ^
(value == null ? 0 : value.hashCode());
}
public String toString() {
return key + "=" + value;
}
}
}
package jdk.incubator.vector;
import java.util.Objects;
import jdk.internal.vm.annotation.ForceInline;
import jdk.internal.misc.Unsafe;
import jdk.internal.vm.vector.VectorSupport;
import static jdk.incubator.vector.VectorOperators.*;
abstract class AbstractMask<E> extends VectorMask<E> {
AbstractMask(boolean[] bits) {
super(bits);
}
abstract boolean[] getBits();
interface MUnOp {
boolean apply(int i, boolean a);
}
abstract AbstractMask<E> uOp(MUnOp f);
interface MBinOp {
boolean apply(int i, boolean a, boolean b);
}
abstract AbstractMask<E> bOp(VectorMask<E> o, MBinOp f);
abstract AbstractSpecies<E> vspecies();
@Override
@ForceInline
public final VectorSpecies<E> vectorSpecies() {
return vspecies();
}
@Override
@ForceInline
public boolean laneIsSet(int i) {
int length = length();
Objects.checkIndex(i, length);
if (length <= Long.SIZE) {
return ((toLong() >>> i) & 1L) == 1;
} else {
return getBits()[i];
}
}
@Override
public void intoArray(boolean[] bits, int i) {
AbstractSpecies<E> vsp = (AbstractSpecies<E>) vectorSpecies();
int laneCount = vsp.laneCount();
i = VectorIntrinsics.checkFromIndexSize(i, laneCount, bits.length);
VectorSupport.store(
vsp.maskType(), vsp.elementType(), laneCount,
bits, (long) i + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET,
this, bits, i,
(c, idx, s) -> System.arraycopy(s.getBits(), 0, c, (int) idx, s.length()));
}
@Override
public boolean[] toArray() {
return getBits().clone();
}
@Override
@ForceInline
@SuppressWarnings("unchecked")
public
<F> VectorMask<F> check(Class<F> elementType) {
if (vectorSpecies().elementType() != elementType) {
throw AbstractSpecies.checkFailed(this, elementType);
}
return (VectorMask<F>) this;
}
@Override
@ForceInline
@SuppressWarnings("unchecked")
public
<F> VectorMask<F> check(VectorSpecies<F> species) {
if (species != vectorSpecies()) {
throw AbstractSpecies.checkFailed(this, species);
}
return (VectorMask<F>) this;
}
@Override
@ForceInline
@SuppressWarnings("unchecked")
<F> VectorMask<F> check(Class<? extends VectorMask<F>> maskClass, Vector<F> vector) {
if (!sameSpecies(maskClass, vector)) {
throw AbstractSpecies.checkFailed(this, vector);
}
return (VectorMask<F>) this;
}
@ForceInline
private <F> boolean sameSpecies(Class<? extends VectorMask<F>> maskClass, Vector<F> vector) {
boolean same = getClass() == maskClass;
assert (same == (vectorSpecies() == vector.species())) : same;
return same;
}
@Override
public VectorMask<E> andNot(VectorMask<E> m) {
return and(m.not());
}
static boolean anyTrueHelper(boolean[] bits) {
for (boolean i : bits) {
if (i) return true;
}
return false;
}
static boolean allTrueHelper(boolean[] bits) {
for (boolean i : bits) {
if (!i) return false;
}
return true;
}
static int trueCountHelper(boolean[] bits) {
int c = 0;
for (boolean i : bits) {
if (i) c++;
}
return c;
}
static int firstTrueHelper(boolean[] bits) {
for (int i = 0; i < bits.length; i++) {
if (bits[i])  return i;
}
return bits.length;
}
static int lastTrueHelper(boolean[] bits) {
for (int i = bits.length-1; i >= 0; i--) {
if (bits[i])  return i;
}
return -1;
}
static long toLongHelper(boolean[] bits) {
long res = 0;
long set = 1;
for (int i = 0; i < bits.length; i++) {
res = bits[i] ? res | set : res;
set = set << 1;
}
return res;
}
@Override
@ForceInline
public VectorMask<E> indexInRange(int offset, int limit) {
int vlength = length();
Vector<E> iota = vectorSpecies().zero().addIndex(1);
VectorMask<E> badMask = checkIndex0(offset, limit, iota, vlength);
return this.andNot(badMask);
}
@Override
@ForceInline
public VectorMask<E> indexInRange(long offset, long limit) {
int vlength = length();
Vector<E> iota = vectorSpecies().zero().addIndex(1);
VectorMask<E> badMask = checkIndex0(offset, limit, iota, vlength);
return this.andNot(badMask);
}
@ForceInline
AbstractVector<E>
toVectorTemplate() {
AbstractSpecies<E> vsp = vspecies();
Vector<E> zero = vsp.broadcast(0);
Vector<E> mone = vsp.broadcast(-1);
return (AbstractVector<E>) zero.blend(mone, this);
}
@ForceInline
void checkIndexByLane(int offset, int length,
Vector<E> iota,
int esize) {
if (VectorIntrinsics.VECTOR_ACCESS_OOB_CHECK == 0) {
return;
}
int vlength = length();
VectorMask<E> badMask;
if (esize == 1) {
badMask = checkIndex0(offset, length, iota, vlength);
} else if (offset >= 0) {
int elemCount = Math.min(vlength, (length - offset) / esize);
badMask = checkIndex0(0, elemCount, iota, vlength);
} else {
int clipOffset = Math.max(offset, -(vlength * esize));
badMask = checkIndex0(clipOffset, length,
iota.lanewise(VectorOperators.MUL, esize),
vlength * esize);
}
badMask = badMask.and(this);
if (badMask.anyTrue()) {
int badLane = badMask.firstTrue();
throw ((AbstractMask<E>)badMask)
.checkIndexFailed(offset, badLane, length, esize);
}
}
private
@ForceInline
VectorMask<E> checkIndex0(int offset, int length,
Vector<E> iota, int vlength) {
int indexLimit = Math.max(0, Math.min(length - offset, vlength));
VectorMask<E> badMask =
iota.compare(GE, iota.broadcast(indexLimit));
if (offset < 0) {
int firstGoodIndex = -Math.max(offset, -vlength);
VectorMask<E> badMask2 =
iota.compare(LT, iota.broadcast(firstGoodIndex));
if (indexLimit >= vlength) {
badMask = badMask2;              } else {
badMask = badMask.or(badMask2);
}
}
return badMask;
}
@ForceInline
void checkIndexByLane(long offset, long length,
Vector<E> iota,
int esize) {
if (VectorIntrinsics.VECTOR_ACCESS_OOB_CHECK == 0) {
return;
}
int vlength = length();
VectorMask<E> badMask;
if (esize == 1) {
badMask = checkIndex0(offset, length, iota, vlength);
} else if (offset >= 0) {
int elemCount = (int) Math.min(vlength, (length - offset) / esize);
badMask = checkIndex0(0, elemCount, iota, vlength);
} else {
int clipOffset = (int) Math.max(offset, -(vlength * esize));
badMask = checkIndex0(clipOffset, length,
iota.lanewise(VectorOperators.MUL, esize),
vlength * esize);
}
badMask = badMask.and(this);
if (badMask.anyTrue()) {
int badLane = badMask.firstTrue();
throw ((AbstractMask<E>)badMask)
.checkIndexFailed(offset, badLane, length, esize);
}
}
private
@ForceInline
VectorMask<E> checkIndex0(long offset, long length,
Vector<E> iota, int vlength) {
int indexLimit = (int) Math.max(0, Math.min(length - offset, vlength));
VectorMask<E> badMask =
iota.compare(GE, iota.broadcast(indexLimit));
if (offset < 0) {
int firstGoodIndex = (int) -Math.max(offset, -vlength);
VectorMask<E> badMask2 =
iota.compare(LT, iota.broadcast(firstGoodIndex));
if (indexLimit >= vlength) {
badMask = badMask2;              } else {
badMask = badMask.or(badMask2);
}
}
return badMask;
}
private IndexOutOfBoundsException checkIndexFailed(long offset, int lane,
long length, int esize) {
String msg = String.format("Masked range check failed: "+
"vector mask %s out of bounds at "+
"index %d+%d for length %d",
this, offset, lane * esize, length);
if (esize != 1) {
msg += String.format(" (each lane spans %d elements)", esize);
}
throw new IndexOutOfBoundsException(msg);
}
}
package jdk.javadoc.internal.doclets.toolkit.builders;
import java.util.List;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import jdk.javadoc.internal.doclets.toolkit.Content;
import jdk.javadoc.internal.doclets.toolkit.DocletException;
import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind;
public abstract class AbstractMemberBuilder extends AbstractBuilder {
protected final TypeElement typeElement;
protected final VisibleMemberTable visibleMemberTable;
public AbstractMemberBuilder(Context context, TypeElement typeElement) {
super(context);
this.typeElement = typeElement;
visibleMemberTable = configuration.getVisibleMemberTable(typeElement);
}
@Override
public void build() {
throw new AssertionError();
}
public abstract void build(Content target) throws DocletException;
public abstract boolean hasMembersToDocument();
protected List<Element> getVisibleMembers(Kind kind) {
return visibleMemberTable.getVisibleMembers(kind);
}
}
package jdk.javadoc.internal.doclets.formats.html;
import java.util.ArrayList;
import java.util.List;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.TypeParameterElement;
import javax.lang.model.type.TypeMirror;
import com.sun.source.doctree.DocTree;
import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
import jdk.javadoc.internal.doclets.formats.html.markup.TagName;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
import jdk.javadoc.internal.doclets.formats.html.markup.Links;
import jdk.javadoc.internal.doclets.toolkit.Content;
import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;
import jdk.javadoc.internal.doclets.toolkit.MemberWriter;
import jdk.javadoc.internal.doclets.toolkit.Resources;
import jdk.javadoc.internal.doclets.toolkit.taglets.DeprecatedTaglet;
import jdk.javadoc.internal.doclets.toolkit.util.Utils;
public abstract class AbstractMemberWriter implements MemberSummaryWriter, MemberWriter {
protected final HtmlConfiguration configuration;
protected final HtmlOptions options;
protected final Utils utils;
protected final SubWriterHolderWriter writer;
protected final Contents contents;
protected final Resources resources;
protected final Links links;
protected final HtmlIds htmlIds;
protected final TypeElement typeElement;
public AbstractMemberWriter(SubWriterHolderWriter writer, TypeElement typeElement) {
this.configuration = writer.configuration;
this.options = configuration.getOptions();
this.writer = writer;
this.typeElement = typeElement;
this.utils = configuration.utils;
this.contents = configuration.getContents();
this.resources = configuration.docResources;
this.links = writer.links;
this.htmlIds = configuration.htmlIds;
}
public AbstractMemberWriter(SubWriterHolderWriter writer) {
this(writer, null);
}
public abstract void addSummaryLabel(Content content);
public abstract TableHeader getSummaryTableHeader(Element member);
private Table summaryTable;
private Table getSummaryTable() {
if (summaryTable == null) {
summaryTable = createSummaryTable();
}
return summaryTable;
}
protected abstract Table createSummaryTable();
public abstract void addInheritedSummaryLabel(TypeElement typeElement, Content content);
protected abstract void addSummaryType(Element member, Content content);
protected void addSummaryLink(TypeElement typeElement, Element member, Content content) {
addSummaryLink(HtmlLinkInfo.Kind.MEMBER, typeElement, member, content);
}
protected abstract void addSummaryLink(HtmlLinkInfo.Kind context,
TypeElement typeElement, Element member, Content content);
protected abstract void addInheritedSummaryLink(TypeElement typeElement,
Element member, Content target);
protected abstract Content getSummaryLink(Element member);
protected void addModifiersAndType(Element member, TypeMirror type,
Content target) {
var code = new HtmlTree(TagName.CODE);
addModifiers(member, code);
if (type == null) {
code.add(switch (member.getKind()) {
case ENUM -> "enum";
case INTERFACE -> "interface";
case ANNOTATION_TYPE -> "@interface";
case RECORD -> "record";
default -> "class";
});
code.add(Entity.NO_BREAK_SPACE);
} else {
List<? extends TypeParameterElement> list = utils.isExecutableElement(member)
? ((ExecutableElement)member).getTypeParameters()
: null;
if (list != null && !list.isEmpty()) {
Content typeParameters = ((AbstractExecutableMemberWriter) this)
.getTypeParameters((ExecutableElement)member);
code.add(typeParameters);
if (typeParameters.charCount() > 10) {
code.add(new HtmlTree(TagName.BR));
} else {
code.add(Entity.NO_BREAK_SPACE);
}
}
code.add(
writer.getLink(new HtmlLinkInfo(configuration,
HtmlLinkInfo.Kind.SUMMARY_RETURN_TYPE, type)));
}
target.add(code);
}
private void addModifiers(Element member, Content target) {
if (utils.isProtected(member)) {
target.add("protected ");
} else if (utils.isPrivate(member)) {
target.add("private ");
} else if (!utils.isPublic(member)) {             target.add(resources.getText("doclet.Package_private"));
target.add(" ");
}
if (!utils.isAnnotationInterface(member.getEnclosingElement()) && utils.isMethod(member)) {
if (!utils.isPlainInterface(member.getEnclosingElement()) && utils.isAbstract(member)) {
target.add("abstract ");
}
if (utils.isDefault(member)) {
target.add("default ");
}
}
if (utils.isStatic(member)) {
target.add("static ");
}
if (!utils.isEnum(member) && utils.isFinal(member)) {
target.add("final ");
}
}
protected void addDeprecatedInfo(Element member, Content target) {
Content output = (new DeprecatedTaglet()).getAllBlockTagOutput(member,
writer.getTagletWriterInstance(false));
if (!output.isEmpty()) {
target.add(HtmlTree.DIV(HtmlStyle.deprecationBlock, output));
}
}
protected void addComment(Element member, Content content) {
if (!utils.getFullBody(member).isEmpty()) {
writer.addInlineComment(member, content);
}
}
protected void addPreviewInfo(Element member, Content content) {
writer.addPreviewInfo(member, content);
}
protected String name(Element member) {
return utils.getSimpleName(member);
}
protected void addUseInfo(List<? extends Element> members, Content heading, Content content) {
if (members == null || members.isEmpty()) {
return;
}
boolean printedUseTableHeader = false;
Table useTable = new Table(HtmlStyle.summaryTable)
.setCaption(heading)
.setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);
for (Element element : members) {
TypeElement te = (typeElement == null)
? utils.getEnclosingTypeElement(element)
: typeElement;
if (!printedUseTableHeader) {
useTable.setHeader(getSummaryTableHeader(element));
printedUseTableHeader = true;
}
Content summaryType = new ContentBuilder();
addSummaryType(element, summaryType);
Content typeContent = new ContentBuilder();
if (te != null
&& !utils.isConstructor(element)
&& !utils.isTypeElement(element)) {
var name = HtmlTree.SPAN(HtmlStyle.typeNameLabel);
name.add(name(te) + ".");
typeContent.add(name);
}
addSummaryLink(utils.isClass(element) || utils.isPlainInterface(element)
? HtmlLinkInfo.Kind.CLASS_USE
: HtmlLinkInfo.Kind.MEMBER,
te, element, typeContent);
Content desc = new ContentBuilder();
writer.addSummaryLinkComment(element, desc);
useTable.addRow(summaryType, typeContent, desc);
}
content.add(useTable);
}
protected void serialWarning(Element e, String key, String a1, String a2) {
if (options.serialWarn()) {
configuration.messages.warning(e, key, a1, a2);
}
}
@Override
public void addMemberSummary(TypeElement tElement, Element member,
List<? extends DocTree> firstSentenceTrees) {
if (tElement != typeElement) {
throw new IllegalStateException();
}
Table table = getSummaryTable();
List<Content> rowContents = new ArrayList<>();
Content summaryType = new ContentBuilder();
addSummaryType(member, summaryType);
if (!summaryType.isEmpty())
rowContents.add(summaryType);
Content summaryLink = new ContentBuilder();
addSummaryLink(tElement, member, summaryLink);
rowContents.add(summaryLink);
Content desc = new ContentBuilder();
writer.addSummaryLinkComment(member, firstSentenceTrees, desc);
rowContents.add(desc);
table.addRow(member, rowContents);
}
@Override
public void addInheritedMemberSummary(TypeElement tElement,
Element nestedClass, boolean isFirst, boolean isLast,
Content content) {
writer.addInheritedMemberSummary(this, tElement, nestedClass, isFirst, content);
}
@Override
public Content getInheritedSummaryHeader(TypeElement tElement) {
Content c = writer.getMemberInherited();
writer.addInheritedSummaryHeader(this, tElement, c);
return c;
}
@Override
public Content getInheritedSummaryLinks() {
return new HtmlTree(TagName.CODE);
}
@Override
public Content getSummaryTable(TypeElement tElement) {
if (tElement != typeElement) {
throw new IllegalStateException();
}
return getSummaryTable();
}
@Override
public Content getMember(Content memberContent) {
return writer.getMember(memberContent);
}
@Override
public Content getMemberList() {
return writer.getMemberList();
}
@Override
public Content getMemberListItem(Content memberContent) {
return writer.getMemberListItem(memberContent);
}
}
package jdk.internal.foreign;
import java.lang.foreign.MemoryAddress;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.MemorySession;
import java.lang.foreign.SegmentAllocator;
import java.lang.foreign.ValueLayout;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.CharBuffer;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;
import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import jdk.internal.access.JavaNioAccess;
import jdk.internal.access.SharedSecrets;
import jdk.internal.access.foreign.UnmapperProxy;
import jdk.internal.misc.ScopedMemoryAccess;
import jdk.internal.util.ArraysSupport;
import jdk.internal.util.Preconditions;
import jdk.internal.vm.annotation.ForceInline;
import static java.lang.foreign.ValueLayout.JAVA_BYTE;
public abstract non-sealed class AbstractMemorySegmentImpl implements MemorySegment, SegmentAllocator, Scoped, BiFunction<String, List<Number>, RuntimeException> {
private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();
static final long NONCE = new Random().nextLong();
static final JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
final long length;
final boolean readOnly;
final MemorySession session;
@ForceInline
AbstractMemorySegmentImpl(long length, boolean readOnly, MemorySession session) {
this.length = length;
this.readOnly = readOnly;
this.session = session;
}
abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session);
abstract ByteBuffer makeByteBuffer();
@Override
public AbstractMemorySegmentImpl asReadOnly() {
return dup(0, length, true, session);
}
@Override
public boolean isReadOnly() {
return readOnly;
}
@Override
public AbstractMemorySegmentImpl asSlice(long offset, long newSize) {
checkBounds(offset, newSize);
return asSliceNoCheck(offset, newSize);
}
@Override
public AbstractMemorySegmentImpl asSlice(long offset) {
checkBounds(offset, 0);
return asSliceNoCheck(offset, length - offset);
}
private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
return dup(offset, newSize, readOnly, session);
}
@Override
public Spliterator<MemorySegment> spliterator(MemoryLayout elementLayout) {
Objects.requireNonNull(elementLayout);
if (elementLayout.byteSize() == 0) {
throw new IllegalArgumentException("Element layout size cannot be zero");
}
Utils.checkElementAlignment(elementLayout, "Element layout alignment greater than its size");
if (!isAlignedForElement(0, elementLayout)) {
throw new IllegalArgumentException("Incompatible alignment constraints");
}
if (!Utils.isAligned(byteSize(), elementLayout.byteSize())) {
throw new IllegalArgumentException("Segment size is not a multiple of layout size");
}
return new SegmentSplitter(elementLayout.byteSize(), byteSize() / elementLayout.byteSize(),
this);
}
@Override
public Stream<MemorySegment> elements(MemoryLayout elementLayout) {
return StreamSupport.stream(spliterator(elementLayout), false);
}
@Override
public final MemorySegment fill(byte value){
checkAccess(0, length, false);
SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);
return this;
}
@Override
public MemorySegment allocate(long bytesSize, long bytesAlignment) {
Utils.checkAllocationSizeAndAlign(bytesSize, bytesAlignment);
return asSlice(0, bytesSize);
}
@Override
public long mismatch(MemorySegment other) {
AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);
final long thisSize = this.byteSize();
final long thatSize = that.byteSize();
final long length = Math.min(thisSize, thatSize);
this.checkAccess(0, length, true);
that.checkAccess(0, length, true);
if (this == other) {
checkValidState();
return -1;
}
long i = 0;
if (length > 7) {
if (get(JAVA_BYTE, 0) != that.get(JAVA_BYTE, 0)) {
return 0;
}
i = vectorizedMismatchLargeForBytes(sessionImpl(), that.sessionImpl(),
this.unsafeGetBase(), this.unsafeGetOffset(),
that.unsafeGetBase(), that.unsafeGetOffset(),
length);
if (i >= 0) {
return i;
}
long remaining = ~i;
assert remaining < 8 : "remaining greater than 7: " + remaining;
i = length - remaining;
}
for (; i < length; i++) {
if (get(JAVA_BYTE, i) != that.get(JAVA_BYTE, i)) {
return i;
}
}
return thisSize != thatSize ? length : -1;
}
private static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,
Object a, long aOffset,
Object b, long bOffset,
long length) {
long off = 0;
long remaining = length;
int i, size;
boolean lastSubRange = false;
while (remaining > 7 && !lastSubRange) {
if (remaining > Integer.MAX_VALUE) {
size = Integer.MAX_VALUE;
} else {
size = (int) remaining;
lastSubRange = true;
}
i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession, bSession,
a, aOffset + off,
b, bOffset + off,
size, ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);
if (i >= 0)
return off + i;
i = size - ~i;
off += i;
remaining -= i;
}
return ~remaining;
}
@Override
public MemoryAddress address() {
throw new UnsupportedOperationException("Cannot obtain address of on-heap segment");
}
@Override
public final ByteBuffer asByteBuffer() {
checkArraySize("ByteBuffer", 1);
ByteBuffer _bb = makeByteBuffer();
if (readOnly) {
_bb = _bb.asReadOnlyBuffer();
}
return _bb;
}
@Override
public final long byteSize() {
return length;
}
@Override
public boolean isMapped() {
return false;
}
@Override
public boolean isNative() {
return false;
}
@Override
public final Optional<MemorySegment> asOverlappingSlice(MemorySegment other) {
AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);
if (unsafeGetBase() == that.unsafeGetBase()) {              final long thisStart = this.unsafeGetOffset();
final long thatStart = that.unsafeGetOffset();
final long thisEnd = thisStart + this.byteSize();
final long thatEnd = thatStart + that.byteSize();
if (thisStart < thatEnd && thisEnd > thatStart) {                  long offsetToThat = this.segmentOffset(that);
long newOffset = offsetToThat >= 0 ? offsetToThat : 0;
return Optional.of(asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat)));
}
}
return Optional.empty();
}
@Override
public final long segmentOffset(MemorySegment other) {
AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) Objects.requireNonNull(other);
if (unsafeGetBase() == that.unsafeGetBase()) {
return that.unsafeGetOffset() - this.unsafeGetOffset();
}
throw new UnsupportedOperationException("Cannot compute offset from native to heap (or vice versa).");
}
@Override
public void load() {
throw new UnsupportedOperationException("Not a mapped segment");
}
@Override
public void unload() {
throw new UnsupportedOperationException("Not a mapped segment");
}
@Override
public boolean isLoaded() {
throw new UnsupportedOperationException("Not a mapped segment");
}
@Override
public void force() {
throw new UnsupportedOperationException("Not a mapped segment");
}
@Override
public final byte[] toArray(ValueLayout.OfByte elementLayout) {
return toArray(byte[].class, elementLayout, byte[]::new, MemorySegment::ofArray);
}
@Override
public final short[] toArray(ValueLayout.OfShort elementLayout) {
return toArray(short[].class, elementLayout, short[]::new, MemorySegment::ofArray);
}
@Override
public final char[] toArray(ValueLayout.OfChar elementLayout) {
return toArray(char[].class, elementLayout, char[]::new, MemorySegment::ofArray);
}
@Override
public final int[] toArray(ValueLayout.OfInt elementLayout) {
return toArray(int[].class, elementLayout, int[]::new, MemorySegment::ofArray);
}
@Override
public final float[] toArray(ValueLayout.OfFloat elementLayout) {
return toArray(float[].class, elementLayout, float[]::new, MemorySegment::ofArray);
}
@Override
public final long[] toArray(ValueLayout.OfLong elementLayout) {
return toArray(long[].class, elementLayout, long[]::new, MemorySegment::ofArray);
}
@Override
public final double[] toArray(ValueLayout.OfDouble elementLayout) {
return toArray(double[].class, elementLayout, double[]::new, MemorySegment::ofArray);
}
private <Z> Z toArray(Class<Z> arrayClass, ValueLayout elemLayout, IntFunction<Z> arrayFactory, Function<Z, MemorySegment> segmentFactory) {
int size = checkArraySize(arrayClass.getSimpleName(), (int)elemLayout.byteSize());
Z arr = arrayFactory.apply(size);
MemorySegment arrSegment = segmentFactory.apply(arr);
MemorySegment.copy(this, elemLayout, 0, arrSegment, elemLayout.withOrder(ByteOrder.nativeOrder()), 0, size);
return arr;
}
@ForceInline
public void checkAccess(long offset, long length, boolean readOnly) {
if (!readOnly && this.readOnly) {
throw new UnsupportedOperationException("Attempt to write a read-only segment");
}
checkBounds(offset, length);
}
public void checkValidState() {
sessionImpl().checkValidState();
}
public abstract long unsafeGetOffset();
public abstract Object unsafeGetBase();
public abstract long maxAlignMask();
@ForceInline
public final boolean isAlignedForElement(long offset, MemoryLayout layout) {
return (((unsafeGetOffset() + offset) | maxAlignMask()) & (layout.byteAlignment() - 1)) == 0;
}
private int checkArraySize(String typeName, int elemSize) {
if (!Utils.isAligned(length, elemSize)) {
throw new IllegalStateException(String.format("Segment size is not a multiple of %d. Size: %d", elemSize, length));
}
long arraySize = length / elemSize;
if (arraySize > (Integer.MAX_VALUE - 8)) {             throw new IllegalStateException(String.format("Segment is too large to wrap as %s. Size: %d", typeName, length));
}
return (int)arraySize;
}
@ForceInline
void checkBounds(long offset, long length) {
if (length > 0) {
Preconditions.checkIndex(offset, this.length - length + 1, this);
} else if (length < 0 || offset < 0 ||
offset > this.length - length) {
throw outOfBoundException(offset, length);
}
}
@Override
public RuntimeException apply(String s, List<Number> numbers) {
long offset = numbers.get(0).longValue();
long length = byteSize() - numbers.get(1).longValue() + 1;
return outOfBoundException(offset, length);
}
@Override
public MemorySession session() {
return session;
}
private IndexOutOfBoundsException outOfBoundException(long offset, long length) {
return new IndexOutOfBoundsException(String.format("Out of bound access on segment %s; new offset = %d; new length = %d",
this, offset, length));
}
protected int id() {
return Math.abs(Objects.hash(unsafeGetBase(), unsafeGetOffset(), NONCE));
}
static class SegmentSplitter implements Spliterator<MemorySegment> {
AbstractMemorySegmentImpl segment;
long elemCount;
final long elementSize;
long currentIndex;
SegmentSplitter(long elementSize, long elemCount, AbstractMemorySegmentImpl segment) {
this.segment = segment;
this.elementSize = elementSize;
this.elemCount = elemCount;
}
@Override
public SegmentSplitter trySplit() {
if (currentIndex == 0 && elemCount > 1) {
AbstractMemorySegmentImpl parent = segment;
long rem = elemCount % 2;
long split = elemCount / 2;
long lobound = split * elementSize;
long hibound = lobound + (rem * elementSize);
elemCount  = split + rem;
segment = parent.asSliceNoCheck(lobound, hibound);
return new SegmentSplitter(elementSize, split, parent.asSliceNoCheck(0, lobound));
} else {
return null;
}
}
@Override
public boolean tryAdvance(Consumer<? super MemorySegment> action) {
Objects.requireNonNull(action);
if (currentIndex < elemCount) {
AbstractMemorySegmentImpl acquired = segment;
try {
action.accept(acquired.asSliceNoCheck(currentIndex * elementSize, elementSize));
} finally {
currentIndex++;
if (currentIndex == elemCount) {
segment = null;
}
}
return true;
} else {
return false;
}
}
@Override
public void forEachRemaining(Consumer<? super MemorySegment> action) {
Objects.requireNonNull(action);
if (currentIndex < elemCount) {
AbstractMemorySegmentImpl acquired = segment;
try {
for (long i = currentIndex ; i < elemCount ; i++) {
action.accept(acquired.asSliceNoCheck(i * elementSize, elementSize));
}
} finally {
currentIndex = elemCount;
segment = null;
}
}
}
@Override
public long estimateSize() {
return elemCount;
}
@Override
public int characteristics() {
return NONNULL | SUBSIZED | SIZED | IMMUTABLE | ORDERED;
}
}
@Override
public String toString() {
return "MemorySegment{ id=0x" + Long.toHexString(id()) + " limit: " + length + " }";
}
@Override
public boolean equals(Object o) {
return o instanceof AbstractMemorySegmentImpl that &&
isNative() == that.isNative() &&
unsafeGetOffset() == that.unsafeGetOffset() &&
unsafeGetBase() == that.unsafeGetBase() &&
length == that.length &&
session.equals(that.session);
}
@Override
public int hashCode() {
return Objects.hash(
isNative(),
unsafeGetOffset(),
unsafeGetBase(),
length,
session
);
}
public static AbstractMemorySegmentImpl ofBuffer(Buffer bb) {
Objects.requireNonNull(bb);
long bbAddress = nioAccess.getBufferAddress(bb);
Object base = nioAccess.getBufferBase(bb);
UnmapperProxy unmapper = nioAccess.unmapper(bb);
int pos = bb.position();
int limit = bb.limit();
int size = limit - pos;
AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl)nioAccess.bufferSegment(bb);
final MemorySession bufferSession;
if (bufferSegment != null) {
bufferSession = bufferSegment.session;
} else {
bufferSession = MemorySessionImpl.heapSession(bb);
}
boolean readOnly = bb.isReadOnly();
int scaleFactor = getScaleFactor(bb);
if (base != null) {
if (base instanceof byte[]) {
return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);
} else if (base instanceof short[]) {
return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);
} else if (base instanceof char[]) {
return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);
} else if (base instanceof int[]) {
return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);
} else if (base instanceof float[]) {
return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);
} else if (base instanceof long[]) {
return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);
} else if (base instanceof double[]) {
return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);
} else {
throw new AssertionError("Cannot get here");
}
} else if (unmapper == null) {
return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, readOnly, bufferSession);
} else {
return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, readOnly, bufferSession);
}
}
private static int getScaleFactor(Buffer buffer) {
if (buffer instanceof ByteBuffer) {
return 0;
} else if (buffer instanceof CharBuffer) {
return 1;
} else if (buffer instanceof ShortBuffer) {
return 1;
} else if (buffer instanceof IntBuffer) {
return 2;
} else if (buffer instanceof FloatBuffer) {
return 2;
} else if (buffer instanceof LongBuffer) {
return 3;
} else if (buffer instanceof DoubleBuffer) {
return 3;
} else {
throw new AssertionError("Cannot get here");
}
}
}
package java.lang;
public class AbstractMethodError extends IncompatibleClassChangeError {
@java.io.Serial
private static final long serialVersionUID = -1654391082989018462L;
public AbstractMethodError() {
super();
}
public AbstractMethodError(String s) {
super(s);
}
}
package com.sun.media.sound;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.sound.midi.InvalidMidiDataException;
import javax.sound.midi.MidiDevice;
import javax.sound.midi.MidiDeviceReceiver;
import javax.sound.midi.MidiDeviceTransmitter;
import javax.sound.midi.MidiMessage;
import javax.sound.midi.MidiUnavailableException;
import javax.sound.midi.Receiver;
import javax.sound.midi.Transmitter;
abstract class AbstractMidiDevice implements MidiDevice, ReferenceCountingDevice {
private ArrayList<Receiver> receiverList;
private TransmitterList transmitterList;
private final Object traRecLock = new Object();
private final MidiDevice.Info info;
private volatile boolean open;
private int openRefCount;
private List<Object> openKeepingObjects;
protected volatile long id;
protected AbstractMidiDevice(MidiDevice.Info info) {
this.info = info;
openRefCount = 0;
}
@Override
public final MidiDevice.Info getDeviceInfo() {
return info;
}
@Override
public final void open() throws MidiUnavailableException {
synchronized(this) {
openRefCount = -1;
doOpen();
}
}
private void openInternal(Object object) throws MidiUnavailableException {
synchronized(this) {
if (openRefCount != -1) {
openRefCount++;
getOpenKeepingObjects().add(object);
}
doOpen();
}
}
private void doOpen() throws MidiUnavailableException {
synchronized(this) {
if (! isOpen()) {
implOpen();
open = true;
}
}
}
@Override
public final void close() {
synchronized (this) {
doClose();
openRefCount = 0;
}
}
public final void closeInternal(Object object) {
synchronized(this) {
if (getOpenKeepingObjects().remove(object)) {
if (openRefCount > 0) {
openRefCount--;
if (openRefCount == 0) {
doClose();
}
}
}
}
}
public final void doClose() {
synchronized(this) {
if (isOpen()) {
implClose();
open = false;
}
}
}
@Override
public final boolean isOpen() {
return open;
}
protected void implClose() {
synchronized (traRecLock) {
if (receiverList != null) {
for(int i = 0; i < receiverList.size(); i++) {
receiverList.get(i).close();
}
receiverList.clear();
}
if (transmitterList != null) {
transmitterList.close();
}
}
}
@Override
public long getMicrosecondPosition() {
return -1;
}
@Override
public final int getMaxReceivers() {
if (hasReceivers()) {
return -1;
} else {
return 0;
}
}
@Override
public final int getMaxTransmitters() {
if (hasTransmitters()) {
return -1;
} else {
return 0;
}
}
@Override
public final Receiver getReceiver() throws MidiUnavailableException {
Receiver receiver;
synchronized (traRecLock) {
receiver = createReceiver();             getReceiverList().add(receiver);
}
return receiver;
}
@Override
@SuppressWarnings("unchecked")     public final List<Receiver> getReceivers() {
List<Receiver> recs;
synchronized (traRecLock) {
if (receiverList == null) {
recs = Collections.unmodifiableList(new ArrayList<Receiver>(0));
} else {
recs = Collections.unmodifiableList
((List<Receiver>) (receiverList.clone()));
}
}
return recs;
}
@Override
public final Transmitter getTransmitter() throws MidiUnavailableException {
Transmitter transmitter;
synchronized (traRecLock) {
transmitter = createTransmitter();             getTransmitterList().add(transmitter);
}
return transmitter;
}
@Override
@SuppressWarnings("unchecked")     public final List<Transmitter> getTransmitters() {
List<Transmitter> tras;
synchronized (traRecLock) {
if (transmitterList == null
|| transmitterList.transmitters.size() == 0) {
tras = Collections.unmodifiableList(new ArrayList<Transmitter>(0));
} else {
tras = Collections.unmodifiableList((List<Transmitter>) (transmitterList.transmitters.clone()));
}
}
return tras;
}
final long getId() {
return id;
}
@Override
public final Receiver getReceiverReferenceCounting()
throws MidiUnavailableException {
Receiver receiver;
synchronized (traRecLock) {
receiver = getReceiver();
AbstractMidiDevice.this.openInternal(receiver);
}
return receiver;
}
@Override
public final Transmitter getTransmitterReferenceCounting()
throws MidiUnavailableException {
Transmitter transmitter;
synchronized (traRecLock) {
transmitter = getTransmitter();
AbstractMidiDevice.this.openInternal(transmitter);
}
return transmitter;
}
private synchronized List<Object> getOpenKeepingObjects() {
if (openKeepingObjects == null) {
openKeepingObjects = new ArrayList<>();
}
return openKeepingObjects;
}
private List<Receiver> getReceiverList() {
synchronized (traRecLock) {
if (receiverList == null) {
receiverList = new ArrayList<>();
}
}
return receiverList;
}
protected boolean hasReceivers() {
return false;
}
protected Receiver createReceiver() throws MidiUnavailableException {
throw new MidiUnavailableException("MIDI IN receiver not available");
}
final TransmitterList getTransmitterList() {
synchronized (traRecLock) {
if (transmitterList == null) {
transmitterList = new TransmitterList();
}
}
return transmitterList;
}
protected boolean hasTransmitters() {
return false;
}
protected Transmitter createTransmitter() throws MidiUnavailableException {
throw new MidiUnavailableException("MIDI OUT transmitter not available");
}
protected abstract void implOpen() throws MidiUnavailableException;
@Override
@SuppressWarnings("removal")
protected final void finalize() {
close();
}
abstract class AbstractReceiver implements MidiDeviceReceiver {
private volatile boolean open = true;
@Override
public final synchronized void send(final MidiMessage message,
final long timeStamp) {
if (!open) {
throw new IllegalStateException("Receiver is not open");
}
implSend(message, timeStamp);
}
abstract void implSend(MidiMessage message, long timeStamp);
@Override
public final void close() {
open = false;
synchronized (AbstractMidiDevice.this.traRecLock) {
AbstractMidiDevice.this.getReceiverList().remove(this);
}
AbstractMidiDevice.this.closeInternal(this);
}
@Override
public final MidiDevice getMidiDevice() {
return AbstractMidiDevice.this;
}
final boolean isOpen() {
return open;
}
}
class BasicTransmitter implements MidiDeviceTransmitter {
private Receiver receiver = null;
TransmitterList tlist = null;
protected BasicTransmitter() {
}
private void setTransmitterList(TransmitterList tlist) {
this.tlist = tlist;
}
@Override
public final void setReceiver(Receiver receiver) {
if (tlist != null && this.receiver != receiver) {
tlist.receiverChanged(this, this.receiver, receiver);
this.receiver = receiver;
}
}
@Override
public final Receiver getReceiver() {
return receiver;
}
@Override
public final void close() {
AbstractMidiDevice.this.closeInternal(this);
if (tlist != null) {
tlist.receiverChanged(this, this.receiver, null);
tlist.remove(this);
tlist = null;
}
}
@Override
public final MidiDevice getMidiDevice() {
return AbstractMidiDevice.this;
}
}
final class TransmitterList {
private final ArrayList<Transmitter> transmitters = new ArrayList<>();
private MidiOutDevice.MidiOutReceiver midiOutReceiver;
private int optimizedReceiverCount = 0;
private void add(Transmitter t) {
synchronized(transmitters) {
transmitters.add(t);
}
if (t instanceof BasicTransmitter) {
((BasicTransmitter) t).setTransmitterList(this);
}
}
private void remove(Transmitter t) {
synchronized(transmitters) {
int index = transmitters.indexOf(t);
if (index >= 0) {
transmitters.remove(index);
}
}
}
private void receiverChanged(BasicTransmitter t,
Receiver oldR,
Receiver newR) {
synchronized(transmitters) {
if (midiOutReceiver == oldR) {
midiOutReceiver = null;
}
if ((newR instanceof MidiOutDevice.MidiOutReceiver newReceiver)
&& (midiOutReceiver == null)) {
midiOutReceiver = newReceiver;
}
optimizedReceiverCount =
((midiOutReceiver!=null)?1:0);
}
}
void close() {
synchronized (transmitters) {
for(int i = 0; i < transmitters.size(); i++) {
transmitters.get(i).close();
}
transmitters.clear();
}
}
void sendMessage(int packedMessage, long timeStamp) {
try {
synchronized(transmitters) {
int size = transmitters.size();
if (optimizedReceiverCount == size) {
if (midiOutReceiver != null) {
midiOutReceiver.sendPackedMidiMessage(packedMessage, timeStamp);
}
} else {
for (int i = 0; i < size; i++) {
Receiver receiver = transmitters.get(i).getReceiver();
if (receiver != null) {
if (optimizedReceiverCount > 0) {
if (receiver instanceof MidiOutDevice.MidiOutReceiver) {
((MidiOutDevice.MidiOutReceiver) receiver).sendPackedMidiMessage(packedMessage, timeStamp);
} else {
receiver.send(new FastShortMessage(packedMessage), timeStamp);
}
} else {
receiver.send(new FastShortMessage(packedMessage), timeStamp);
}
}
}
}
}
} catch (InvalidMidiDataException e) {
}
}
void sendMessage(byte[] data, long timeStamp) {
try {
synchronized(transmitters) {
int size = transmitters.size();
for (int i = 0; i < size; i++) {
Receiver receiver = transmitters.get(i).getReceiver();
if (receiver != null) {
receiver.send(new FastSysexMessage(data), timeStamp);
}
}
}
} catch (InvalidMidiDataException e) {
return;
}
}
void sendMessage(MidiMessage message, long timeStamp) {
if (message instanceof FastShortMessage) {
sendMessage(((FastShortMessage) message).getPackedMsg(), timeStamp);
return;
}
synchronized(transmitters) {
int size = transmitters.size();
if (optimizedReceiverCount == size) {
if (midiOutReceiver != null) {
midiOutReceiver.send(message, timeStamp);
}
} else {
for (int i = 0; i < size; i++) {
Receiver receiver = transmitters.get(i).getReceiver();
if (receiver != null) {
receiver.send(message, timeStamp);
}
}
}
}
}
} }
package com.sun.media.sound;
import java.util.Objects;
import javax.sound.midi.MidiDevice;
import javax.sound.midi.spi.MidiDeviceProvider;
public abstract class AbstractMidiDeviceProvider extends MidiDeviceProvider {
private static final boolean enabled;
static {
Platform.initialize();
enabled = Platform.isMidiIOEnabled();
}
final synchronized void readDeviceInfos() {
Info[] infos = getInfoCache();
MidiDevice[] devices = getDeviceCache();
if (!enabled) {
if (infos == null || infos.length != 0) {
setInfoCache(new Info[0]);
}
if (devices == null || devices.length != 0) {
setDeviceCache(new MidiDevice[0]);
}
return;
}
int oldNumDevices = (infos==null)?-1:infos.length;
int newNumDevices = getNumDevices();
if (oldNumDevices != newNumDevices) {
Info[] newInfos = new Info[newNumDevices];
MidiDevice[] newDevices = new MidiDevice[newNumDevices];
for (int i = 0; i < newNumDevices; i++) {
Info newInfo = createInfo(i);
if (infos != null) {
for (int ii = 0; ii < infos.length; ii++) {
Info info = infos[ii];
if (info != null && info.equalStrings(newInfo)) {
newInfos[i] = info;
info.setIndex(i);
infos[ii] = null;                             newDevices[i] = devices[ii];
devices[ii] = null;
break;
}
}
}
if (newInfos[i] == null) {
newInfos[i] = newInfo;
}
}
if (infos != null) {
for (int i = 0; i < infos.length; i++) {
if (infos[i] != null) {
infos[i].setIndex(-1);
}
}
}
setInfoCache(newInfos);
setDeviceCache(newDevices);
}
}
@Override
public final MidiDevice.Info[] getDeviceInfo() {
readDeviceInfos();
Info[] infos = getInfoCache();
MidiDevice.Info[] localArray = new MidiDevice.Info[infos.length];
System.arraycopy(infos, 0, localArray, 0, infos.length);
return localArray;
}
@Override
public final MidiDevice getDevice(final MidiDevice.Info info) {
Objects.requireNonNull(info);
if (info instanceof Info) {
readDeviceInfos();
MidiDevice[] devices = getDeviceCache();
Info[] infos = getInfoCache();
Info thisInfo = (Info) info;
int index = thisInfo.getIndex();
if (index >= 0 && index < devices.length && infos[index] == info) {
if (devices[index] == null) {
devices[index] = createDevice(thisInfo);
}
if (devices[index] != null) {
return devices[index];
}
}
}
throw MidiUtils.unsupportedDevice(info);
}
static class Info extends MidiDevice.Info {
private int index;
Info(String name, String vendor, String description, String version, int index) {
super(name, vendor, description, version);
this.index = index;
}
final boolean equalStrings(Info info) {
return      (info != null
&& getName().equals(info.getName())
&& getVendor().equals(info.getVendor())
&& getDescription().equals(info.getDescription())
&& getVersion().equals(info.getVersion()));
}
final int getIndex() {
return index;
}
final void setIndex(int index) {
this.index = index;
}
}
abstract int getNumDevices();
abstract MidiDevice[] getDeviceCache();
abstract void setDeviceCache(MidiDevice[] devices);
abstract Info[] getInfoCache();
abstract void setInfoCache(Info[] infos);
abstract Info createInfo(int index);
abstract MidiDevice createDevice(Info info);
}
package com.sun.media.sound;
import java.util.ArrayList;
import java.util.Vector;
import javax.sound.sampled.Control;
import javax.sound.sampled.Line;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.Mixer;
abstract class AbstractMixer extends AbstractLine implements Mixer {
protected static final int PCM  = 0;
protected static final int ULAW = 1;
protected static final int ALAW = 2;
private final Mixer.Info mixerInfo;
protected Line.Info[] sourceLineInfo;
protected Line.Info[] targetLineInfo;
private boolean started = false;
private boolean manuallyOpened = false;
private final Vector<Line> sourceLines = new Vector<>();
private final Vector<Line> targetLines = new Vector<>();
protected AbstractMixer(Mixer.Info mixerInfo,
Control[] controls,
Line.Info[] sourceLineInfo,
Line.Info[] targetLineInfo) {
super(new Line.Info(Mixer.class), null, controls);
this.mixer = this;
if (controls == null) {
controls = new Control[0];
}
this.mixerInfo = mixerInfo;
this.sourceLineInfo = sourceLineInfo;
this.targetLineInfo = targetLineInfo;
}
@Override
public final Mixer.Info getMixerInfo() {
return mixerInfo;
}
@Override
public final Line.Info[] getSourceLineInfo() {
Line.Info[] localArray = new Line.Info[sourceLineInfo.length];
System.arraycopy(sourceLineInfo, 0, localArray, 0, sourceLineInfo.length);
return localArray;
}
@Override
public final Line.Info[] getTargetLineInfo() {
Line.Info[] localArray = new Line.Info[targetLineInfo.length];
System.arraycopy(targetLineInfo, 0, localArray, 0, targetLineInfo.length);
return localArray;
}
@Override
public final Line.Info[] getSourceLineInfo(Line.Info info) {
int i;
ArrayList<Line.Info> vec = new ArrayList<>();
for (i = 0; i < sourceLineInfo.length; i++) {
if (info.matches(sourceLineInfo[i])) {
vec.add(sourceLineInfo[i]);
}
}
Line.Info[] returnedArray = new Line.Info[vec.size()];
for (i = 0; i < returnedArray.length; i++) {
returnedArray[i] = vec.get(i);
}
return returnedArray;
}
@Override
public final Line.Info[] getTargetLineInfo(Line.Info info) {
int i;
ArrayList<Line.Info> vec = new ArrayList<>();
for (i = 0; i < targetLineInfo.length; i++) {
if (info.matches(targetLineInfo[i])) {
vec.add(targetLineInfo[i]);
}
}
Line.Info[] returnedArray = new Line.Info[vec.size()];
for (i = 0; i < returnedArray.length; i++) {
returnedArray[i] = vec.get(i);
}
return returnedArray;
}
@Override
public final boolean isLineSupported(Line.Info info) {
int i;
for (i = 0; i < sourceLineInfo.length; i++) {
if (info.matches(sourceLineInfo[i])) {
return true;
}
}
for (i = 0; i < targetLineInfo.length; i++) {
if (info.matches(targetLineInfo[i])) {
return true;
}
}
return false;
}
@Override
public abstract Line getLine(Line.Info info) throws LineUnavailableException;
@Override
public abstract int getMaxLines(Line.Info info);
protected abstract void implOpen() throws LineUnavailableException;
protected abstract void implStart();
protected abstract void implStop();
protected abstract void implClose();
@Override
public final Line[] getSourceLines() {
Line[] localLines;
synchronized(sourceLines) {
localLines = new Line[sourceLines.size()];
for (int i = 0; i < localLines.length; i++) {
localLines[i] = sourceLines.elementAt(i);
}
}
return localLines;
}
@Override
public final Line[] getTargetLines() {
Line[] localLines;
synchronized(targetLines) {
localLines = new Line[targetLines.size()];
for (int i = 0; i < localLines.length; i++) {
localLines[i] = targetLines.elementAt(i);
}
}
return localLines;
}
@Override
public final void synchronize(Line[] lines, boolean maintainSync) {
throw new IllegalArgumentException("Synchronization not supported by this mixer.");
}
@Override
public final void unsynchronize(Line[] lines) {
throw new IllegalArgumentException("Synchronization not supported by this mixer.");
}
@Override
public final boolean isSynchronizationSupported(Line[] lines,
boolean maintainSync) {
return false;
}
@Override
public final synchronized void open() throws LineUnavailableException {
open(true);
}
final synchronized void open(boolean manual) throws LineUnavailableException {
if (!isOpen()) {
implOpen();
setOpen(true);
if (manual) {
manuallyOpened = true;
}
}
}
final synchronized void open(Line line) throws LineUnavailableException {
if (this.equals(line)) {
return;
}
if (isSourceLine(line.getLineInfo())) {
if (! sourceLines.contains(line) ) {
open(false);
sourceLines.addElement(line);
}
} else {
if(isTargetLine(line.getLineInfo())) {
if (! targetLines.contains(line) ) {
open(false);
targetLines.addElement(line);
}
} else {
if (Printer.err) Printer.err("Unknown line received for AbstractMixer.open(Line): " + line);
}
}
}
final synchronized void close(Line line) {
if (this.equals(line)) {
return;
}
sourceLines.removeElement(line);
targetLines.removeElement(line);
if (sourceLines.isEmpty() && targetLines.isEmpty() && !manuallyOpened) {
close();
}
}
@Override
public final synchronized void close() {
if (isOpen()) {
Line[] localLines = getSourceLines();
for (int i = 0; i<localLines.length; i++) {
localLines[i].close();
}
localLines = getTargetLines();
for (int i = 0; i<localLines.length; i++) {
localLines[i].close();
}
implClose();
setOpen(false);
}
manuallyOpened = false;
}
final synchronized void start(Line line) {
if (this.equals(line)) {
return;
}
if (!started) {
implStart();
started = true;
}
}
final synchronized void stop(Line line) {
if (this.equals(line)) {
return;
}
@SuppressWarnings("unchecked")
Vector<Line> localSourceLines = (Vector<Line>)sourceLines.clone();
for (int i = 0; i < localSourceLines.size(); i++) {
if (localSourceLines.elementAt(i) instanceof AbstractDataLine) {
AbstractDataLine sourceLine = (AbstractDataLine)localSourceLines.elementAt(i);
if ( sourceLine.isStartedRunning() && (!sourceLine.equals(line)) ) {
return;
}
}
}
@SuppressWarnings("unchecked")
Vector<Line> localTargetLines = (Vector<Line>)targetLines.clone();
for (int i = 0; i < localTargetLines.size(); i++) {
if (localTargetLines.elementAt(i) instanceof AbstractDataLine) {
AbstractDataLine targetLine = (AbstractDataLine)localTargetLines.elementAt(i);
if ( targetLine.isStartedRunning() && (!targetLine.equals(line)) ) {
return;
}
}
}
started = false;
implStop();
}
final boolean isSourceLine(Line.Info info) {
for (int i = 0; i < sourceLineInfo.length; i++) {
if (info.matches(sourceLineInfo[i])) {
return true;
}
}
return false;
}
final boolean isTargetLine(Line.Info info) {
for (int i = 0; i < targetLineInfo.length; i++) {
if (info.matches(targetLineInfo[i])) {
return true;
}
}
return false;
}
final Line.Info getLineInfo(Line.Info info) {
if (info == null) {
return null;
}
for (int i = 0; i < sourceLineInfo.length; i++) {
if (info.matches(sourceLineInfo[i])) {
return sourceLineInfo[i];
}
}
for (int i = 0; i < targetLineInfo.length; i++) {
if (info.matches(targetLineInfo[i])) {
return targetLineInfo[i];
}
}
return null;
}
}
package sun.jvmstat.monitor;
public abstract class AbstractMonitor implements Monitor  {
protected String name;
protected Units units;
protected Variability variability;
protected int vectorLength;
protected boolean supported;
protected AbstractMonitor(String name, Units units, Variability variability,
boolean supported, int vectorLength) {
this.name = name;
this.units = units;
this.variability = variability;
this.vectorLength = vectorLength;
this.supported = supported;
}
protected AbstractMonitor(String name, Units units, Variability variability,
boolean supported) {
this(name, units, variability, supported, 0);
}
public String getName() {
return name;
}
public String getBaseName() {
int baseIndex = name.lastIndexOf('.') + 1;
return name.substring(baseIndex);
}
public Units getUnits() {
return units;
}
public Variability getVariability() {
return variability;
}
public boolean isVector() {
return vectorLength > 0;
}
public int getVectorLength() {
return vectorLength;
}
public boolean isSupported() {
return supported;
}
public abstract Object getValue();
}
package sun.jvmstat.perfdata.monitor;
import java.util.List;
import sun.jvmstat.monitor.*;
import sun.jvmstat.monitor.event.VmListener;
public abstract class AbstractMonitoredVm implements BufferedMonitoredVm {
protected VmIdentifier vmid;
protected AbstractPerfDataBuffer pdb;
protected int interval;
public AbstractMonitoredVm(VmIdentifier vmid, int interval)
throws MonitorException {
this.vmid = vmid;
this.interval = interval;
}
public VmIdentifier getVmIdentifier() {
return vmid;
}
public Monitor findByName(String name) throws MonitorException {
return pdb.findByName(name);
}
public List<Monitor> findByPattern(String patternString) throws MonitorException {
return pdb.findByPattern(patternString);
}
public void detach() {
}
public void setInterval(int interval) {
this.interval = interval;
}
public int getInterval() {
return interval;
}
public void setLastException(Exception e) {
}
public Exception getLastException() {
return null;
}
public void clearLastException() {
}
public boolean isErrored() {
return false;
}
public MonitorStatus getMonitorStatus() throws MonitorException {
return pdb.getMonitorStatus();
}
public abstract void addVmListener(VmListener l);
public abstract void removeVmListener(VmListener l);
public byte[] getBytes() {
return pdb.getBytes();
}
public int getCapacity() {
return pdb.getCapacity();
}
}
package java.awt.image;
import java.awt.Graphics;
import java.awt.Image;
public abstract class AbstractMultiResolutionImage extends java.awt.Image
implements MultiResolutionImage {
protected AbstractMultiResolutionImage() {}
@Override
public int getWidth(ImageObserver observer) {
return getBaseImage().getWidth(observer);
}
@Override
public int getHeight(ImageObserver observer) {
return getBaseImage().getHeight(observer);
}
@Override
public ImageProducer getSource() {
return getBaseImage().getSource();
}
@Override
public Graphics getGraphics() {
throw new UnsupportedOperationException("getGraphics() not supported"
+ " on Multi-Resolution Images");
}
@Override
public Object getProperty(String name, ImageObserver observer) {
return getBaseImage().getProperty(name, observer);
}
protected abstract Image getBaseImage();
}
package build.tools.jdwpgen;
import java.util.*;
import java.io.*;
abstract class AbstractNamedNode extends Node {
NameNode nameNode = null;
String name;
public String name() {
return name;
}
void prune() {
Iterator<Node> it = components.iterator();
if (it.hasNext()) {
Node nameNode = it.next();
if (nameNode instanceof NameNode) {
this.nameNode = (NameNode)nameNode;
this.name = this.nameNode.text();
it.remove();
} else {
error("Bad name: " + name);
}
} else {
error("empty");
}
super.prune();
}
void constrain(Context ctx) {
nameNode.constrain(ctx);
super.constrain(ctx.subcontext(name));
}
void document(PrintWriter writer) {
writer.println("<h2 id=\"" + name + "\">" + name +
" Command Set</h2>");
for (Node node : components) {
node.document(writer);
}
}
String javaClassName() {
return name();
}
void genJavaClassSpecifics(PrintWriter writer, int depth) {
}
String javaClassImplements() {
return "";     }
void genJavaClass(PrintWriter writer, int depth) {
writer.println();
genJavaComment(writer, depth);
indent(writer, depth);
if (depth != 0) {
writer.print("static ");
}
writer.print("class " + javaClassName());
writer.println(javaClassImplements() + " {");
genJavaClassSpecifics(writer, depth+1);
for (Node node : components) {
node.genJava(writer, depth+1);
}
indent(writer, depth);
writer.println("}");
}
void genCInclude(PrintWriter writer) {
if (nameNode instanceof NameValueNode) {
writer.println("#define " + context.whereC +
" " + nameNode.value());
}
super.genCInclude(writer);
}
}
package com.sun.nio.sctp;
public class AbstractNotificationHandler<T>
implements NotificationHandler<T>
{
protected AbstractNotificationHandler() {}
@Override
public HandlerResult handleNotification(Notification notification,
T attachment) {
return HandlerResult.CONTINUE;
}
public HandlerResult handleNotification(AssociationChangeNotification notification,
T attachment) {
return HandlerResult.CONTINUE;
}
public HandlerResult handleNotification(PeerAddressChangeNotification notification,
T attachment) {
return HandlerResult.CONTINUE;
}
public HandlerResult handleNotification(SendFailedNotification notification,
T attachment) {
return HandlerResult.CONTINUE;
}
public HandlerResult handleNotification(ShutdownNotification notification,
T attachment) {
return HandlerResult.CONTINUE;
}
}
package jdk.internal.joptsimple;
import java.util.ArrayList;
import java.util.List;
import static java.util.Collections.*;
import jdk.internal.joptsimple.internal.Reflection;
import jdk.internal.joptsimple.internal.ReflectionException;
import static jdk.internal.joptsimple.internal.Strings.*;
public abstract class AbstractOptionSpec<V> implements OptionSpec<V>, OptionDescriptor {
private final List<String> options = new ArrayList<>();
private final String description;
private boolean forHelp;
AbstractOptionSpec( String option ) {
this( singletonList( option ), EMPTY );
}
AbstractOptionSpec( List<String> options, String description ) {
arrangeOptions( options );
this.description = description;
}
public final List<String> options() {
return unmodifiableList( options );
}
public final List<V> values( OptionSet detectedOptions ) {
return detectedOptions.valuesOf( this );
}
public final V value( OptionSet detectedOptions ) {
return detectedOptions.valueOf( this );
}
public String description() {
return description;
}
public final AbstractOptionSpec<V> forHelp() {
forHelp = true;
return this;
}
public final boolean isForHelp() {
return forHelp;
}
public boolean representsNonOptions() {
return false;
}
protected abstract V convert( String argument );
protected V convertWith( ValueConverter<V> converter, String argument ) {
try {
return Reflection.convertWith( converter, argument );
} catch ( ReflectionException | ValueConversionException ex ) {
throw new OptionArgumentConversionException( this, argument, ex );
}
}
protected String argumentTypeIndicatorFrom( ValueConverter<V> converter ) {
if ( converter == null )
return null;
String pattern = converter.valuePattern();
return pattern == null ? converter.valueType().getName() : pattern;
}
abstract void handleOption( OptionParser parser, ArgumentList arguments, OptionSet detectedOptions,
String detectedArgument );
private void arrangeOptions( List<String> unarranged ) {
if ( unarranged.size() == 1 ) {
options.addAll( unarranged );
return;
}
List<String> shortOptions = new ArrayList<>();
List<String> longOptions = new ArrayList<>();
for ( String each : unarranged ) {
if ( each.length() == 1 )
shortOptions.add( each );
else
longOptions.add( each );
}
sort( shortOptions );
sort( longOptions );
options.addAll( shortOptions );
options.addAll( longOptions );
}
@Override
public boolean equals( Object that ) {
if ( !( that instanceof AbstractOptionSpec<?> ) )
return false;
AbstractOptionSpec<?> other = (AbstractOptionSpec<?>) that;
return options.equals( other.options );
}
@Override
public int hashCode() {
return options.hashCode();
}
@Override
public String toString() {
return options.toString();
}
}
package jdk.javadoc.internal.doclets.formats.html;
import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;
import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;
import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
import jdk.javadoc.internal.doclets.toolkit.Content;
import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
public abstract class AbstractOverviewIndexWriter extends HtmlDocletWriter {
public AbstractOverviewIndexWriter(HtmlConfiguration configuration,
DocPath filename) {
super(configuration, filename);
}
protected void addOverviewHeader(Content target) {
addConfigurationTitle(target);
addOverviewComment(target);
addOverviewTags(target);
}
protected void addOverviewComment(Content content) {
if (!utils.getFullBody(configuration.overviewElement).isEmpty()) {
addInlineComment(configuration.overviewElement, content);
}
}
protected void addOverviewTags(Content content) {
if (!utils.getFullBody(configuration.overviewElement).isEmpty()) {
addTagsInfo(configuration.overviewElement, content);
}
}
protected void buildOverviewIndexFile(String title, String description)
throws DocFileIOException {
String windowOverview = resources.getText(title);
Content body = getBody(getWindowTitle(windowOverview));
Content main = new ContentBuilder();
addOverviewHeader(main);
addIndex(main);
body.add(new BodyContents()
.setHeader(getHeader(PageMode.OVERVIEW))
.addMainContent(main)
.setFooter(getFooter()));
printHtmlDocument(
configuration.metakeywords.getOverviewMetaKeywords(title, configuration.getOptions().docTitle()),
description, body);
}
protected abstract void addIndex(Content target);
protected void addConfigurationTitle(Content target) {
String doctitle = configuration.getOptions().docTitle();
if (!doctitle.isEmpty()) {
var title = RawHtml.of(doctitle);
var heading = HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING,
HtmlStyle.title, title);
var div = HtmlTree.DIV(HtmlStyle.header, heading);
target.add(div);
}
}
}
package java.util.concurrent.locks;
public abstract class AbstractOwnableSynchronizer
implements java.io.Serializable {
private static final long serialVersionUID = 3737899427754241961L;
protected AbstractOwnableSynchronizer() { }
private transient Thread exclusiveOwnerThread;
protected final void setExclusiveOwnerThread(Thread thread) {
exclusiveOwnerThread = thread;
}
protected final Thread getExclusiveOwnerThread() {
return exclusiveOwnerThread;
}
}
package sun.jvmstat.perfdata.monitor;
import sun.jvmstat.monitor.*;
import java.util.*;
import java.io.*;
import java.lang.reflect.*;
import java.nio.ByteBuffer;
public abstract class AbstractPerfDataBuffer {
protected PerfDataBufferImpl impl;
public int getLocalVmId() {
return impl.getLocalVmId();
}
public byte[] getBytes() {
return impl.getBytes();
}
public int getCapacity() {
return impl.getCapacity();
}
public Monitor findByName(String name) throws MonitorException {
return impl.findByName(name);
}
public List<Monitor> findByPattern(String patternString) throws MonitorException {
return impl.findByPattern(patternString);
}
public MonitorStatus getMonitorStatus() throws MonitorException {
return impl.getMonitorStatus();
}
public ByteBuffer getByteBuffer() {
return impl.getByteBuffer();
}
protected void createPerfDataBuffer(ByteBuffer bb, int lvmid)
throws MonitorException {
int majorVersion = AbstractPerfDataBufferPrologue.getMajorVersion(bb);
int minorVersion = AbstractPerfDataBufferPrologue.getMinorVersion(bb);
String classname = "sun.jvmstat.perfdata.monitor.v"
+ majorVersion + "_" + minorVersion
+ ".PerfDataBuffer";
try {
Class<?> implClass = Class.forName(classname);
Constructor<?> cons = implClass.getConstructor(new Class<?>[] {
Class.forName("java.nio.ByteBuffer"),
Integer.TYPE
});
impl = (PerfDataBufferImpl)cons.newInstance(new Object[] {
bb, lvmid
});
} catch (ClassNotFoundException e) {
throw new IllegalArgumentException(
"Could not find " + classname + ": " + e.getMessage(), e);
} catch (NoSuchMethodException e) {
throw new IllegalArgumentException(
"Expected constructor missing in " + classname + ": "
+ e.getMessage(), e);
} catch (IllegalAccessException e) {
throw new IllegalArgumentException(
"Unexpected constructor access in " + classname + ": "
+ e.getMessage(), e);
} catch (InstantiationException e) {
throw new IllegalArgumentException(
classname + "is abstract: " + e.getMessage(), e);
} catch (InvocationTargetException e) {
Throwable cause = e.getCause();
if (cause instanceof MonitorException) {
throw (MonitorException)cause;
}
throw new RuntimeException("Unexpected exception: "
+ e.getMessage() , e);
}
}
}
package sun.jvmstat.perfdata.monitor;
import sun.jvmstat.monitor.*;
import java.nio.ByteOrder;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
public abstract class AbstractPerfDataBufferPrologue {
protected ByteBuffer byteBuffer;
static final int PERFDATA_PROLOG_OFFSET=0;
static final int PERFDATA_PROLOG_MAGIC_OFFSET=0;
static final int PERFDATA_PROLOG_BYTEORDER_OFFSET=4;
static final int PERFDATA_PROLOG_BYTEORDER_SIZE=1;             static final int PERFDATA_PROLOG_MAJOR_OFFSET=5;
static final int PERFDATA_PROLOG_MAJOR_SIZE=1;                 static final int PERFDATA_PROLOG_MINOR_OFFSET=6;
static final int PERFDATA_PROLOG_MINOR_SIZE=1;                 static final int PERFDATA_PROLOG_RESERVEDB1_OFFSET=7;
static final int PERFDATA_PROLOG_RESERVEDB1_SIZE=1;
static final int PERFDATA_PROLOG_SIZE=8;
static final byte PERFDATA_BIG_ENDIAN=0;
static final byte PERFDATA_LITTLE_ENDIAN=1;
static final int  PERFDATA_MAGIC = 0xcafec0c0;
public static final String PERFDATA_MAJOR_NAME =
"sun.perfdata.majorVersion";
public static final String PERFDATA_MINOR_NAME =
"sun.perfdata.minorVersion";
public AbstractPerfDataBufferPrologue(ByteBuffer byteBuffer)
throws MonitorException  {
this.byteBuffer = byteBuffer.duplicate();
if (getMagic() != PERFDATA_MAGIC) {
throw new MonitorVersionException(
"Bad Magic: " + Integer.toHexString(getMagic()));
}
this.byteBuffer.order(getByteOrder());
}
public int getMagic() {
ByteOrder order = byteBuffer.order();
byteBuffer.order(ByteOrder.BIG_ENDIAN);
byteBuffer.position(PERFDATA_PROLOG_MAGIC_OFFSET);
int magic = byteBuffer.getInt();
byteBuffer.order(order);
return magic;
}
public ByteOrder getByteOrder() {
byteBuffer.position(PERFDATA_PROLOG_BYTEORDER_OFFSET);
byte byte_order = byteBuffer.get();
if (byte_order == PERFDATA_BIG_ENDIAN) {
return ByteOrder.BIG_ENDIAN;
} else {
return ByteOrder.LITTLE_ENDIAN;
}
}
public int getMajorVersion() {
byteBuffer.position(PERFDATA_PROLOG_MAJOR_OFFSET);
return (int)byteBuffer.get();
}
public int getMinorVersion() {
byteBuffer.position(PERFDATA_PROLOG_MINOR_OFFSET);
return (int)byteBuffer.get();
}
public abstract boolean isAccessible();
public abstract boolean supportsAccessible();
public int getSize() {
return PERFDATA_PROLOG_SIZE;      }
public IntBuffer majorVersionBuffer() {
int[] holder = new int[1];
holder[0] = getMajorVersion();
IntBuffer ib = IntBuffer.wrap(holder);
ib.limit(1);
return ib;
}
public IntBuffer minorVersionBuffer() {
int[] holder = new int[1];
holder[0] = getMinorVersion();
IntBuffer ib = IntBuffer.wrap(holder);
ib.limit(1);
return ib;
}
public static int getMagic(ByteBuffer bb) {
int position = bb.position();
ByteOrder order = bb.order();
bb.order(ByteOrder.BIG_ENDIAN);
bb.position(PERFDATA_PROLOG_MAGIC_OFFSET);
int magic = bb.getInt();
bb.order(order);
bb.position(position);
return magic;
}
public static int getMajorVersion(ByteBuffer bb) {
int position = bb.position();
bb.position(PERFDATA_PROLOG_MAJOR_OFFSET);
int major = (int) bb.get();
bb.position(position);
return major;
}
public static int getMinorVersion(ByteBuffer bb) {
int position = bb.position();
bb.position(PERFDATA_PROLOG_MINOR_OFFSET);
int minor = (int)bb.get();
bb.position(position);
return minor;
}
public static ByteOrder getByteOrder(ByteBuffer bb) {
int position = bb.position();
bb.position(PERFDATA_PROLOG_BYTEORDER_OFFSET);
ByteOrder order = (bb.get() == PERFDATA_BIG_ENDIAN)
? ByteOrder.BIG_ENDIAN
: ByteOrder.LITTLE_ENDIAN;
bb.position(position);
return order;
}
}
package java.util.stream;
import java.util.Objects;
import java.util.Spliterator;
import java.util.function.IntFunction;
import java.util.function.Supplier;
abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT, S>>
extends PipelineHelper<E_OUT> implements BaseStream<E_OUT, S> {
private static final String MSG_STREAM_LINKED = "stream has already been operated upon or closed";
private static final String MSG_CONSUMED = "source already consumed or closed";
@SuppressWarnings("rawtypes")
private final AbstractPipeline sourceStage;
@SuppressWarnings("rawtypes")
private final AbstractPipeline previousStage;
protected final int sourceOrOpFlags;
@SuppressWarnings("rawtypes")
private AbstractPipeline nextStage;
private int depth;
private int combinedFlags;
private Spliterator<?> sourceSpliterator;
private Supplier<? extends Spliterator<?>> sourceSupplier;
private boolean linkedOrConsumed;
private boolean sourceAnyStateful;
private Runnable sourceCloseAction;
private boolean parallel;
AbstractPipeline(Supplier<? extends Spliterator<?>> source,
int sourceFlags, boolean parallel) {
this.previousStage = null;
this.sourceSupplier = source;
this.sourceStage = this;
this.sourceOrOpFlags = sourceFlags & StreamOpFlag.STREAM_MASK;
this.combinedFlags = (~(sourceOrOpFlags << 1)) & StreamOpFlag.INITIAL_OPS_VALUE;
this.depth = 0;
this.parallel = parallel;
}
AbstractPipeline(Spliterator<?> source,
int sourceFlags, boolean parallel) {
this.previousStage = null;
this.sourceSpliterator = source;
this.sourceStage = this;
this.sourceOrOpFlags = sourceFlags & StreamOpFlag.STREAM_MASK;
this.combinedFlags = (~(sourceOrOpFlags << 1)) & StreamOpFlag.INITIAL_OPS_VALUE;
this.depth = 0;
this.parallel = parallel;
}
AbstractPipeline(AbstractPipeline<?, E_IN, ?> previousStage, int opFlags) {
if (previousStage.linkedOrConsumed)
throw new IllegalStateException(MSG_STREAM_LINKED);
previousStage.linkedOrConsumed = true;
previousStage.nextStage = this;
this.previousStage = previousStage;
this.sourceOrOpFlags = opFlags & StreamOpFlag.OP_MASK;
this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);
this.sourceStage = previousStage.sourceStage;
if (opIsStateful())
sourceStage.sourceAnyStateful = true;
this.depth = previousStage.depth + 1;
}
final <R> R evaluate(TerminalOp<E_OUT, R> terminalOp) {
assert getOutputShape() == terminalOp.inputShape();
if (linkedOrConsumed)
throw new IllegalStateException(MSG_STREAM_LINKED);
linkedOrConsumed = true;
return isParallel()
? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))
: terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));
}
@SuppressWarnings("unchecked")
final Node<E_OUT> evaluateToArrayNode(IntFunction<E_OUT[]> generator) {
if (linkedOrConsumed)
throw new IllegalStateException(MSG_STREAM_LINKED);
linkedOrConsumed = true;
if (isParallel() && previousStage != null && opIsStateful()) {
depth = 0;
return opEvaluateParallel(previousStage, previousStage.sourceSpliterator(0), generator);
}
else {
return evaluate(sourceSpliterator(0), true, generator);
}
}
@SuppressWarnings("unchecked")
final Spliterator<E_OUT> sourceStageSpliterator() {
if (this != sourceStage)
throw new IllegalStateException();
if (linkedOrConsumed)
throw new IllegalStateException(MSG_STREAM_LINKED);
linkedOrConsumed = true;
if (sourceStage.sourceSpliterator != null) {
@SuppressWarnings("unchecked")
Spliterator<E_OUT> s = sourceStage.sourceSpliterator;
sourceStage.sourceSpliterator = null;
return s;
}
else if (sourceStage.sourceSupplier != null) {
@SuppressWarnings("unchecked")
Spliterator<E_OUT> s = (Spliterator<E_OUT>) sourceStage.sourceSupplier.get();
sourceStage.sourceSupplier = null;
return s;
}
else {
throw new IllegalStateException(MSG_CONSUMED);
}
}
@Override
@SuppressWarnings("unchecked")
public final S sequential() {
sourceStage.parallel = false;
return (S) this;
}
@Override
@SuppressWarnings("unchecked")
public final S parallel() {
sourceStage.parallel = true;
return (S) this;
}
@Override
public void close() {
linkedOrConsumed = true;
sourceSupplier = null;
sourceSpliterator = null;
if (sourceStage.sourceCloseAction != null) {
Runnable closeAction = sourceStage.sourceCloseAction;
sourceStage.sourceCloseAction = null;
closeAction.run();
}
}
@Override
@SuppressWarnings("unchecked")
public S onClose(Runnable closeHandler) {
if (linkedOrConsumed)
throw new IllegalStateException(MSG_STREAM_LINKED);
Objects.requireNonNull(closeHandler);
Runnable existingHandler = sourceStage.sourceCloseAction;
sourceStage.sourceCloseAction =
(existingHandler == null)
? closeHandler
: Streams.composeWithExceptions(existingHandler, closeHandler);
return (S) this;
}
@Override
@SuppressWarnings("unchecked")
public Spliterator<E_OUT> spliterator() {
if (linkedOrConsumed)
throw new IllegalStateException(MSG_STREAM_LINKED);
linkedOrConsumed = true;
if (this == sourceStage) {
if (sourceStage.sourceSpliterator != null) {
@SuppressWarnings("unchecked")
Spliterator<E_OUT> s = (Spliterator<E_OUT>) sourceStage.sourceSpliterator;
sourceStage.sourceSpliterator = null;
return s;
}
else if (sourceStage.sourceSupplier != null) {
@SuppressWarnings("unchecked")
Supplier<Spliterator<E_OUT>> s = (Supplier<Spliterator<E_OUT>>) sourceStage.sourceSupplier;
sourceStage.sourceSupplier = null;
return lazySpliterator(s);
}
else {
throw new IllegalStateException(MSG_CONSUMED);
}
}
else {
return wrap(this, () -> sourceSpliterator(0), isParallel());
}
}
@Override
public final boolean isParallel() {
return sourceStage.parallel;
}
final int getStreamFlags() {
return StreamOpFlag.toStreamFlags(combinedFlags);
}
@SuppressWarnings("unchecked")
private Spliterator<?> sourceSpliterator(int terminalFlags) {
Spliterator<?> spliterator = null;
if (sourceStage.sourceSpliterator != null) {
spliterator = sourceStage.sourceSpliterator;
sourceStage.sourceSpliterator = null;
}
else if (sourceStage.sourceSupplier != null) {
spliterator = (Spliterator<?>) sourceStage.sourceSupplier.get();
sourceStage.sourceSupplier = null;
}
else {
throw new IllegalStateException(MSG_CONSUMED);
}
if (isParallel() && sourceStage.sourceAnyStateful) {
int depth = 1;
for (@SuppressWarnings("rawtypes") AbstractPipeline u = sourceStage, p = sourceStage.nextStage, e = this;
u != e;
u = p, p = p.nextStage) {
int thisOpFlags = p.sourceOrOpFlags;
if (p.opIsStateful()) {
depth = 0;
if (StreamOpFlag.SHORT_CIRCUIT.isKnown(thisOpFlags)) {
thisOpFlags = thisOpFlags & ~StreamOpFlag.IS_SHORT_CIRCUIT;
}
spliterator = p.opEvaluateParallelLazy(u, spliterator);
thisOpFlags = spliterator.hasCharacteristics(Spliterator.SIZED)
? (thisOpFlags & ~StreamOpFlag.NOT_SIZED) | StreamOpFlag.IS_SIZED
: (thisOpFlags & ~StreamOpFlag.IS_SIZED) | StreamOpFlag.NOT_SIZED;
}
p.depth = depth++;
p.combinedFlags = StreamOpFlag.combineOpFlags(thisOpFlags, u.combinedFlags);
}
}
if (terminalFlags != 0)  {
combinedFlags = StreamOpFlag.combineOpFlags(terminalFlags, combinedFlags);
}
return spliterator;
}
@Override
final StreamShape getSourceShape() {
@SuppressWarnings("rawtypes")
AbstractPipeline p = AbstractPipeline.this;
while (p.depth > 0) {
p = p.previousStage;
}
return p.getOutputShape();
}
@Override
final <P_IN> long exactOutputSizeIfKnown(Spliterator<P_IN> spliterator) {
int flags = getStreamAndOpFlags();
long size = StreamOpFlag.SIZED.isKnown(flags) ? spliterator.getExactSizeIfKnown() : -1;
if (size != -1 && StreamOpFlag.SIZE_ADJUSTING.isKnown(flags) && !isParallel()) {
for (AbstractPipeline<?, ?, ?> stage = sourceStage.nextStage; stage != null; stage = stage.nextStage) {
size = stage.exactOutputSize(size);
}
}
return size;
}
long exactOutputSize(long previousSize) {
return previousSize;
}
@Override
final <P_IN, S extends Sink<E_OUT>> S wrapAndCopyInto(S sink, Spliterator<P_IN> spliterator) {
copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);
return sink;
}
@Override
final <P_IN> void copyInto(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator) {
Objects.requireNonNull(wrappedSink);
if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {
wrappedSink.begin(spliterator.getExactSizeIfKnown());
spliterator.forEachRemaining(wrappedSink);
wrappedSink.end();
}
else {
copyIntoWithCancel(wrappedSink, spliterator);
}
}
@Override
@SuppressWarnings("unchecked")
final <P_IN> boolean copyIntoWithCancel(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator) {
@SuppressWarnings({"rawtypes","unchecked"})
AbstractPipeline p = AbstractPipeline.this;
while (p.depth > 0) {
p = p.previousStage;
}
wrappedSink.begin(spliterator.getExactSizeIfKnown());
boolean cancelled = p.forEachWithCancel(spliterator, wrappedSink);
wrappedSink.end();
return cancelled;
}
@Override
final int getStreamAndOpFlags() {
return combinedFlags;
}
final boolean isOrdered() {
return StreamOpFlag.ORDERED.isKnown(combinedFlags);
}
@Override
@SuppressWarnings("unchecked")
final <P_IN> Sink<P_IN> wrapSink(Sink<E_OUT> sink) {
Objects.requireNonNull(sink);
for ( @SuppressWarnings("rawtypes") AbstractPipeline p=AbstractPipeline.this; p.depth > 0; p=p.previousStage) {
sink = p.opWrapSink(p.previousStage.combinedFlags, sink);
}
return (Sink<P_IN>) sink;
}
@Override
@SuppressWarnings("unchecked")
final <P_IN> Spliterator<E_OUT> wrapSpliterator(Spliterator<P_IN> sourceSpliterator) {
if (depth == 0) {
return (Spliterator<E_OUT>) sourceSpliterator;
}
else {
return wrap(this, () -> sourceSpliterator, isParallel());
}
}
@Override
@SuppressWarnings("unchecked")
final <P_IN> Node<E_OUT> evaluate(Spliterator<P_IN> spliterator,
boolean flatten,
IntFunction<E_OUT[]> generator) {
if (isParallel()) {
return evaluateToNode(this, spliterator, flatten, generator);
}
else {
Node.Builder<E_OUT> nb = makeNodeBuilder(
exactOutputSizeIfKnown(spliterator), generator);
return wrapAndCopyInto(nb, spliterator).build();
}
}
abstract StreamShape getOutputShape();
abstract <P_IN> Node<E_OUT> evaluateToNode(PipelineHelper<E_OUT> helper,
Spliterator<P_IN> spliterator,
boolean flattenTree,
IntFunction<E_OUT[]> generator);
abstract <P_IN> Spliterator<E_OUT> wrap(PipelineHelper<E_OUT> ph,
Supplier<Spliterator<P_IN>> supplier,
boolean isParallel);
abstract Spliterator<E_OUT> lazySpliterator(Supplier<? extends Spliterator<E_OUT>> supplier);
abstract boolean forEachWithCancel(Spliterator<E_OUT> spliterator, Sink<E_OUT> sink);
@Override
abstract Node.Builder<E_OUT> makeNodeBuilder(long exactSizeIfKnown,
IntFunction<E_OUT[]> generator);
abstract boolean opIsStateful();
abstract Sink<E_IN> opWrapSink(int flags, Sink<E_OUT> sink);
<P_IN> Node<E_OUT> opEvaluateParallel(PipelineHelper<E_OUT> helper,
Spliterator<P_IN> spliterator,
IntFunction<E_OUT[]> generator) {
throw new UnsupportedOperationException("Parallel evaluation is not supported");
}
@SuppressWarnings("unchecked")
<P_IN> Spliterator<E_OUT> opEvaluateParallelLazy(PipelineHelper<E_OUT> helper,
Spliterator<P_IN> spliterator) {
return opEvaluateParallel(helper, spliterator, i -> (E_OUT[]) new Object[i]).spliterator();
}
}
package jdk.tools.jlink.internal.plugins;
import jdk.tools.jlink.plugin.Plugin;
import jdk.tools.jlink.internal.JlinkTask;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import jdk.internal.org.objectweb.asm.ClassReader;
import jdk.tools.jlink.plugin.ResourcePoolEntry;
public abstract class AbstractPlugin implements Plugin {
static final String DESCRIPTION = "description";
static final String USAGE = "usage";
private static final ResourceBundle standardPluginsBundle;
static {
Locale locale = Locale.getDefault();
try {
standardPluginsBundle = ResourceBundle.getBundle("jdk.tools.jlink."
+ "resources.plugins", locale);
} catch (MissingResourceException e) {
throw new InternalError("Cannot find jlink resource bundle for "
+ "locale " + locale);
}
}
private final ResourceBundle pluginsBundle;
private final String name;
protected AbstractPlugin(String name) {
this.name = name;
this.pluginsBundle = standardPluginsBundle;
}
protected AbstractPlugin(String name, ResourceBundle bundle) {
this.name = name;
this.pluginsBundle = bundle;
}
private void dumpClassFile(String path, byte[] buf) {
try {
String fullPath = String.format("%d-%s%s%s",
ProcessHandle.current().pid(),
getName(), File.separator,
path.replace('/', File.separatorChar));
System.err.printf("Dumping class file %s\n", fullPath);
new File(fullPath.substring(0, fullPath.lastIndexOf('/'))).mkdirs();
Files.write(Paths.get(fullPath), buf);
} catch (IOException ioExp) {
System.err.println("writing " + path + " failed");
ioExp.printStackTrace();
}
}
ClassReader newClassReader(String path, ResourcePoolEntry resource) {
byte[] content = resource.contentBytes();
try {
return new ClassReader(content);
} catch (Exception e) {
if (JlinkTask.DEBUG) {
System.err.printf("Failed to parse class file: %s from resource of type %s\n", path,
resource.getClass().getName());
e.printStackTrace();
dumpClassFile(path, content);
}
throw e;
}
}
protected ClassReader newClassReader(String path, byte[] buf) {
try {
return new ClassReader(buf);
} catch (Exception e) {
if (JlinkTask.DEBUG) {
System.err.printf("Failed to parse class file: %s\n", path);
e.printStackTrace();
dumpClassFile(path, buf);
}
throw e;
}
}
@Override
public String getName() {
return name;
}
@Override
public String getDescription() {
return getMessage(getName() + "." + DESCRIPTION, getName());
}
@Override
public String getUsage() {
return getMessage(getName() + "." + USAGE, getName());
}
@Override
public String getArgumentsDescription() {
return PluginsResourceBundle.getArgument(getName());
}
protected String getMessage(String key, Object...args) {
return PluginsResourceBundle.getMessage(this.pluginsBundle, key, args);
}
}
package sun.nio.fs;
import java.nio.file.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.io.IOException;
import java.util.*;
abstract class AbstractPoller implements Runnable {
private final ArrayDeque<Request> requests;
private boolean shutdown;
protected AbstractPoller() {
this.requests = new ArrayDeque<>();
this.shutdown = false;
}
@SuppressWarnings("removal")
public void start() {
final Runnable thisRunnable = this;
AccessController.doPrivileged(new PrivilegedAction<>() {
@Override
public Object run() {
Thread thr = new Thread(null,
thisRunnable,
"FileSystemWatchService",
0,
false);
thr.setDaemon(true);
thr.start();
return null;
}
});
}
abstract void wakeup() throws IOException;
abstract Object implRegister(Path path,
Set<? extends WatchEvent.Kind<?>> events,
WatchEvent.Modifier... modifiers);
abstract void implCancelKey(WatchKey key);
abstract void implCloseAll();
final WatchKey register(Path dir,
WatchEvent.Kind<?>[] events,
WatchEvent.Modifier... modifiers)
throws IOException
{
if (dir == null)
throw new NullPointerException();
Set<WatchEvent.Kind<?>> eventSet = HashSet.newHashSet(events.length);
for (WatchEvent.Kind<?> event: events) {
if (event == StandardWatchEventKinds.ENTRY_CREATE ||
event == StandardWatchEventKinds.ENTRY_MODIFY ||
event == StandardWatchEventKinds.ENTRY_DELETE)
{
eventSet.add(event);
continue;
}
if (event == StandardWatchEventKinds.OVERFLOW)
continue;
if (event == null)
throw new NullPointerException("An element in event set is 'null'");
throw new UnsupportedOperationException(event.name());
}
if (eventSet.isEmpty())
throw new IllegalArgumentException("No events to register");
return (WatchKey)invoke(RequestType.REGISTER, dir, eventSet, modifiers);
}
final void cancel(WatchKey key) {
try {
invoke(RequestType.CANCEL, key);
} catch (IOException x) {
throw new AssertionError(x.getMessage());
}
}
final void close() throws IOException {
invoke(RequestType.CLOSE);
}
private static enum RequestType {
REGISTER,
CANCEL,
CLOSE;
}
private static class Request {
private final RequestType type;
private final Object[] params;
private boolean completed = false;
private Object result = null;
Request(RequestType type, Object... params) {
this.type = type;
this.params = params;
}
RequestType type() {
return type;
}
Object[] parameters() {
return params;
}
void release(Object result) {
synchronized (this) {
this.completed = true;
this.result = result;
notifyAll();
}
}
Object awaitResult() {
boolean interrupted = false;
synchronized (this) {
while (!completed) {
try {
wait();
} catch (InterruptedException x) {
interrupted = true;
}
}
if (interrupted)
Thread.currentThread().interrupt();
return result;
}
}
}
private Object invoke(RequestType type, Object... params) throws IOException {
Request req = new Request(type, params);
synchronized (requests) {
if (shutdown) {
throw new ClosedWatchServiceException();
}
requests.add(req);
wakeup();
}
Object result = req.awaitResult();
if (result instanceof RuntimeException)
throw (RuntimeException)result;
if (result instanceof IOException )
throw (IOException)result;
return result;
}
@SuppressWarnings("unchecked")
boolean processRequests() {
synchronized (requests) {
Request req;
while ((req = requests.poll()) != null) {
if (shutdown) {
req.release(new ClosedWatchServiceException());
continue;
}
switch (req.type()) {
case REGISTER: {
Object[] params = req.parameters();
Path path = (Path)params[0];
Set<? extends WatchEvent.Kind<?>> events =
(Set<? extends WatchEvent.Kind<?>>)params[1];
WatchEvent.Modifier[] modifiers =
(WatchEvent.Modifier[])params[2];
req.release(implRegister(path, events, modifiers));
break;
}
case CANCEL : {
Object[] params = req.parameters();
WatchKey key = (WatchKey)params[0];
implCancelKey(key);
req.release(null);
break;
}
case CLOSE: {
implCloseAll();
req.release(null);
shutdown = true;
break;
}
default:
req.release(new IOException("request not recognized"));
}
}
}
return shutdown;
}
}
package jdk.internal.org.jline.terminal.impl;
import java.io.IOError;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.Objects;
import java.util.function.IntConsumer;
import jdk.internal.org.jline.terminal.Attributes;
import jdk.internal.org.jline.terminal.Cursor;
import jdk.internal.org.jline.terminal.Size;
import jdk.internal.org.jline.terminal.spi.Pty;
public abstract class AbstractPosixTerminal extends AbstractTerminal {
protected final Pty pty;
protected final Attributes originalAttributes;
public AbstractPosixTerminal(String name, String type, Pty pty) throws IOException {
this(name, type, pty, null, SignalHandler.SIG_DFL);
}
public AbstractPosixTerminal(String name, String type, Pty pty, Charset encoding, SignalHandler signalHandler) throws IOException {
super(name, type, encoding, signalHandler);
Objects.requireNonNull(pty);
this.pty = pty;
this.originalAttributes = this.pty.getAttr();
}
public Pty getPty() {
return pty;
}
public Attributes getAttributes() {
try {
return pty.getAttr();
} catch (IOException e) {
throw new IOError(e);
}
}
public void setAttributes(Attributes attr) {
try {
pty.setAttr(attr);
} catch (IOException e) {
throw new IOError(e);
}
}
public Size getSize() {
try {
return pty.getSize();
} catch (IOException e) {
throw new IOError(e);
}
}
public void setSize(Size size) {
try {
pty.setSize(size);
} catch (IOException e) {
throw new IOError(e);
}
}
protected void doClose() throws IOException {
super.doClose();
pty.setAttr(originalAttributes);
pty.close();
}
@Override
public Cursor getCursorPosition(IntConsumer discarded) {
return CursorSupport.getCursorPosition(this, discarded);
}
}
package java.util.prefs;
import java.util.*;
import java.io.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
public abstract class AbstractPreferences extends Preferences {
static final int CODE_POINT_U0000 = '\u0000';
private final String name;
private final String absolutePath;
final AbstractPreferences parent;
private final AbstractPreferences root;
protected boolean newNode = false;
private Map<String, AbstractPreferences> kidCache = new HashMap<>();
private boolean removed = false;
private PreferenceChangeListener[] prefListeners =
new PreferenceChangeListener[0];
private NodeChangeListener[] nodeListeners = new NodeChangeListener[0];
protected final Object lock = new Object();
protected AbstractPreferences(AbstractPreferences parent, String name) {
if (parent==null) {
if (!name.isEmpty())
throw new IllegalArgumentException("Root name '"+name+
"' must be \"\"");
this.absolutePath = "/";
root = this;
} else {
if (name.indexOf('/') != -1)
throw new IllegalArgumentException("Name '" + name +
"' contains '/'");
if (name.isEmpty())
throw new IllegalArgumentException("Illegal name: empty string");
root = parent.root;
absolutePath = (parent==root ? "/" + name
: parent.absolutePath() + "/" + name);
}
this.name = name;
this.parent = parent;
}
public void put(String key, String value) {
if (key==null || value==null)
throw new NullPointerException();
if (key.length() > MAX_KEY_LENGTH)
throw new IllegalArgumentException("Key too long: "+key);
if (value.length() > MAX_VALUE_LENGTH)
throw new IllegalArgumentException("Value too long: "+value);
if (key.indexOf(CODE_POINT_U0000) != -1)
throw new IllegalArgumentException("Key contains code point U+0000");
if (value.indexOf(CODE_POINT_U0000) != -1)
throw new IllegalArgumentException("Value contains code point U+0000");
synchronized(lock) {
if (removed)
throw new IllegalStateException("Node has been removed.");
putSpi(key, value);
enqueuePreferenceChangeEvent(key, value);
}
}
public String get(String key, String def) {
if (key==null)
throw new NullPointerException("Null key");
if (key.indexOf(CODE_POINT_U0000) != -1)
throw new IllegalArgumentException("Key contains code point U+0000");
synchronized(lock) {
if (removed)
throw new IllegalStateException("Node has been removed.");
String result = null;
try {
result = getSpi(key);
} catch (Exception e) {
}
return (result==null ? def : result);
}
}
public void remove(String key) {
Objects.requireNonNull(key, "Specified key cannot be null");
if (key.indexOf(CODE_POINT_U0000) != -1)
throw new IllegalArgumentException("Key contains code point U+0000");
synchronized(lock) {
if (removed)
throw new IllegalStateException("Node has been removed.");
removeSpi(key);
enqueuePreferenceChangeEvent(key, null);
}
}
public void clear() throws BackingStoreException {
synchronized(lock) {
for (String key : keys())
remove(key);
}
}
public void putInt(String key, int value) {
put(key, Integer.toString(value));
}
public int getInt(String key, int def) {
int result = def;
try {
String value = get(key, null);
if (value != null)
result = Integer.parseInt(value);
} catch (NumberFormatException e) {
}
return result;
}
public void putLong(String key, long value) {
put(key, Long.toString(value));
}
public long getLong(String key, long def) {
long result = def;
try {
String value = get(key, null);
if (value != null)
result = Long.parseLong(value);
} catch (NumberFormatException e) {
}
return result;
}
public void putBoolean(String key, boolean value) {
put(key, String.valueOf(value));
}
public boolean getBoolean(String key, boolean def) {
boolean result = def;
String value = get(key, null);
if (value != null) {
if (value.equalsIgnoreCase("true"))
result = true;
else if (value.equalsIgnoreCase("false"))
result = false;
}
return result;
}
public void putFloat(String key, float value) {
put(key, Float.toString(value));
}
public float getFloat(String key, float def) {
float result = def;
try {
String value = get(key, null);
if (value != null)
result = Float.parseFloat(value);
} catch (NumberFormatException e) {
}
return result;
}
public void putDouble(String key, double value) {
put(key, Double.toString(value));
}
public double getDouble(String key, double def) {
double result = def;
try {
String value = get(key, null);
if (value != null)
result = Double.parseDouble(value);
} catch (NumberFormatException e) {
}
return result;
}
public void putByteArray(String key, byte[] value) {
put(key, Base64.byteArrayToBase64(value));
}
public byte[] getByteArray(String key, byte[] def) {
byte[] result = def;
String value = get(key, null);
try {
if (value != null)
result = Base64.base64ToByteArray(value);
}
catch (RuntimeException e) {
}
return result;
}
public String[] keys() throws BackingStoreException {
synchronized(lock) {
if (removed)
throw new IllegalStateException("Node has been removed.");
return keysSpi();
}
}
public String[] childrenNames() throws BackingStoreException {
synchronized(lock) {
if (removed)
throw new IllegalStateException("Node has been removed.");
Set<String> s = new TreeSet<>(kidCache.keySet());
for (String kid : childrenNamesSpi())
s.add(kid);
return s.toArray(EMPTY_STRING_ARRAY);
}
}
private static final String[] EMPTY_STRING_ARRAY = new String[0];
protected final AbstractPreferences[] cachedChildren() {
return kidCache.values().toArray(EMPTY_ABSTRACT_PREFS_ARRAY);
}
private static final AbstractPreferences[] EMPTY_ABSTRACT_PREFS_ARRAY
= new AbstractPreferences[0];
public Preferences parent() {
synchronized(lock) {
if (removed)
throw new IllegalStateException("Node has been removed.");
return parent;
}
}
public Preferences node(String path) {
synchronized(lock) {
if (removed)
throw new IllegalStateException("Node has been removed.");
if (path.isEmpty())
return this;
if (path.equals("/"))
return root;
if (path.charAt(0) != '/')
return node(new StringTokenizer(path, "/", true));
}
return root.node(new StringTokenizer(path.substring(1), "/", true));
}
private Preferences node(StringTokenizer path) {
String token = path.nextToken();
if (token.equals("/"))              throw new IllegalArgumentException("Consecutive slashes in path");
synchronized(lock) {
AbstractPreferences child = kidCache.get(token);
if (child == null) {
if (token.length() > MAX_NAME_LENGTH)
throw new IllegalArgumentException(
"Node name " + token + " too long");
child = childSpi(token);
if (child.newNode)
enqueueNodeAddedEvent(child);
kidCache.put(token, child);
}
if (!path.hasMoreTokens())
return child;
path.nextToken();              if (!path.hasMoreTokens())
throw new IllegalArgumentException("Path ends with slash");
return child.node(path);
}
}
public boolean nodeExists(String path)
throws BackingStoreException
{
synchronized(lock) {
if (path.isEmpty())
return !removed;
if (removed)
throw new IllegalStateException("Node has been removed.");
if (path.equals("/"))
return true;
if (path.charAt(0) != '/')
return nodeExists(new StringTokenizer(path, "/", true));
}
return root.nodeExists(new StringTokenizer(path.substring(1), "/",
true));
}
private boolean nodeExists(StringTokenizer path)
throws BackingStoreException
{
String token = path.nextToken();
if (token.equals("/"))              throw new IllegalArgumentException("Consecutive slashes in path");
synchronized(lock) {
AbstractPreferences child = kidCache.get(token);
if (child == null)
child = getChild(token);
if (child==null)
return false;
if (!path.hasMoreTokens())
return true;
path.nextToken();              if (!path.hasMoreTokens())
throw new IllegalArgumentException("Path ends with slash");
return child.nodeExists(path);
}
}
public void removeNode() throws BackingStoreException {
if (this==root)
throw new UnsupportedOperationException("Can't remove the root!");
synchronized(parent.lock) {
removeNode2();
parent.kidCache.remove(name);
}
}
private void removeNode2() throws BackingStoreException {
synchronized(lock) {
if (removed)
throw new IllegalStateException("Node already removed.");
String[] kidNames = childrenNamesSpi();
for (String kidName : kidNames)
if (!kidCache.containsKey(kidName))
kidCache.put(kidName, childSpi(kidName));
for (Iterator<AbstractPreferences> i = kidCache.values().iterator();
i.hasNext();) {
try {
i.next().removeNode2();
i.remove();
} catch (BackingStoreException x) { }
}
removeNodeSpi();
removed = true;
parent.enqueueNodeRemovedEvent(this);
}
}
public String name() {
return name;
}
public String absolutePath() {
return absolutePath;
}
@SuppressWarnings("removal")
public boolean isUserNode() {
return AccessController.doPrivileged(
new PrivilegedAction<Boolean>() {
public Boolean run() {
return root == Preferences.userRoot();
}
}).booleanValue();
}
public void addPreferenceChangeListener(PreferenceChangeListener pcl) {
if (pcl==null)
throw new NullPointerException("Change listener is null.");
synchronized(lock) {
if (removed)
throw new IllegalStateException("Node has been removed.");
PreferenceChangeListener[] old = prefListeners;
prefListeners = new PreferenceChangeListener[old.length + 1];
System.arraycopy(old, 0, prefListeners, 0, old.length);
prefListeners[old.length] = pcl;
}
startEventDispatchThreadIfNecessary();
}
public void removePreferenceChangeListener(PreferenceChangeListener pcl) {
synchronized(lock) {
if (removed)
throw new IllegalStateException("Node has been removed.");
if ((prefListeners == null) || (prefListeners.length == 0))
throw new IllegalArgumentException("Listener not registered.");
PreferenceChangeListener[] newPl =
new PreferenceChangeListener[prefListeners.length - 1];
int i = 0;
while (i < newPl.length && prefListeners[i] != pcl)
newPl[i] = prefListeners[i++];
if (i == newPl.length &&  prefListeners[i] != pcl)
throw new IllegalArgumentException("Listener not registered.");
while (i < newPl.length)
newPl[i] = prefListeners[++i];
prefListeners = newPl;
}
}
public void addNodeChangeListener(NodeChangeListener ncl) {
if (ncl==null)
throw new NullPointerException("Change listener is null.");
synchronized(lock) {
if (removed)
throw new IllegalStateException("Node has been removed.");
if (nodeListeners == null) {
nodeListeners = new NodeChangeListener[1];
nodeListeners[0] = ncl;
} else {
NodeChangeListener[] old = nodeListeners;
nodeListeners = new NodeChangeListener[old.length + 1];
System.arraycopy(old, 0, nodeListeners, 0, old.length);
nodeListeners[old.length] = ncl;
}
}
startEventDispatchThreadIfNecessary();
}
public void removeNodeChangeListener(NodeChangeListener ncl) {
synchronized(lock) {
if (removed)
throw new IllegalStateException("Node has been removed.");
if ((nodeListeners == null) || (nodeListeners.length == 0))
throw new IllegalArgumentException("Listener not registered.");
int i = 0;
while (i < nodeListeners.length && nodeListeners[i] != ncl)
i++;
if (i == nodeListeners.length)
throw new IllegalArgumentException("Listener not registered.");
NodeChangeListener[] newNl =
new NodeChangeListener[nodeListeners.length - 1];
if (i != 0)
System.arraycopy(nodeListeners, 0, newNl, 0, i);
if (i != newNl.length)
System.arraycopy(nodeListeners, i + 1,
newNl, i, newNl.length - i);
nodeListeners = newNl;
}
}
protected abstract void putSpi(String key, String value);
protected abstract String getSpi(String key);
protected abstract void removeSpi(String key);
protected abstract void removeNodeSpi() throws BackingStoreException;
protected abstract String[] keysSpi() throws BackingStoreException;
protected abstract String[] childrenNamesSpi()
throws BackingStoreException;
protected AbstractPreferences getChild(String nodeName)
throws BackingStoreException {
synchronized(lock) {
String[] kidNames = childrenNames();
for (String kidName : kidNames)
if (kidName.equals(nodeName))
return childSpi(kidName);
}
return null;
}
protected abstract AbstractPreferences childSpi(String name);
public String toString() {
return (this.isUserNode() ? "User" : "System") +
" Preference Node: " + this.absolutePath();
}
public void sync() throws BackingStoreException {
sync2();
}
private void sync2() throws BackingStoreException {
AbstractPreferences[] cachedKids;
synchronized(lock) {
if (removed)
throw new IllegalStateException("Node has been removed");
syncSpi();
cachedKids = cachedChildren();
}
for (AbstractPreferences cachedKid : cachedKids)
cachedKid.sync2();
}
protected abstract void syncSpi() throws BackingStoreException;
public void flush() throws BackingStoreException {
flush2();
}
private void flush2() throws BackingStoreException {
AbstractPreferences[] cachedKids;
synchronized(lock) {
flushSpi();
if(removed)
return;
cachedKids = cachedChildren();
}
for (AbstractPreferences cachedKid : cachedKids)
cachedKid.flush2();
}
protected abstract void flushSpi() throws BackingStoreException;
protected boolean isRemoved() {
synchronized(lock) {
return removed;
}
}
private static final List<EventObject> eventQueue = new LinkedList<>();
private static class NodeAddedEvent extends NodeChangeEvent {
private static final long serialVersionUID = -6743557530157328528L;
NodeAddedEvent(Preferences parent, Preferences child) {
super(parent, child);
}
}
private static class NodeRemovedEvent extends NodeChangeEvent {
private static final long serialVersionUID = 8735497392918824837L;
NodeRemovedEvent(Preferences parent, Preferences child) {
super(parent, child);
}
}
private static class EventDispatchThread extends Thread {
private EventDispatchThread() {
super(null, null, "Event Dispatch Thread", 0, false);
}
public void run() {
while(true) {
EventObject event = null;
synchronized(eventQueue) {
try {
while (eventQueue.isEmpty())
eventQueue.wait();
event = eventQueue.remove(0);
} catch (InterruptedException e) {
return;
}
}
AbstractPreferences src=(AbstractPreferences)event.getSource();
if (event instanceof PreferenceChangeEvent) {
PreferenceChangeEvent pce = (PreferenceChangeEvent)event;
PreferenceChangeListener[] listeners = src.prefListeners();
for (PreferenceChangeListener listener : listeners)
listener.preferenceChange(pce);
} else {
NodeChangeEvent nce = (NodeChangeEvent)event;
NodeChangeListener[] listeners = src.nodeListeners();
if (nce instanceof NodeAddedEvent) {
for (NodeChangeListener listener : listeners)
listener.childAdded(nce);
} else {
for (NodeChangeListener listener : listeners)
listener.childRemoved(nce);
}
}
}
}
}
private static Thread eventDispatchThread = null;
private static synchronized void startEventDispatchThreadIfNecessary() {
if (eventDispatchThread == null) {
eventDispatchThread = new EventDispatchThread();
eventDispatchThread.setDaemon(true);
eventDispatchThread.start();
}
}
PreferenceChangeListener[] prefListeners() {
synchronized(lock) {
return prefListeners;
}
}
NodeChangeListener[] nodeListeners() {
synchronized(lock) {
return nodeListeners;
}
}
private void enqueuePreferenceChangeEvent(String key, String newValue) {
if (prefListeners.length != 0) {
synchronized(eventQueue) {
eventQueue.add(new PreferenceChangeEvent(this, key, newValue));
eventQueue.notify();
}
}
}
private void enqueueNodeAddedEvent(Preferences child) {
if (nodeListeners.length != 0) {
synchronized(eventQueue) {
eventQueue.add(new NodeAddedEvent(this, child));
eventQueue.notify();
}
}
}
private void enqueueNodeRemovedEvent(Preferences child) {
if (nodeListeners.length != 0) {
synchronized(eventQueue) {
eventQueue.add(new NodeRemovedEvent(this, child));
eventQueue.notify();
}
}
}
public void exportNode(OutputStream os)
throws IOException, BackingStoreException
{
XmlSupport.export(os, this, false);
}
public void exportSubtree(OutputStream os)
throws IOException, BackingStoreException
{
XmlSupport.export(os, this, true);
}
}
package javax.annotation.processing;
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.Objects;
import javax.lang.model.element.*;
import javax.lang.model.SourceVersion;
import javax.tools.Diagnostic;
public abstract class AbstractProcessor implements Processor {
protected ProcessingEnvironment processingEnv;
private boolean initialized = false;
protected AbstractProcessor() {}
@Override
public Set<String> getSupportedOptions() {
SupportedOptions so = this.getClass().getAnnotation(SupportedOptions.class);
return (so == null) ?
Set.of() :
arrayToSet(so.value(), false, "option value", "@SupportedOptions");
}
@Override
public Set<String> getSupportedAnnotationTypes() {
SupportedAnnotationTypes sat = this.getClass().getAnnotation(SupportedAnnotationTypes.class);
boolean initialized = isInitialized();
if  (sat == null) {
if (initialized)
processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
"No SupportedAnnotationTypes annotation " +
"found on " + this.getClass().getName() +
", returning an empty set.");
return Set.of();
} else {
boolean stripModulePrefixes =
initialized &&
processingEnv.getSourceVersion().compareTo(SourceVersion.RELEASE_8) <= 0;
return arrayToSet(sat.value(), stripModulePrefixes,
"annotation interface", "@SupportedAnnotationTypes");
}
}
@Override
public SourceVersion getSupportedSourceVersion() {
SupportedSourceVersion ssv = this.getClass().getAnnotation(SupportedSourceVersion.class);
SourceVersion sv = null;
if (ssv == null) {
sv = SourceVersion.RELEASE_6;
if (isInitialized())
processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
"No SupportedSourceVersion annotation " +
"found on " + this.getClass().getName() +
", returning " + sv + ".");
} else
sv = ssv.value();
return sv;
}
public synchronized void init(ProcessingEnvironment processingEnv) {
if (initialized)
throw new IllegalStateException("Cannot call init more than once.");
Objects.requireNonNull(processingEnv, "Tool provided null ProcessingEnvironment");
this.processingEnv = processingEnv;
initialized = true;
}
@Override
public abstract boolean process(Set<? extends TypeElement> annotations,
RoundEnvironment roundEnv);
@Override
public Iterable<? extends Completion> getCompletions(Element element,
AnnotationMirror annotation,
ExecutableElement member,
String userText) {
return List.of();
}
protected synchronized boolean isInitialized() {
return initialized;
}
private Set<String> arrayToSet(String[] array,
boolean stripModulePrefixes,
String contentType,
String annotationName) {
assert array != null;
Set<String> set = new HashSet<>();
for (String s : array) {
boolean stripped = false;
if (stripModulePrefixes) {
int index = s.indexOf('/');
if (index != -1) {
s = s.substring(index + 1);
stripped = true;
}
}
boolean added = set.add(s);
if (!added && !stripped && isInitialized() ) {
processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
"Duplicate " + contentType  +
" ``" + s  + "'' for processor " +
this.getClass().getName() +
" in its " + annotationName  +
"annotation.");
}
}
return Collections.unmodifiableSet(set);
}
}
package jdk.vm.ci.meta;
public abstract class AbstractProfiledItem<T> implements Comparable<AbstractProfiledItem<?>> {
protected final T item;
protected final double probability;
public AbstractProfiledItem(T item, double probability) {
assert item != null;
assert probability >= 0.0D && probability <= 1.0D;
this.item = item;
this.probability = probability;
}
protected T getItem() {
return item;
}
public double getProbability() {
return probability;
}
@Override
public int compareTo(AbstractProfiledItem<?> o) {
return Double.compare(o.getProbability(), getProbability());
}
@Override
public int hashCode() {
final int prime = 31;
int result = 1;
long temp;
temp = Double.doubleToLongBits(probability);
result = prime * result + (int) (temp ^ (temp >>> 32));
result = prime * result + item.hashCode();
return result;
}
@Override
public boolean equals(Object obj) {
if (this == obj) {
return true;
}
if (obj == null) {
return false;
}
if (getClass() != obj.getClass()) {
return false;
}
AbstractProfiledItem<?> other = (AbstractProfiledItem<?>) obj;
if (Double.doubleToLongBits(probability) != Double.doubleToLongBits(other.probability)) {
return false;
}
return item.equals(other.item);
}
@Override
public abstract String toString();
}
package jdk.internal.org.jline.terminal.impl;
import jdk.internal.org.jline.terminal.Attributes;
import jdk.internal.org.jline.terminal.spi.Pty;
import jdk.internal.org.jline.utils.NonBlockingInputStream;
import java.io.IOError;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_NON_BLOCKING_READS;
public abstract class AbstractPty implements Pty {
private Attributes current;
@Override
public void setAttr(Attributes attr) throws IOException {
current = new Attributes(attr);
doSetAttr(attr);
}
@Override
public InputStream getSlaveInput() throws IOException {
InputStream si = doGetSlaveInput();
if (Boolean.parseBoolean(System.getProperty(PROP_NON_BLOCKING_READS, "true"))) {
return new PtyInputStream(si);
} else {
return si;
}
}
protected abstract void doSetAttr(Attributes attr) throws IOException;
protected abstract InputStream doGetSlaveInput() throws IOException;
protected void checkInterrupted() throws InterruptedIOException {
if (Thread.interrupted()) {
throw new InterruptedIOException();
}
}
class PtyInputStream extends NonBlockingInputStream {
final InputStream in;
int c = 0;
PtyInputStream(InputStream in) {
this.in = in;
}
@Override
public int read(long timeout, boolean isPeek) throws IOException {
checkInterrupted();
if (c != 0) {
int r = c;
if (!isPeek) {
c = 0;
}
return r;
} else {
setNonBlocking();
long start = System.currentTimeMillis();
while (true) {
int r = in.read();
if (r >= 0) {
if (isPeek) {
c = r;
}
return r;
}
checkInterrupted();
long cur = System.currentTimeMillis();
if (timeout > 0 && cur - start > timeout) {
return NonBlockingInputStream.READ_EXPIRED;
}
}
}
}
@Override
public int readBuffered(byte[] b) throws IOException {
return in.read(b);
}
private void setNonBlocking() {
if (current == null
|| current.getControlChar(Attributes.ControlChar.VMIN) != 0
|| current.getControlChar(Attributes.ControlChar.VTIME) != 1) {
try {
Attributes attr = getAttr();
attr.setControlChar(Attributes.ControlChar.VMIN, 0);
attr.setControlChar(Attributes.ControlChar.VTIME, 1);
setAttr(attr);
} catch (IOException e) {
throw new IOError(e);
}
}
}
}
}
package java.util;
public abstract class AbstractQueue<E>
extends AbstractCollection<E>
implements Queue<E> {
protected AbstractQueue() {
}
public boolean add(E e) {
if (offer(e))
return true;
else
throw new IllegalStateException("Queue full");
}
public E remove() {
E x = poll();
if (x != null)
return x;
else
throw new NoSuchElementException();
}
public E element() {
E x = peek();
if (x != null)
return x;
else
throw new NoSuchElementException();
}
public void clear() {
while (poll() != null)
;
}
public boolean addAll(Collection<? extends E> c) {
if (c == null)
throw new NullPointerException();
if (c == this)
throw new IllegalArgumentException();
boolean modified = false;
for (E e : c)
if (add(e))
modified = true;
return modified;
}
}
package java.util.concurrent.locks;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RejectedExecutionException;
import jdk.internal.misc.Unsafe;
public abstract class AbstractQueuedLongSynchronizer
extends AbstractOwnableSynchronizer
implements java.io.Serializable {
private static final long serialVersionUID = 7373984972572414692L;
public AbstractQueuedLongSynchronizer() {}
static final int WAITING   = 1;              static final int CANCELLED = 0x80000000;     static final int COND      = 2;
abstract static class Node {
volatile Node prev;               volatile Node next;               Thread waiter;                    volatile int status;
final boolean casPrev(Node c, Node v) {              return U.weakCompareAndSetReference(this, PREV, c, v);
}
final boolean casNext(Node c, Node v) {              return U.weakCompareAndSetReference(this, NEXT, c, v);
}
final int getAndUnsetStatus(int v) {                 return U.getAndBitwiseAndInt(this, STATUS, ~v);
}
final void setPrevRelaxed(Node p) {                  U.putReference(this, PREV, p);
}
final void setStatusRelaxed(int s) {                 U.putInt(this, STATUS, s);
}
final void clearStatus() {                           U.putIntOpaque(this, STATUS, 0);
}
private static final long STATUS
= U.objectFieldOffset(Node.class, "status");
private static final long NEXT
= U.objectFieldOffset(Node.class, "next");
private static final long PREV
= U.objectFieldOffset(Node.class, "prev");
}
static final class ExclusiveNode extends Node { }
static final class SharedNode extends Node { }
static final class ConditionNode extends Node
implements ForkJoinPool.ManagedBlocker {
ConditionNode nextWaiter;
public final boolean isReleasable() {
return status <= 1 || Thread.currentThread().isInterrupted();
}
public final boolean block() {
while (!isReleasable()) LockSupport.park();
return true;
}
}
private transient volatile Node head;
private transient volatile Node tail;
private volatile long state;
protected final long getState() {
return state;
}
protected final void setState(long newState) {
state = newState;
}
protected final boolean compareAndSetState(long expect, long update) {
return U.compareAndSetLong(this, STATE, expect, update);
}
private boolean casTail(Node c, Node v) {
return U.compareAndSetReference(this, TAIL, c, v);
}
private Node tryInitializeHead() {
for (Node h = null, t;;) {
if ((t = tail) != null)
return t;
else if (head != null)
Thread.onSpinWait();
else {
if (h == null) {
try {
h = new ExclusiveNode();
} catch (OutOfMemoryError oome) {
return null;
}
}
if (U.compareAndSetReference(this, HEAD, null, h))
return tail = h;
}
}
}
final void enqueue(ConditionNode node) {
if (node != null) {
boolean unpark = false;
for (Node t;;) {
if ((t = tail) == null && (t = tryInitializeHead()) == null) {
unpark = true;                                 break;
}
node.setPrevRelaxed(t);                        if (casTail(t, node)) {
t.next = node;
if (t.status < 0)                                  unpark = true;
break;
}
}
if (unpark)
LockSupport.unpark(node.waiter);
}
}
final boolean isEnqueued(Node node) {
for (Node t = tail; t != null; t = t.prev)
if (t == node)
return true;
return false;
}
private static void signalNext(Node h) {
Node s;
if (h != null && (s = h.next) != null && s.status != 0) {
s.getAndUnsetStatus(WAITING);
LockSupport.unpark(s.waiter);
}
}
private static void signalNextIfShared(Node h) {
Node s;
if (h != null && (s = h.next) != null &&
(s instanceof SharedNode) && s.status != 0) {
s.getAndUnsetStatus(WAITING);
LockSupport.unpark(s.waiter);
}
}
final int acquire(Node node, long arg, boolean shared,
boolean interruptible, boolean timed, long time) {
Thread current = Thread.currentThread();
byte spins = 0, postSpins = 0;           boolean interrupted = false, first = false;
Node pred = null;
for (;;) {
if (!first && (pred = (node == null) ? null : node.prev) != null &&
!(first = (head == pred))) {
if (pred.status < 0) {
cleanQueue();                               continue;
} else if (pred.prev == null) {
Thread.onSpinWait();                        continue;
}
}
if (first || pred == null) {
boolean acquired;
try {
if (shared)
acquired = (tryAcquireShared(arg) >= 0);
else
acquired = tryAcquire(arg);
} catch (Throwable ex) {
cancelAcquire(node, interrupted, false);
throw ex;
}
if (acquired) {
if (first) {
node.prev = null;
head = node;
pred.next = null;
node.waiter = null;
if (shared)
signalNextIfShared(node);
if (interrupted)
current.interrupt();
}
return 1;
}
}
Node t;
if ((t = tail) == null) {                           if (tryInitializeHead() == null)
return acquireOnOOME(shared, arg);
} else if (node == null) {                          try {
node = (shared) ? new SharedNode() : new ExclusiveNode();
} catch (OutOfMemoryError oome) {
return acquireOnOOME(shared, arg);
}
} else if (pred == null) {                          node.waiter = current;
node.setPrevRelaxed(t);                         if (!casTail(t, node))
node.setPrevRelaxed(null);                  else
t.next = node;
} else if (first && spins != 0) {
--spins;                                        Thread.onSpinWait();
} else if (node.status == 0) {
node.status = WAITING;                      } else {
long nanos;
spins = postSpins = (byte)((postSpins << 1) | 1);
if (!timed)
LockSupport.park(this);
else if ((nanos = time - System.nanoTime()) > 0L)
LockSupport.parkNanos(this, nanos);
else
break;
node.clearStatus();
if ((interrupted |= Thread.interrupted()) && interruptible)
break;
}
}
return cancelAcquire(node, interrupted, interruptible);
}
private int acquireOnOOME(boolean shared, long arg) {
for (long nanos = 1L;;) {
if (shared ? (tryAcquireShared(arg) >= 0) : tryAcquire(arg))
return 1;
U.park(false, nanos);                           if (nanos < 1L << 30)                               nanos <<= 1;
}
}
private void cleanQueue() {
for (;;) {                                           for (Node q = tail, s = null, p, n;;) {                 if (q == null || (p = q.prev) == null)
return;                                      if (s == null ? tail != q : (s.prev != q || s.status < 0))
break;                                       if (q.status < 0) {                                  if ((s == null ? casTail(q, p) : s.casPrev(q, p)) &&
q.prev == p) {
p.casNext(q, s);                                 if (p.prev == null)
signalNext(p);
}
break;
}
if ((n = p.next) != q) {                             if (n != null && q.prev == p) {
p.casNext(n, q);
if (p.prev == null)
signalNext(p);
}
break;
}
s = q;
q = q.prev;
}
}
}
private int cancelAcquire(Node node, boolean interrupted,
boolean interruptible) {
if (node != null) {
node.waiter = null;
node.status = CANCELLED;
if (node.prev != null)
cleanQueue();
}
if (interrupted) {
if (interruptible)
return CANCELLED;
else
Thread.currentThread().interrupt();
}
return 0;
}
protected boolean tryAcquire(long arg) {
throw new UnsupportedOperationException();
}
protected boolean tryRelease(long arg) {
throw new UnsupportedOperationException();
}
protected long tryAcquireShared(long arg) {
throw new UnsupportedOperationException();
}
protected boolean tryReleaseShared(long arg) {
throw new UnsupportedOperationException();
}
protected boolean isHeldExclusively() {
throw new UnsupportedOperationException();
}
public final void acquire(long arg) {
if (!tryAcquire(arg))
acquire(null, arg, false, false, false, 0L);
}
public final void acquireInterruptibly(long arg)
throws InterruptedException {
if (Thread.interrupted() ||
(!tryAcquire(arg) && acquire(null, arg, false, true, false, 0L) < 0))
throw new InterruptedException();
}
public final boolean tryAcquireNanos(long arg, long nanosTimeout)
throws InterruptedException {
if (!Thread.interrupted()) {
if (tryAcquire(arg))
return true;
if (nanosTimeout <= 0L)
return false;
int stat = acquire(null, arg, false, true, true,
System.nanoTime() + nanosTimeout);
if (stat > 0)
return true;
if (stat == 0)
return false;
}
throw new InterruptedException();
}
public final boolean release(long arg) {
if (tryRelease(arg)) {
signalNext(head);
return true;
}
return false;
}
public final void acquireShared(long arg) {
if (tryAcquireShared(arg) < 0)
acquire(null, arg, true, false, false, 0L);
}
public final void acquireSharedInterruptibly(long arg)
throws InterruptedException {
if (Thread.interrupted() ||
(tryAcquireShared(arg) < 0 &&
acquire(null, arg, true, true, false, 0L) < 0))
throw new InterruptedException();
}
public final boolean tryAcquireSharedNanos(long arg, long nanosTimeout)
throws InterruptedException {
if (!Thread.interrupted()) {
if (tryAcquireShared(arg) >= 0)
return true;
if (nanosTimeout <= 0L)
return false;
int stat = acquire(null, arg, true, true, true,
System.nanoTime() + nanosTimeout);
if (stat > 0)
return true;
if (stat == 0)
return false;
}
throw new InterruptedException();
}
public final boolean releaseShared(long arg) {
if (tryReleaseShared(arg)) {
signalNext(head);
return true;
}
return false;
}
public final boolean hasQueuedThreads() {
for (Node p = tail, h = head; p != h && p != null; p = p.prev)
if (p.status >= 0)
return true;
return false;
}
public final boolean hasContended() {
return head != null;
}
public final Thread getFirstQueuedThread() {
Thread first = null, w; Node h, s;
if ((h = head) != null && ((s = h.next) == null ||
(first = s.waiter) == null ||
s.prev == null)) {
for (Node p = tail, q; p != null && (q = p.prev) != null; p = q)
if ((w = p.waiter) != null)
first = w;
}
return first;
}
public final boolean isQueued(Thread thread) {
if (thread == null)
throw new NullPointerException();
for (Node p = tail; p != null; p = p.prev)
if (p.waiter == thread)
return true;
return false;
}
final boolean apparentlyFirstQueuedIsExclusive() {
Node h, s;
return (h = head) != null && (s = h.next)  != null &&
!(s instanceof SharedNode) && s.waiter != null;
}
public final boolean hasQueuedPredecessors() {
Thread first = null; Node h, s;
if ((h = head) != null && ((s = h.next) == null ||
(first = s.waiter) == null ||
s.prev == null))
first = getFirstQueuedThread();         return first != null && first != Thread.currentThread();
}
public final int getQueueLength() {
int n = 0;
for (Node p = tail; p != null; p = p.prev) {
if (p.waiter != null)
++n;
}
return n;
}
public final Collection<Thread> getQueuedThreads() {
ArrayList<Thread> list = new ArrayList<>();
for (Node p = tail; p != null; p = p.prev) {
Thread t = p.waiter;
if (t != null)
list.add(t);
}
return list;
}
public final Collection<Thread> getExclusiveQueuedThreads() {
ArrayList<Thread> list = new ArrayList<>();
for (Node p = tail; p != null; p = p.prev) {
if (!(p instanceof SharedNode)) {
Thread t = p.waiter;
if (t != null)
list.add(t);
}
}
return list;
}
public final Collection<Thread> getSharedQueuedThreads() {
ArrayList<Thread> list = new ArrayList<>();
for (Node p = tail; p != null; p = p.prev) {
if (p instanceof SharedNode) {
Thread t = p.waiter;
if (t != null)
list.add(t);
}
}
return list;
}
public String toString() {
return super.toString()
+ "[State = " + getState() + ", "
+ (hasQueuedThreads() ? "non" : "") + "empty queue]";
}
public final boolean owns(ConditionObject condition) {
return condition.isOwnedBy(this);
}
public final boolean hasWaiters(ConditionObject condition) {
if (!owns(condition))
throw new IllegalArgumentException("Not owner");
return condition.hasWaiters();
}
public final int getWaitQueueLength(ConditionObject condition) {
if (!owns(condition))
throw new IllegalArgumentException("Not owner");
return condition.getWaitQueueLength();
}
public final Collection<Thread> getWaitingThreads(ConditionObject condition) {
if (!owns(condition))
throw new IllegalArgumentException("Not owner");
return condition.getWaitingThreads();
}
public class ConditionObject implements Condition, java.io.Serializable {
private static final long serialVersionUID = 1173984872572414699L;
private transient ConditionNode firstWaiter;
private transient ConditionNode lastWaiter;
static final long OOME_COND_WAIT_DELAY = 10L * 1000L * 1000L;
public ConditionObject() { }
private void doSignal(ConditionNode first, boolean all) {
while (first != null) {
ConditionNode next = first.nextWaiter;
if ((firstWaiter = next) == null)
lastWaiter = null;
if ((first.getAndUnsetStatus(COND) & COND) != 0) {
enqueue(first);
if (!all)
break;
}
first = next;
}
}
public final void signal() {
ConditionNode first = firstWaiter;
if (!isHeldExclusively())
throw new IllegalMonitorStateException();
else if (first != null)
doSignal(first, false);
}
public final void signalAll() {
ConditionNode first = firstWaiter;
if (!isHeldExclusively())
throw new IllegalMonitorStateException();
else if (first != null)
doSignal(first, true);
}
private long enableWait(ConditionNode node) {
if (isHeldExclusively()) {
node.waiter = Thread.currentThread();
node.setStatusRelaxed(COND | WAITING);
ConditionNode last = lastWaiter;
if (last == null)
firstWaiter = node;
else
last.nextWaiter = node;
lastWaiter = node;
long savedState = getState();
if (release(savedState))
return savedState;
}
node.status = CANCELLED;             throw new IllegalMonitorStateException();
}
private boolean canReacquire(ConditionNode node) {
Node p;             return node != null && (p = node.prev) != null &&
(p.next == node || isEnqueued(node));
}
private void unlinkCancelledWaiters(ConditionNode node) {
if (node == null || node.nextWaiter != null || node == lastWaiter) {
ConditionNode w = firstWaiter, trail = null;
while (w != null) {
ConditionNode next = w.nextWaiter;
if ((w.status & COND) == 0) {
w.nextWaiter = null;
if (trail == null)
firstWaiter = next;
else
trail.nextWaiter = next;
if (next == null)
lastWaiter = trail;
} else
trail = w;
w = next;
}
}
}
private ConditionNode newConditionNode() {
long savedState;
if (tryInitializeHead() != null) {
try {
return new ConditionNode();
} catch (OutOfMemoryError oome) {
}
}
if (!isHeldExclusively() || !release(savedState = getState()))
throw new IllegalMonitorStateException();
U.park(false, OOME_COND_WAIT_DELAY);
acquireOnOOME(false, savedState);
return null;
}
public final void awaitUninterruptibly() {
ConditionNode node = newConditionNode();
if (node == null)
return;
long savedState = enableWait(node);
LockSupport.setCurrentBlocker(this);             boolean interrupted = false, rejected = false;
while (!canReacquire(node)) {
if (Thread.interrupted())
interrupted = true;
else if ((node.status & COND) != 0) {
try {
if (rejected)
node.block();
else
ForkJoinPool.managedBlock(node);
} catch (RejectedExecutionException ex) {
rejected = true;
} catch (InterruptedException ie) {
interrupted = true;
}
} else
Thread.onSpinWait();                }
LockSupport.setCurrentBlocker(null);
node.clearStatus();
acquire(node, savedState, false, false, false, 0L);
if (interrupted)
Thread.currentThread().interrupt();
}
public final void await() throws InterruptedException {
if (Thread.interrupted())
throw new InterruptedException();
ConditionNode node = newConditionNode();
if (node == null)
return;
long savedState = enableWait(node);
LockSupport.setCurrentBlocker(this);             boolean interrupted = false, cancelled = false, rejected = false;
while (!canReacquire(node)) {
if (interrupted |= Thread.interrupted()) {
if (cancelled = (node.getAndUnsetStatus(COND) & COND) != 0)
break;                              } else if ((node.status & COND) != 0) {
try {
if (rejected)
node.block();
else
ForkJoinPool.managedBlock(node);
} catch (RejectedExecutionException ex) {
rejected = true;
} catch (InterruptedException ie) {
interrupted = true;
}
} else
Thread.onSpinWait();                }
LockSupport.setCurrentBlocker(null);
node.clearStatus();
acquire(node, savedState, false, false, false, 0L);
if (interrupted) {
if (cancelled) {
unlinkCancelledWaiters(node);
throw new InterruptedException();
}
Thread.currentThread().interrupt();
}
}
public final long awaitNanos(long nanosTimeout)
throws InterruptedException {
if (Thread.interrupted())
throw new InterruptedException();
ConditionNode node = newConditionNode();
if (node == null)
return nanosTimeout - OOME_COND_WAIT_DELAY;
long savedState = enableWait(node);
long nanos = (nanosTimeout < 0L) ? 0L : nanosTimeout;
long deadline = System.nanoTime() + nanos;
boolean cancelled = false, interrupted = false;
while (!canReacquire(node)) {
if ((interrupted |= Thread.interrupted()) ||
(nanos = deadline - System.nanoTime()) <= 0L) {
if (cancelled = (node.getAndUnsetStatus(COND) & COND) != 0)
break;
} else
LockSupport.parkNanos(this, nanos);
}
node.clearStatus();
acquire(node, savedState, false, false, false, 0L);
if (cancelled) {
unlinkCancelledWaiters(node);
if (interrupted)
throw new InterruptedException();
} else if (interrupted)
Thread.currentThread().interrupt();
long remaining = deadline - System.nanoTime();             return (remaining <= nanosTimeout) ? remaining : Long.MIN_VALUE;
}
public final boolean awaitUntil(Date deadline)
throws InterruptedException {
long abstime = deadline.getTime();
if (Thread.interrupted())
throw new InterruptedException();
ConditionNode node = newConditionNode();
if (node == null)
return false;
long savedState = enableWait(node);
boolean cancelled = false, interrupted = false;
while (!canReacquire(node)) {
if ((interrupted |= Thread.interrupted()) ||
System.currentTimeMillis() >= abstime) {
if (cancelled = (node.getAndUnsetStatus(COND) & COND) != 0)
break;
} else
LockSupport.parkUntil(this, abstime);
}
node.clearStatus();
acquire(node, savedState, false, false, false, 0L);
if (cancelled) {
unlinkCancelledWaiters(node);
if (interrupted)
throw new InterruptedException();
} else if (interrupted)
Thread.currentThread().interrupt();
return !cancelled;
}
public final boolean await(long time, TimeUnit unit)
throws InterruptedException {
long nanosTimeout = unit.toNanos(time);
if (Thread.interrupted())
throw new InterruptedException();
ConditionNode node = newConditionNode();
if (node == null)
return false;
long savedState = enableWait(node);
long nanos = (nanosTimeout < 0L) ? 0L : nanosTimeout;
long deadline = System.nanoTime() + nanos;
boolean cancelled = false, interrupted = false;
while (!canReacquire(node)) {
if ((interrupted |= Thread.interrupted()) ||
(nanos = deadline - System.nanoTime()) <= 0L) {
if (cancelled = (node.getAndUnsetStatus(COND) & COND) != 0)
break;
} else
LockSupport.parkNanos(this, nanos);
}
node.clearStatus();
acquire(node, savedState, false, false, false, 0L);
if (cancelled) {
unlinkCancelledWaiters(node);
if (interrupted)
throw new InterruptedException();
} else if (interrupted)
Thread.currentThread().interrupt();
return !cancelled;
}
final boolean isOwnedBy(AbstractQueuedLongSynchronizer sync) {
return sync == AbstractQueuedLongSynchronizer.this;
}
protected final boolean hasWaiters() {
if (!isHeldExclusively())
throw new IllegalMonitorStateException();
for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {
if ((w.status & COND) != 0)
return true;
}
return false;
}
protected final int getWaitQueueLength() {
if (!isHeldExclusively())
throw new IllegalMonitorStateException();
int n = 0;
for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {
if ((w.status & COND) != 0)
++n;
}
return n;
}
protected final Collection<Thread> getWaitingThreads() {
if (!isHeldExclusively())
throw new IllegalMonitorStateException();
ArrayList<Thread> list = new ArrayList<>();
for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {
if ((w.status & COND) != 0) {
Thread t = w.waiter;
if (t != null)
list.add(t);
}
}
return list;
}
}
private static final Unsafe U = Unsafe.getUnsafe();
private static final long STATE
= U.objectFieldOffset(AbstractQueuedLongSynchronizer.class, "state");
private static final long HEAD
= U.objectFieldOffset(AbstractQueuedLongSynchronizer.class, "head");
private static final long TAIL
= U.objectFieldOffset(AbstractQueuedLongSynchronizer.class, "tail");
static {
Class<?> ensureLoaded = LockSupport.class;
}
}
package java.util.concurrent.locks;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RejectedExecutionException;
import jdk.internal.misc.Unsafe;
public abstract class AbstractQueuedSynchronizer
extends AbstractOwnableSynchronizer
implements java.io.Serializable {
private static final long serialVersionUID = 7373984972572414691L;
protected AbstractQueuedSynchronizer() { }
static final int WAITING   = 1;              static final int CANCELLED = 0x80000000;     static final int COND      = 2;
abstract static class Node {
volatile Node prev;               volatile Node next;               Thread waiter;                    volatile int status;
final boolean casPrev(Node c, Node v) {              return U.weakCompareAndSetReference(this, PREV, c, v);
}
final boolean casNext(Node c, Node v) {              return U.weakCompareAndSetReference(this, NEXT, c, v);
}
final int getAndUnsetStatus(int v) {                 return U.getAndBitwiseAndInt(this, STATUS, ~v);
}
final void setPrevRelaxed(Node p) {                  U.putReference(this, PREV, p);
}
final void setStatusRelaxed(int s) {                 U.putInt(this, STATUS, s);
}
final void clearStatus() {                           U.putIntOpaque(this, STATUS, 0);
}
private static final long STATUS
= U.objectFieldOffset(Node.class, "status");
private static final long NEXT
= U.objectFieldOffset(Node.class, "next");
private static final long PREV
= U.objectFieldOffset(Node.class, "prev");
}
static final class ExclusiveNode extends Node { }
static final class SharedNode extends Node { }
static final class ConditionNode extends Node
implements ForkJoinPool.ManagedBlocker {
ConditionNode nextWaiter;
public final boolean isReleasable() {
return status <= 1 || Thread.currentThread().isInterrupted();
}
public final boolean block() {
while (!isReleasable()) LockSupport.park();
return true;
}
}
private transient volatile Node head;
private transient volatile Node tail;
private volatile int state;
protected final int getState() {
return state;
}
protected final void setState(int newState) {
state = newState;
}
protected final boolean compareAndSetState(int expect, int update) {
return U.compareAndSetInt(this, STATE, expect, update);
}
private boolean casTail(Node c, Node v) {
return U.compareAndSetReference(this, TAIL, c, v);
}
private Node tryInitializeHead() {
for (Node h = null, t;;) {
if ((t = tail) != null)
return t;
else if (head != null)
Thread.onSpinWait();
else {
if (h == null) {
try {
h = new ExclusiveNode();
} catch (OutOfMemoryError oome) {
return null;
}
}
if (U.compareAndSetReference(this, HEAD, null, h))
return tail = h;
}
}
}
final void enqueue(ConditionNode node) {
if (node != null) {
boolean unpark = false;
for (Node t;;) {
if ((t = tail) == null && (t = tryInitializeHead()) == null) {
unpark = true;                                 break;
}
node.setPrevRelaxed(t);                        if (casTail(t, node)) {
t.next = node;
if (t.status < 0)                                  unpark = true;
break;
}
}
if (unpark)
LockSupport.unpark(node.waiter);
}
}
final boolean isEnqueued(Node node) {
for (Node t = tail; t != null; t = t.prev)
if (t == node)
return true;
return false;
}
private static void signalNext(Node h) {
Node s;
if (h != null && (s = h.next) != null && s.status != 0) {
s.getAndUnsetStatus(WAITING);
LockSupport.unpark(s.waiter);
}
}
private static void signalNextIfShared(Node h) {
Node s;
if (h != null && (s = h.next) != null &&
(s instanceof SharedNode) && s.status != 0) {
s.getAndUnsetStatus(WAITING);
LockSupport.unpark(s.waiter);
}
}
final int acquire(Node node, int arg, boolean shared,
boolean interruptible, boolean timed, long time) {
Thread current = Thread.currentThread();
byte spins = 0, postSpins = 0;           boolean interrupted = false, first = false;
Node pred = null;
for (;;) {
if (!first && (pred = (node == null) ? null : node.prev) != null &&
!(first = (head == pred))) {
if (pred.status < 0) {
cleanQueue();                               continue;
} else if (pred.prev == null) {
Thread.onSpinWait();                        continue;
}
}
if (first || pred == null) {
boolean acquired;
try {
if (shared)
acquired = (tryAcquireShared(arg) >= 0);
else
acquired = tryAcquire(arg);
} catch (Throwable ex) {
cancelAcquire(node, interrupted, false);
throw ex;
}
if (acquired) {
if (first) {
node.prev = null;
head = node;
pred.next = null;
node.waiter = null;
if (shared)
signalNextIfShared(node);
if (interrupted)
current.interrupt();
}
return 1;
}
}
Node t;
if ((t = tail) == null) {                           if (tryInitializeHead() == null)
return acquireOnOOME(shared, arg);
} else if (node == null) {                          try {
node = (shared) ? new SharedNode() : new ExclusiveNode();
} catch (OutOfMemoryError oome) {
return acquireOnOOME(shared, arg);
}
} else if (pred == null) {                          node.waiter = current;
node.setPrevRelaxed(t);                         if (!casTail(t, node))
node.setPrevRelaxed(null);                  else
t.next = node;
} else if (first && spins != 0) {
--spins;                                        Thread.onSpinWait();
} else if (node.status == 0) {
node.status = WAITING;                      } else {
long nanos;
spins = postSpins = (byte)((postSpins << 1) | 1);
if (!timed)
LockSupport.park(this);
else if ((nanos = time - System.nanoTime()) > 0L)
LockSupport.parkNanos(this, nanos);
else
break;
node.clearStatus();
if ((interrupted |= Thread.interrupted()) && interruptible)
break;
}
}
return cancelAcquire(node, interrupted, interruptible);
}
private int acquireOnOOME(boolean shared, int arg) {
for (long nanos = 1L;;) {
if (shared ? (tryAcquireShared(arg) >= 0) : tryAcquire(arg))
return 1;
U.park(false, nanos);                           if (nanos < 1L << 30)                               nanos <<= 1;
}
}
private void cleanQueue() {
for (;;) {                                           for (Node q = tail, s = null, p, n;;) {                 if (q == null || (p = q.prev) == null)
return;                                      if (s == null ? tail != q : (s.prev != q || s.status < 0))
break;                                       if (q.status < 0) {                                  if ((s == null ? casTail(q, p) : s.casPrev(q, p)) &&
q.prev == p) {
p.casNext(q, s);                                 if (p.prev == null)
signalNext(p);
}
break;
}
if ((n = p.next) != q) {                             if (n != null && q.prev == p) {
p.casNext(n, q);
if (p.prev == null)
signalNext(p);
}
break;
}
s = q;
q = q.prev;
}
}
}
private int cancelAcquire(Node node, boolean interrupted,
boolean interruptible) {
if (node != null) {
node.waiter = null;
node.status = CANCELLED;
if (node.prev != null)
cleanQueue();
}
if (interrupted) {
if (interruptible)
return CANCELLED;
else
Thread.currentThread().interrupt();
}
return 0;
}
protected boolean tryAcquire(int arg) {
throw new UnsupportedOperationException();
}
protected boolean tryRelease(int arg) {
throw new UnsupportedOperationException();
}
protected int tryAcquireShared(int arg) {
throw new UnsupportedOperationException();
}
protected boolean tryReleaseShared(int arg) {
throw new UnsupportedOperationException();
}
protected boolean isHeldExclusively() {
throw new UnsupportedOperationException();
}
public final void acquire(int arg) {
if (!tryAcquire(arg))
acquire(null, arg, false, false, false, 0L);
}
public final void acquireInterruptibly(int arg)
throws InterruptedException {
if (Thread.interrupted() ||
(!tryAcquire(arg) && acquire(null, arg, false, true, false, 0L) < 0))
throw new InterruptedException();
}
public final boolean tryAcquireNanos(int arg, long nanosTimeout)
throws InterruptedException {
if (!Thread.interrupted()) {
if (tryAcquire(arg))
return true;
if (nanosTimeout <= 0L)
return false;
int stat = acquire(null, arg, false, true, true,
System.nanoTime() + nanosTimeout);
if (stat > 0)
return true;
if (stat == 0)
return false;
}
throw new InterruptedException();
}
public final boolean release(int arg) {
if (tryRelease(arg)) {
signalNext(head);
return true;
}
return false;
}
public final void acquireShared(int arg) {
if (tryAcquireShared(arg) < 0)
acquire(null, arg, true, false, false, 0L);
}
public final void acquireSharedInterruptibly(int arg)
throws InterruptedException {
if (Thread.interrupted() ||
(tryAcquireShared(arg) < 0 &&
acquire(null, arg, true, true, false, 0L) < 0))
throw new InterruptedException();
}
public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
throws InterruptedException {
if (!Thread.interrupted()) {
if (tryAcquireShared(arg) >= 0)
return true;
if (nanosTimeout <= 0L)
return false;
int stat = acquire(null, arg, true, true, true,
System.nanoTime() + nanosTimeout);
if (stat > 0)
return true;
if (stat == 0)
return false;
}
throw new InterruptedException();
}
public final boolean releaseShared(int arg) {
if (tryReleaseShared(arg)) {
signalNext(head);
return true;
}
return false;
}
public final boolean hasQueuedThreads() {
for (Node p = tail, h = head; p != h && p != null; p = p.prev)
if (p.status >= 0)
return true;
return false;
}
public final boolean hasContended() {
return head != null;
}
public final Thread getFirstQueuedThread() {
Thread first = null, w; Node h, s;
if ((h = head) != null && ((s = h.next) == null ||
(first = s.waiter) == null ||
s.prev == null)) {
for (Node p = tail, q; p != null && (q = p.prev) != null; p = q)
if ((w = p.waiter) != null)
first = w;
}
return first;
}
public final boolean isQueued(Thread thread) {
if (thread == null)
throw new NullPointerException();
for (Node p = tail; p != null; p = p.prev)
if (p.waiter == thread)
return true;
return false;
}
final boolean apparentlyFirstQueuedIsExclusive() {
Node h, s;
return (h = head) != null && (s = h.next)  != null &&
!(s instanceof SharedNode) && s.waiter != null;
}
public final boolean hasQueuedPredecessors() {
Thread first = null; Node h, s;
if ((h = head) != null && ((s = h.next) == null ||
(first = s.waiter) == null ||
s.prev == null))
first = getFirstQueuedThread();         return first != null && first != Thread.currentThread();
}
public final int getQueueLength() {
int n = 0;
for (Node p = tail; p != null; p = p.prev) {
if (p.waiter != null)
++n;
}
return n;
}
public final Collection<Thread> getQueuedThreads() {
ArrayList<Thread> list = new ArrayList<>();
for (Node p = tail; p != null; p = p.prev) {
Thread t = p.waiter;
if (t != null)
list.add(t);
}
return list;
}
public final Collection<Thread> getExclusiveQueuedThreads() {
ArrayList<Thread> list = new ArrayList<>();
for (Node p = tail; p != null; p = p.prev) {
if (!(p instanceof SharedNode)) {
Thread t = p.waiter;
if (t != null)
list.add(t);
}
}
return list;
}
public final Collection<Thread> getSharedQueuedThreads() {
ArrayList<Thread> list = new ArrayList<>();
for (Node p = tail; p != null; p = p.prev) {
if (p instanceof SharedNode) {
Thread t = p.waiter;
if (t != null)
list.add(t);
}
}
return list;
}
public String toString() {
return super.toString()
+ "[State = " + getState() + ", "
+ (hasQueuedThreads() ? "non" : "") + "empty queue]";
}
public final boolean owns(ConditionObject condition) {
return condition.isOwnedBy(this);
}
public final boolean hasWaiters(ConditionObject condition) {
if (!owns(condition))
throw new IllegalArgumentException("Not owner");
return condition.hasWaiters();
}
public final int getWaitQueueLength(ConditionObject condition) {
if (!owns(condition))
throw new IllegalArgumentException("Not owner");
return condition.getWaitQueueLength();
}
public final Collection<Thread> getWaitingThreads(ConditionObject condition) {
if (!owns(condition))
throw new IllegalArgumentException("Not owner");
return condition.getWaitingThreads();
}
public class ConditionObject implements Condition, java.io.Serializable {
private static final long serialVersionUID = 1173984872572414699L;
private transient ConditionNode firstWaiter;
private transient ConditionNode lastWaiter;
static final long OOME_COND_WAIT_DELAY = 10L * 1000L * 1000L;
public ConditionObject() { }
private void doSignal(ConditionNode first, boolean all) {
while (first != null) {
ConditionNode next = first.nextWaiter;
if ((firstWaiter = next) == null)
lastWaiter = null;
if ((first.getAndUnsetStatus(COND) & COND) != 0) {
enqueue(first);
if (!all)
break;
}
first = next;
}
}
public final void signal() {
ConditionNode first = firstWaiter;
if (!isHeldExclusively())
throw new IllegalMonitorStateException();
else if (first != null)
doSignal(first, false);
}
public final void signalAll() {
ConditionNode first = firstWaiter;
if (!isHeldExclusively())
throw new IllegalMonitorStateException();
else if (first != null)
doSignal(first, true);
}
private int enableWait(ConditionNode node) {
if (isHeldExclusively()) {
node.waiter = Thread.currentThread();
node.setStatusRelaxed(COND | WAITING);
ConditionNode last = lastWaiter;
if (last == null)
firstWaiter = node;
else
last.nextWaiter = node;
lastWaiter = node;
int savedState = getState();
if (release(savedState))
return savedState;
}
node.status = CANCELLED;             throw new IllegalMonitorStateException();
}
private boolean canReacquire(ConditionNode node) {
Node p;             return node != null && (p = node.prev) != null &&
(p.next == node || isEnqueued(node));
}
private void unlinkCancelledWaiters(ConditionNode node) {
if (node == null || node.nextWaiter != null || node == lastWaiter) {
ConditionNode w = firstWaiter, trail = null;
while (w != null) {
ConditionNode next = w.nextWaiter;
if ((w.status & COND) == 0) {
w.nextWaiter = null;
if (trail == null)
firstWaiter = next;
else
trail.nextWaiter = next;
if (next == null)
lastWaiter = trail;
} else
trail = w;
w = next;
}
}
}
private ConditionNode newConditionNode() {
int savedState;
if (tryInitializeHead() != null) {
try {
return new ConditionNode();
} catch (OutOfMemoryError oome) {
}
}
if (!isHeldExclusively() || !release(savedState = getState()))
throw new IllegalMonitorStateException();
U.park(false, OOME_COND_WAIT_DELAY);
acquireOnOOME(false, savedState);
return null;
}
public final void awaitUninterruptibly() {
ConditionNode node = newConditionNode();
if (node == null)
return;
int savedState = enableWait(node);
LockSupport.setCurrentBlocker(this);             boolean interrupted = false, rejected = false;
while (!canReacquire(node)) {
if (Thread.interrupted())
interrupted = true;
else if ((node.status & COND) != 0) {
try {
if (rejected)
node.block();
else
ForkJoinPool.managedBlock(node);
} catch (RejectedExecutionException ex) {
rejected = true;
} catch (InterruptedException ie) {
interrupted = true;
}
} else
Thread.onSpinWait();                }
LockSupport.setCurrentBlocker(null);
node.clearStatus();
acquire(node, savedState, false, false, false, 0L);
if (interrupted)
Thread.currentThread().interrupt();
}
public final void await() throws InterruptedException {
if (Thread.interrupted())
throw new InterruptedException();
ConditionNode node = newConditionNode();
if (node == null)
return;
int savedState = enableWait(node);
LockSupport.setCurrentBlocker(this);             boolean interrupted = false, cancelled = false, rejected = false;
while (!canReacquire(node)) {
if (interrupted |= Thread.interrupted()) {
if (cancelled = (node.getAndUnsetStatus(COND) & COND) != 0)
break;                              } else if ((node.status & COND) != 0) {
try {
if (rejected)
node.block();
else
ForkJoinPool.managedBlock(node);
} catch (RejectedExecutionException ex) {
rejected = true;
} catch (InterruptedException ie) {
interrupted = true;
}
} else
Thread.onSpinWait();                }
LockSupport.setCurrentBlocker(null);
node.clearStatus();
acquire(node, savedState, false, false, false, 0L);
if (interrupted) {
if (cancelled) {
unlinkCancelledWaiters(node);
throw new InterruptedException();
}
Thread.currentThread().interrupt();
}
}
public final long awaitNanos(long nanosTimeout)
throws InterruptedException {
if (Thread.interrupted())
throw new InterruptedException();
ConditionNode node = newConditionNode();
if (node == null)
return nanosTimeout - OOME_COND_WAIT_DELAY;
int savedState = enableWait(node);
long nanos = (nanosTimeout < 0L) ? 0L : nanosTimeout;
long deadline = System.nanoTime() + nanos;
boolean cancelled = false, interrupted = false;
while (!canReacquire(node)) {
if ((interrupted |= Thread.interrupted()) ||
(nanos = deadline - System.nanoTime()) <= 0L) {
if (cancelled = (node.getAndUnsetStatus(COND) & COND) != 0)
break;
} else
LockSupport.parkNanos(this, nanos);
}
node.clearStatus();
acquire(node, savedState, false, false, false, 0L);
if (cancelled) {
unlinkCancelledWaiters(node);
if (interrupted)
throw new InterruptedException();
} else if (interrupted)
Thread.currentThread().interrupt();
long remaining = deadline - System.nanoTime();             return (remaining <= nanosTimeout) ? remaining : Long.MIN_VALUE;
}
public final boolean awaitUntil(Date deadline)
throws InterruptedException {
long abstime = deadline.getTime();
if (Thread.interrupted())
throw new InterruptedException();
ConditionNode node = newConditionNode();
if (node == null)
return false;
int savedState = enableWait(node);
boolean cancelled = false, interrupted = false;
while (!canReacquire(node)) {
if ((interrupted |= Thread.interrupted()) ||
System.currentTimeMillis() >= abstime) {
if (cancelled = (node.getAndUnsetStatus(COND) & COND) != 0)
break;
} else
LockSupport.parkUntil(this, abstime);
}
node.clearStatus();
acquire(node, savedState, false, false, false, 0L);
if (cancelled) {
unlinkCancelledWaiters(node);
if (interrupted)
throw new InterruptedException();
} else if (interrupted)
Thread.currentThread().interrupt();
return !cancelled;
}
public final boolean await(long time, TimeUnit unit)
throws InterruptedException {
long nanosTimeout = unit.toNanos(time);
if (Thread.interrupted())
throw new InterruptedException();
ConditionNode node = newConditionNode();
if (node == null)
return false;
int savedState = enableWait(node);
long nanos = (nanosTimeout < 0L) ? 0L : nanosTimeout;
long deadline = System.nanoTime() + nanos;
boolean cancelled = false, interrupted = false;
while (!canReacquire(node)) {
if ((interrupted |= Thread.interrupted()) ||
(nanos = deadline - System.nanoTime()) <= 0L) {
if (cancelled = (node.getAndUnsetStatus(COND) & COND) != 0)
break;
} else
LockSupport.parkNanos(this, nanos);
}
node.clearStatus();
acquire(node, savedState, false, false, false, 0L);
if (cancelled) {
unlinkCancelledWaiters(node);
if (interrupted)
throw new InterruptedException();
} else if (interrupted)
Thread.currentThread().interrupt();
return !cancelled;
}
final boolean isOwnedBy(AbstractQueuedSynchronizer sync) {
return sync == AbstractQueuedSynchronizer.this;
}
protected final boolean hasWaiters() {
if (!isHeldExclusively())
throw new IllegalMonitorStateException();
for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {
if ((w.status & COND) != 0)
return true;
}
return false;
}
protected final int getWaitQueueLength() {
if (!isHeldExclusively())
throw new IllegalMonitorStateException();
int n = 0;
for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {
if ((w.status & COND) != 0)
++n;
}
return n;
}
protected final Collection<Thread> getWaitingThreads() {
if (!isHeldExclusively())
throw new IllegalMonitorStateException();
ArrayList<Thread> list = new ArrayList<>();
for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {
if ((w.status & COND) != 0) {
Thread t = w.waiter;
if (t != null)
list.add(t);
}
}
return list;
}
}
private static final Unsafe U = Unsafe.getUnsafe();
private static final long STATE
= U.objectFieldOffset(AbstractQueuedSynchronizer.class, "state");
private static final long HEAD
= U.objectFieldOffset(AbstractQueuedSynchronizer.class, "head");
private static final long TAIL
= U.objectFieldOffset(AbstractQueuedSynchronizer.class, "tail");
static {
Class<?> ensureLoaded = LockSupport.class;
}
}
package javax.swing.plaf.nimbus;
import java.awt.*;
import java.awt.image.*;
import java.lang.reflect.Method;
import javax.swing.*;
import javax.swing.plaf.UIResource;
import javax.swing.Painter;
import java.awt.print.PrinterGraphics;
import sun.reflect.misc.MethodUtil;
public abstract class AbstractRegionPainter implements Painter<JComponent> {
private PaintContext ctx;
private float f;
private float leftWidth;
private float topHeight;
private float centerWidth;
private float centerHeight;
private float rightWidth;
private float bottomHeight;
private float leftScale;
private float topScale;
private float centerHScale;
private float centerVScale;
private float rightScale;
private float bottomScale;
protected AbstractRegionPainter() { }
@Override
public final void paint(Graphics2D g, JComponent c, int w, int h) {
if (w <= 0 || h <=0) return;
Object[] extendedCacheKeys = getExtendedCacheKeys(c);
ctx = getPaintContext();
PaintContext.CacheMode cacheMode = ctx == null ? PaintContext.CacheMode.NO_CACHING : ctx.cacheMode;
if (cacheMode == PaintContext.CacheMode.NO_CACHING ||
!ImageCache.getInstance().isImageCachable(w, h) ||
g instanceof PrinterGraphics) {
paint0(g, c, w, h, extendedCacheKeys);
} else if (cacheMode == PaintContext.CacheMode.FIXED_SIZES) {
paintWithFixedSizeCaching(g, c, w, h, extendedCacheKeys);
} else {
paintWith9SquareCaching(g, ctx, c, w, h, extendedCacheKeys);
}
}
protected Object[] getExtendedCacheKeys(JComponent c) {
return null;
}
protected abstract PaintContext getPaintContext();
protected void configureGraphics(Graphics2D g) {
g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
}
protected abstract void doPaint(Graphics2D g, JComponent c, int width,
int height, Object[] extendedCacheKeys);
protected final float decodeX(float x) {
if (x >= 0 && x <= 1) {
return x * leftWidth;
} else if (x > 1 && x < 2) {
return ((x-1) * centerWidth) + leftWidth;
} else if (x >= 2 && x <= 3) {
return ((x-2) * rightWidth) + leftWidth + centerWidth;
} else {
throw new IllegalArgumentException("Invalid x");
}
}
protected final float decodeY(float y) {
if (y >= 0 && y <= 1) {
return y * topHeight;
} else if (y > 1 && y < 2) {
return ((y-1) * centerHeight) + topHeight;
} else if (y >= 2 && y <= 3) {
return ((y-2) * bottomHeight) + topHeight + centerHeight;
} else {
throw new IllegalArgumentException("Invalid y");
}
}
protected final float decodeAnchorX(float x, float dx) {
if (x >= 0 && x <= 1) {
return decodeX(x) + (dx * leftScale);
} else if (x > 1 && x < 2) {
return decodeX(x) + (dx * centerHScale);
} else if (x >= 2 && x <= 3) {
return decodeX(x) + (dx * rightScale);
} else {
throw new IllegalArgumentException("Invalid x");
}
}
protected final float decodeAnchorY(float y, float dy) {
if (y >= 0 && y <= 1) {
return decodeY(y) + (dy * topScale);
} else if (y > 1 && y < 2) {
return decodeY(y) + (dy * centerVScale);
} else if (y >= 2 && y <= 3) {
return decodeY(y) + (dy * bottomScale);
} else {
throw new IllegalArgumentException("Invalid y");
}
}
protected final Color decodeColor(String key, float hOffset, float sOffset,
float bOffset, int aOffset) {
if (UIManager.getLookAndFeel() instanceof NimbusLookAndFeel){
NimbusLookAndFeel laf = (NimbusLookAndFeel) UIManager.getLookAndFeel();
return laf.getDerivedColor(key, hOffset, sOffset, bOffset, aOffset, true);
} else {
return Color.getHSBColor(hOffset,sOffset,bOffset);
}
}
protected final Color decodeColor(Color color1, Color color2,
float midPoint) {
return new Color(NimbusLookAndFeel.deriveARGB(color1, color2, midPoint));
}
protected final LinearGradientPaint decodeGradient(float x1, float y1, float x2, float y2, float[] midpoints, Color[] colors) {
if (x1 == x2 && y1 == y2) {
y2 += .00001f;
}
return new LinearGradientPaint(x1, y1, x2, y2, midpoints, colors);
}
protected final RadialGradientPaint decodeRadialGradient(float x, float y, float r, float[] midpoints, Color[] colors) {
if (r == 0f) {
r = .00001f;
}
return new RadialGradientPaint(x, y, r, midpoints, colors);
}
protected final Color getComponentColor(JComponent c, String property,
Color defaultColor,
float saturationOffset,
float brightnessOffset,
int alphaOffset) {
Color color = null;
if (c != null) {
if ("background".equals(property)) {
color = c.getBackground();
} else if ("foreground".equals(property)) {
color = c.getForeground();
} else if (c instanceof JList && "selectionForeground".equals(property)) {
color = ((JList) c).getSelectionForeground();
} else if (c instanceof JList && "selectionBackground".equals(property)) {
color = ((JList) c).getSelectionBackground();
} else if (c instanceof JTable && "selectionForeground".equals(property)) {
color = ((JTable) c).getSelectionForeground();
} else if (c instanceof JTable && "selectionBackground".equals(property)) {
color = ((JTable) c).getSelectionBackground();
} else {
String s = "get" + Character.toUpperCase(property.charAt(0)) + property.substring(1);
try {
Method method = MethodUtil.getMethod(c.getClass(), s, null);
color = (Color) MethodUtil.invoke(method, c, null);
} catch (Exception e) {
}
if (color == null) {
Object value = c.getClientProperty(property);
if (value instanceof Color) {
color = (Color) value;
}
}
}
}
if (color == null || color instanceof UIResource) {
return defaultColor;
} else if (saturationOffset != 0 || brightnessOffset != 0 || alphaOffset != 0) {
float[] tmp = Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), null);
tmp[1] = clamp(tmp[1] + saturationOffset);
tmp[2] = clamp(tmp[2] + brightnessOffset);
int alpha = clamp(color.getAlpha() + alphaOffset);
return new Color((Color.HSBtoRGB(tmp[0], tmp[1], tmp[2]) & 0xFFFFFF) | (alpha <<24));
} else {
return color;
}
}
protected static class PaintContext {
protected static enum CacheMode {
NO_CACHING,
FIXED_SIZES,
NINE_SQUARE_SCALE
}
private static Insets EMPTY_INSETS = new Insets(0, 0, 0, 0);
private Insets stretchingInsets;
private Dimension canvasSize;
private boolean inverted;
private CacheMode cacheMode;
private double maxHorizontalScaleFactor;
private double maxVerticalScaleFactor;
private float a;         private float b;         private float c;         private float d;         private float aPercent;         private float bPercent;         private float cPercent;         private float dPercent;
public PaintContext(Insets insets, Dimension canvasSize, boolean inverted) {
this(insets, canvasSize, inverted, null, 1, 1);
}
public PaintContext(Insets insets, Dimension canvasSize, boolean inverted,
CacheMode cacheMode, double maxH, double maxV) {
if (maxH < 1 || maxV < 1) {
throw new IllegalArgumentException("Both maxH and maxV must be >= 1");
}
this.stretchingInsets = insets == null ? EMPTY_INSETS : insets;
this.canvasSize = canvasSize;
this.inverted = inverted;
this.cacheMode = cacheMode == null ? CacheMode.NO_CACHING : cacheMode;
this.maxHorizontalScaleFactor = maxH;
this.maxVerticalScaleFactor = maxV;
if (canvasSize != null) {
a = stretchingInsets.left;
b = canvasSize.width - stretchingInsets.right;
c = stretchingInsets.top;
d = canvasSize.height - stretchingInsets.bottom;
this.canvasSize = canvasSize;
this.inverted = inverted;
if (inverted) {
float available = canvasSize.width - (b - a);
aPercent = available > 0f ? a / available : 0f;
bPercent = available > 0f ? b / available : 0f;
available = canvasSize.height - (d - c);
cPercent = available > 0f ? c / available : 0f;
dPercent = available > 0f ? d / available : 0f;
}
}
}
}
private void prepare(float w, float h) {
if (ctx == null || ctx.canvasSize == null) {
f = 1f;
leftWidth = centerWidth = rightWidth = 0f;
topHeight = centerHeight = bottomHeight = 0f;
leftScale = centerHScale = rightScale = 0f;
topScale = centerVScale = bottomScale = 0f;
return;
}
Number scale = (Number)UIManager.get("scale");
f = scale == null ? 1f : scale.floatValue();
if (ctx.inverted) {
centerWidth = (ctx.b - ctx.a) * f;
float availableSpace = w - centerWidth;
leftWidth = availableSpace * ctx.aPercent;
rightWidth = availableSpace * ctx.bPercent;
centerHeight = (ctx.d - ctx.c) * f;
availableSpace = h - centerHeight;
topHeight = availableSpace * ctx.cPercent;
bottomHeight = availableSpace * ctx.dPercent;
} else {
leftWidth = ctx.a * f;
rightWidth = (float)(ctx.canvasSize.getWidth() - ctx.b) * f;
centerWidth = w - leftWidth - rightWidth;
topHeight = ctx.c * f;
bottomHeight = (float)(ctx.canvasSize.getHeight() - ctx.d) * f;
centerHeight = h - topHeight - bottomHeight;
}
leftScale = ctx.a == 0f ? 0f : leftWidth / ctx.a;
centerHScale = (ctx.b - ctx.a) == 0f ? 0f : centerWidth / (ctx.b - ctx.a);
rightScale = (ctx.canvasSize.width - ctx.b) == 0f ? 0f : rightWidth / (ctx.canvasSize.width - ctx.b);
topScale = ctx.c == 0f ? 0f : topHeight / ctx.c;
centerVScale = (ctx.d - ctx.c) == 0f ? 0f : centerHeight / (ctx.d - ctx.c);
bottomScale = (ctx.canvasSize.height - ctx.d) == 0f ? 0f : bottomHeight / (ctx.canvasSize.height - ctx.d);
}
private void paintWith9SquareCaching(Graphics2D g, PaintContext ctx,
JComponent c, int w, int h,
Object[] extendedCacheKeys) {
Dimension canvas = ctx.canvasSize;
Insets insets = ctx.stretchingInsets;
if (w <= (canvas.width * ctx.maxHorizontalScaleFactor) && h <= (canvas.height * ctx.maxVerticalScaleFactor)) {
VolatileImage img = getImage(g.getDeviceConfiguration(), c, canvas.width, canvas.height, extendedCacheKeys);
if (img != null) {
Insets dstInsets;
if (ctx.inverted){
int leftRight = (w-(canvas.width-(insets.left+insets.right)))/2;
int topBottom = (h-(canvas.height-(insets.top+insets.bottom)))/2;
dstInsets = new Insets(topBottom,leftRight,topBottom,leftRight);
} else {
dstInsets = insets;
}
Object oldScaleingHints = g.getRenderingHint(RenderingHints.KEY_INTERPOLATION);
g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
ImageScalingHelper.paint(g, 0, 0, w, h, img, insets, dstInsets,
ImageScalingHelper.PaintType.PAINT9_STRETCH, ImageScalingHelper.PAINT_ALL);
g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,
oldScaleingHints!=null?oldScaleingHints:RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);
} else {
paint0(g, c, w, h, extendedCacheKeys);
}
} else {
paint0(g, c, w, h, extendedCacheKeys);
}
}
private void paintWithFixedSizeCaching(Graphics2D g, JComponent c, int w,
int h, Object[] extendedCacheKeys) {
VolatileImage img = getImage(g.getDeviceConfiguration(), c, w, h, extendedCacheKeys);
if (img != null) {
g.drawImage(img, 0, 0, null);
} else {
paint0(g, c, w, h, extendedCacheKeys);
}
}
private VolatileImage getImage(GraphicsConfiguration config, JComponent c,
int w, int h, Object[] extendedCacheKeys) {
ImageCache imageCache = ImageCache.getInstance();
VolatileImage buffer = (VolatileImage) imageCache.getImage(config, w, h, this, extendedCacheKeys);
int renderCounter = 0;         do {
int bufferStatus = VolatileImage.IMAGE_INCOMPATIBLE;
if (buffer != null) {
bufferStatus = buffer.validate(config);
}
if (bufferStatus == VolatileImage.IMAGE_INCOMPATIBLE || bufferStatus == VolatileImage.IMAGE_RESTORED) {
if (buffer == null || buffer.getWidth() != w || buffer.getHeight() != h ||
bufferStatus == VolatileImage.IMAGE_INCOMPATIBLE) {
if (buffer != null) {
buffer.flush();
buffer = null;
}
buffer = config.createCompatibleVolatileImage(w, h,
Transparency.TRANSLUCENT);
imageCache.setImage(buffer, config, w, h, this, extendedCacheKeys);
}
Graphics2D bg = buffer.createGraphics();
bg.setComposite(AlphaComposite.Clear);
bg.fillRect(0, 0, w, h);
bg.setComposite(AlphaComposite.SrcOver);
configureGraphics(bg);
paint0(bg, c, w, h, extendedCacheKeys);
bg.dispose();
}
} while (buffer.contentsLost() && renderCounter++ < 3);
if (renderCounter == 3) return null;
return buffer;
}
private void paint0(Graphics2D g, JComponent c, int width, int height,
Object[] extendedCacheKeys) {
prepare(width, height);
g = (Graphics2D)g.create();
configureGraphics(g);
doPaint(g, c, width, height, extendedCacheKeys);
g.dispose();
}
private float clamp(float value) {
if (value < 0) {
value = 0;
} else if (value > 1) {
value = 1;
}
return value;
}
private int clamp(int value) {
if (value < 0) {
value = 0;
} else if (value > 255) {
value = 255;
}
return value;
}
}
package jdk.dynalink.support;
import java.lang.invoke.CallSite;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MutableCallSite;
import jdk.dynalink.CallSiteDescriptor;
import jdk.dynalink.RelinkableCallSite;
import jdk.dynalink.linker.GuardedInvocation;
public abstract class AbstractRelinkableCallSite extends MutableCallSite implements RelinkableCallSite {
private final CallSiteDescriptor descriptor;
protected AbstractRelinkableCallSite(final CallSiteDescriptor descriptor) {
super(descriptor.getMethodType());
this.descriptor = descriptor;
}
@Override
public CallSiteDescriptor getDescriptor() {
return descriptor;
}
@Override
public void initialize(final MethodHandle relinkAndInvoke) {
setTarget(relinkAndInvoke);
}
}
package sun.reflect.generics.repository;
import sun.reflect.generics.factory.GenericsFactory;
import sun.reflect.generics.tree.Tree;
import sun.reflect.generics.visitor.Reifier;
public abstract class AbstractRepository<T extends Tree> {
private final GenericsFactory factory;
private final T tree;
private GenericsFactory getFactory() { return factory;}
protected T getTree(){ return tree;}
protected Reifier getReifier(){return Reifier.make(getFactory());}
protected AbstractRepository(String rawSig, GenericsFactory f) {
tree = parse(rawSig);
factory = f;
}
protected abstract T parse(String s);
}
package java.util.spi;
import jdk.internal.access.JavaUtilResourceBundleAccess;
import jdk.internal.access.SharedSecrets;
import sun.util.resources.Bundles;
import java.io.IOException;
import java.io.InputStream;
import java.io.UncheckedIOException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Locale;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import static sun.security.util.SecurityConstants.GET_CLASSLOADER_PERMISSION;
public abstract class AbstractResourceBundleProvider implements ResourceBundleProvider {
private static final JavaUtilResourceBundleAccess RB_ACCESS =
SharedSecrets.getJavaUtilResourceBundleAccess();
private static final String FORMAT_CLASS = "java.class";
private static final String FORMAT_PROPERTIES = "java.properties";
private final String[] formats;
protected AbstractResourceBundleProvider() {
this(FORMAT_PROPERTIES);
}
protected AbstractResourceBundleProvider(String... formats) {
this.formats = formats.clone();          if (this.formats.length == 0) {
throw new IllegalArgumentException("empty formats");
}
for (String f : this.formats) {
if (!FORMAT_CLASS.equals(f) && !FORMAT_PROPERTIES.equals(f)) {
throw new IllegalArgumentException(f);
}
}
}
protected String toBundleName(String baseName, Locale locale) {
return ResourceBundle.Control.getControl(ResourceBundle.Control.FORMAT_DEFAULT)
.toBundleName(baseName, locale);
}
@Override
public ResourceBundle getBundle(String baseName, Locale locale) {
Module module = this.getClass().getModule();
String bundleName = toBundleName(baseName, locale);
var bundle = getBundle0(module, bundleName);
if (bundle == null) {
var otherBundleName = Bundles.toOtherBundleName(baseName, bundleName, locale);
if (!bundleName.equals(otherBundleName)) {
bundle = getBundle0(module, Bundles.toOtherBundleName(baseName, bundleName, locale));
}
}
return bundle;
}
private ResourceBundle getBundle0(Module module, String bundleName) {
ResourceBundle bundle = null;
for (String format : formats) {
try {
if (FORMAT_CLASS.equals(format)) {
bundle = loadResourceBundle(module, bundleName);
} else if (FORMAT_PROPERTIES.equals(format)) {
bundle = loadPropertyResourceBundle(module, bundleName);
}
if (bundle != null) {
break;
}
} catch (IOException e) {
throw new UncheckedIOException(e);
}
}
return bundle;
}
private static ResourceBundle loadResourceBundle(Module module, String bundleName)
{
PrivilegedAction<Class<?>> pa = () -> Class.forName(module, bundleName);
@SuppressWarnings("removal")
Class<?> c = AccessController.doPrivileged(pa, null, GET_CLASSLOADER_PERMISSION);
if (c != null && ResourceBundle.class.isAssignableFrom(c)) {
@SuppressWarnings("unchecked")
Class<ResourceBundle> bundleClass = (Class<ResourceBundle>) c;
return RB_ACCESS.newResourceBundle(bundleClass);
}
return null;
}
private static ResourceBundle loadPropertyResourceBundle(Module module,
String bundleName)
throws IOException
{
String resourceName = toResourceName(bundleName, "properties");
if (resourceName == null) {
return null;
}
PrivilegedAction<InputStream> pa = () -> {
try {
return module.getResourceAsStream(resourceName);
} catch (IOException e) {
throw new UncheckedIOException(e);
}
};
try (@SuppressWarnings("removal") InputStream stream = AccessController.doPrivileged(pa)) {
if (stream != null) {
return new PropertyResourceBundle(stream);
} else {
return null;
}
} catch (UncheckedIOException e) {
throw e.getCause();
}
}
private static String toResourceName(String bundleName, String suffix) {
if (bundleName.contains(":            return null;
}
StringBuilder sb = new StringBuilder(bundleName.length() + 1 + suffix.length());
sb.append(bundleName.replace('.', '/')).append('.').append(suffix);
return sb.toString();
}
}
package jdk.tools.jlink.internal;
import java.util.Objects;
import jdk.tools.jlink.plugin.ResourcePoolEntry;
abstract class AbstractResourcePoolEntry implements ResourcePoolEntry {
private final String path;
private final String module;
private final Type type;
AbstractResourcePoolEntry(String module, String path, Type type) {
this.module = Objects.requireNonNull(module);
this.path = Objects.requireNonNull(path);
this.type = Objects.requireNonNull(type);
}
@Override
public final String moduleName() {
return module;
}
@Override
public final String path() {
return path;
}
@Override
public final Type type() {
return type;
}
@Override
public int hashCode() {
return Objects.hashCode(this.path);
}
@Override
public boolean equals(Object other) {
if (!(other instanceof AbstractResourcePoolEntry)) {
return false;
}
AbstractResourcePoolEntry f = (AbstractResourcePoolEntry) other;
return f.path.equals(path);
}
@Override
public String toString() {
return path();
}
}
package compiler.cha;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import static compiler.cha.Utils.*;
public class AbstractRootMethod {
public static void main(String[] args) {
run(AbstractClass.class);
run(AbstractInterface.class);
if (!jdk.test.whitebox.code.Compiler.isC1Enabled()) {
run(AbstractClass.TestMH.class, AbstractClass.class);
run(AbstractInterface.TestMH.class, AbstractInterface.class);
}
System.out.println("TEST PASSED");
}
public static class AbstractClass extends ATest<AbstractClass.C> {
public AbstractClass() {
super(C.class, D.class);
}
interface I1 { Object m(); }
interface I2 { default Object m() { return "I2.m"; } }
static abstract class C            { public abstract Object m(); }
static abstract class D  extends C {
final Object ret = CORRECT;
public Object m() {
return ret;
}
}
static abstract class E1 extends C {  }
static abstract class E2 extends C { public abstract Object m(); }
static abstract class E3 extends C { public Object m() { return "E3.m"; } }
static abstract class F1 extends C implements I1 { }
static abstract class F2 extends C implements I2 { }
static          class G  extends C { public Object m() { return CORRECT; } }
@Override
public Object test(C obj) {
return obj.m();         }
@Override
public void checkInvalidReceiver() {
}
@TestCase
public void test() {
compile(megamorphic());             assertCompiled();
initialize(E1.class,                         E2.class,                         E3.class,                         F1.class,                         F2.class);             assertCompiled();
load(G.class);
assertCompiled();
initialize(G.class);
assertNotCompiled();
compile(megamorphic());
call(new C() { public Object m() { return CORRECT; } });             call(new G() { public Object m() { return CORRECT; } });             assertCompiled();
}
public static class TestMH extends AbstractClass {
static final MethodHandle TEST_MH = findVirtualHelper(C.class, "m", Object.class, MethodHandles.lookup());
@Override
public Object test(C obj) {
try {
return TEST_MH.invokeExact(obj);                 } catch (Throwable e) {
throw new InternalError(e);
}
}
}
}
public static class AbstractInterface extends ATest<AbstractInterface.C> {
public AbstractInterface() {
super(C.class, D.class);
}
interface I1 { Object m(); }
interface I2 extends I { default Object m() { return "I2.m"; } }
interface I { Object m(); }
static abstract class C implements I { }
static abstract class D  extends C {
final Object ret = CORRECT;
public Object m() {
return ret;
}
}
static abstract class E1 extends C {  }
static abstract class E2 extends C { public abstract Object m(); }
static abstract class E3 extends C { public Object m() { return "E3.m"; } }
static abstract class F1 extends C implements I1 { }
static abstract class F2 extends C implements I2 { }
static          class G  extends C { public Object m() { return CORRECT; } }
@Override
public Object test(C obj) {
return obj.m();         }
@Override
public void checkInvalidReceiver() {
}
@TestCase
public void test() {
compile(megamorphic());             assertCompiled();
initialize(E1.class,                         E2.class,                         E3.class,                         F1.class,                         F2.class);             assertCompiled();
load(G.class);
assertCompiled();
initialize(G.class);
assertNotCompiled();
compile(megamorphic());
call(new C() { public Object m() { return CORRECT; } });             call(new G() { public Object m() { return CORRECT; } });             assertCompiled();
}
public static class TestMH extends AbstractInterface {
static final MethodHandle TEST_MH = findVirtualHelper(C.class, "m", Object.class, MethodHandles.lookup());
@Override
public Object test(C obj) {
try {
return TEST_MH.invokeExact(obj);                 } catch (Throwable e) {
throw new InternalError(e);
}
}
}
}
}
package com.sun.security.sasl.util;
import javax.security.sasl.*;
import java.io.*;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.logging.Logger;
import java.util.logging.Level;
import sun.security.util.HexDumpEncoder;
public abstract class AbstractSaslImpl {
protected boolean completed = false;
protected boolean privacy = false;
protected boolean integrity = false;
protected byte[] qop;               protected byte allQop;              protected byte[] strength;
protected int sendMaxBufSize = 0;         protected int recvMaxBufSize = 65536;     protected int rawSendSize;
protected String myClassName;
protected AbstractSaslImpl(Map<String, ?> props, String className)
throws SaslException {
myClassName = className;
if (props != null) {
String prop;
qop = parseQop(prop=(String)props.get(Sasl.QOP));
logger.logp(Level.FINE, myClassName, "constructor",
"SASLIMPL01:Preferred qop property: {0}", prop);
allQop = combineMasks(qop);
if (logger.isLoggable(Level.FINE)) {
logger.logp(Level.FINE, myClassName, "constructor",
"SASLIMPL02:Preferred qop mask: {0}", allQop);
if (qop.length > 0) {
StringBuilder str = new StringBuilder();
for (int i = 0; i < qop.length; i++) {
str.append(Byte.toString(qop[i]));
str.append(' ');
}
logger.logp(Level.FINE, myClassName, "constructor",
"SASLIMPL03:Preferred qops : {0}", str.toString());
}
}
strength = parseStrength(prop=(String)props.get(Sasl.STRENGTH));
logger.logp(Level.FINE, myClassName, "constructor",
"SASLIMPL04:Preferred strength property: {0}", prop);
if (logger.isLoggable(Level.FINE) && strength.length > 0) {
StringBuilder str = new StringBuilder();
for (int i = 0; i < strength.length; i++) {
str.append(Byte.toString(strength[i]));
str.append(' ');
}
logger.logp(Level.FINE, myClassName, "constructor",
"SASLIMPL05:Cipher strengths: {0}", str.toString());
}
prop = (String)props.get(Sasl.MAX_BUFFER);
if (prop != null) {
try {
logger.logp(Level.FINE, myClassName, "constructor",
"SASLIMPL06:Max receive buffer size: {0}", prop);
recvMaxBufSize = Integer.parseInt(prop);
} catch (NumberFormatException e) {
throw new SaslException(
"Property must be string representation of integer: " +
Sasl.MAX_BUFFER);
}
}
prop = (String)props.get(MAX_SEND_BUF);
if (prop != null) {
try {
logger.logp(Level.FINE, myClassName, "constructor",
"SASLIMPL07:Max send buffer size: {0}", prop);
sendMaxBufSize = Integer.parseInt(prop);
} catch (NumberFormatException e) {
throw new SaslException(
"Property must be string representation of integer: " +
MAX_SEND_BUF);
}
}
} else {
qop = DEFAULT_QOP;
allQop = NO_PROTECTION;
strength = STRENGTH_MASKS;
}
}
public boolean isComplete() {
return completed;
}
public Object getNegotiatedProperty(String propName) {
if (!completed) {
throw new IllegalStateException("SASL authentication not completed");
}
switch (propName) {
case Sasl.QOP:
if (privacy) {
return "auth-conf";
} else if (integrity) {
return "auth-int";
} else {
return "auth";
}
case Sasl.MAX_BUFFER:
return Integer.toString(recvMaxBufSize);
case Sasl.RAW_SEND_SIZE:
return Integer.toString(rawSendSize);
case MAX_SEND_BUF:
return Integer.toString(sendMaxBufSize);
default:
return null;
}
}
protected static final byte combineMasks(byte[] in) {
byte answer = 0;
for (int i = 0; i < in.length; i++) {
answer |= in[i];
}
return answer;
}
protected static final byte findPreferredMask(byte pref, byte[] in) {
for (int i = 0; i < in.length; i++) {
if ((in[i]&pref) != 0) {
return in[i];
}
}
return (byte)0;
}
private static final byte[] parseQop(String qop) throws SaslException {
return parseQop(qop, null, false);
}
protected static final byte[] parseQop(String qop, String[] saveTokens,
boolean ignore) throws SaslException {
if (qop == null) {
return DEFAULT_QOP;           }
return parseProp(Sasl.QOP, qop, QOP_TOKENS, QOP_MASKS, saveTokens, ignore);
}
private static final byte[] parseStrength(String strength)
throws SaslException {
if (strength == null) {
return DEFAULT_STRENGTH;           }
return parseProp(Sasl.STRENGTH, strength, STRENGTH_TOKENS,
STRENGTH_MASKS, null, false);
}
private static final byte[] parseProp(String propName, String propVal,
String[] vals, byte[] masks, String[] tokens, boolean ignore)
throws SaslException {
StringTokenizer parser = new StringTokenizer(propVal, ", \t\n");
String token;
byte[] answer = new byte[vals.length];
int i = 0;
boolean found;
while (parser.hasMoreTokens() && i < answer.length) {
token = parser.nextToken();
found = false;
for (int j = 0; !found && j < vals.length; j++) {
if (token.equalsIgnoreCase(vals[j])) {
found = true;
answer[i++] = masks[j];
if (tokens != null) {
tokens[j] = token;                        }
}
}
if (!found && !ignore) {
throw new SaslException(
"Invalid token in " + propName + ": " + propVal);
}
}
for (int j = i; j < answer.length; j++) {
answer[j] = 0;
}
return answer;
}
protected static final void traceOutput(String srcClass, String srcMethod,
String traceTag, byte[] output) {
traceOutput(srcClass, srcMethod, traceTag, output, 0,
output == null ? 0 : output.length);
}
protected static final void traceOutput(String srcClass, String srcMethod,
String traceTag, byte[] output, int offset, int len) {
try {
int origlen = len;
Level lev;
if (!logger.isLoggable(Level.FINEST)) {
len = Math.min(16, len);
lev = Level.FINER;
} else {
lev = Level.FINEST;
}
String content;
if (output != null) {
ByteArrayOutputStream out = new ByteArrayOutputStream(len);
new HexDumpEncoder().encodeBuffer(
new ByteArrayInputStream(output, offset, len), out);
content = out.toString();
} else {
content = "NULL";
}
logger.logp(lev, srcClass, srcMethod, "{0} ( {1} ): {2}",
new Object[] {traceTag, origlen, content});
} catch (Exception e) {
logger.logp(Level.WARNING, srcClass, srcMethod,
"SASLIMPL09:Error generating trace output: {0}", e);
}
}
protected static final int networkByteOrderToInt(byte[] buf, int start,
int count) {
if (count > 4) {
throw new IllegalArgumentException("Cannot handle more than 4 bytes");
}
int answer = 0;
for (int i = 0; i < count; i++) {
answer <<= 8;
answer |= ((int)buf[start+i] & 0xff);
}
return answer;
}
protected static final void intToNetworkByteOrder(int num, byte[] buf,
int start, int count) {
if (count > 4) {
throw new IllegalArgumentException("Cannot handle more than 4 bytes");
}
for (int i = count-1; i >= 0; i--) {
buf[start+i] = (byte)(num & 0xff);
num >>>= 8;
}
}
private static final String SASL_LOGGER_NAME = "javax.security.sasl";
protected static final String MAX_SEND_BUF = "javax.security.sasl.sendmaxbuffer";
protected static final Logger logger = Logger.getLogger(SASL_LOGGER_NAME);
protected static final byte NO_PROTECTION = (byte)1;
protected static final byte INTEGRITY_ONLY_PROTECTION = (byte)2;
protected static final byte PRIVACY_PROTECTION = (byte)4;
protected static final byte LOW_STRENGTH = (byte)1;
protected static final byte MEDIUM_STRENGTH = (byte)2;
protected static final byte HIGH_STRENGTH = (byte)4;
private static final byte[] DEFAULT_QOP = new byte[]{NO_PROTECTION};
private static final String[] QOP_TOKENS = {"auth-conf",
"auth-int",
"auth"};
private static final byte[] QOP_MASKS = {PRIVACY_PROTECTION,
INTEGRITY_ONLY_PROTECTION,
NO_PROTECTION};
private static final byte[] DEFAULT_STRENGTH = new byte[]{
HIGH_STRENGTH, MEDIUM_STRENGTH, LOW_STRENGTH};
private static final String[] STRENGTH_TOKENS = {"low",
"medium",
"high"};
private static final byte[] STRENGTH_MASKS = {LOW_STRENGTH,
MEDIUM_STRENGTH,
HIGH_STRENGTH};
}
package com.sun.org.apache.xerces.internal.parsers;
import com.sun.org.apache.xerces.internal.impl.Constants;
import com.sun.org.apache.xerces.internal.util.EntityResolver2Wrapper;
import com.sun.org.apache.xerces.internal.util.EntityResolverWrapper;
import com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper;
import com.sun.org.apache.xerces.internal.util.SAXMessageFormatter;
import com.sun.org.apache.xerces.internal.util.Status;
import com.sun.org.apache.xerces.internal.util.SymbolHash;
import com.sun.org.apache.xerces.internal.util.XMLSymbols;
import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;
import com.sun.org.apache.xerces.internal.xni.Augmentations;
import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
import com.sun.org.apache.xerces.internal.xni.QName;
import com.sun.org.apache.xerces.internal.xni.XMLAttributes;
import com.sun.org.apache.xerces.internal.xni.XMLLocator;
import com.sun.org.apache.xerces.internal.xni.XMLResourceIdentifier;
import com.sun.org.apache.xerces.internal.xni.XMLString;
import com.sun.org.apache.xerces.internal.xni.XNIException;
import com.sun.org.apache.xerces.internal.xni.parser.XMLConfigurationException;
import com.sun.org.apache.xerces.internal.xni.parser.XMLEntityResolver;
import com.sun.org.apache.xerces.internal.xni.parser.XMLErrorHandler;
import com.sun.org.apache.xerces.internal.xni.parser.XMLInputSource;
import com.sun.org.apache.xerces.internal.xni.parser.XMLParseException;
import com.sun.org.apache.xerces.internal.xni.parser.XMLParserConfiguration;
import com.sun.org.apache.xerces.internal.xs.AttributePSVI;
import com.sun.org.apache.xerces.internal.xs.ElementPSVI;
import com.sun.org.apache.xerces.internal.xs.PSVIProvider;
import java.io.CharConversionException;
import java.io.IOException;
import java.util.Locale;
import javax.xml.XMLConstants;
import org.xml.sax.AttributeList;
import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.DocumentHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.Parser;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXParseException;
import org.xml.sax.XMLReader;
import org.xml.sax.ext.Attributes2;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.ext.EntityResolver2;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.ext.Locator2;
import org.xml.sax.helpers.LocatorImpl;
@SuppressWarnings("deprecation")
public abstract class AbstractSAXParser
extends AbstractXMLDocumentParser
implements PSVIProvider,               Parser, XMLReader {
protected static final String NAMESPACES =
Constants.SAX_FEATURE_PREFIX + Constants.NAMESPACES_FEATURE;
protected static final String NAMESPACE_PREFIXES =
Constants.SAX_FEATURE_PREFIX + Constants.NAMESPACE_PREFIXES_FEATURE;
protected static final String STRING_INTERNING =
Constants.SAX_FEATURE_PREFIX + Constants.STRING_INTERNING_FEATURE;
protected static final String ALLOW_UE_AND_NOTATION_EVENTS =
Constants.SAX_FEATURE_PREFIX + Constants.ALLOW_DTD_EVENTS_AFTER_ENDDTD_FEATURE;
private static final String[] RECOGNIZED_FEATURES = {
NAMESPACES,
NAMESPACE_PREFIXES,
STRING_INTERNING,
};
protected static final String LEXICAL_HANDLER =
Constants.SAX_PROPERTY_PREFIX + Constants.LEXICAL_HANDLER_PROPERTY;
protected static final String DECLARATION_HANDLER =
Constants.SAX_PROPERTY_PREFIX + Constants.DECLARATION_HANDLER_PROPERTY;
protected static final String DOM_NODE =
Constants.SAX_PROPERTY_PREFIX + Constants.DOM_NODE_PROPERTY;
private static final String SECURITY_MANAGER =
Constants.XERCES_PROPERTY_PREFIX + Constants.SECURITY_MANAGER_PROPERTY;
private static final String[] RECOGNIZED_PROPERTIES = {
LEXICAL_HANDLER,
DECLARATION_HANDLER,
DOM_NODE,
};
protected boolean fNamespaces;
protected boolean fNamespacePrefixes = false;
protected boolean fLexicalHandlerParameterEntities = true;
protected boolean fStandalone;
protected boolean fResolveDTDURIs = true;
protected boolean fUseEntityResolver2 = true;
protected boolean fXMLNSURIs = false;
protected ContentHandler fContentHandler;
protected DocumentHandler fDocumentHandler;
protected NamespaceContext fNamespaceContext;
protected org.xml.sax.DTDHandler fDTDHandler;
protected DeclHandler fDeclHandler;
protected LexicalHandler fLexicalHandler;
protected QName fQName = new QName();
protected boolean fParseInProgress = false;
protected String fVersion;
private final AttributesProxy fAttributesProxy = new AttributesProxy();
private Augmentations fAugmentations = null;
private static final int BUFFER_SIZE = 20;
private char[] fCharBuffer =  new char[BUFFER_SIZE];
protected SymbolHash fDeclaredAttrs = null;
protected AbstractSAXParser(XMLParserConfiguration config) {
super(config);
config.addRecognizedFeatures(RECOGNIZED_FEATURES);
config.addRecognizedProperties(RECOGNIZED_PROPERTIES);
try {
config.setFeature(ALLOW_UE_AND_NOTATION_EVENTS, false);
}
catch (XMLConfigurationException e) {
}
}
public void startDocument(XMLLocator locator, String encoding,
NamespaceContext namespaceContext, Augmentations augs)
throws XNIException {
fNamespaceContext = namespaceContext;
try {
if (fDocumentHandler != null) {
if (locator != null) {
fDocumentHandler.setDocumentLocator(new LocatorProxy(locator));
}
fDocumentHandler.startDocument();
}
if (fContentHandler != null) {
if (locator != null) {
fContentHandler.setDocumentLocator(new LocatorProxy(locator));
}
fContentHandler.startDocument();
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void xmlDecl(String version, String encoding, String standalone, Augmentations augs)
throws XNIException {
fVersion = version;
fStandalone = "yes".equals(standalone);
if (fContentHandler != null) {
try {
fContentHandler.declaration(version, encoding, standalone);
} catch (SAXException e) {
throw new XNIException(e);
}
}
}
public void doctypeDecl(String rootElement,
String publicId, String systemId, Augmentations augs)
throws XNIException {
fInDTD = true;
try {
if (fLexicalHandler != null) {
fLexicalHandler.startDTD(rootElement, publicId, systemId);
}
}
catch (SAXException e) {
throw new XNIException(e);
}
if(fDeclHandler != null) {
fDeclaredAttrs = new SymbolHash();
}
}
public void startGeneralEntity(String name, XMLResourceIdentifier identifier,
String encoding, Augmentations augs)
throws XNIException {
try {
if (augs != null && Boolean.TRUE.equals(augs.getItem(Constants.ENTITY_SKIPPED))) {
if (fContentHandler != null) {
fContentHandler.skippedEntity(name);
}
}
else {
if (fLexicalHandler != null) {
fLexicalHandler.startEntity(name);
}
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void endGeneralEntity(String name, Augmentations augs) throws XNIException {
try {
if (augs == null || !Boolean.TRUE.equals(augs.getItem(Constants.ENTITY_SKIPPED))) {
if (fLexicalHandler != null) {
fLexicalHandler.endEntity(name);
}
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void startElement(QName element, XMLAttributes attributes, Augmentations augs)
throws XNIException {
try {
if (fDocumentHandler != null) {
fAttributesProxy.setAttributes(attributes);
fDocumentHandler.startElement(element.rawname, fAttributesProxy);
}
if (fContentHandler != null) {
if (fNamespaces) {
startNamespaceMapping();
int len = attributes.getLength();
if (!fNamespacePrefixes) {
for (int i = len - 1; i >= 0; --i) {
attributes.getName(i, fQName);
if ((fQName.prefix == XMLSymbols.PREFIX_XMLNS) ||
(fQName.rawname == XMLSymbols.PREFIX_XMLNS)) {
attributes.removeAttributeAt(i);
}
}
}
else if (!fXMLNSURIs) {
for (int i = len - 1; i >= 0; --i) {
attributes.getName(i, fQName);
if ((fQName.prefix == XMLSymbols.PREFIX_XMLNS) ||
(fQName.rawname == XMLSymbols.PREFIX_XMLNS)) {
fQName.prefix = "";
fQName.uri = "";
fQName.localpart = "";
attributes.setName(i, fQName);
}
}
}
}
fAugmentations = augs;
String uri = element.uri != null ? element.uri : "";
String localpart = fNamespaces ? element.localpart : "";
fAttributesProxy.setAttributes(attributes);
fContentHandler.startElement(uri, localpart, element.rawname,
fAttributesProxy);
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void characters(XMLString text, Augmentations augs) throws XNIException {
if (text.length == 0) {
return;
}
try {
if (fDocumentHandler != null) {
fDocumentHandler.characters(text.ch, text.offset, text.length);
}
if (fContentHandler != null) {
fContentHandler.characters(text.ch, text.offset, text.length);
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void ignorableWhitespace(XMLString text, Augmentations augs) throws XNIException {
try {
if (fDocumentHandler != null) {
fDocumentHandler.ignorableWhitespace(text.ch, text.offset, text.length);
}
if (fContentHandler != null) {
fContentHandler.ignorableWhitespace(text.ch, text.offset, text.length);
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void endElement(QName element, Augmentations augs) throws XNIException {
try {
if (fDocumentHandler != null) {
fDocumentHandler.endElement(element.rawname);
}
if (fContentHandler != null) {
fAugmentations = augs;
String uri = element.uri != null ? element.uri : "";
String localpart = fNamespaces ? element.localpart : "";
fContentHandler.endElement(uri, localpart,
element.rawname);
if (fNamespaces) {
endNamespaceMapping();
}
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void startCDATA(Augmentations augs) throws XNIException {
try {
if (fLexicalHandler != null) {
fLexicalHandler.startCDATA();
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void endCDATA(Augmentations augs) throws XNIException {
try {
if (fLexicalHandler != null) {
fLexicalHandler.endCDATA();
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void comment(XMLString text, Augmentations augs) throws XNIException {
try {
if (fLexicalHandler != null) {
fLexicalHandler.comment(text.ch, 0, text.length);
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void processingInstruction(String target, XMLString data, Augmentations augs)
throws XNIException {
try {
if (fDocumentHandler != null) {
fDocumentHandler.processingInstruction(target,
data.toString());
}
if (fContentHandler != null) {
fContentHandler.processingInstruction(target, data.toString());
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void endDocument(Augmentations augs) throws XNIException {
try {
if (fDocumentHandler != null) {
fDocumentHandler.endDocument();
}
if (fContentHandler != null) {
fContentHandler.endDocument();
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void startExternalSubset(XMLResourceIdentifier identifier,
Augmentations augs) throws XNIException {
startParameterEntity("[dtd]", null, null, augs);
}
public void endExternalSubset(Augmentations augs) throws XNIException {
endParameterEntity("[dtd]", augs);
}
public void startParameterEntity(String name,
XMLResourceIdentifier identifier,
String encoding, Augmentations augs)
throws XNIException {
try {
if (augs != null && Boolean.TRUE.equals(augs.getItem(Constants.ENTITY_SKIPPED))) {
if (fContentHandler != null) {
fContentHandler.skippedEntity(name);
}
}
else {
if (fLexicalHandler != null && fLexicalHandlerParameterEntities) {
fLexicalHandler.startEntity(name);
}
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void endParameterEntity(String name, Augmentations augs) throws XNIException {
try {
if (augs == null || !Boolean.TRUE.equals(augs.getItem(Constants.ENTITY_SKIPPED))) {
if (fLexicalHandler != null && fLexicalHandlerParameterEntities) {
fLexicalHandler.endEntity(name);
}
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void elementDecl(String name, String contentModel, Augmentations augs)
throws XNIException {
try {
if (fDeclHandler != null) {
fDeclHandler.elementDecl(name, contentModel);
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void attributeDecl(String elementName, String attributeName,
String type, String[] enumeration,
String defaultType, XMLString defaultValue,
XMLString nonNormalizedDefaultValue, Augmentations augs) throws XNIException {
try {
if (fDeclHandler != null) {
String elemAttr = new StringBuffer(elementName).append("<").append(attributeName).toString();
if(fDeclaredAttrs.get(elemAttr) != null) {
return;
}
fDeclaredAttrs.put(elemAttr, Boolean.TRUE);
if (type.equals("NOTATION") ||
type.equals("ENUMERATION")) {
StringBuffer str = new StringBuffer();
if (type.equals("NOTATION")) {
str.append(type);
str.append(" (");
}
else {
str.append("(");
}
for (int i = 0; i < enumeration.length; i++) {
str.append(enumeration[i]);
if (i < enumeration.length - 1) {
str.append('|');
}
}
str.append(')');
type = str.toString();
}
String value = (defaultValue==null) ? null : defaultValue.toString();
fDeclHandler.attributeDecl(elementName, attributeName,
type, defaultType, value);
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void internalEntityDecl(String name, XMLString text,
XMLString nonNormalizedText,
Augmentations augs) throws XNIException {
try {
if (fDeclHandler != null) {
fDeclHandler.internalEntityDecl(name, text.toString());
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void externalEntityDecl(String name, XMLResourceIdentifier identifier,
Augmentations augs) throws XNIException {
try {
if (fDeclHandler != null) {
String publicId = identifier.getPublicId();
String systemId = fResolveDTDURIs ?
identifier.getExpandedSystemId() : identifier.getLiteralSystemId();
fDeclHandler.externalEntityDecl(name, publicId, systemId);
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void unparsedEntityDecl(String name, XMLResourceIdentifier identifier,
String notation,
Augmentations augs) throws XNIException {
try {
if (fDTDHandler != null) {
String publicId = identifier.getPublicId();
String systemId = fResolveDTDURIs ?
identifier.getExpandedSystemId() : identifier.getLiteralSystemId();
fDTDHandler.unparsedEntityDecl(name, publicId, systemId, notation);
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void notationDecl(String name, XMLResourceIdentifier identifier,
Augmentations augs) throws XNIException {
try {
if (fDTDHandler != null) {
String publicId = identifier.getPublicId();
String systemId = fResolveDTDURIs ?
identifier.getExpandedSystemId() : identifier.getLiteralSystemId();
fDTDHandler.notationDecl(name, publicId, systemId);
}
}
catch (SAXException e) {
throw new XNIException(e);
}
}
public void endDTD(Augmentations augs) throws XNIException {
fInDTD = false;
try {
if (fLexicalHandler != null) {
fLexicalHandler.endDTD();
}
}
catch (SAXException e) {
throw new XNIException(e);
}
if(fDeclaredAttrs != null) {
fDeclaredAttrs.clear();
}
}
public void parse(String systemId) throws SAXException, IOException {
XMLInputSource source = new XMLInputSource(null, systemId, null, false);
try {
parse(source);
}
catch (XMLParseException e) {
Exception ex = e.getException();
if (ex == null || ex instanceof CharConversionException) {
LocatorImpl locatorImpl = new LocatorImpl(){
public String getXMLVersion() {
return fVersion;
}
public String getEncoding() {
return null;
}
};
locatorImpl.setPublicId(e.getPublicId());
locatorImpl.setSystemId(e.getExpandedSystemId());
locatorImpl.setLineNumber(e.getLineNumber());
locatorImpl.setColumnNumber(e.getColumnNumber());
throw (ex == null) ?
new SAXParseException(e.getMessage(), locatorImpl) :
new SAXParseException(e.getMessage(), locatorImpl, ex);
}
if (ex instanceof SAXException) {
throw (SAXException)ex;
}
if (ex instanceof IOException) {
throw (IOException)ex;
}
throw new SAXException(ex);
}
catch (XNIException e) {
Exception ex = e.getException();
if (ex == null) {
throw new SAXException(e.getMessage());
}
if (ex instanceof SAXException) {
throw (SAXException)ex;
}
if (ex instanceof IOException) {
throw (IOException)ex;
}
throw new SAXException(ex);
}
}
public void parse(InputSource inputSource)
throws SAXException, IOException {
try {
XMLInputSource xmlInputSource =
new XMLInputSource(inputSource.getPublicId(),
inputSource.getSystemId(),
null, false);
xmlInputSource.setByteStream(inputSource.getByteStream());
xmlInputSource.setCharacterStream(inputSource.getCharacterStream());
xmlInputSource.setEncoding(inputSource.getEncoding());
parse(xmlInputSource);
}
catch (XMLParseException e) {
Exception ex = e.getException();
if (ex == null || ex instanceof CharConversionException) {
LocatorImpl locatorImpl = new LocatorImpl() {
public String getXMLVersion() {
return fVersion;
}
public String getEncoding() {
return null;
}
};
locatorImpl.setPublicId(e.getPublicId());
locatorImpl.setSystemId(e.getExpandedSystemId());
locatorImpl.setLineNumber(e.getLineNumber());
locatorImpl.setColumnNumber(e.getColumnNumber());
throw (ex == null) ?
new SAXParseException(e.getMessage(), locatorImpl) :
new SAXParseException(e.getMessage(), locatorImpl, ex);
}
if (ex instanceof SAXException) {
throw (SAXException)ex;
}
if (ex instanceof IOException) {
throw (IOException)ex;
}
throw new SAXException(ex);
}
catch (XNIException e) {
Exception ex = e.getException();
if (ex == null) {
throw new SAXException(e.getMessage());
}
if (ex instanceof SAXException) {
throw (SAXException)ex;
}
if (ex instanceof IOException) {
throw (IOException)ex;
}
throw new SAXException(ex);
}
}
public void setEntityResolver(EntityResolver resolver) {
try {
XMLEntityResolver xer = (XMLEntityResolver) fConfiguration.getProperty(ENTITY_RESOLVER);
if (fUseEntityResolver2 && resolver instanceof EntityResolver2) {
if (xer instanceof EntityResolver2Wrapper) {
EntityResolver2Wrapper er2w = (EntityResolver2Wrapper) xer;
er2w.setEntityResolver((EntityResolver2) resolver);
}
else {
fConfiguration.setProperty(ENTITY_RESOLVER,
new EntityResolver2Wrapper((EntityResolver2) resolver));
}
}
else {
if (xer instanceof EntityResolverWrapper) {
EntityResolverWrapper erw = (EntityResolverWrapper) xer;
erw.setEntityResolver(resolver);
}
else {
fConfiguration.setProperty(ENTITY_RESOLVER,
new EntityResolverWrapper(resolver));
}
}
}
catch (XMLConfigurationException e) {
}
}
public EntityResolver getEntityResolver() {
EntityResolver entityResolver = null;
try {
XMLEntityResolver xmlEntityResolver =
(XMLEntityResolver)fConfiguration.getProperty(ENTITY_RESOLVER);
if (xmlEntityResolver != null) {
if (xmlEntityResolver instanceof EntityResolverWrapper) {
entityResolver =
((EntityResolverWrapper) xmlEntityResolver).getEntityResolver();
}
else if (xmlEntityResolver instanceof EntityResolver2Wrapper) {
entityResolver =
((EntityResolver2Wrapper) xmlEntityResolver).getEntityResolver();
}
}
}
catch (XMLConfigurationException e) {
}
return entityResolver;
}
public void setErrorHandler(ErrorHandler errorHandler) {
try {
XMLErrorHandler xeh = (XMLErrorHandler) fConfiguration.getProperty(ERROR_HANDLER);
if (xeh instanceof ErrorHandlerWrapper) {
ErrorHandlerWrapper ehw = (ErrorHandlerWrapper) xeh;
ehw.setErrorHandler(errorHandler);
}
else {
fConfiguration.setProperty(ERROR_HANDLER,
new ErrorHandlerWrapper(errorHandler));
}
}
catch (XMLConfigurationException e) {
}
}
public ErrorHandler getErrorHandler() {
ErrorHandler errorHandler = null;
try {
XMLErrorHandler xmlErrorHandler =
(XMLErrorHandler)fConfiguration.getProperty(ERROR_HANDLER);
if (xmlErrorHandler != null &&
xmlErrorHandler instanceof ErrorHandlerWrapper) {
errorHandler = ((ErrorHandlerWrapper)xmlErrorHandler).getErrorHandler();
}
}
catch (XMLConfigurationException e) {
}
return errorHandler;
}
public void setLocale(Locale locale) throws SAXException {
fConfiguration.setLocale(locale);
}
public void setDTDHandler(DTDHandler dtdHandler) {
fDTDHandler = dtdHandler;
}
public void setDocumentHandler(DocumentHandler documentHandler) {
fDocumentHandler = documentHandler;
}
public void setContentHandler(ContentHandler contentHandler) {
fContentHandler = contentHandler;
}
public ContentHandler getContentHandler() {
return fContentHandler;
}
public DTDHandler getDTDHandler() {
return fDTDHandler;
}
public void setFeature(String featureId, boolean state)
throws SAXNotRecognizedException, SAXNotSupportedException {
try {
if (featureId.startsWith(Constants.SAX_FEATURE_PREFIX)) {
final int suffixLength = featureId.length() - Constants.SAX_FEATURE_PREFIX.length();
if (suffixLength == Constants.NAMESPACES_FEATURE.length() &&
featureId.endsWith(Constants.NAMESPACES_FEATURE)) {
fConfiguration.setFeature(featureId, state);
fNamespaces = state;
return;
}
if (suffixLength == Constants.NAMESPACE_PREFIXES_FEATURE.length() &&
featureId.endsWith(Constants.NAMESPACE_PREFIXES_FEATURE)) {
fConfiguration.setFeature(featureId, state);
fNamespacePrefixes = state;
return;
}
if (suffixLength == Constants.STRING_INTERNING_FEATURE.length() &&
featureId.endsWith(Constants.STRING_INTERNING_FEATURE)) {
if (!state) {
throw new SAXNotSupportedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"false-not-supported", new Object [] {featureId}));
}
return;
}
if (suffixLength == Constants.LEXICAL_HANDLER_PARAMETER_ENTITIES_FEATURE.length() &&
featureId.endsWith(Constants.LEXICAL_HANDLER_PARAMETER_ENTITIES_FEATURE)) {
fLexicalHandlerParameterEntities = state;
return;
}
if (suffixLength == Constants.RESOLVE_DTD_URIS_FEATURE.length() &&
featureId.endsWith(Constants.RESOLVE_DTD_URIS_FEATURE)) {
fResolveDTDURIs = state;
return;
}
if (suffixLength == Constants.UNICODE_NORMALIZATION_CHECKING_FEATURE.length() &&
featureId.endsWith(Constants.UNICODE_NORMALIZATION_CHECKING_FEATURE)) {
if (state) {
throw new SAXNotSupportedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"true-not-supported", new Object [] {featureId}));
}
return;
}
if (suffixLength == Constants.XMLNS_URIS_FEATURE.length() &&
featureId.endsWith(Constants.XMLNS_URIS_FEATURE)) {
fXMLNSURIs = state;
return;
}
if (suffixLength == Constants.USE_ENTITY_RESOLVER2_FEATURE.length() &&
featureId.endsWith(Constants.USE_ENTITY_RESOLVER2_FEATURE)) {
if (state != fUseEntityResolver2) {
fUseEntityResolver2 = state;
setEntityResolver(getEntityResolver());
}
return;
}
if ((suffixLength == Constants.IS_STANDALONE_FEATURE.length() &&
featureId.endsWith(Constants.IS_STANDALONE_FEATURE)) ||
(suffixLength == Constants.USE_ATTRIBUTES2_FEATURE.length() &&
featureId.endsWith(Constants.USE_ATTRIBUTES2_FEATURE)) ||
(suffixLength == Constants.USE_LOCATOR2_FEATURE.length() &&
featureId.endsWith(Constants.USE_LOCATOR2_FEATURE)) ||
(suffixLength == Constants.XML_11_FEATURE.length() &&
featureId.endsWith(Constants.XML_11_FEATURE))) {
throw new SAXNotSupportedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"feature-read-only", new Object [] {featureId}));
}
}
else if (featureId.equals(XMLConstants.FEATURE_SECURE_PROCESSING)) {
if (state) {
if (fConfiguration.getProperty(SECURITY_MANAGER )==null) {
fConfiguration.setProperty(SECURITY_MANAGER, new XMLSecurityManager());
}
}
}
fConfiguration.setFeature(featureId, state);
}
catch (XMLConfigurationException e) {
String identifier = e.getIdentifier();
if (e.getType() == Status.NOT_RECOGNIZED) {
throw new SAXNotRecognizedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"feature-not-recognized", new Object [] {identifier}));
}
else {
throw new SAXNotSupportedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"feature-not-supported", new Object [] {identifier}));
}
}
}
public boolean getFeature(String featureId)
throws SAXNotRecognizedException, SAXNotSupportedException {
try {
if (featureId.startsWith(Constants.SAX_FEATURE_PREFIX)) {
final int suffixLength = featureId.length() - Constants.SAX_FEATURE_PREFIX.length();
if (suffixLength == Constants.NAMESPACE_PREFIXES_FEATURE.length() &&
featureId.endsWith(Constants.NAMESPACE_PREFIXES_FEATURE)) {
boolean state = fConfiguration.getFeature(featureId);
return state;
}
if (suffixLength == Constants.STRING_INTERNING_FEATURE.length() &&
featureId.endsWith(Constants.STRING_INTERNING_FEATURE)) {
return true;
}
if (suffixLength == Constants.IS_STANDALONE_FEATURE.length() &&
featureId.endsWith(Constants.IS_STANDALONE_FEATURE)) {
return fStandalone;
}
if (suffixLength == Constants.XML_11_FEATURE.length() &&
featureId.endsWith(Constants.XML_11_FEATURE)) {
return (fConfiguration instanceof XML11Configurable);
}
if (suffixLength == Constants.LEXICAL_HANDLER_PARAMETER_ENTITIES_FEATURE.length() &&
featureId.endsWith(Constants.LEXICAL_HANDLER_PARAMETER_ENTITIES_FEATURE)) {
return fLexicalHandlerParameterEntities;
}
if (suffixLength == Constants.RESOLVE_DTD_URIS_FEATURE.length() &&
featureId.endsWith(Constants.RESOLVE_DTD_URIS_FEATURE)) {
return fResolveDTDURIs;
}
if (suffixLength == Constants.XMLNS_URIS_FEATURE.length() &&
featureId.endsWith(Constants.XMLNS_URIS_FEATURE)) {
return fXMLNSURIs;
}
if (suffixLength == Constants.UNICODE_NORMALIZATION_CHECKING_FEATURE.length() &&
featureId.endsWith(Constants.UNICODE_NORMALIZATION_CHECKING_FEATURE)) {
return false;
}
if (suffixLength == Constants.USE_ENTITY_RESOLVER2_FEATURE.length() &&
featureId.endsWith(Constants.USE_ENTITY_RESOLVER2_FEATURE)) {
return fUseEntityResolver2;
}
if ((suffixLength == Constants.USE_ATTRIBUTES2_FEATURE.length() &&
featureId.endsWith(Constants.USE_ATTRIBUTES2_FEATURE)) ||
(suffixLength == Constants.USE_LOCATOR2_FEATURE.length() &&
featureId.endsWith(Constants.USE_LOCATOR2_FEATURE))) {
return true;
}
}
return fConfiguration.getFeature(featureId);
}
catch (XMLConfigurationException e) {
String identifier = e.getIdentifier();
if (e.getType() == Status.NOT_RECOGNIZED) {
throw new SAXNotRecognizedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"feature-not-recognized", new Object [] {identifier}));
}
else {
throw new SAXNotSupportedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"feature-not-supported", new Object [] {identifier}));
}
}
}
public void setProperty(String propertyId, Object value)
throws SAXNotRecognizedException, SAXNotSupportedException {
try {
if (propertyId.startsWith(Constants.SAX_PROPERTY_PREFIX)) {
final int suffixLength = propertyId.length() - Constants.SAX_PROPERTY_PREFIX.length();
if (suffixLength == Constants.LEXICAL_HANDLER_PROPERTY.length() &&
propertyId.endsWith(Constants.LEXICAL_HANDLER_PROPERTY)) {
try {
setLexicalHandler((LexicalHandler)value);
}
catch (ClassCastException e) {
throw new SAXNotSupportedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"incompatible-class", new Object [] {propertyId, "org.xml.sax.ext.LexicalHandler"}));
}
return;
}
if (suffixLength == Constants.DECLARATION_HANDLER_PROPERTY.length() &&
propertyId.endsWith(Constants.DECLARATION_HANDLER_PROPERTY)) {
try {
setDeclHandler((DeclHandler)value);
}
catch (ClassCastException e) {
throw new SAXNotSupportedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"incompatible-class", new Object [] {propertyId, "org.xml.sax.ext.DeclHandler"}));
}
return;
}
if ((suffixLength == Constants.DOM_NODE_PROPERTY.length() &&
propertyId.endsWith(Constants.DOM_NODE_PROPERTY)) ||
(suffixLength == Constants.DOCUMENT_XML_VERSION_PROPERTY.length() &&
propertyId.endsWith(Constants.DOCUMENT_XML_VERSION_PROPERTY))) {
throw new SAXNotSupportedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"property-read-only", new Object [] {propertyId}));
}
}
fConfiguration.setProperty(propertyId, value);
}
catch (XMLConfigurationException e) {
String identifier = e.getIdentifier();
if (e.getType() == Status.NOT_RECOGNIZED) {
throw new SAXNotRecognizedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"property-not-recognized", new Object [] {identifier}));
}
else {
throw new SAXNotSupportedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"property-not-supported", new Object [] {identifier}));
}
}
}
public Object getProperty(String propertyId)
throws SAXNotRecognizedException, SAXNotSupportedException {
try {
if (propertyId.startsWith(Constants.SAX_PROPERTY_PREFIX)) {
final int suffixLength = propertyId.length() - Constants.SAX_PROPERTY_PREFIX.length();
if (suffixLength == Constants.DOCUMENT_XML_VERSION_PROPERTY.length() &&
propertyId.endsWith(Constants.DOCUMENT_XML_VERSION_PROPERTY)) {
return fVersion;
}
if (suffixLength == Constants.LEXICAL_HANDLER_PROPERTY.length() &&
propertyId.endsWith(Constants.LEXICAL_HANDLER_PROPERTY)) {
return getLexicalHandler();
}
if (suffixLength == Constants.DECLARATION_HANDLER_PROPERTY.length() &&
propertyId.endsWith(Constants.DECLARATION_HANDLER_PROPERTY)) {
return getDeclHandler();
}
if (suffixLength == Constants.DOM_NODE_PROPERTY.length() &&
propertyId.endsWith(Constants.DOM_NODE_PROPERTY)) {
throw new SAXNotSupportedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"dom-node-read-not-supported", null));
}
}
return fConfiguration.getProperty(propertyId);
}
catch (XMLConfigurationException e) {
String identifier = e.getIdentifier();
if (e.getType() == Status.NOT_RECOGNIZED) {
throw new SAXNotRecognizedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"property-not-recognized", new Object [] {identifier}));
}
else {
throw new SAXNotSupportedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"property-not-supported", new Object [] {identifier}));
}
}
}
protected void setDeclHandler(DeclHandler handler)
throws SAXNotRecognizedException, SAXNotSupportedException {
if (fParseInProgress) {
throw new SAXNotSupportedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"property-not-parsing-supported",
new Object [] {"http:        }
fDeclHandler = handler;
}
protected DeclHandler getDeclHandler()
throws SAXNotRecognizedException, SAXNotSupportedException {
return fDeclHandler;
}
protected void setLexicalHandler(LexicalHandler handler)
throws SAXNotRecognizedException, SAXNotSupportedException {
if (fParseInProgress) {
throw new SAXNotSupportedException(
SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),
"property-not-parsing-supported",
new Object [] {"http:        }
fLexicalHandler = handler;
}
protected LexicalHandler getLexicalHandler()
throws SAXNotRecognizedException, SAXNotSupportedException {
return fLexicalHandler;
}
protected final void startNamespaceMapping() throws SAXException{
int count = fNamespaceContext.getDeclaredPrefixCount();
if (count > 0) {
String prefix = null;
String uri = null;
for (int i = 0; i < count; i++) {
prefix = fNamespaceContext.getDeclaredPrefixAt(i);
uri = fNamespaceContext.getURI(prefix);
fContentHandler.startPrefixMapping(prefix,
(uri == null) ? "" : uri);
}
}
}
protected final void endNamespaceMapping() throws SAXException {
int count = fNamespaceContext.getDeclaredPrefixCount();
if (count > 0) {
for (int i = 0; i < count; i++) {
fContentHandler.endPrefixMapping(fNamespaceContext.getDeclaredPrefixAt(i));
}
}
}
public void reset() throws XNIException {
super.reset();
fInDTD = false;
fVersion = "1.0";
fStandalone = false;
fNamespaces = fConfiguration.getFeature(NAMESPACES);
fNamespacePrefixes = fConfiguration.getFeature(NAMESPACE_PREFIXES);
fAugmentations = null;
fDeclaredAttrs = null;
}
protected class LocatorProxy
implements Locator2 {
protected XMLLocator fLocator;
public LocatorProxy(XMLLocator locator) {
fLocator = locator;
}
public String getPublicId() {
return fLocator.getPublicId();
}
public String getSystemId() {
return fLocator.getExpandedSystemId();
}
public int getLineNumber() {
return fLocator.getLineNumber();
}
public int getColumnNumber() {
return fLocator.getColumnNumber();
}
public String getXMLVersion() {
return fLocator.getXMLVersion();
}
public String getEncoding() {
return fLocator.getEncoding();
}
}
protected static final class AttributesProxy
implements AttributeList, Attributes2 {
protected XMLAttributes fAttributes;
public void setAttributes(XMLAttributes attributes) {
fAttributes = attributes;
}
public int getLength() {
return fAttributes.getLength();
}
public String getName(int i) {
return fAttributes.getQName(i);
}
public String getQName(int index) {
return fAttributes.getQName(index);
}
public String getURI(int index) {
String uri= fAttributes.getURI(index);
return uri != null ? uri : "";
}
public String getLocalName(int index) {
return fAttributes.getLocalName(index);
}
public String getType(int i) {
return fAttributes.getType(i);
}
public String getType(String name) {
return fAttributes.getType(name);
}
public String getType(String uri, String localName) {
return uri.equals("") ? fAttributes.getType(null, localName) :
fAttributes.getType(uri, localName);
}
public String getValue(int i) {
return fAttributes.getValue(i);
}
public String getValue(String name) {
return fAttributes.getValue(name);
}
public String getValue(String uri, String localName) {
return uri.equals("") ? fAttributes.getValue(null, localName) :
fAttributes.getValue(uri, localName);
}
public int getIndex(String qName) {
return fAttributes.getIndex(qName);
}
public int getIndex(String uri, String localPart) {
return uri.equals("") ? fAttributes.getIndex(null, localPart) :
fAttributes.getIndex(uri, localPart);
}
public boolean isDeclared(int index) {
if (index < 0 || index >= fAttributes.getLength()) {
throw new ArrayIndexOutOfBoundsException(index);
}
return Boolean.TRUE.equals(
fAttributes.getAugmentations(index).getItem(
Constants.ATTRIBUTE_DECLARED));
}
public boolean isDeclared(String qName) {
int index = getIndex(qName);
if (index == -1) {
throw new IllegalArgumentException(qName);
}
return Boolean.TRUE.equals(
fAttributes.getAugmentations(index).getItem(
Constants.ATTRIBUTE_DECLARED));
}
public boolean isDeclared(String uri, String localName) {
int index = getIndex(uri, localName);
if (index == -1) {
throw new IllegalArgumentException(localName);
}
return Boolean.TRUE.equals(
fAttributes.getAugmentations(index).getItem(
Constants.ATTRIBUTE_DECLARED));
}
public boolean isSpecified(int index) {
if (index < 0 || index >= fAttributes.getLength()) {
throw new ArrayIndexOutOfBoundsException(index);
}
return fAttributes.isSpecified(index);
}
public boolean isSpecified(String qName) {
int index = getIndex(qName);
if (index == -1) {
throw new IllegalArgumentException(qName);
}
return fAttributes.isSpecified(index);
}
public boolean isSpecified(String uri, String localName) {
int index = getIndex(uri, localName);
if (index == -1) {
throw new IllegalArgumentException(localName);
}
return fAttributes.isSpecified(index);
}
}
public ElementPSVI getElementPSVI(){
return (fAugmentations != null)?(ElementPSVI)fAugmentations.getItem(Constants.ELEMENT_PSVI):null;
}
public AttributePSVI getAttributePSVI(int index){
return (AttributePSVI)fAttributesProxy.fAttributes.getAugmentations(index).getItem(Constants.ATTRIBUTE_PSVI);
}
public AttributePSVI getAttributePSVIByName(String uri,
String localname){
return (AttributePSVI)fAttributesProxy.fAttributes.getAugmentations(uri, localname).getItem(Constants.ATTRIBUTE_PSVI);
}
}
package sun.reflect.generics.scope;
import java.lang.reflect.GenericDeclaration;
import java.lang.reflect.TypeVariable;
public abstract class AbstractScope<D extends GenericDeclaration>
implements Scope {
private final D recvr;
private volatile Scope enclosingScope;
protected AbstractScope(D decl){ recvr = decl;}
protected D getRecvr() {return recvr;}
protected abstract Scope computeEnclosingScope();
protected Scope getEnclosingScope() {
Scope value = enclosingScope;
if (value == null) {
value = computeEnclosingScope();
enclosingScope = value;
}
return value;
}
public TypeVariable<?> lookup(String name) {
TypeVariable<?>[] tas = getRecvr().getTypeParameters();
for (TypeVariable<?> tv : tas) {
if (tv.getName().equals(name)) {return tv;}
}
return getEnclosingScope().lookup(name);
}
}
package javax.script;
import java.io.Reader;
public abstract class AbstractScriptEngine  implements ScriptEngine {
protected ScriptContext context;
public AbstractScriptEngine() {
context = new SimpleScriptContext();
}
public AbstractScriptEngine(Bindings n) {
this();
if (n == null) {
throw new NullPointerException("n is null");
}
context.setBindings(n, ScriptContext.ENGINE_SCOPE);
}
public void setContext(ScriptContext ctxt) {
if (ctxt == null) {
throw new NullPointerException("null context");
}
context = ctxt;
}
public ScriptContext getContext() {
return context;
}
public Bindings getBindings(int scope) {
if (scope == ScriptContext.GLOBAL_SCOPE) {
return context.getBindings(ScriptContext.GLOBAL_SCOPE);
} else if (scope == ScriptContext.ENGINE_SCOPE) {
return context.getBindings(ScriptContext.ENGINE_SCOPE);
} else {
throw new IllegalArgumentException("Invalid scope value.");
}
}
public void setBindings(Bindings bindings, int scope) {
if (scope == ScriptContext.GLOBAL_SCOPE) {
context.setBindings(bindings, ScriptContext.GLOBAL_SCOPE);
} else if (scope == ScriptContext.ENGINE_SCOPE) {
context.setBindings(bindings, ScriptContext.ENGINE_SCOPE);
} else {
throw new IllegalArgumentException("Invalid scope value.");
}
}
public void put(String key, Object value) {
Bindings nn = getBindings(ScriptContext.ENGINE_SCOPE);
if (nn != null) {
nn.put(key, value);
}
}
public Object get(String key) {
Bindings nn = getBindings(ScriptContext.ENGINE_SCOPE);
if (nn != null) {
return nn.get(key);
}
return null;
}
public Object eval(Reader reader, Bindings bindings ) throws ScriptException {
ScriptContext ctxt = getScriptContext(bindings);
return eval(reader, ctxt);
}
public Object eval(String script, Bindings bindings) throws ScriptException {
ScriptContext ctxt = getScriptContext(bindings);
return eval(script , ctxt);
}
public Object eval(Reader reader) throws ScriptException {
return eval(reader, context);
}
public Object eval(String script) throws ScriptException {
return eval(script, context);
}
protected ScriptContext getScriptContext(Bindings nn) {
SimpleScriptContext ctxt = new SimpleScriptContext(context.getReader(), context.getWriter(), context.getErrorWriter());
Bindings gs = getBindings(ScriptContext.GLOBAL_SCOPE);
if (gs != null) {
ctxt.setBindings(gs, ScriptContext.GLOBAL_SCOPE);
}
if (nn != null) {
ctxt.setBindings(nn,
ScriptContext.ENGINE_SCOPE);
} else {
throw new NullPointerException("Engine scope Bindings may not be null.");
}
return ctxt;
}
}
package java.nio.channels.spi;
import java.io.IOException;
import java.nio.channels.CancelledKeyException;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.ClosedSelectorException;
import java.nio.channels.IllegalBlockingModeException;
import java.nio.channels.IllegalSelectorException;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.Arrays;
import java.util.function.Consumer;
public abstract class AbstractSelectableChannel
extends SelectableChannel
{
private final SelectorProvider provider;
private SelectionKey[] keys = null;
private int keyCount = 0;
private final Object keyLock = new Object();
private final Object regLock = new Object();
private volatile boolean nonBlocking;
protected AbstractSelectableChannel(SelectorProvider provider) {
this.provider = provider;
}
public final SelectorProvider provider() {
return provider;
}
private void addKey(SelectionKey k) {
assert Thread.holdsLock(keyLock);
int i = 0;
if ((keys != null) && (keyCount < keys.length)) {
for (i = 0; i < keys.length; i++)
if (keys[i] == null)
break;
} else if (keys == null) {
keys = new SelectionKey[2];
} else {
int n = keys.length * 2;
SelectionKey[] ks =  new SelectionKey[n];
for (i = 0; i < keys.length; i++)
ks[i] = keys[i];
keys = ks;
i = keyCount;
}
keys[i] = k;
keyCount++;
}
private SelectionKey findKey(Selector sel) {
assert Thread.holdsLock(keyLock);
if (keys == null)
return null;
for (int i = 0; i < keys.length; i++)
if ((keys[i] != null) && (keys[i].selector() == sel))
return keys[i];
return null;
}
void removeKey(SelectionKey k) {                            synchronized (keyLock) {
for (int i = 0; i < keys.length; i++)
if (keys[i] == k) {
keys[i] = null;
keyCount--;
}
((AbstractSelectionKey)k).invalidate();
}
}
private boolean haveValidKeys() {
synchronized (keyLock) {
if (keyCount == 0)
return false;
for (int i = 0; i < keys.length; i++) {
if ((keys[i] != null) && keys[i].isValid())
return true;
}
return false;
}
}
public final boolean isRegistered() {
synchronized (keyLock) {
return keyCount != 0;
}
}
public final SelectionKey keyFor(Selector sel) {
synchronized (keyLock) {
return findKey(sel);
}
}
private void forEach(Consumer<SelectionKey> action) {
synchronized (keyLock) {
SelectionKey[] keys = this.keys;
if (keys != null) {
Arrays.stream(keys).filter(k -> k != null).forEach(action::accept);
}
}
}
public final SelectionKey register(Selector sel, int ops, Object att)
throws ClosedChannelException
{
if ((ops & ~validOps()) != 0)
throw new IllegalArgumentException();
if (!isOpen())
throw new ClosedChannelException();
synchronized (regLock) {
if (isBlocking())
throw new IllegalBlockingModeException();
synchronized (keyLock) {
if (!isOpen())
throw new ClosedChannelException();
SelectionKey k = findKey(sel);
if (k != null) {
k.attach(att);
k.interestOps(ops);
} else {
k = ((AbstractSelector)sel).register(this, ops, att);
addKey(k);
}
return k;
}
}
}
protected final void implCloseChannel() throws IOException {
implCloseSelectableChannel();
SelectionKey[] copyOfKeys = null;
synchronized (keyLock) {
if (keys != null) {
copyOfKeys = keys.clone();
}
}
if (copyOfKeys != null) {
for (SelectionKey k : copyOfKeys) {
if (k != null) {
k.cancel();                   }
}
}
}
protected abstract void implCloseSelectableChannel() throws IOException;
public final boolean isBlocking() {
return !nonBlocking;
}
public final Object blockingLock() {
return regLock;
}
public final SelectableChannel configureBlocking(boolean block)
throws IOException
{
synchronized (regLock) {
if (!isOpen())
throw new ClosedChannelException();
boolean blocking = !nonBlocking;
if (block != blocking) {
if (block && haveValidKeys())
throw new IllegalBlockingModeException();
implConfigureBlocking(block);
nonBlocking = !block;
}
}
return this;
}
protected abstract void implConfigureBlocking(boolean block)
throws IOException;
}
package java.nio.channels.spi;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.VarHandle;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import sun.nio.ch.SelectionKeyImpl;
import sun.nio.ch.SelectorImpl;
public abstract class AbstractSelectionKey
extends SelectionKey
{
private static final VarHandle INVALID;
static {
try {
MethodHandles.Lookup l = MethodHandles.lookup();
INVALID = l.findVarHandle(AbstractSelectionKey.class, "invalid", boolean.class);
} catch (Exception e) {
throw new InternalError(e);
}
}
protected AbstractSelectionKey() { }
private volatile boolean invalid;
public final boolean isValid() {
return !invalid;
}
void invalidate() {                                         invalid = true;
}
public final void cancel() {
boolean changed = (boolean) INVALID.compareAndSet(this, false, true);
if (changed) {
Selector sel = selector();
if (sel instanceof SelectorImpl) {
((SelectorImpl) sel).cancel((SelectionKeyImpl) this);
} else {
((AbstractSelector) sel).cancel(this);
}
}
}
}
package java.nio.channels.spi;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.VarHandle;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.HashSet;
import java.util.Set;
import sun.nio.ch.Interruptible;
import sun.nio.ch.SelectorImpl;
public abstract class AbstractSelector
extends Selector
{
private static final VarHandle CLOSED;
static {
try {
MethodHandles.Lookup l = MethodHandles.lookup();
CLOSED = l.findVarHandle(AbstractSelector.class, "closed", boolean.class);
} catch (Exception e) {
throw new InternalError(e);
}
}
private volatile boolean closed;
private final SelectorProvider provider;
private final Set<SelectionKey> cancelledKeys;
protected AbstractSelector(SelectorProvider provider) {
this.provider = provider;
if (this instanceof SelectorImpl) {
this.cancelledKeys = Set.of();
} else {
this.cancelledKeys = new HashSet<>();
}
}
void cancel(SelectionKey k) {                               synchronized (cancelledKeys) {
cancelledKeys.add(k);
}
}
public final void close() throws IOException {
boolean changed = (boolean) CLOSED.compareAndSet(this, false, true);
if (changed) {
implCloseSelector();
}
}
protected abstract void implCloseSelector() throws IOException;
public final boolean isOpen() {
return !closed;
}
public final SelectorProvider provider() {
return provider;
}
protected final Set<SelectionKey> cancelledKeys() {
return cancelledKeys;
}
protected abstract SelectionKey register(AbstractSelectableChannel ch,
int ops, Object att);
protected final void deregister(AbstractSelectionKey key) {
((AbstractSelectableChannel)key.channel()).removeKey(key);
}
private Interruptible interruptor = null;
protected final void begin() {
if (interruptor == null) {
interruptor = new Interruptible() {
public void interrupt(Thread ignore) {
AbstractSelector.this.wakeup();
}};
}
AbstractInterruptibleChannel.blockedOn(interruptor);
Thread me = Thread.currentThread();
if (me.isInterrupted())
interruptor.interrupt(me);
}
protected final void end() {
AbstractInterruptibleChannel.blockedOn(null);
}
}
package java.util;
public abstract class AbstractSequentialList<E> extends AbstractList<E> {
protected AbstractSequentialList() {
}
public E get(int index) {
try {
return listIterator(index).next();
} catch (NoSuchElementException exc) {
throw new IndexOutOfBoundsException("Index: "+index);
}
}
public E set(int index, E element) {
try {
ListIterator<E> e = listIterator(index);
E oldVal = e.next();
e.set(element);
return oldVal;
} catch (NoSuchElementException exc) {
throw new IndexOutOfBoundsException("Index: "+index);
}
}
public void add(int index, E element) {
try {
listIterator(index).add(element);
} catch (NoSuchElementException exc) {
throw new IndexOutOfBoundsException("Index: "+index);
}
}
public E remove(int index) {
try {
ListIterator<E> e = listIterator(index);
E outCast = e.next();
e.remove();
return outCast;
} catch (NoSuchElementException exc) {
throw new IndexOutOfBoundsException("Index: "+index);
}
}
public boolean addAll(int index, Collection<? extends E> c) {
try {
boolean modified = false;
ListIterator<E> e1 = listIterator(index);
for (E e : c) {
e1.add(e);
modified = true;
}
return modified;
} catch (NoSuchElementException exc) {
throw new IndexOutOfBoundsException("Index: "+index);
}
}
public Iterator<E> iterator() {
return listIterator();
}
public abstract ListIterator<E> listIterator(int index);
}
package java.util;
public abstract class AbstractSet<E> extends AbstractCollection<E> implements Set<E> {
protected AbstractSet() {
}
public boolean equals(Object o) {
if (o == this)
return true;
if (!(o instanceof Set))
return false;
Collection<?> c = (Collection<?>) o;
if (c.size() != size())
return false;
try {
return containsAll(c);
} catch (ClassCastException | NullPointerException unused) {
return false;
}
}
public int hashCode() {
int h = 0;
Iterator<E> i = iterator();
while (i.hasNext()) {
E obj = i.next();
if (obj != null)
h += obj.hashCode();
}
return h;
}
public boolean removeAll(Collection<?> c) {
Objects.requireNonNull(c);
boolean modified = false;
if (size() > c.size()) {
for (Object e : c)
modified |= remove(e);
} else {
for (Iterator<?> i = iterator(); i.hasNext(); ) {
if (c.contains(i.next())) {
i.remove();
modified = true;
}
}
}
return modified;
}
}
package java.util.stream;
import java.util.Spliterator;
import java.util.concurrent.atomic.AtomicReference;
@SuppressWarnings("serial")
abstract class AbstractShortCircuitTask<P_IN, P_OUT, R,
K extends AbstractShortCircuitTask<P_IN, P_OUT, R, K>>
extends AbstractTask<P_IN, P_OUT, R, K> {
protected final AtomicReference<R> sharedResult;
protected volatile boolean canceled;
protected AbstractShortCircuitTask(PipelineHelper<P_OUT> helper,
Spliterator<P_IN> spliterator) {
super(helper, spliterator);
sharedResult = new AtomicReference<>();
}
protected AbstractShortCircuitTask(K parent,
Spliterator<P_IN> spliterator) {
super(parent, spliterator);
sharedResult = parent.sharedResult;
}
protected abstract R getEmptyResult();
@Override
public void compute() {
Spliterator<P_IN> rs = spliterator, ls;
long sizeEstimate = rs.estimateSize();
long sizeThreshold = getTargetSize(sizeEstimate);
boolean forkRight = false;
@SuppressWarnings("unchecked") K task = (K) this;
AtomicReference<R> sr = sharedResult;
R result;
while ((result = sr.get()) == null) {
if (task.taskCanceled()) {
result = task.getEmptyResult();
break;
}
if (sizeEstimate <= sizeThreshold || (ls = rs.trySplit()) == null) {
result = task.doLeaf();
break;
}
K leftChild, rightChild, taskToFork;
task.leftChild  = leftChild = task.makeChild(ls);
task.rightChild = rightChild = task.makeChild(rs);
task.setPendingCount(1);
if (forkRight) {
forkRight = false;
rs = ls;
task = leftChild;
taskToFork = rightChild;
}
else {
forkRight = true;
task = rightChild;
taskToFork = leftChild;
}
taskToFork.fork();
sizeEstimate = rs.estimateSize();
}
task.setLocalResult(result);
task.tryComplete();
}
protected void shortCircuit(R result) {
if (result != null)
sharedResult.compareAndSet(null, result);
}
@Override
protected void setLocalResult(R localResult) {
if (isRoot()) {
if (localResult != null)
sharedResult.compareAndSet(null, localResult);
}
else
super.setLocalResult(localResult);
}
@Override
public R getRawResult() {
return getLocalResult();
}
@Override
public R getLocalResult() {
if (isRoot()) {
R answer = sharedResult.get();
return (answer == null) ? getEmptyResult() : answer;
}
else
return super.getLocalResult();
}
protected void cancel() {
canceled = true;
}
protected boolean taskCanceled() {
boolean cancel = canceled;
if (!cancel) {
for (K parent = getParent(); !cancel && parent != null; parent = parent.getParent())
cancel = parent.canceled;
}
return cancel;
}
protected void cancelLaterNodes() {
for (@SuppressWarnings("unchecked") K parent = getParent(), node = (K) this;
parent != null;
node = parent, parent = parent.getParent()) {
if (parent.leftChild == node) {
K rightSibling = parent.rightChild;
if (!rightSibling.canceled)
rightSibling.cancel();
}
}
}
}
package jdk.incubator.vector;
import java.util.function.IntUnaryOperator;
import jdk.internal.vm.annotation.ForceInline;
abstract class AbstractShuffle<E> extends VectorShuffle<E> {
static final IntUnaryOperator IDENTITY = i -> i;
AbstractShuffle(int length, byte[] reorder) {
super(reorder);
assert(length == reorder.length);
assert(indexesInRange(reorder));
}
AbstractShuffle(int length, int[] reorder) {
this(length, reorder, 0);
}
AbstractShuffle(int length, int[] reorder, int offset) {
super(prepare(length, reorder, offset));
}
AbstractShuffle(int length, IntUnaryOperator f) {
super(prepare(length, f));
}
private static byte[] prepare(int length, int[] reorder, int offset) {
byte[] a = new byte[length];
for (int i = 0; i < length; i++) {
int si = reorder[offset + i];
si = partiallyWrapIndex(si, length);
a[i] = (byte) si;
}
return a;
}
private static byte[] prepare(int length, IntUnaryOperator f) {
byte[] a = new byte[length];
for (int i = 0; i < a.length; i++) {
int si = f.applyAsInt(i);
si = partiallyWrapIndex(si, length);
a[i] = (byte) si;
}
return a;
}
byte[] reorder() {
return (byte[])getPayload();
}
abstract AbstractSpecies<E> vspecies();
@Override
@ForceInline
public final VectorSpecies<E> vectorSpecies() {
return vspecies();
}
@Override
@ForceInline
public void intoArray(int[] a, int offset) {
byte[] reorder = reorder();
int vlen = reorder.length;
for (int i = 0; i < vlen; i++) {
int sourceIndex = reorder[i];
assert(sourceIndex >= -vlen && sourceIndex < vlen);
a[offset + i] = sourceIndex;
}
}
@Override
@ForceInline
public int[] toArray() {
byte[] reorder = reorder();
int[] a = new int[reorder.length];
intoArray(a, 0);
return a;
}
@ForceInline
final
AbstractVector<E>
toVectorTemplate() {
return (AbstractVector<E>) vspecies().fromIntValues(toArray());
}
@ForceInline
public final VectorShuffle<E> checkIndexes() {
if (VectorIntrinsics.VECTOR_ACCESS_OOB_CHECK == 0) {
return this;
}
Vector<E> shufvec = this.toVector();
VectorMask<E> vecmask = shufvec.compare(VectorOperators.LT, vspecies().zero());
if (vecmask.anyTrue()) {
byte[] reorder = reorder();
throw checkIndexFailed(reorder[vecmask.firstTrue()], length());
}
return this;
}
@ForceInline
public final VectorShuffle<E> wrapIndexes() {
Vector<E> shufvec = this.toVector();
VectorMask<E> vecmask = shufvec.compare(VectorOperators.LT, vspecies().zero());
if (vecmask.anyTrue()) {
byte[] reorder = reorder();
return wrapAndRebuild(reorder);
}
return this;
}
@ForceInline
public final VectorShuffle<E> wrapAndRebuild(byte[] oldReorder) {
int length = oldReorder.length;
byte[] reorder = new byte[length];
for (int i = 0; i < length; i++) {
int si = oldReorder[i];
if ((length & (length - 1)) == 0) {
si += si & length;              } else if (si < 0) {
si += length;
}
assert(si >= 0 && si < length);
reorder[i] = (byte) si;
}
return vspecies().dummyVector().shuffleFromBytes(reorder);
}
@ForceInline
public final VectorMask<E> laneIsValid() {
Vector<E> shufvec = this.toVector();
return shufvec.compare(VectorOperators.GE, vspecies().zero());
}
@Override
@ForceInline
@SuppressWarnings("unchecked")
public final
<F> VectorShuffle<F> check(VectorSpecies<F> species) {
if (species != vectorSpecies()) {
throw AbstractSpecies.checkFailed(this, species);
}
return (VectorShuffle<F>) this;
}
@Override
@ForceInline
public final int checkIndex(int index) {
return checkIndex0(index, length(), (byte)1);
}
@Override
@ForceInline
public final int wrapIndex(int index) {
return checkIndex0(index, length(), (byte)0);
}
@ForceInline
static
int partiallyWrapIndex(int index, int laneCount) {
return checkIndex0(index, laneCount, (byte)-1);
}
@ForceInline
static int checkIndex0(int index, int laneCount, byte mode) {
int wrapped = VectorIntrinsics.wrapToRange(index, laneCount);
if (mode == 0 || wrapped == index) {
return wrapped;
}
if (mode < 0) {
return wrapped - laneCount;          }
throw checkIndexFailed(index, laneCount);
}
private static IndexOutOfBoundsException checkIndexFailed(int index, int laneCount) {
int max = laneCount - 1;
String msg = "required an index in [0.."+max+"] but found "+index;
return new IndexOutOfBoundsException(msg);
}
static boolean indexesInRange(byte[] reorder) {
int length = reorder.length;
for (byte si : reorder) {
if (si >= length || si < -length) {
boolean assertsEnabled = false;
assert(assertsEnabled = true);
if (assertsEnabled) {
String msg = ("index "+si+"out of range ["+length+"] in "+
java.util.Arrays.toString(reorder));
throw new AssertionError(msg);
}
return false;
}
}
return true;
}
}
package build.tools.jdwpgen;
import java.util.*;
import java.io.*;
abstract class AbstractSimpleNode extends Node {
AbstractSimpleNode() {
kind = "-simple-";
components = new ArrayList<Node>();
}
void document(PrintWriter writer) {
writer.print(toString());
}
}
package build.tools.jdwpgen;
import java.util.*;
abstract class AbstractSimpleTypeNode extends AbstractTypeNode {
void constrain(Context ctx) {
context = ctx;
nameNode.constrain(ctx);
if (components.size() != 0) {
error("Extraneous content: " + components.get(0));
}
}
}
package jdk.incubator.vector;
import java.lang.foreign.MemorySegment;
import jdk.internal.vm.annotation.ForceInline;
import jdk.internal.vm.annotation.Stable;
import java.lang.reflect.Array;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.function.Function;
import java.util.function.IntUnaryOperator;
abstract class AbstractSpecies<E> extends jdk.internal.vm.vector.VectorSupport.VectorSpecies<E>
implements VectorSpecies<E> {
@Stable
final VectorShape vectorShape;
@Stable
final LaneType laneType;
@Stable
final int laneCount;
@Stable
final int laneCountLog2P1;
@Stable
final Class<? extends AbstractVector<E>> vectorType;
@Stable
final Class<? extends AbstractMask<E>> maskType;
@Stable
final Function<Object, ? extends AbstractVector<E>> vectorFactory;
@Stable
final VectorShape indexShape;
@Stable
final int maxScale, minScale;
@Stable
final int vectorBitSize, vectorByteSize;
AbstractSpecies(VectorShape vectorShape,
LaneType laneType,
Class<? extends AbstractVector<E>> vectorType,
Class<? extends AbstractMask<E>> maskType,
Function<Object, ? extends AbstractVector<E>> vectorFactory) {
this.vectorShape = vectorShape;
this.laneType = laneType;
this.vectorType = vectorType;
this.maskType = maskType;
this.vectorFactory = vectorFactory;
int bitSize = vectorShape.vectorBitSize();
int byteSize = bitSize / Byte.SIZE;
assert(byteSize * 8 == bitSize);
this.vectorBitSize = bitSize;
this.vectorByteSize = byteSize;
int elementSize = laneType.elementSize;
this.laneCount = bitSize / elementSize;
assert(laneCount > 0);          this.laneCountLog2P1 = Integer.numberOfTrailingZeros(laneCount) + 1;
int indexBitSize = Integer.SIZE * laneCount;
this.indexShape = VectorShape.forIndexBitSize(indexBitSize, elementSize);
int precision = laneType.elementPrecision;
if (precision >= Integer.SIZE) {
this.maxScale = Integer.MAX_VALUE;
this.minScale = Integer.MIN_VALUE;
} else {
boolean isfp = (laneType.elementKind == 'F');
long x = laneCount;
long maxScale = ((1L << precision)-(isfp?0:1)) / x;
long minScale = (-1L << precision) / x;
this.maxScale = (int) maxScale;
this.minScale = (int) minScale;
}
}
@Stable     AbstractSpecies<Integer> indexSpecies;
@Stable     AbstractShuffle<Byte> swapBytesShuffle;
@Stable     AbstractVector<E> dummyVector;
@Override
@ForceInline
public final int length() {
return laneCount;
}
@ForceInline
final int laneCount() {
return laneCount;
}
@ForceInline
final int laneCountLog2() {
return laneCountLog2P1 - 1;      }
@Override
@ForceInline
@SuppressWarnings("unchecked")
public Class<E> elementType() {
return (Class<E>) laneType.elementType;
}
@ForceInline
@SuppressWarnings("unchecked")
Class<E> genericElementType() {
return (Class<E>) laneType.genericElementType;
}
@Override
@ForceInline
public Class<? extends AbstractVector<E>> vectorType() {
return vectorType;
}
@Override
@ForceInline
public final Class<? extends AbstractMask<E>> maskType() {
return maskType;
}
@Override
@ForceInline
public final int elementSize() {
return laneType.elementSize;
}
@ForceInline
final int elementByteSize() {
return laneType.elementSize / Byte.SIZE;
}
@Override
@ForceInline
public final VectorShape vectorShape() {
return vectorShape;
}
@ForceInline
final VectorShape indexShape() {
return indexShape;
}
@Override
@ForceInline
public final int vectorBitSize() {
return vectorBitSize;
}
@Override
@ForceInline
public final int vectorByteSize() {
return vectorByteSize;
}
@Override
@ForceInline
public final int loopBound(int length) {
return VectorIntrinsics.roundDown(length, laneCount);
}
@Override
@ForceInline
public final long loopBound(long length) {
return VectorIntrinsics.roundDown(length, laneCount);
}
@Override
@ForceInline
public final VectorMask<E> indexInRange(int offset, int limit) {
return maskAll(true).indexInRange(offset, limit);
}
@Override
@ForceInline
public final VectorMask<E> indexInRange(long offset, long limit) {
return maskAll(true).indexInRange(offset, limit);
}
@Override
@ForceInline
public final <F> VectorSpecies<F> withLanes(Class<F> newType) {
return withLanes(LaneType.of(newType)).check(newType);
}
@ForceInline
final
AbstractSpecies<?> withLanes(LaneType newType) {
if (newType == laneType)  return this;
return findSpecies(newType, vectorShape);
}
@ForceInline
AbstractSpecies<?> asIntegral() {
return withLanes(laneType.asIntegral());
}
@ForceInline
AbstractSpecies<?> asFloating() {
return withLanes(laneType.asFloating());
}
@Override
@ForceInline
@SuppressWarnings("unchecked")
public final VectorSpecies<E> withShape(VectorShape newShape) {
if (newShape == vectorShape)  return this;
return (VectorSpecies<E>) findSpecies(laneType, newShape);
}
@ForceInline
AbstractSpecies<Integer> indexSpecies() {
AbstractSpecies<Integer> sp = indexSpecies;
if (sp != null)  return sp;
return indexSpecies = findSpecies(LaneType.INT, indexShape).check0(int.class);
}
@ForceInline
@SuppressWarnings("unchecked")
AbstractSpecies<Byte> byteSpecies() {
return (AbstractSpecies<Byte>) withLanes(LaneType.BYTE);
}
@ForceInline
AbstractShuffle<Byte> swapBytesShuffle() {
AbstractShuffle<Byte> sh = swapBytesShuffle;
if (sh != null)  return sh;
return swapBytesShuffle = makeSwapBytesShuffle();
}
private AbstractShuffle<Byte> makeSwapBytesShuffle() {
int vbytes = vectorByteSize();
int lbytes = elementByteSize();
int[] sourceIndexes = new int[vbytes];
for (int i = 0; i < vbytes; i++) {
sourceIndexes[i] = i ^ (lbytes-1);
}
return (AbstractShuffle<Byte>)
VectorShuffle.fromValues(byteSpecies(), sourceIndexes);
}
abstract Vector<E> fromIntValues(int[] values);
@ForceInline
AbstractVector<E> dummyVector() {
AbstractVector<E> dummy = dummyVector;
if (dummy != null)  return dummy;
return makeDummyVector();
}
private AbstractVector<E> makeDummyVector() {
Object za = Array.newInstance(elementType(), laneCount);
return dummyVector = vectorFactory.apply(za);
}
@ForceInline
AbstractMask<E> maskFactory(boolean[] bits) {
return dummyVector().maskFromArray(bits);
}
public final
@Override
@ForceInline
VectorShuffle<E> shuffleFromArray(int[] sourceIndexes, int offset) {
return dummyVector().shuffleFromArray(sourceIndexes, offset);
}
public final
@Override
@ForceInline
VectorShuffle<E> shuffleFromValues(int... sourceIndexes) {
return dummyVector().shuffleFromArray(sourceIndexes, 0);
}
public final
@Override
@ForceInline
VectorShuffle<E> shuffleFromOp(IntUnaryOperator fn) {
return dummyVector().shuffleFromOp(fn);
}
public final
@Override
@ForceInline
VectorShuffle<E> iotaShuffle(int start, int step, boolean wrap) {
AbstractShuffle<E> res;
if (start == 0 && step == 1)
return dummyVector().iotaShuffle();
else
return dummyVector().iotaShuffle(start, step, wrap);
}
@ForceInline
@Override
public final Vector<E> fromMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {
return dummyVector()
.fromMemorySegment0(ms, offset)
.maybeSwap(bo);
}
@Override
public VectorMask<E> loadMask(boolean[] bits, int offset) {
return VectorMask.fromArray(this, bits, offset);
}
public abstract AbstractVector<E> zero();
abstract AbstractVector<E> iota();
abstract long longToElementBits(long e);
abstract AbstractVector<E> broadcastBits(long bits);
final IllegalArgumentException badElementBits(long iv, Object cv) {
String msg = String.format("Vector creation failed: "+
"value %s cannot be represented in ETYPE %s"+
"; result of cast is %s",
iv,
elementType(),
cv);
return new IllegalArgumentException(msg);
}
static
final IllegalArgumentException badArrayBits(Object iv,
boolean isInt,
long cv) {
String msg = String.format("Array creation failed: "+
"lane value %s cannot be represented in %s"+
"; result of cast is %s",
iv,
(isInt ? "int" : "long"),
cv);
return new IllegalArgumentException(msg);
}
Object iotaArray() {
Object ia = Array.newInstance(laneType.elementType,
laneCount);
assert(ia.getClass() == laneType.arrayType);
checkValue(laneCount-1);          for (int i = 0; i < laneCount; i++) {
if ((byte)i == i)
Array.setByte(ia, i, (byte)i);
else if ((short)i == i)
Array.setShort(ia, i, (short)i);
else
Array.setInt(ia, i, i);
assert(Array.getDouble(ia, i) == i);
}
return ia;
}
@ForceInline
void checkScale(int scale) {
if (scale > 0) {
if (scale <= maxScale)  return;
} else {             if (scale >= minScale)  return;
}
throw checkScaleFailed(scale);
}
private IllegalArgumentException checkScaleFailed(int scale) {
String msg = String.format("%s: cannot represent VLENGTH*%d",
this, scale);
return new IllegalArgumentException(msg);
}
interface RVOp {
long apply(int i);      }
abstract AbstractVector<E> rvOp(RVOp f);
interface FOpm {
boolean apply(int i);
}
AbstractMask<E> opm(FOpm f) {
boolean[] res = new boolean[laneCount];
for (int i = 0; i < res.length; i++) {
res[i] = f.apply(i);
}
return dummyVector().maskFromArray(res);
}
@Override
@ForceInline
public final
<F> VectorSpecies<F> check(Class<F> elementType) {
return check0(elementType);
}
@ForceInline
@SuppressWarnings("unchecked")
final
<F> AbstractSpecies<F> check0(Class<F> elementType) {
if (elementType != this.elementType()) {
throw AbstractSpecies.checkFailed(this, elementType);
}
return (AbstractSpecies<F>) this;
}
@ForceInline
AbstractSpecies<E> check(LaneType laneType) {
if (laneType != this.laneType) {
throw AbstractSpecies.checkFailed(this, laneType);
}
return this;
}
@Override
@ForceInline
public int partLimit(VectorSpecies<?> toSpecies, boolean lanewise) {
AbstractSpecies<?> rsp = (AbstractSpecies<?>) toSpecies;
int inSizeLog2 = this.vectorShape.vectorBitSizeLog2;
int outSizeLog2 = rsp.vectorShape.vectorBitSizeLog2;
if (lanewise) {
inSizeLog2 += (rsp.laneType.elementSizeLog2 -
this.laneType.elementSizeLog2);
}
int diff = (inSizeLog2 - outSizeLog2);
int sign = (diff >> -1);
int d = (diff ^ sign) - sign;
return ((sign | 1) << d) & ~1;
}
static ClassCastException checkFailed(Object what, Object required) {
AbstractSpecies<?> whatSpecies = null;
String where;
if (what instanceof VectorSpecies) {
whatSpecies = (AbstractSpecies<?>) what;
where = whatSpecies.toString();
} else if (what instanceof Vector) {
whatSpecies = (AbstractSpecies<?>) ((Vector<?>) what).species();
where = "a Vector<"+whatSpecies.genericElementType()+">";
} else if (what instanceof VectorMask) {
whatSpecies = (AbstractSpecies<?>) ((VectorMask<?>) what).vectorSpecies();
where = "a VectorMask<"+whatSpecies.genericElementType()+">";
} else if (what instanceof VectorShuffle) {
whatSpecies = (AbstractSpecies<?>) ((VectorShuffle<?>) what).vectorSpecies();
where = "a VectorShuffle<"+whatSpecies.genericElementType()+">";
} else {
where = what.toString();
}
Object found = null;
if (whatSpecies != null) {
if (required instanceof VectorSpecies) {
found = whatSpecies;
} else if (required instanceof Vector) {
found = whatSpecies;
required = ((Vector<?>)required).species();
} else if (required instanceof Class) {
Class<?> requiredClass = (Class<?>) required;
LaneType requiredType = LaneType.forClassOrNull(requiredClass);
found = whatSpecies.elementType();
if (requiredType == null) {
required = required + " (not a valid lane type)";
} else if (!requiredClass.isPrimitive()) {
required = required + " (should be " + requiredType + ")";
}
} else if (required instanceof LaneType) {
required = ((LaneType) required).elementType;
found = whatSpecies.elementType();
} else if (required instanceof Integer) {
required = required + " lanes";
found = whatSpecies.length();
}
}
if (found == null)  found = "bad value";
String msg = where+": required "+required+" but found "+found;
return new ClassCastException(msg);
}
private static final @Stable AbstractSpecies<?>[][] CACHES
= new AbstractSpecies<?>[LaneType.SK_LIMIT][VectorShape.SK_LIMIT];
@ForceInline
static <E>
AbstractSpecies<E> findSpecies(Class<E> elementType,
LaneType laneType,
VectorShape shape) {
assert(elementType == laneType.elementType);
return findSpecies(laneType, shape).check0(elementType);
}
@ForceInline
static
AbstractSpecies<?> findSpecies(LaneType laneType,
VectorShape shape) {
AbstractSpecies<?> s = CACHES[laneType.switchKey][shape.switchKey];
if (s != null)  return s;
return computeSpecies(laneType, shape);
}
private static
AbstractSpecies<?> computeSpecies(LaneType laneType,
VectorShape shape) {
AbstractSpecies<?> s = null;
switch (laneType.switchKey) {
case LaneType.SK_FLOAT:
s = FloatVector.species(shape); break;
case LaneType.SK_DOUBLE:
s = DoubleVector.species(shape); break;
case LaneType.SK_BYTE:
s = ByteVector.species(shape); break;
case LaneType.SK_SHORT:
s = ShortVector.species(shape); break;
case LaneType.SK_INT:
s = IntVector.species(shape); break;
case LaneType.SK_LONG:
s = LongVector.species(shape); break;
}
if (s == null) {
throw new AssertionError("bootstrap problem");
}
assert(s.laneType == laneType) : s + "!=" + laneType;
assert(s.vectorShape == shape) : s + "!=" + shape;
CACHES[laneType.switchKey][shape.switchKey] = s;
return s;
}
@Override
public final String toString() {
return "Species["+laneType+", "+laneCount+", "+vectorShape+"]";
}
@Override
public final boolean equals(Object obj) {
if (obj instanceof AbstractSpecies) {
AbstractSpecies<?> that = (AbstractSpecies<?>) obj;
return (this.laneType == that.laneType &&
this.laneCount == that.laneCount &&
this.vectorShape == that.vectorShape);
}
return this == obj;
}
@Override
public final int hashCode() {
int[] a = { laneType.ordinal(), laneCount, vectorShape.ordinal() };
return Arrays.hashCode(a);
}
}
package java.util.stream;
abstract class AbstractSpinedBuffer {
public static final int MIN_CHUNK_POWER = 4;
public static final int MIN_CHUNK_SIZE = 1 << MIN_CHUNK_POWER;
public static final int MAX_CHUNK_POWER = 30;
public static final int MIN_SPINE_SIZE = 8;
protected final int initialChunkPower;
protected int elementIndex;
protected int spineIndex;
protected long[] priorElementCount;
protected AbstractSpinedBuffer() {
this.initialChunkPower = MIN_CHUNK_POWER;
}
protected AbstractSpinedBuffer(int initialCapacity) {
if (initialCapacity < 0)
throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity);
this.initialChunkPower = Math.max(MIN_CHUNK_POWER,
Integer.SIZE - Integer.numberOfLeadingZeros(initialCapacity - 1));
}
public boolean isEmpty() {
return (spineIndex == 0) && (elementIndex == 0);
}
public long count() {
return (spineIndex == 0)
? elementIndex
: priorElementCount[spineIndex] + elementIndex;
}
protected int chunkSize(int n) {
int power = (n == 0 || n == 1)
? initialChunkPower
: Math.min(initialChunkPower + n - 1, AbstractSpinedBuffer.MAX_CHUNK_POWER);
return 1 << power;
}
public abstract void clear();
}
package javax.swing;
import java.util.*;
import javax.swing.event.*;
import java.io.Serializable;
@SuppressWarnings("serial") public abstract class AbstractSpinnerModel implements SpinnerModel, Serializable
{
private transient ChangeEvent changeEvent = null;
protected EventListenerList listenerList = new EventListenerList();
protected AbstractSpinnerModel() {}
public void addChangeListener(ChangeListener l) {
listenerList.add(ChangeListener.class, l);
}
public void removeChangeListener(ChangeListener l) {
listenerList.remove(ChangeListener.class, l);
}
public ChangeListener[] getChangeListeners() {
return listenerList.getListeners(ChangeListener.class);
}
protected void fireStateChanged()
{
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length - 2; i >= 0; i -=2 ) {
if (listeners[i] == ChangeListener.class) {
if (changeEvent == null) {
changeEvent = new ChangeEvent(this);
}
((ChangeListener)listeners[i+1]).stateChanged(changeEvent);
}
}
}
public <T extends EventListener> T[] getListeners(Class<T> listenerType) {
return listenerList.getListeners(listenerType);
}
}
package compiler.arraycopy.stress;
import java.util.Random;
public abstract class AbstractStressArrayCopy {
static final int MAX_SIZE = 128*1024 + 1;
static final int EXHAUSTIVE_SIZES = Integer.getInteger("exhaustiveSizes", 192);
static final int FUZZ_COUNT = Integer.getInteger("fuzzCount", 300);
public static void throwSeedError(int len, int pos) {
throw new RuntimeException("Error after seed: " +
len + " elements, at pos " + pos);
}
public static void throwContentsError(int l, int r, int len, int pos) {
throwError("in contents", l, r, len, pos);
}
public static void throwHeadError(int l, int r, int len, int pos) {
throwError("in head", l, r, len, pos);
}
public static void throwTailError(int l, int r, int len, int pos) {
throwError("in tail", l, r, len, pos);
}
private static void throwError(String phase, int l, int r, int len, int pos) {
throw new RuntimeException("Error " + phase + ": " +
len + " elements, " +
"[" + l + ", " + (l+len) + ") -> " +
"[" + r + ", " + (r+len) + "), " +
"at pos " + pos);
}
protected abstract void testWith(int size, int l, int r, int len);
private void checkBounds(int size, int l, int r, int len) {
if (l >= size)      throw new IllegalStateException("l is out of bounds");
if (l + len > size) throw new IllegalStateException("l+len is out of bounds");
if (r >= size)      throw new IllegalStateException("r is out of bounds");
if (r + len > size) throw new IllegalStateException("r+len is out of bounds: " + l + " " + r + " " + len + " " + size);
}
private void checkDisjoint(int size, int l, int r, int len) {
if (l == r)               throw new IllegalStateException("Not disjoint: l == r");
if (l < r && l + len > r) throw new IllegalStateException("Not disjoint");
if (l > r && r + len > l) throw new IllegalStateException("Not disjoint");
}
private void checkConjoint(int size, int l, int r, int len) {
if (l == r) return;         if (l < r && l + len < r) throw new IllegalStateException("Not conjoint");
if (l > r && r + len < l) throw new IllegalStateException("Not conjoint");
}
public void exhaustiveWith(int size) {
for (int l = 0; l < size; l++) {
for (int r = 0; r < size; r++) {
int maxLen = Math.min(size - l, size - r);
for (int len = 0; len <= maxLen; len++) {
checkBounds(size, l, r, len);
testWith(size, l, r, len);
}
}
}
}
public void fuzzWith(Random rand, int size) {
testWith(size, 0, 1, 1);
testWith(size, 0, 1, size-1);
for (int c = 0; c < FUZZ_COUNT; c++) {
int l = rand.nextInt(size / 2);
int len = rand.nextInt((size - l) / 2);
int r = (l + len + 1) + rand.nextInt(size - 2*len - l - 1);
checkBounds(size, l, r, len);
checkDisjoint(size, l, r, len);
testWith(size, l, r, len);
testWith(size, r, l, len);
}
for (int c = 0; c < FUZZ_COUNT; c++) {
int l = rand.nextInt(size);
int len = rand.nextInt(size - l);
int r = Math.min(l + (len > 0 ? rand.nextInt(len) : 0), size - len);
checkBounds(size, l, r, len);
checkConjoint(size, l, r, len);
testWith(size, l, r, len);
testWith(size, r, l, len);
}
}
public void run(Random rand) {
for (int size = 1; size <= EXHAUSTIVE_SIZES; size++) {
exhaustiveWith(size);
}
for (int size = 10; size < MAX_SIZE; size *= 10) {
if (size <= EXHAUSTIVE_SIZES) continue;
fuzzWith(rand, size - 1);
fuzzWith(rand, size);
fuzzWith(rand, size + 1);
}
for (int size = 2; size < MAX_SIZE; size *= 2) {
if (size <= EXHAUSTIVE_SIZES) continue;
fuzzWith(rand, size - 1);
fuzzWith(rand, size);
fuzzWith(rand, size + 1);
}
}
}
package java.lang;
import jdk.internal.math.DoubleToDecimal;
import jdk.internal.math.FloatToDecimal;
import java.io.IOException;
import java.util.Arrays;
import java.util.Spliterator;
import java.util.stream.IntStream;
import java.util.stream.StreamSupport;
import jdk.internal.util.ArraysSupport;
import jdk.internal.util.Preconditions;
import static java.lang.String.COMPACT_STRINGS;
import static java.lang.String.UTF16;
import static java.lang.String.LATIN1;
import static java.lang.String.checkIndex;
import static java.lang.String.checkOffset;
abstract sealed class AbstractStringBuilder implements Appendable, CharSequence
permits StringBuilder, StringBuffer {
byte[] value;
byte coder;
boolean maybeLatin1;
int count;
private static final byte[] EMPTYVALUE = new byte[0];
AbstractStringBuilder() {
value = EMPTYVALUE;
}
AbstractStringBuilder(int capacity) {
if (COMPACT_STRINGS) {
value = new byte[capacity];
coder = LATIN1;
} else {
value = StringUTF16.newBytesFor(capacity);
coder = UTF16;
}
}
AbstractStringBuilder(String str) {
int length = str.length();
int capacity = (length < Integer.MAX_VALUE - 16)
? length + 16 : Integer.MAX_VALUE;
final byte initCoder = str.coder();
coder = initCoder;
value = (initCoder == LATIN1)
? new byte[capacity] : StringUTF16.newBytesFor(capacity);
append(str);
}
AbstractStringBuilder(CharSequence seq) {
int length = seq.length();
if (length < 0) {
throw new NegativeArraySizeException("Negative length: " + length);
}
int capacity = (length < Integer.MAX_VALUE - 16)
? length + 16 : Integer.MAX_VALUE;
final byte initCoder;
if (COMPACT_STRINGS) {
if (seq instanceof AbstractStringBuilder asb) {
initCoder = asb.getCoder();
maybeLatin1 |= asb.maybeLatin1;
} else if (seq instanceof String s) {
initCoder = s.coder();
} else {
initCoder = LATIN1;
}
} else {
initCoder = UTF16;
}
coder = initCoder;
value = (initCoder == LATIN1)
? new byte[capacity] : StringUTF16.newBytesFor(capacity);
append(seq);
}
int compareTo(AbstractStringBuilder another) {
if (this == another) {
return 0;
}
byte[] val1 = value;
byte[] val2 = another.value;
int count1 = this.count;
int count2 = another.count;
if (coder == another.coder) {
return isLatin1() ? StringLatin1.compareTo(val1, val2, count1, count2)
: StringUTF16.compareTo(val1, val2, count1, count2);
}
return isLatin1() ? StringLatin1.compareToUTF16(val1, val2, count1, count2)
: StringUTF16.compareToLatin1(val1, val2, count1, count2);
}
@Override
public int length() {
return count;
}
public int capacity() {
return value.length >> coder;
}
public void ensureCapacity(int minimumCapacity) {
if (minimumCapacity > 0) {
ensureCapacityInternal(minimumCapacity);
}
}
private void ensureCapacityInternal(int minimumCapacity) {
int oldCapacity = value.length >> coder;
if (minimumCapacity - oldCapacity > 0) {
value = Arrays.copyOf(value,
newCapacity(minimumCapacity) << coder);
}
}
private int newCapacity(int minCapacity) {
int oldLength = value.length;
int newLength = minCapacity << coder;
int growth = newLength - oldLength;
int length = ArraysSupport.newLength(oldLength, growth, oldLength + (2 << coder));
if (length == Integer.MAX_VALUE) {
throw new OutOfMemoryError("Required length exceeds implementation limit");
}
return length >> coder;
}
private void inflate() {
if (!isLatin1()) {
return;
}
byte[] buf = StringUTF16.newBytesFor(value.length);
StringLatin1.inflate(value, 0, buf, 0, count);
this.value = buf;
this.coder = UTF16;
}
public void trimToSize() {
int length = count << coder;
if (length < value.length) {
value = Arrays.copyOf(value, length);
}
}
public void setLength(int newLength) {
if (newLength < 0) {
throw new StringIndexOutOfBoundsException(newLength);
}
ensureCapacityInternal(newLength);
if (count < newLength) {
if (isLatin1()) {
StringLatin1.fillNull(value, count, newLength);
} else {
StringUTF16.fillNull(value, count, newLength);
}
} else if (count > newLength) {
maybeLatin1 = true;
}
count = newLength;
}
@Override
public char charAt(int index) {
checkIndex(index, count);
if (isLatin1()) {
return (char)(value[index] & 0xff);
}
return StringUTF16.getChar(value, index);
}
public int codePointAt(int index) {
int count = this.count;
byte[] value = this.value;
checkIndex(index, count);
if (isLatin1()) {
return value[index] & 0xff;
}
return StringUTF16.codePointAtSB(value, index, count);
}
public int codePointBefore(int index) {
int i = index - 1;
checkIndex(i, count);
if (isLatin1()) {
return value[i] & 0xff;
}
return StringUTF16.codePointBeforeSB(value, index);
}
public int codePointCount(int beginIndex, int endIndex) {
Preconditions.checkFromToIndex(beginIndex, endIndex, length(), null);
if (isLatin1()) {
return endIndex - beginIndex;
}
return StringUTF16.codePointCountSB(value, beginIndex, endIndex);
}
public int offsetByCodePoints(int index, int codePointOffset) {
if (index < 0 || index > count) {
throw new IndexOutOfBoundsException();
}
return Character.offsetByCodePoints(this,
index, codePointOffset);
}
public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
{
Preconditions.checkFromToIndex(srcBegin, srcEnd, count, Preconditions.SIOOBE_FORMATTER);          int n = srcEnd - srcBegin;
Preconditions.checkFromToIndex(dstBegin, dstBegin + n, dst.length, Preconditions.IOOBE_FORMATTER);
if (isLatin1()) {
StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);
} else {
StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);
}
}
public void setCharAt(int index, char ch) {
checkIndex(index, count);
if (isLatin1() && StringLatin1.canEncode(ch)) {
value[index] = (byte)ch;
} else {
if (isLatin1()) {
inflate();
}
StringUTF16.putCharSB(value, index, ch);
maybeLatin1 = true;
}
}
public AbstractStringBuilder append(Object obj) {
return append(String.valueOf(obj));
}
public AbstractStringBuilder append(String str) {
if (str == null) {
return appendNull();
}
int len = str.length();
ensureCapacityInternal(count + len);
putStringAt(count, str);
count += len;
return this;
}
public AbstractStringBuilder append(StringBuffer sb) {
return this.append((AbstractStringBuilder)sb);
}
AbstractStringBuilder append(AbstractStringBuilder asb) {
if (asb == null) {
return appendNull();
}
int len = asb.length();
ensureCapacityInternal(count + len);
inflateIfNeededFor(asb);
asb.getBytes(value, count, coder);
count += len;
maybeLatin1 |= asb.maybeLatin1;
return this;
}
@Override
public AbstractStringBuilder append(CharSequence s) {
if (s == null) {
return appendNull();
}
if (s instanceof String) {
return this.append((String)s);
}
if (s instanceof AbstractStringBuilder) {
return this.append((AbstractStringBuilder)s);
}
return this.append(s, 0, s.length());
}
private AbstractStringBuilder appendNull() {
ensureCapacityInternal(count + 4);
int count = this.count;
byte[] val = this.value;
if (isLatin1()) {
val[count++] = 'n';
val[count++] = 'u';
val[count++] = 'l';
val[count++] = 'l';
} else {
count = StringUTF16.putCharsAt(val, count, 'n', 'u', 'l', 'l');
}
this.count = count;
return this;
}
@Override
public AbstractStringBuilder append(CharSequence s, int start, int end) {
if (s == null) {
s = "null";
}
Preconditions.checkFromToIndex(start, end, s.length(), Preconditions.IOOBE_FORMATTER);
int len = end - start;
ensureCapacityInternal(count + len);
if (s instanceof String) {
appendChars((String)s, start, end);
} else {
appendChars(s, start, end);
}
return this;
}
public AbstractStringBuilder append(char[] str) {
int len = str.length;
ensureCapacityInternal(count + len);
appendChars(str, 0, len);
return this;
}
public AbstractStringBuilder append(char[] str, int offset, int len) {
int end = offset + len;
Preconditions.checkFromToIndex(offset, end, str.length, Preconditions.IOOBE_FORMATTER);
ensureCapacityInternal(count + len);
appendChars(str, offset, end);
return this;
}
public AbstractStringBuilder append(boolean b) {
ensureCapacityInternal(count + (b ? 4 : 5));
int count = this.count;
byte[] val = this.value;
if (isLatin1()) {
if (b) {
val[count++] = 't';
val[count++] = 'r';
val[count++] = 'u';
val[count++] = 'e';
} else {
val[count++] = 'f';
val[count++] = 'a';
val[count++] = 'l';
val[count++] = 's';
val[count++] = 'e';
}
} else {
if (b) {
count = StringUTF16.putCharsAt(val, count, 't', 'r', 'u', 'e');
} else {
count = StringUTF16.putCharsAt(val, count, 'f', 'a', 'l', 's', 'e');
}
}
this.count = count;
return this;
}
@Override
public AbstractStringBuilder append(char c) {
ensureCapacityInternal(count + 1);
if (isLatin1() && StringLatin1.canEncode(c)) {
value[count++] = (byte)c;
} else {
if (isLatin1()) {
inflate();
}
StringUTF16.putCharSB(value, count++, c);
}
return this;
}
public AbstractStringBuilder append(int i) {
int count = this.count;
int spaceNeeded = count + Integer.stringSize(i);
ensureCapacityInternal(spaceNeeded);
if (isLatin1()) {
Integer.getChars(i, spaceNeeded, value);
} else {
StringUTF16.getChars(i, count, spaceNeeded, value);
}
this.count = spaceNeeded;
return this;
}
public AbstractStringBuilder append(long l) {
int count = this.count;
int spaceNeeded = count + Long.stringSize(l);
ensureCapacityInternal(spaceNeeded);
if (isLatin1()) {
Long.getChars(l, spaceNeeded, value);
} else {
StringUTF16.getChars(l, count, spaceNeeded, value);
}
this.count = spaceNeeded;
return this;
}
public AbstractStringBuilder append(float f) {
try {
FloatToDecimal.appendTo(f, this);
} catch (IOException e) {
throw new AssertionError(e);
}
return this;
}
public AbstractStringBuilder append(double d) {
try {
DoubleToDecimal.appendTo(d, this);
} catch (IOException e) {
throw new AssertionError(e);
}
return this;
}
public AbstractStringBuilder delete(int start, int end) {
int count = this.count;
if (end > count) {
end = count;
}
Preconditions.checkFromToIndex(start, end, count, Preconditions.SIOOBE_FORMATTER);
int len = end - start;
if (len > 0) {
shift(end, -len);
this.count = count - len;
maybeLatin1 = true;
}
return this;
}
public AbstractStringBuilder appendCodePoint(int codePoint) {
if (Character.isBmpCodePoint(codePoint)) {
return append((char)codePoint);
}
return append(Character.toChars(codePoint));
}
public AbstractStringBuilder deleteCharAt(int index) {
checkIndex(index, count);
shift(index + 1, -1);
count--;
maybeLatin1 = true;
return this;
}
public AbstractStringBuilder replace(int start, int end, String str) {
int count = this.count;
if (end > count) {
end = count;
}
Preconditions.checkFromToIndex(start, end, count, Preconditions.SIOOBE_FORMATTER);
int len = str.length();
int newCount = count + len - (end - start);
ensureCapacityInternal(newCount);
shift(end, newCount - count);
this.count = newCount;
putStringAt(start, str);
maybeLatin1 = true;
return this;
}
public String substring(int start) {
return substring(start, count);
}
@Override
public CharSequence subSequence(int start, int end) {
return substring(start, end);
}
public String substring(int start, int end) {
Preconditions.checkFromToIndex(start, end, count, Preconditions.SIOOBE_FORMATTER);
if (isLatin1()) {
return StringLatin1.newString(value, start, end - start);
}
return StringUTF16.newString(value, start, end - start);
}
private void shift(int offset, int n) {
System.arraycopy(value, offset << coder,
value, (offset + n) << coder, (count - offset) << coder);
}
public AbstractStringBuilder insert(int index, char[] str, int offset,
int len)
{
checkOffset(index, count);
Preconditions.checkFromToIndex(offset, offset + len, str.length, Preconditions.SIOOBE_FORMATTER);
ensureCapacityInternal(count + len);
shift(index, len);
count += len;
putCharsAt(index, str, offset, offset + len);
return this;
}
public AbstractStringBuilder insert(int offset, Object obj) {
return insert(offset, String.valueOf(obj));
}
public AbstractStringBuilder insert(int offset, String str) {
checkOffset(offset, count);
if (str == null) {
str = "null";
}
int len = str.length();
ensureCapacityInternal(count + len);
shift(offset, len);
count += len;
putStringAt(offset, str);
return this;
}
public AbstractStringBuilder insert(int offset, char[] str) {
checkOffset(offset, count);
int len = str.length;
ensureCapacityInternal(count + len);
shift(offset, len);
count += len;
putCharsAt(offset, str, 0, len);
return this;
}
public AbstractStringBuilder insert(int dstOffset, CharSequence s) {
if (s == null) {
s = "null";
}
return this.insert(dstOffset, s, 0, s.length());
}
public AbstractStringBuilder insert(int dstOffset, CharSequence s,
int start, int end)
{
if (s == null) {
s = "null";
}
checkOffset(dstOffset, count);
Preconditions.checkFromToIndex(start, end, s.length(), Preconditions.IOOBE_FORMATTER);
int len = end - start;
ensureCapacityInternal(count + len);
shift(dstOffset, len);
count += len;
if (s instanceof String) {
putStringAt(dstOffset, (String) s, start, end);
} else {
putCharsAt(dstOffset, s, start, end);
}
return this;
}
public AbstractStringBuilder insert(int offset, boolean b) {
return insert(offset, String.valueOf(b));
}
public AbstractStringBuilder insert(int offset, char c) {
checkOffset(offset, count);
ensureCapacityInternal(count + 1);
shift(offset, 1);
count += 1;
if (isLatin1() && StringLatin1.canEncode(c)) {
value[offset] = (byte)c;
} else {
if (isLatin1()) {
inflate();
}
StringUTF16.putCharSB(value, offset, c);
}
return this;
}
public AbstractStringBuilder insert(int offset, int i) {
return insert(offset, String.valueOf(i));
}
public AbstractStringBuilder insert(int offset, long l) {
return insert(offset, String.valueOf(l));
}
public AbstractStringBuilder insert(int offset, float f) {
return insert(offset, String.valueOf(f));
}
public AbstractStringBuilder insert(int offset, double d) {
return insert(offset, String.valueOf(d));
}
public int indexOf(String str) {
return indexOf(str, 0);
}
public int indexOf(String str, int fromIndex) {
return String.indexOf(value, coder, count, str, fromIndex);
}
public int lastIndexOf(String str) {
return lastIndexOf(str, count);
}
public int lastIndexOf(String str, int fromIndex) {
return String.lastIndexOf(value, coder, count, str, fromIndex);
}
public AbstractStringBuilder reverse() {
byte[] val = this.value;
int count = this.count;
int n = count - 1;
if (isLatin1()) {
for (int j = (n-1) >> 1; j >= 0; j--) {
int k = n - j;
byte cj = val[j];
val[j] = val[k];
val[k] = cj;
}
} else {
StringUTF16.reverse(val, count);
}
return this;
}
@Override
public abstract String toString();
@Override
public IntStream chars() {
return StreamSupport.intStream(
() -> {
byte[] val = this.value;
int count = this.count;
byte coder = this.coder;
return coder == LATIN1
? new StringLatin1.CharsSpliterator(val, 0, count, 0)
: new StringUTF16.CharsSpliterator(val, 0, count, 0);
},
Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED,
false);
}
@Override
public IntStream codePoints() {
return StreamSupport.intStream(
() -> {
byte[] val = this.value;
int count = this.count;
byte coder = this.coder;
return coder == LATIN1
? new StringLatin1.CharsSpliterator(val, 0, count, 0)
: new StringUTF16.CodePointsSpliterator(val, 0, count, 0);
},
Spliterator.ORDERED,
false);
}
final byte[] getValue() {
return value;
}
void getBytes(byte[] dst, int dstBegin, byte coder) {
if (this.coder == coder) {
System.arraycopy(value, 0, dst, dstBegin << coder, count << coder);
} else {                    StringLatin1.inflate(value, 0, dst, dstBegin, count);
}
}
void initBytes(char[] value, int off, int len) {
if (String.COMPACT_STRINGS) {
this.value = StringUTF16.compress(value, off, len);
if (this.value != null) {
this.coder = LATIN1;
return;
}
}
this.coder = UTF16;
this.value = StringUTF16.toBytes(value, off, len);
}
final byte getCoder() {
return COMPACT_STRINGS ? coder : UTF16;
}
final boolean isLatin1() {
return COMPACT_STRINGS && coder == LATIN1;
}
private final void putCharsAt(int index, char[] s, int off, int end) {
if (isLatin1()) {
byte[] val = this.value;
for (int i = off, j = index; i < end; i++) {
char c = s[i];
if (StringLatin1.canEncode(c)) {
val[j++] = (byte)c;
} else {
inflate();
StringUTF16.putCharsSB(this.value, j, s, i, end);
return;
}
}
} else {
StringUTF16.putCharsSB(this.value, index, s, off, end);
}
}
private final void putCharsAt(int index, CharSequence s, int off, int end) {
if (isLatin1()) {
byte[] val = this.value;
for (int i = off, j = index; i < end; i++) {
char c = s.charAt(i);
if (StringLatin1.canEncode(c)) {
val[j++] = (byte)c;
} else {
inflate();
StringUTF16.putCharsSB(this.value, j, s, i, end);
return;
}
}
} else {
StringUTF16.putCharsSB(this.value, index, s, off, end);
}
}
private void inflateIfNeededFor(String input) {
if (COMPACT_STRINGS && (coder != input.coder())) {
inflate();
}
}
private void inflateIfNeededFor(AbstractStringBuilder input) {
if (COMPACT_STRINGS && (coder != input.getCoder())) {
inflate();
}
}
private void putStringAt(int index, String str, int off, int end) {
inflateIfNeededFor(str);
str.getBytes(value, off, index, coder, end - off);
}
private void putStringAt(int index, String str) {
inflateIfNeededFor(str);
str.getBytes(value, index, coder);
}
private final void appendChars(char[] s, int off, int end) {
int count = this.count;
if (isLatin1()) {
byte[] val = this.value;
for (int i = off, j = count; i < end; i++) {
char c = s[i];
if (StringLatin1.canEncode(c)) {
val[j++] = (byte)c;
} else {
this.count = count = j;
inflate();
StringUTF16.putCharsSB(this.value, j, s, i, end);
this.count = count + end - i;
return;
}
}
} else {
StringUTF16.putCharsSB(this.value, count, s, off, end);
}
this.count = count + end - off;
}
private final void appendChars(String s, int off, int end) {
if (isLatin1()) {
if (s.isLatin1()) {
System.arraycopy(s.value(), off, this.value, this.count, end - off);
} else {
byte[] val = this.value;
for (int i = off, j = count; i < end; i++) {
char c = s.charAt(i);
if (StringLatin1.canEncode(c)) {
val[j++] = (byte) c;
} else {
count = j;
inflate();
System.arraycopy(s.value(), i << UTF16, this.value, j << UTF16, (end - i) << UTF16);
count += end - i;
return;
}
}
}
} else if (s.isLatin1()) {
StringUTF16.putCharsSB(this.value, this.count, s, off, end);
} else {             System.arraycopy(s.value(), off << UTF16, this.value, this.count << UTF16, (end - off) << UTF16);
}
count += end - off;
}
private final void appendChars(CharSequence s, int off, int end) {
if (isLatin1()) {
byte[] val = this.value;
for (int i = off, j = count; i < end; i++) {
char c = s.charAt(i);
if (StringLatin1.canEncode(c)) {
val[j++] = (byte)c;
} else {
count = j;
inflate();
StringUTF16.putCharsSB(this.value, j, s, i, end);
count += end - i;
return;
}
}
} else {
StringUTF16.putCharsSB(this.value, count, s, off, end);
}
count += end - off;
}
}
package jdk.internal.net.http;
import java.util.concurrent.Flow;
import jdk.internal.net.http.common.Demand;
abstract class AbstractSubscription implements Flow.Subscription {
private final Demand demand = new Demand();
protected Demand demand() { return demand; }
}
package javax.swing.table;
import javax.swing.*;
import javax.swing.event.*;
import java.io.Serializable;
import java.util.EventListener;
@SuppressWarnings("serial") public abstract class AbstractTableModel implements TableModel, Serializable
{
protected EventListenerList listenerList = new EventListenerList();
protected AbstractTableModel() {}
public String getColumnName(int column) {
String result = "";
for (; column >= 0; column = column / 26 - 1) {
result = (char)((char)(column%26)+'A') + result;
}
return result;
}
public int findColumn(String columnName) {
for (int i = 0; i < getColumnCount(); i++) {
if (columnName.equals(getColumnName(i))) {
return i;
}
}
return -1;
}
public Class<?> getColumnClass(int columnIndex) {
return Object.class;
}
public boolean isCellEditable(int rowIndex, int columnIndex) {
return false;
}
public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
}
public void addTableModelListener(TableModelListener l) {
listenerList.add(TableModelListener.class, l);
}
public void removeTableModelListener(TableModelListener l) {
listenerList.remove(TableModelListener.class, l);
}
public TableModelListener[] getTableModelListeners() {
return listenerList.getListeners(TableModelListener.class);
}
public void fireTableDataChanged() {
fireTableChanged(new TableModelEvent(this));
}
public void fireTableStructureChanged() {
fireTableChanged(new TableModelEvent(this, TableModelEvent.HEADER_ROW));
}
public void fireTableRowsInserted(int firstRow, int lastRow) {
fireTableChanged(new TableModelEvent(this, firstRow, lastRow,
TableModelEvent.ALL_COLUMNS, TableModelEvent.INSERT));
}
public void fireTableRowsUpdated(int firstRow, int lastRow) {
fireTableChanged(new TableModelEvent(this, firstRow, lastRow,
TableModelEvent.ALL_COLUMNS, TableModelEvent.UPDATE));
}
public void fireTableRowsDeleted(int firstRow, int lastRow) {
fireTableChanged(new TableModelEvent(this, firstRow, lastRow,
TableModelEvent.ALL_COLUMNS, TableModelEvent.DELETE));
}
public void fireTableCellUpdated(int row, int column) {
fireTableChanged(new TableModelEvent(this, row, row, column));
}
public void fireTableChanged(TableModelEvent e) {
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==TableModelListener.class) {
((TableModelListener)listeners[i+1]).tableChanged(e);
}
}
}
public <T extends EventListener> T[] getListeners(Class<T> listenerType) {
return listenerList.getListeners(listenerType);
}
}
package java.util.stream;
import java.util.Spliterator;
import java.util.concurrent.CountedCompleter;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinWorkerThread;
@SuppressWarnings("serial")
abstract class AbstractTask<P_IN, P_OUT, R,
K extends AbstractTask<P_IN, P_OUT, R, K>>
extends CountedCompleter<R> {
private static final int LEAF_TARGET = ForkJoinPool.getCommonPoolParallelism() << 2;
protected final PipelineHelper<P_OUT> helper;
protected Spliterator<P_IN> spliterator;
protected long targetSize;
protected K leftChild;
protected K rightChild;
private R localResult;
protected AbstractTask(PipelineHelper<P_OUT> helper,
Spliterator<P_IN> spliterator) {
super(null);
this.helper = helper;
this.spliterator = spliterator;
this.targetSize = 0L;
}
protected AbstractTask(K parent,
Spliterator<P_IN> spliterator) {
super(parent);
this.spliterator = spliterator;
this.helper = parent.helper;
this.targetSize = parent.targetSize;
}
public static int getLeafTarget() {
Thread t = Thread.currentThread();
if (t instanceof ForkJoinWorkerThread) {
return ((ForkJoinWorkerThread) t).getPool().getParallelism() << 2;
}
else {
return LEAF_TARGET;
}
}
protected abstract K makeChild(Spliterator<P_IN> spliterator);
protected abstract R doLeaf();
public static long suggestTargetSize(long sizeEstimate) {
long est = sizeEstimate / getLeafTarget();
return est > 0L ? est : 1L;
}
protected final long getTargetSize(long sizeEstimate) {
long s;
return ((s = targetSize) != 0 ? s :
(targetSize = suggestTargetSize(sizeEstimate)));
}
@Override
public R getRawResult() {
return localResult;
}
@Override
protected void setRawResult(R result) {
if (result != null)
throw new IllegalStateException();
}
protected R getLocalResult() {
return localResult;
}
protected void setLocalResult(R localResult) {
this.localResult = localResult;
}
protected boolean isLeaf() {
return leftChild == null;
}
protected boolean isRoot() {
return getParent() == null;
}
@SuppressWarnings("unchecked")
protected K getParent() {
return (K) getCompleter();
}
@Override
public void compute() {
Spliterator<P_IN> rs = spliterator, ls;         long sizeEstimate = rs.estimateSize();
long sizeThreshold = getTargetSize(sizeEstimate);
boolean forkRight = false;
@SuppressWarnings("unchecked") K task = (K) this;
while (sizeEstimate > sizeThreshold && (ls = rs.trySplit()) != null) {
K leftChild, rightChild, taskToFork;
task.leftChild  = leftChild = task.makeChild(ls);
task.rightChild = rightChild = task.makeChild(rs);
task.setPendingCount(1);
if (forkRight) {
forkRight = false;
rs = ls;
task = leftChild;
taskToFork = rightChild;
}
else {
forkRight = true;
task = rightChild;
taskToFork = leftChild;
}
taskToFork.fork();
sizeEstimate = rs.estimateSize();
}
task.setLocalResult(task.doLeaf());
task.tryComplete();
}
@Override
public void onCompletion(CountedCompleter<?> caller) {
spliterator = null;
leftChild = rightChild = null;
}
protected boolean isLeftmostNode() {
@SuppressWarnings("unchecked")
K node = (K) this;
while (node != null) {
K parent = node.getParent();
if (parent != null && parent.leftChild != node)
return false;
node = parent;
}
return true;
}
}
package jdk.internal.org.jline.terminal.impl;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.nio.charset.Charset;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.IntConsumer;
import java.util.function.IntSupplier;
import jdk.internal.org.jline.terminal.Attributes;
import jdk.internal.org.jline.terminal.Attributes.ControlChar;
import jdk.internal.org.jline.terminal.Attributes.InputFlag;
import jdk.internal.org.jline.terminal.Attributes.LocalFlag;
import jdk.internal.org.jline.terminal.Cursor;
import jdk.internal.org.jline.terminal.MouseEvent;
import jdk.internal.org.jline.terminal.Terminal;
import jdk.internal.org.jline.utils.ColorPalette;
import jdk.internal.org.jline.utils.Curses;
import jdk.internal.org.jline.utils.InfoCmp;
import jdk.internal.org.jline.utils.InfoCmp.Capability;
import jdk.internal.org.jline.utils.Log;
import jdk.internal.org.jline.utils.Status;
public abstract class AbstractTerminal implements Terminal {
protected final String name;
protected final String type;
protected final Charset encoding;
protected final Map<Signal, SignalHandler> handlers = new ConcurrentHashMap<>();
protected final Set<Capability> bools = new HashSet<>();
protected final Map<Capability, Integer> ints = new HashMap<>();
protected final Map<Capability, String> strings = new HashMap<>();
protected final ColorPalette palette = new ColorPalette(this);
protected Status status;
protected Runnable onClose;
public AbstractTerminal(String name, String type) throws IOException {
this(name, type, null, SignalHandler.SIG_DFL);
}
public AbstractTerminal(String name, String type, Charset encoding, SignalHandler signalHandler) throws IOException {
this.name = name;
this.type = type != null ? type : "ansi";
this.encoding = encoding != null ? encoding : System.out.charset();
for (Signal signal : Signal.values()) {
handlers.put(signal, signalHandler);
}
}
public void setOnClose(Runnable onClose) {
this.onClose = onClose;
}
public Status getStatus() {
return getStatus(true);
}
public Status getStatus(boolean create) {
if (status == null && create) {
status = new Status(this);
}
return status;
}
public SignalHandler handle(Signal signal, SignalHandler handler) {
Objects.requireNonNull(signal);
Objects.requireNonNull(handler);
return handlers.put(signal, handler);
}
public void raise(Signal signal) {
Objects.requireNonNull(signal);
SignalHandler handler = handlers.get(signal);
if (handler != SignalHandler.SIG_DFL && handler != SignalHandler.SIG_IGN) {
handler.handle(signal);
}
if (status != null && signal == Signal.WINCH) {
status.resize();
}
}
public final void close() throws IOException {
try {
doClose();
} finally {
if (onClose != null) {
onClose.run();
}
}
}
protected void doClose() throws IOException {
if (status != null) {
status.update(null);
flush();
}
}
protected void echoSignal(Signal signal) {
ControlChar cc = null;
switch (signal) {
case INT:
cc = ControlChar.VINTR;
break;
case QUIT:
cc = ControlChar.VQUIT;
break;
case TSTP:
cc = ControlChar.VSUSP;
break;
}
if (cc != null) {
int vcc = getAttributes().getControlChar(cc);
if (vcc > 0 && vcc < 32) {
writer().write(new char[]{'^', (char) (vcc + '@')}, 0, 2);
}
}
}
public Attributes enterRawMode() {
Attributes prvAttr = getAttributes();
Attributes newAttr = new Attributes(prvAttr);
newAttr.setLocalFlags(EnumSet.of(LocalFlag.ICANON, LocalFlag.ECHO, LocalFlag.IEXTEN), false);
newAttr.setInputFlags(EnumSet.of(InputFlag.IXON, InputFlag.ICRNL, InputFlag.INLCR), false);
newAttr.setControlChar(ControlChar.VMIN, 0);
newAttr.setControlChar(ControlChar.VTIME, 1);
setAttributes(newAttr);
return prvAttr;
}
public boolean echo() {
return getAttributes().getLocalFlag(LocalFlag.ECHO);
}
public boolean echo(boolean echo) {
Attributes attr = getAttributes();
boolean prev = attr.getLocalFlag(LocalFlag.ECHO);
if (prev != echo) {
attr.setLocalFlag(LocalFlag.ECHO, echo);
setAttributes(attr);
}
return prev;
}
public String getName() {
return name;
}
public String getType() {
return type;
}
public String getKind() {
return getClass().getSimpleName();
}
@Override
public Charset encoding() {
return this.encoding;
}
public void flush() {
writer().flush();
}
public boolean puts(Capability capability, Object... params) {
String str = getStringCapability(capability);
if (str == null) {
return false;
}
Curses.tputs(writer(), str, params);
return true;
}
public boolean getBooleanCapability(Capability capability) {
return bools.contains(capability);
}
public Integer getNumericCapability(Capability capability) {
return ints.get(capability);
}
public String getStringCapability(Capability capability) {
return strings.get(capability);
}
protected void parseInfoCmp() {
String capabilities = null;
try {
capabilities = InfoCmp.getInfoCmp(type);
} catch (Exception e) {
Log.warn("Unable to retrieve infocmp for type " + type, e);
}
if (capabilities == null) {
capabilities = InfoCmp.getLoadedInfoCmp("ansi");
}
InfoCmp.parseInfoCmp(capabilities, bools, ints, strings);
}
@Override
public Cursor getCursorPosition(IntConsumer discarded) {
return null;
}
private MouseEvent lastMouseEvent = new MouseEvent(
MouseEvent.Type.Moved, MouseEvent.Button.NoButton,
EnumSet.noneOf(MouseEvent.Modifier.class), 0, 0);
@Override
public boolean hasMouseSupport() {
return MouseSupport.hasMouseSupport(this);
}
@Override
public boolean trackMouse(MouseTracking tracking) {
return MouseSupport.trackMouse(this, tracking);
}
@Override
public MouseEvent readMouseEvent() {
return lastMouseEvent = MouseSupport.readMouse(this, lastMouseEvent);
}
@Override
public MouseEvent readMouseEvent(IntSupplier reader) {
return lastMouseEvent = MouseSupport.readMouse(reader, lastMouseEvent);
}
@Override
public boolean hasFocusSupport() {
return type.startsWith("xterm");
}
@Override
public boolean trackFocus(boolean tracking) {
if (hasFocusSupport()) {
writer().write(tracking ? "\033[?1004h" : "\033[?1004l");
writer().flush();
return true;
} else {
return false;
}
}
protected void checkInterrupted() throws InterruptedIOException {
if (Thread.interrupted()) {
throw new InterruptedIOException();
}
}
@Override
public boolean canPauseResume() {
return false;
}
@Override
public void pause() {
}
@Override
public void pause(boolean wait) throws InterruptedException {
}
@Override
public void resume() {
}
@Override
public boolean paused() {
return false;
}
@Override
public ColorPalette getPalette() {
return palette;
}
}
package compiler.lib.ir_framework.test;
import compiler.lib.ir_framework.*;
import compiler.lib.ir_framework.shared.TestRun;
import compiler.lib.ir_framework.shared.TestRunException;
import jdk.test.whitebox.WhiteBox;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
abstract class AbstractTest {
protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
protected static final int TEST_COMPILATION_TIMEOUT = Integer.parseInt(System.getProperty("TestCompilationTimeout", "10000"));
protected static final int WAIT_FOR_COMPILATION_TIMEOUT = Integer.parseInt(System.getProperty("WaitForCompilationTimeout", "10000"));
protected static final boolean VERIFY_OOPS = (Boolean)WHITE_BOX.getVMFlag("VerifyOops");
protected final int warmupIterations;
protected final boolean skip;
AbstractTest(int warmupIterations, boolean skip) {
this.warmupIterations = warmupIterations;
this.skip = skip;
}
protected boolean shouldCompile(DeclaredTest test) {
return test.getCompLevel() != CompLevel.SKIP;
}
abstract String getName();
public boolean isSkipped() {
return skip;
}
protected static boolean isWaitForCompilation(DeclaredTest test) {
return test.getCompLevel() == CompLevel.WAIT_FOR_COMPILATION;
}
protected static Object createInvocationTarget(Method method) {
Class<?> clazz = method.getDeclaringClass();
Object invocationTarget;
if (Modifier.isStatic(method.getModifiers())) {
invocationTarget = null;
} else {
try {
Constructor<?> constructor = clazz.getDeclaredConstructor();
constructor.setAccessible(true);
invocationTarget = constructor.newInstance();
} catch (Exception e) {
throw new TestRunException("Could not create instance of " + clazz
+ ". Make sure there is a constructor without arguments.", e);
}
}
return invocationTarget;
}
public void run() {
if (skip) {
return;
}
onStart();
for (int i = 0; i < warmupIterations; i++) {
invokeTest();
}
onWarmupFinished();
compileTest();
invokeTest();
}
protected void onStart() {
}
abstract protected void invokeTest();
abstract protected void onWarmupFinished();
abstract protected void compileTest();
protected void compileMethod(DeclaredTest test) {
final Method testMethod = test.getTestMethod();
TestRun.check(WHITE_BOX.isMethodCompilable(testMethod, test.getCompLevel().getValue(), false),
"Method " + testMethod + " not compilable at level " + test.getCompLevel()
+ ". Did you use compileonly without including all @Test methods?");
TestRun.check(WHITE_BOX.isMethodCompilable(testMethod),
"Method " + testMethod + " not compilable at level " + test.getCompLevel()
+ ". Did you use compileonly without including all @Test methods?");
if (TestFramework.VERBOSE) {
System.out.println("Compile method " + testMethod + " after warm-up...");
}
final boolean maybeCodeBufferOverflow = (TestVM.TEST_C1 && VERIFY_OOPS);
final long started = System.currentTimeMillis();
long elapsed = 0;
int lastCompilationLevel = -10;
enqueueMethodForCompilation(test);
do {
if (!WHITE_BOX.isMethodQueuedForCompilation(testMethod)) {
if (elapsed > 0) {
if (TestVM.VERBOSE) {
System.out.println(testMethod + " is not in queue anymore due to compiling it simultaneously on " +
"a different level. Enqueue again.");
}
enqueueMethodForCompilation(test);
}
}
if (maybeCodeBufferOverflow && elapsed > 1000 && !WHITE_BOX.isMethodCompiled(testMethod, false)) {
WHITE_BOX.setBooleanVMFlag("VerifyOops", false);
WHITE_BOX.clearMethodState(testMethod);
enqueueMethodForCompilation(test);
WHITE_BOX.setBooleanVMFlag("VerifyOops", true);
}
lastCompilationLevel = WHITE_BOX.getMethodCompilationLevel(testMethod, false);
if (lastCompilationLevel == test.getCompLevel().getValue()) {
break;
}
elapsed = System.currentTimeMillis() - started;
} while (elapsed < TEST_COMPILATION_TIMEOUT);
TestRun.check(elapsed < TEST_COMPILATION_TIMEOUT,
"Could not compile " + testMethod + " at level " + test.getCompLevel() + " after "
+ TEST_COMPILATION_TIMEOUT/1000 + "s. Last compilation level: " + lastCompilationLevel);
checkCompilationLevel(test);
}
private void enqueueMethodForCompilation(DeclaredTest test) {
TestVM.enqueueForCompilation(test.getTestMethod(), test.getCompLevel());
}
protected void checkCompilationLevel(DeclaredTest test) {
CompLevel level = CompLevel.forValue(WHITE_BOX.getMethodCompilationLevel(test.getTestMethod()));
TestRun.check(level == test.getCompLevel(),  "Compilation level should be " + test.getCompLevel().name()
+ " (requested) but was " + level.name() + " for " + test.getTestMethod());
}
final protected void waitForCompilation(DeclaredTest test) {
final Method testMethod = test.getTestMethod();
final boolean maybeCodeBufferOverflow = (TestVM.TEST_C1 && VERIFY_OOPS);
final long started = System.currentTimeMillis();
boolean stateCleared = false;
long elapsed;
do {
elapsed = System.currentTimeMillis() - started;
int level = WHITE_BOX.getMethodCompilationLevel(testMethod);
if (maybeCodeBufferOverflow && elapsed > 5000
&& (!WHITE_BOX.isMethodCompiled(testMethod, false) || level != test.getCompLevel().getValue())) {
retryDisabledVerifyOops(testMethod, stateCleared);
stateCleared = true;
} else {
invokeTest();
}
boolean isCompiled = WHITE_BOX.isMethodCompiled(testMethod, false);
if (TestVM.VERBOSE) {
System.out.println("Is " + testMethod + " compiled? " + isCompiled);
}
if (isCompiled || TestVM.XCOMP || TestVM.EXCLUDE_RANDOM) {
return;
}
} while (elapsed < WAIT_FOR_COMPILATION_TIMEOUT);
throw new TestRunException(testMethod + " not compiled after waiting for "
+ WAIT_FOR_COMPILATION_TIMEOUT/1000 + " s");
}
private void retryDisabledVerifyOops(Method testMethod, boolean stateCleared) {
System.out.println("Temporarily disabling VerifyOops");
try {
WHITE_BOX.setBooleanVMFlag("VerifyOops", false);
if (!stateCleared) {
WHITE_BOX.clearMethodState(testMethod);
}
invokeTest();
} finally {
WHITE_BOX.setBooleanVMFlag("VerifyOops", true);
System.out.println("Re-enabled VerifyOops");
}
}
}
package compiler.compilercontrol.share;
import compiler.compilercontrol.share.method.MethodDescriptor;
import compiler.compilercontrol.share.method.MethodGenerator;
import compiler.compilercontrol.share.pool.PoolHelper;
import jdk.test.lib.util.Pair;
import java.lang.reflect.Executable;
import java.util.List;
import java.util.concurrent.Callable;
public abstract class AbstractTestBase {
protected static final MethodGenerator METHOD_GEN = new MethodGenerator();
protected static final int ATTEMPTS = 25;
protected static final List<Pair<Executable, Callable<?>>> METHODS
= new PoolHelper().getAllMethods(PoolHelper.METHOD_FILTER);
public abstract void test();
public static MethodDescriptor getValidMethodDescriptor(Executable exec) {
MethodDescriptor md = METHOD_GEN.generateRandomDescriptor(exec);
for (int i = 0; !md.isValid() && i < ATTEMPTS; i++) {
md = METHOD_GEN.generateRandomDescriptor(exec);
}
if (!md.isValid() || "any.method()".matches(md.getRegexp())) {
md = MethodGenerator.commandDescriptor(exec);
}
return md;
}
}
package com.sun.org.apache.xalan.internal.xsltc.runtime;
import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.DOMCache;
import com.sun.org.apache.xalan.internal.xsltc.DOMEnhancedForDTM;
import com.sun.org.apache.xalan.internal.xsltc.Translet;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.dom.DOMAdapter;
import com.sun.org.apache.xalan.internal.xsltc.dom.KeyIndex;
import com.sun.org.apache.xalan.internal.xsltc.runtime.output.TransletOutputHandlerFactory;
import com.sun.org.apache.xml.internal.dtm.DTM;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Templates;
import jdk.xml.internal.JdkConstants;
import jdk.xml.internal.JdkXmlUtils;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;
public abstract class AbstractTranslet implements Translet {
public String  _version = "1.0";
public String  _method = null;
public String  _encoding = "UTF-8";
public boolean _omitHeader = false;
public String  _standalone = null;
public boolean  _isStandalone = false;
public String  _doctypePublic = null;
public String  _doctypeSystem = null;
public boolean _indent = false;
public String  _mediaType = null;
public List<String> _cdata = null;
public int _indentamount = -1;
public static final int FIRST_TRANSLET_VERSION = 100;
public static final int VER_SPLIT_NAMES_ARRAY = 101;
public static final int CURRENT_TRANSLET_VERSION = VER_SPLIT_NAMES_ARRAY;
protected int transletVersion = FIRST_TRANSLET_VERSION;
protected String[] namesArray;
protected String[] urisArray;
protected int[]    typesArray;
protected String[] namespaceArray;
protected Templates _templates = null;
protected boolean _hasIdCall = false;
protected StringValueHandler stringValueHandler = new StringValueHandler();
private final static String EMPTYSTRING = "";
private final static String ID_INDEX_NAME = "##id";
private boolean _overrideDefaultParser;
private FileOutputStream output = null;
private String _accessExternalStylesheet = JdkConstants.EXTERNAL_ACCESS_DEFAULT;
private String _accessErr = null;
public void printInternalState() {
System.out.println("-------------------------------------");
System.out.println("AbstractTranslet this = " + this);
System.out.println("pbase = " + pbase);
System.out.println("vframe = " + pframe);
System.out.println("paramsStack.size() = " + paramsStack.size());
System.out.println("namesArray.size = " + namesArray.length);
System.out.println("namespaceArray.size = " + namespaceArray.length);
System.out.println("");
System.out.println("Total memory = " + Runtime.getRuntime().totalMemory());
}
public final DOMAdapter makeDOMAdapter(DOM dom)
throws TransletException {
setRootForKeys(dom.getDocument());
return new DOMAdapter(dom, namesArray, urisArray, typesArray, namespaceArray);
}
protected int pbase = 0, pframe = 0;
protected List<Object> paramsStack = new ArrayList<>();
public final void pushParamFrame() {
paramsStack.add(pframe, pbase);
pbase = ++pframe;
}
public final void popParamFrame() {
if (pbase > 0) {
final int oldpbase = ((Integer)paramsStack.get(--pbase));
for (int i = pframe - 1; i >= pbase; i--) {
paramsStack.remove(i);
}
pframe = pbase; pbase = oldpbase;
}
}
public final Object addParameter(String name, Object value) {
name = BasisLibrary.mapQNameToJavaName (name);
return addParameter(name, value, false);
}
public final Object addParameter(String name, Object value,
boolean isDefault)
{
for (int i = pframe - 1; i >= pbase; i--) {
final Parameter param = (Parameter) paramsStack.get(i);
if (param._name.equals(name)) {
if (param._isDefault || !isDefault) {
param._value = value;
param._isDefault = isDefault;
return value;
}
return param._value;
}
}
paramsStack.add(pframe++, new Parameter(name, value, isDefault));
return value;
}
public void clearParameters() {
pbase = pframe = 0;
paramsStack.clear();
}
public final Object getParameter(String name) {
name = BasisLibrary.mapQNameToJavaName (name);
for (int i = pframe - 1; i >= pbase; i--) {
final Parameter param = (Parameter)paramsStack.get(i);
if (param._name.equals(name)) return param._value;
}
return null;
}
private MessageHandler _msgHandler = null;
public final void setMessageHandler(MessageHandler handler) {
_msgHandler = handler;
}
public final void displayMessage(String msg) {
if (_msgHandler == null) {
System.err.println(msg);
}
else {
_msgHandler.displayMessage(msg);
}
}
public Map<String, DecimalFormat> _formatSymbols = null;
public void addDecimalFormat(String name, DecimalFormatSymbols symbols) {
if (_formatSymbols == null) _formatSymbols = new HashMap<>();
if (name == null) name = EMPTYSTRING;
final DecimalFormat df = new DecimalFormat();
if (symbols != null) {
df.setDecimalFormatSymbols(symbols);
}
_formatSymbols.put(name, df);
}
public final DecimalFormat getDecimalFormat(String name) {
if (_formatSymbols != null) {
if (name == null) name = EMPTYSTRING;
DecimalFormat df = _formatSymbols.get(name);
if (df == null) df = _formatSymbols.get(EMPTYSTRING);
return df;
}
return(null);
}
public final void prepassDocument(DOM document) {
setIndexSize(document.getSize());
buildIDIndex(document);
}
private final void buildIDIndex(DOM document) {
setRootForKeys(document.getDocument());
if (document instanceof DOMEnhancedForDTM) {
DOMEnhancedForDTM enhancedDOM = (DOMEnhancedForDTM)document;
if (enhancedDOM.hasDOMSource()) {
buildKeyIndex(ID_INDEX_NAME, document);
return;
}
else {
final Map<String, Integer> elementsByID = enhancedDOM.getElementsWithIDs();
if (elementsByID == null) {
return;
}
boolean hasIDValues = false;
for (Map.Entry<String, Integer> entry : elementsByID.entrySet()) {
final int element = document.getNodeHandle(entry.getValue());
buildKeyIndex(ID_INDEX_NAME, element, entry.getKey());
hasIDValues = true;
}
if (hasIDValues) {
setKeyIndexDom(ID_INDEX_NAME, document);
}
}
}
}
public final void postInitialization() {
if (transletVersion < VER_SPLIT_NAMES_ARRAY) {
int arraySize = namesArray.length;
String[] newURIsArray = new String[arraySize];
String[] newNamesArray = new String[arraySize];
int[] newTypesArray = new int[arraySize];
for (int i = 0; i < arraySize; i++) {
String name = namesArray[i];
int colonIndex = name.lastIndexOf(':');
int lNameStartIdx = colonIndex+1;
if (colonIndex > -1) {
newURIsArray[i] = name.substring(0, colonIndex);
}
if (name.charAt(lNameStartIdx) == '@') {
lNameStartIdx++;
newTypesArray[i] = DTM.ATTRIBUTE_NODE;
} else if (name.charAt(lNameStartIdx) == '?') {
lNameStartIdx++;
newTypesArray[i] = DTM.NAMESPACE_NODE;
} else {
newTypesArray[i] = DTM.ELEMENT_NODE;
}
newNamesArray[i] =
(lNameStartIdx == 0) ? name
: name.substring(lNameStartIdx);
}
namesArray = newNamesArray;
urisArray  = newURIsArray;
typesArray = newTypesArray;
}
if (transletVersion > CURRENT_TRANSLET_VERSION) {
BasisLibrary.runTimeError(BasisLibrary.UNKNOWN_TRANSLET_VERSION_ERR,
this.getClass().getName());
}
}
private Map<String, KeyIndex> _keyIndexes = null;
private KeyIndex  _emptyKeyIndex = null;
private int       _indexSize = 0;
private int       _currentRootForKeys = 0;
public void setIndexSize(int size) {
if (size > _indexSize) _indexSize = size;
}
public KeyIndex createKeyIndex() {
return(new KeyIndex(_indexSize));
}
public void buildKeyIndex(String name, int node, String value) {
KeyIndex index = buildKeyIndexHelper(name);
index.add(value, node, _currentRootForKeys);
}
public void buildKeyIndex(String name, DOM dom) {
KeyIndex index = buildKeyIndexHelper(name);
index.setDom(dom, dom.getDocument());
}
private KeyIndex buildKeyIndexHelper(String name) {
if (_keyIndexes == null) _keyIndexes = new HashMap<>();
KeyIndex index = _keyIndexes.get(name);
if (index == null) {
_keyIndexes.put(name, index = new KeyIndex(_indexSize));
}
return index;
}
public KeyIndex getKeyIndex(String name) {
if (_keyIndexes == null) {
return (_emptyKeyIndex != null)
? _emptyKeyIndex
: (_emptyKeyIndex = new KeyIndex(1));
}
final KeyIndex index = _keyIndexes.get(name);
if (index == null) {
return (_emptyKeyIndex != null)
? _emptyKeyIndex
: (_emptyKeyIndex = new KeyIndex(1));
}
return(index);
}
private void setRootForKeys(int root) {
_currentRootForKeys = root;
}
public void buildKeys(DOM document, DTMAxisIterator iterator,
SerializationHandler handler,
int root) throws TransletException {
}
public void setKeyIndexDom(String name, DOM document) {
getKeyIndex(name).setDom(document, document.getDocument());
}
private DOMCache _domCache = null;
public void setDOMCache(DOMCache cache) {
_domCache = cache;
}
public DOMCache getDOMCache() {
return(_domCache);
}
public SerializationHandler openOutputHandler(String filename, boolean append)
throws TransletException
{
try {
final TransletOutputHandlerFactory factory = TransletOutputHandlerFactory
.newInstance(_overrideDefaultParser, _msgHandler.getErrorListener());
String dirStr = new File(filename).getParent();
if ((null != dirStr) && (dirStr.length() > 0)) {
File dir = new File(dirStr);
dir.mkdirs();
}
output = new FileOutputStream(filename, append);
factory.setEncoding(_encoding);
factory.setOutputMethod(_method);
factory.setOutputStream(new BufferedOutputStream(output));
factory.setOutputType(TransletOutputHandlerFactory.STREAM);
final SerializationHandler handler
= factory.getSerializationHandler();
transferOutputSettings(handler);
handler.startDocument();
return handler;
}
catch (Exception e) {
throw new TransletException(e);
}
}
public SerializationHandler openOutputHandler(String filename)
throws TransletException
{
return openOutputHandler(filename, false);
}
public void closeOutputHandler(SerializationHandler handler) {
try {
handler.endDocument();
handler.close();
if (output != null) {
output.close();
}
}
catch (Exception e) {
}
}
public abstract void transform(DOM document, DTMAxisIterator iterator,
SerializationHandler handler)
throws TransletException;
public final void transform(DOM document, SerializationHandler handler)
throws TransletException {
try {
transform(document, document.getIterator(), handler);
} finally {
_keyIndexes = null;
}
}
public final void characters(final String string,
SerializationHandler handler)
throws TransletException {
if (string != null) {
try {
handler.characters(string);
} catch (Exception e) {
throw new TransletException(e);
}
}
}
public void addCdataElement(String name) {
if (_cdata == null) {
_cdata = new ArrayList<>();
}
int lastColon = name.lastIndexOf(':');
if (lastColon > 0) {
String uri = name.substring(0, lastColon);
String localName = name.substring(lastColon+1);
_cdata.add(uri);
_cdata.add(localName);
} else {
_cdata.add(null);
_cdata.add(name);
}
}
protected void transferOutputSettings(SerializationHandler handler) {
if (_method != null) {
if (_method.equals("xml")) {
if (_standalone != null) {
handler.setStandalone(_standalone);
}
if (_omitHeader) {
handler.setOmitXMLDeclaration(true);
}
handler.setCdataSectionElements(_cdata);
if (_version != null) {
handler.setVersion(_version);
}
handler.setIndent(_indent);
if (_indentamount >= 0)
handler.setIndentAmount(_indentamount);
if (_doctypeSystem != null) {
handler.setDoctype(_doctypeSystem, _doctypePublic);
}
handler.setIsStandalone(_isStandalone);
}
else if (_method.equals("html")) {
handler.setIndent(_indent);
handler.setDoctype(_doctypeSystem, _doctypePublic);
if (_mediaType != null) {
handler.setMediaType(_mediaType);
}
}
}
else {
handler.setCdataSectionElements(_cdata);
if (_version != null) {
handler.setVersion(_version);
}
if (_standalone != null) {
handler.setStandalone(_standalone);
}
if (_omitHeader) {
handler.setOmitXMLDeclaration(true);
}
handler.setIndent(_indent);
handler.setDoctype(_doctypeSystem, _doctypePublic);
handler.setIsStandalone(_isStandalone);
}
}
private Map<String, Class<?>> _auxClasses = null;
public void addAuxiliaryClass(Class<?> auxClass) {
if (_auxClasses == null) _auxClasses = new HashMap<>();
_auxClasses.put(auxClass.getName(), auxClass);
}
public void setAuxiliaryClasses(Map<String, Class<?>> auxClasses) {
_auxClasses = auxClasses;
}
public Class<?> getAuxiliaryClass(String className) {
if (_auxClasses == null) return null;
return((Class)_auxClasses.get(className));
}
public String[] getNamesArray() {
return namesArray;
}
public String[] getUrisArray() {
return urisArray;
}
public int[] getTypesArray() {
return typesArray;
}
public String[] getNamespaceArray() {
return namespaceArray;
}
public boolean hasIdCall() {
return _hasIdCall;
}
public Templates getTemplates() {
return _templates;
}
public void setTemplates(Templates templates) {
_templates = templates;
}
public boolean overrideDefaultParser() {
return _overrideDefaultParser;
}
public void setOverrideDefaultParser(boolean flag) {
_overrideDefaultParser = flag;
}
public String getAllowedProtocols() {
return _accessExternalStylesheet;
}
public void setAllowedProtocols(String protocols) {
_accessExternalStylesheet = protocols;
}
public String getAccessError() {
return _accessErr;
}
public void setAccessError(String accessErr) {
this._accessErr = accessErr;
}
protected DOMImplementation _domImplementation = null;
public Document newDocument(String uri, String qname)
throws ParserConfigurationException
{
if (_domImplementation == null) {
DocumentBuilderFactory dbf = JdkXmlUtils.getDOMFactory(_overrideDefaultParser);
_domImplementation = dbf.newDocumentBuilder().getDOMImplementation();
}
return _domImplementation.createDocument(uri, qname, null);
}
}
package sun.jvm.hotspot.ui.treetable;
import javax.swing.tree.*;
import javax.swing.event.*;
public abstract class AbstractTreeTableModel implements TreeTableModel {
protected Object root;
protected EventListenerList listenerList = new EventListenerList();
public AbstractTreeTableModel(Object root) {
this.root = root;
}
public Object getRoot() {
return root;
}
public boolean isLeaf(Object node) {
return getChildCount(node) == 0;
}
public void valueForPathChanged(TreePath path, Object newValue) {}
public int getIndexOfChild(Object parent, Object child) {
for (int i = 0; i < getChildCount(parent); i++) {
if (getChild(parent, i).equals(child)) {
return i;
}
}
return -1;
}
public void addTreeModelListener(TreeModelListener l) {
listenerList.add(TreeModelListener.class, l);
}
public void removeTreeModelListener(TreeModelListener l) {
listenerList.remove(TreeModelListener.class, l);
}
protected void fireTreeNodesChanged(Object source, Object[] path,
int[] childIndices,
Object[] children) {
Object[] listeners = listenerList.getListenerList();
TreeModelEvent e = null;
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==TreeModelListener.class) {
if (e == null)
e = new TreeModelEvent(source, path,
childIndices, children);
((TreeModelListener)listeners[i+1]).treeNodesChanged(e);
}
}
}
protected void fireTreeNodesInserted(Object source, Object[] path,
int[] childIndices,
Object[] children) {
Object[] listeners = listenerList.getListenerList();
TreeModelEvent e = null;
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==TreeModelListener.class) {
if (e == null)
e = new TreeModelEvent(source, path,
childIndices, children);
((TreeModelListener)listeners[i+1]).treeNodesInserted(e);
}
}
}
protected void fireTreeNodesRemoved(Object source, Object[] path,
int[] childIndices,
Object[] children) {
Object[] listeners = listenerList.getListenerList();
TreeModelEvent e = null;
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==TreeModelListener.class) {
if (e == null)
e = new TreeModelEvent(source, path,
childIndices, children);
((TreeModelListener)listeners[i+1]).treeNodesRemoved(e);
}
}
}
protected void fireTreeStructureChanged(Object source, Object[] path,
int[] childIndices,
Object[] children) {
Object[] listeners = listenerList.getListenerList();
TreeModelEvent e = null;
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==TreeModelListener.class) {
if (e == null)
e = new TreeModelEvent(source, path,
childIndices, children);
((TreeModelListener)listeners[i+1]).treeStructureChanged(e);
}
}
}
public Class getColumnClass(int column) { return Object.class; }
public boolean isCellEditable(Object node, int column) {
return getColumnClass(column) == TreeTableModel.class;
}
public void setValueAt(Object aValue, Object node, int column) {}
}
package jdk.javadoc.internal.doclets.formats.html;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
import jdk.javadoc.internal.doclets.formats.html.markup.TagName;
import jdk.javadoc.internal.doclets.toolkit.Content;
import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;
import jdk.javadoc.internal.doclets.toolkit.util.ClassTree.Hierarchy;
import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
import javax.lang.model.element.TypeElement;
import java.util.Collection;
import java.util.SortedSet;
import java.util.TreeSet;
public abstract class AbstractTreeWriter extends HtmlDocletWriter {
protected final ClassTree classTree;
protected AbstractTreeWriter(HtmlConfiguration configuration,
DocPath filename, ClassTree classTree) {
super(configuration, filename);
this.classTree = classTree;
}
protected void addLevelInfo(TypeElement parent, Collection<TypeElement> collection,
Hierarchy hierarchy, Content content) {
if (!collection.isEmpty()) {
var ul = new HtmlTree(TagName.UL);
for (TypeElement local : collection) {
var li = new HtmlTree(TagName.LI);
li.setStyle(HtmlStyle.circle);
addPartialInfo(local, li);
addExtendsImplements(parent, local, li);
addLevelInfo(local, hierarchy.subtypes(local), hierarchy, li);                   ul.add(li);
}
content.add(ul);
}
}
protected void addTree(Hierarchy hierarchy, String heading, Content content) {
SortedSet<TypeElement> roots = hierarchy.roots();
if (!roots.isEmpty()) {
TypeElement firstTypeElement = roots.first();
Content headingContent = contents.getContent(heading);
var sectionHeading = HtmlTree.HEADING_TITLE(Headings.CONTENT_HEADING,
headingContent);
var section = HtmlTree.SECTION(HtmlStyle.hierarchy, sectionHeading);
addLevelInfo(!utils.isPlainInterface(firstTypeElement) ? firstTypeElement : null,
roots, hierarchy, section);
content.add(section);
}
}
protected void addExtendsImplements(TypeElement parent,
TypeElement typeElement,
Content content)
{
SortedSet<TypeElement> interfaces = new TreeSet<>(comparators.makeGeneralPurposeComparator());
typeElement.getInterfaces().forEach(t -> interfaces.add(utils.asTypeElement(t)));
if (interfaces.size() > (utils.isPlainInterface(typeElement) ? 1 : 0)) {
boolean isFirst = true;
for (TypeElement intf : interfaces) {
if (parent != intf) {
if (utils.isPublic(intf) || utils.isLinkable(intf)) {
if (isFirst) {
isFirst = false;
if (utils.isPlainInterface(typeElement)) {
content.add(" (");
content.add(contents.also);
content.add(" extends ");
} else {
content.add(" (implements ");
}
} else {
content.add(", ");
}
addPreQualifiedClassLink(HtmlLinkInfo.Kind.TREE, intf, content);
}
}
}
if (!isFirst) {
content.add(")");
}
}
}
protected void addPartialInfo(TypeElement typeElement, Content content) {
addPreQualifiedStrongClassLink(HtmlLinkInfo.Kind.TREE, typeElement, content);
}
}
package build.tools.jdwpgen;
import java.util.*;
import java.io.*;
abstract class AbstractTypeListNode extends AbstractNamedNode {
void constrainComponent(Context ctx, Node node) {
if (node instanceof TypeNode) {
node.constrain(ctx);
} else {
error("Expected type descriptor item, got: " + node);
}
}
void document(PrintWriter writer) {
writer.println("<dt>" + name() + " Data");
writer.println("<dd>");
if (components.isEmpty()) {
writer.println("(None)");
} else {
writer.println("<table><tr>");
writer.println("<th class=\"bold\" style=\"width: 20%\" scope=\"col\">Type");
writer.println("<th class=\"bold\" style=\"width: 15%\" scope=\"col\">Name");
writer.println("<th class=\"bold\" style=\"width: 65%\" scope=\"col\">Description");
writer.println("</tr>");
for (Node node : components) {
node.document(writer);
}
writer.println("</table>");
}
writer.println("</dd>");
}
void genJavaClassBodyComponents(PrintWriter writer, int depth) {
for (Node node : components) {
TypeNode tn = (TypeNode)node;
tn.genJavaDeclaration(writer, depth);
}
}
void genJavaReads(PrintWriter writer, int depth) {
for (Node node : components) {
TypeNode tn = (TypeNode)node;
tn.genJavaRead(writer, depth, tn.name());
}
}
void genJavaReadingClassBody(PrintWriter writer, int depth,
String className) {
genJavaClassBodyComponents(writer, depth);
writer.println();
indent(writer, depth);
if (!context.inEvent()) {
writer.print("private ");
}
writer.println(className +
"(VirtualMachineImpl vm, PacketStream ps) {");
genJavaReads(writer, depth+1);
indent(writer, depth);
writer.println("}");
}
String javaParams() {
StringBuffer sb = new StringBuffer();
for (Iterator<Node> it = components.iterator(); it.hasNext();) {
TypeNode tn = (TypeNode)it.next();
sb.append(tn.javaParam());
if (it.hasNext()) {
sb.append(", ");
}
}
return sb.toString();
}
void genJavaWrites(PrintWriter writer, int depth) {
for (Node node : components) {
TypeNode tn = (TypeNode)node;
tn.genJavaWrite(writer, depth, tn.name());
}
}
void genJavaWritingClassBody(PrintWriter writer, int depth,
String className) {
genJavaClassBodyComponents(writer, depth);
writer.println();
indent(writer, depth);
writer.println(className + "(" + javaParams() + ") {");
for (Node node : components) {
TypeNode tn = (TypeNode)node;
indent(writer, depth+1);
writer.println("this." + tn.name() + " = " + tn.name() + ";");
}
indent(writer, depth);
writer.println("}");
}
}
package build.tools.jdwpgen;
import java.util.*;
import java.io.*;
abstract class AbstractTypeNode extends AbstractNamedNode
implements TypeNode {
abstract String docType();
public abstract void genJavaWrite(PrintWriter writer, int depth,
String writeLabel);
abstract String javaRead();
void document(PrintWriter writer) {
writer.println("<tr>");
writer.println("<td>" + indentElement(structIndent, docType()));
writer.println("<th scope=\"row\"><i>" + name() + "</i>");
writer.println("<td>" + comment() + "&nbsp;");
writer.println("</tr>");
}
String javaType() {
return docType();     }
public void genJavaRead(PrintWriter writer, int depth,
String readLabel) {
indent(writer, depth);
writer.print(readLabel);
writer.print(" = ");
writer.print(javaRead());
writer.println(";");
genJavaDebugRead(writer, depth, readLabel, debugValue(readLabel));
}
public void genJavaDeclaration(PrintWriter writer, int depth) {
writer.println();
genJavaComment(writer, depth);
indent(writer, depth);
writer.print("final ");
writer.print(javaType());
writer.print(" " + name);
writer.println(";");
}
public String javaParam() {
return javaType() + " " + name;
}
}
package javax.lang.model.util;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import static javax.lang.model.SourceVersion.*;
@SupportedSourceVersion(RELEASE_20)
public abstract class AbstractTypeVisitor14<R, P> extends AbstractTypeVisitor9<R, P> {
protected AbstractTypeVisitor14() {
super();
}
}
package javax.lang.model.util;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.type.*;
import static javax.lang.model.SourceVersion.*;
@SupportedSourceVersion(RELEASE_6)
public abstract class AbstractTypeVisitor6<R, P> implements TypeVisitor<R, P> {
@Deprecated(since="9")
protected AbstractTypeVisitor6() {}
public final R visit(TypeMirror t, P p) {
return t.accept(this, p);
}
public final R visit(TypeMirror t) {
return t.accept(this, null);
}
public R visitUnion(UnionType t, P p) {
return visitUnknown(t, p);
}
@Override
public R visitIntersection(IntersectionType t, P p) {
return visitUnknown(t, p);
}
@Override
public R visitUnknown(TypeMirror t, P p) {
throw new UnknownTypeException(t, p);
}
}
package javax.lang.model.util;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.type.*;
import static javax.lang.model.SourceVersion.*;
@SupportedSourceVersion(RELEASE_7)
public abstract class AbstractTypeVisitor7<R, P> extends AbstractTypeVisitor6<R, P> {
@Deprecated(since="12")
protected AbstractTypeVisitor7() {
super();      }
@Override
public abstract R visitUnion(UnionType t, P p);
}
package javax.lang.model.util;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.type.*;
import static javax.lang.model.SourceVersion.*;
@SupportedSourceVersion(RELEASE_8)
public abstract class AbstractTypeVisitor8<R, P> extends AbstractTypeVisitor7<R, P> {
@SuppressWarnings("deprecation")     protected AbstractTypeVisitor8() {
super();
}
@Override
public abstract R visitIntersection(IntersectionType t, P p);
}
package javax.lang.model.util;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.type.*;
import javax.lang.model.SourceVersion;
import static javax.lang.model.SourceVersion.*;
@SupportedSourceVersion(RELEASE_14)
public abstract class AbstractTypeVisitor9<R, P> extends AbstractTypeVisitor8<R, P> {
protected AbstractTypeVisitor9() {
super();
}
}
package javax.swing.undo;
import java.io.Serializable;
import javax.swing.UIManager;
@SuppressWarnings("serial") public class AbstractUndoableEdit implements UndoableEdit, Serializable {
protected static final String UndoName = "Undo";
protected static final String RedoName = "Redo";
boolean hasBeenDone;
boolean alive;
public AbstractUndoableEdit() {
super();
hasBeenDone = true;
alive = true;
}
public void die() {
alive = false;
}
public void undo() throws CannotUndoException {
if (!canUndo()) {
throw new CannotUndoException();
}
hasBeenDone = false;
}
public boolean canUndo() {
return alive && hasBeenDone;
}
public void redo() throws CannotRedoException {
if (!canRedo()) {
throw new CannotRedoException();
}
hasBeenDone = true;
}
public boolean canRedo() {
return alive && !hasBeenDone;
}
public boolean addEdit(UndoableEdit anEdit) {
return false;
}
public boolean replaceEdit(UndoableEdit anEdit) {
return false;
}
public boolean isSignificant() {
return true;
}
public String getPresentationName() {
return "";
}
public String getUndoPresentationName() {
String name = getPresentationName();
if (!"".equals(name)) {
name = UIManager.getString("AbstractUndoableEdit.undoText") +
" " + name;
} else {
name = UIManager.getString("AbstractUndoableEdit.undoText");
}
return name;
}
public String getRedoPresentationName() {
String name = getPresentationName();
if (!"".equals(name)) {
name = UIManager.getString("AbstractUndoableEdit.redoText") +
" " + name;
} else {
name = UIManager.getString("AbstractUndoableEdit.redoText");
}
return name;
}
public String toString()
{
return super.toString()
+ " hasBeenDone: " + hasBeenDone
+ " alive: " + alive;
}
}
package sun.nio.fs;
import java.nio.ByteBuffer;
import java.nio.file.attribute.UserDefinedFileAttributeView;
import java.io.IOException;
import java.util.*;
abstract class AbstractUserDefinedFileAttributeView
implements UserDefinedFileAttributeView, DynamicFileAttributeView
{
protected AbstractUserDefinedFileAttributeView() { }
protected void checkAccess(String file,
boolean checkRead,
boolean checkWrite)
{
assert checkRead || checkWrite;
@SuppressWarnings("removal")
SecurityManager sm = System.getSecurityManager();
if (sm != null) {
if (checkRead)
sm.checkRead(file);
if (checkWrite)
sm.checkWrite(file);
sm.checkPermission(new RuntimePermission("accessUserDefinedAttributes"));
}
}
@Override
public final String name() {
return "user";
}
@Override
public final void setAttribute(String attribute, Object value)
throws IOException
{
ByteBuffer bb;
if (value instanceof byte[]) {
bb = ByteBuffer.wrap((byte[])value);
} else {
bb = (ByteBuffer)value;
}
write(attribute, bb);
}
@Override
public final Map<String,Object> readAttributes(String[] attributes)
throws IOException
{
List<String> names = new ArrayList<>();
for (String name: attributes) {
if (name.equals("*")) {
names = list();
break;
} else {
if (name.isEmpty())
throw new IllegalArgumentException();
names.add(name);
}
}
Map<String,Object> result = new HashMap<>();
for (String name: names) {
int size = size(name);
byte[] buf = new byte[size];
int n = read(name, ByteBuffer.wrap(buf));
byte[] value = (n == size) ? buf : Arrays.copyOf(buf, n);
result.put(name, value);
}
return result;
}
}
package java.lang.invoke;
import sun.invoke.util.Wrapper;
import java.lang.reflect.Modifier;
import static java.lang.invoke.MethodHandleInfo.*;
import static sun.invoke.util.Wrapper.forPrimitiveType;
import static sun.invoke.util.Wrapper.forWrapperType;
import static sun.invoke.util.Wrapper.isWrapperType;
abstract class AbstractValidatingLambdaMetafactory {
final MethodHandles.Lookup caller;            final Class<?> targetClass;                   final MethodType factoryType;                 final Class<?> interfaceClass;                final String interfaceMethodName;             final MethodType interfaceMethodType;         final MethodHandle implementation;            final MethodType implMethodType;              final MethodHandleInfo implInfo;              final int implKind;                           final boolean implIsInstanceMethod;           final Class<?> implClass;                     final MethodType dynamicMethodType;           final boolean isSerializable;                 final Class<?>[] altInterfaces;               final MethodType[] altMethods;
AbstractValidatingLambdaMetafactory(MethodHandles.Lookup caller,
MethodType factoryType,
String interfaceMethodName,
MethodType interfaceMethodType,
MethodHandle implementation,
MethodType dynamicMethodType,
boolean isSerializable,
Class<?>[] altInterfaces,
MethodType[] altMethods)
throws LambdaConversionException {
if (!caller.hasFullPrivilegeAccess()) {
throw new LambdaConversionException(String.format(
"Invalid caller: %s",
caller.lookupClass().getName()));
}
this.caller = caller;
this.targetClass = caller.lookupClass();
this.factoryType = factoryType;
this.interfaceClass = factoryType.returnType();
this.interfaceMethodName = interfaceMethodName;
this.interfaceMethodType  = interfaceMethodType;
this.implementation = implementation;
this.implMethodType = implementation.type();
try {
this.implInfo = caller.revealDirect(implementation);         } catch (IllegalArgumentException e) {
throw new LambdaConversionException(implementation + " is not direct or cannot be cracked");
}
switch (implInfo.getReferenceKind()) {
case REF_invokeVirtual:
case REF_invokeInterface:
this.implClass = implMethodType.parameterType(0);
this.implKind = implClass.isInterface() ? REF_invokeInterface : REF_invokeVirtual;
this.implIsInstanceMethod = true;
break;
case REF_invokeSpecial:
this.implClass = implInfo.getDeclaringClass();
this.implIsInstanceMethod = true;
if (targetClass == implClass && Modifier.isPrivate(implInfo.getModifiers())) {
this.implKind = implClass.isInterface() ? REF_invokeInterface : REF_invokeVirtual;
} else {
this.implKind = REF_invokeSpecial;
}
break;
case REF_invokeStatic:
case REF_newInvokeSpecial:
this.implClass = implInfo.getDeclaringClass();
this.implKind = implInfo.getReferenceKind();
this.implIsInstanceMethod = false;
break;
default:
throw new LambdaConversionException(String.format("Unsupported MethodHandle kind: %s", implInfo));
}
this.dynamicMethodType = dynamicMethodType;
this.isSerializable = isSerializable;
this.altInterfaces = altInterfaces;
this.altMethods = altMethods;
if (interfaceMethodName.isEmpty() ||
interfaceMethodName.indexOf('.') >= 0 ||
interfaceMethodName.indexOf(';') >= 0 ||
interfaceMethodName.indexOf('[') >= 0 ||
interfaceMethodName.indexOf('/') >= 0 ||
interfaceMethodName.indexOf('<') >= 0 ||
interfaceMethodName.indexOf('>') >= 0) {
throw new LambdaConversionException(String.format(
"Method name '%s' is not legal",
interfaceMethodName));
}
if (!interfaceClass.isInterface()) {
throw new LambdaConversionException(String.format(
"%s is not an interface",
interfaceClass.getName()));
}
for (Class<?> c : altInterfaces) {
if (!c.isInterface()) {
throw new LambdaConversionException(String.format(
"%s is not an interface",
c.getName()));
}
}
}
abstract CallSite buildCallSite()
throws LambdaConversionException;
void validateMetafactoryArgs() throws LambdaConversionException {
final int implArity = implMethodType.parameterCount();
final int capturedArity = factoryType.parameterCount();
final int samArity = interfaceMethodType.parameterCount();
final int dynamicArity = dynamicMethodType.parameterCount();
if (implArity != capturedArity + samArity) {
throw new LambdaConversionException(
String.format("Incorrect number of parameters for %s method %s; %d captured parameters, %d functional interface method parameters, %d implementation parameters",
implIsInstanceMethod ? "instance" : "static", implInfo,
capturedArity, samArity, implArity));
}
if (dynamicArity != samArity) {
throw new LambdaConversionException(
String.format("Incorrect number of parameters for %s method %s; %d dynamic parameters, %d functional interface method parameters",
implIsInstanceMethod ? "instance" : "static", implInfo,
dynamicArity, samArity));
}
for (MethodType bridgeMT : altMethods) {
if (bridgeMT.parameterCount() != samArity) {
throw new LambdaConversionException(
String.format("Incorrect number of parameters for bridge signature %s; incompatible with %s",
bridgeMT, interfaceMethodType));
}
}
final int capturedStart;         final int samStart;         if (implIsInstanceMethod) {
final Class<?> receiverClass;
if (capturedArity == 0) {
capturedStart = 0;
samStart = 1;
receiverClass = dynamicMethodType.parameterType(0);
} else {
capturedStart = 1;
samStart = capturedArity;
receiverClass = factoryType.parameterType(0);
}
if (!implClass.isAssignableFrom(receiverClass)) {
throw new LambdaConversionException(
String.format("Invalid receiver type %s; not a subtype of implementation type %s",
receiverClass, implClass));
}
} else {
capturedStart = 0;
samStart = capturedArity;
}
for (int i=capturedStart; i<capturedArity; i++) {
Class<?> implParamType = implMethodType.parameterType(i);
Class<?> capturedParamType = factoryType.parameterType(i);
if (!capturedParamType.equals(implParamType)) {
throw new LambdaConversionException(
String.format("Type mismatch in captured lambda parameter %d: expecting %s, found %s",
i, capturedParamType, implParamType));
}
}
for (int i=samStart; i<implArity; i++) {
Class<?> implParamType = implMethodType.parameterType(i);
Class<?> dynamicParamType = dynamicMethodType.parameterType(i - capturedArity);
if (!isAdaptableTo(dynamicParamType, implParamType, true)) {
throw new LambdaConversionException(
String.format("Type mismatch for lambda argument %d: %s is not convertible to %s",
i, dynamicParamType, implParamType));
}
}
Class<?> expectedType = dynamicMethodType.returnType();
Class<?> actualReturnType = implMethodType.returnType();
if (!isAdaptableToAsReturn(actualReturnType, expectedType)) {
throw new LambdaConversionException(
String.format("Type mismatch for lambda return: %s is not convertible to %s",
actualReturnType, expectedType));
}
checkDescriptor(interfaceMethodType);
for (MethodType bridgeMT : altMethods) {
checkDescriptor(bridgeMT);
}
}
private void checkDescriptor(MethodType descriptor) throws LambdaConversionException {
for (int i = 0; i < dynamicMethodType.parameterCount(); i++) {
Class<?> dynamicParamType = dynamicMethodType.parameterType(i);
Class<?> descriptorParamType = descriptor.parameterType(i);
if (!descriptorParamType.isAssignableFrom(dynamicParamType)) {
String msg = String.format("Type mismatch for dynamic parameter %d: %s is not a subtype of %s",
i, dynamicParamType, descriptorParamType);
throw new LambdaConversionException(msg);
}
}
Class<?> dynamicReturnType = dynamicMethodType.returnType();
Class<?> descriptorReturnType = descriptor.returnType();
if (!isAdaptableToAsReturnStrict(dynamicReturnType, descriptorReturnType)) {
String msg = String.format("Type mismatch for lambda expected return: %s is not convertible to %s",
dynamicReturnType, descriptorReturnType);
throw new LambdaConversionException(msg);
}
}
private boolean isAdaptableTo(Class<?> fromType, Class<?> toType, boolean strict) {
if (fromType.equals(toType)) {
return true;
}
if (fromType.isPrimitive()) {
Wrapper wfrom = forPrimitiveType(fromType);
if (toType.isPrimitive()) {
Wrapper wto = forPrimitiveType(toType);
return wto.isConvertibleFrom(wfrom);
} else {
return toType.isAssignableFrom(wfrom.wrapperType());
}
} else {
if (toType.isPrimitive()) {
Wrapper wfrom;
if (isWrapperType(fromType) && (wfrom = forWrapperType(fromType)).primitiveType().isPrimitive()) {
Wrapper wto = forPrimitiveType(toType);
return wto.isConvertibleFrom(wfrom);
} else {
return !strict;
}
} else {
return !strict || toType.isAssignableFrom(fromType);
}
}
}
private boolean isAdaptableToAsReturn(Class<?> fromType, Class<?> toType) {
return toType.equals(void.class)
|| !fromType.equals(void.class) && isAdaptableTo(fromType, toType, false);
}
private boolean isAdaptableToAsReturnStrict(Class<?> fromType, Class<?> toType) {
if (fromType.equals(void.class) || toType.equals(void.class)) return fromType.equals(toType);
else return isAdaptableTo(fromType, toType, true);
}
}
package jdk.incubator.vector;
import java.lang.foreign.MemorySegment;
import jdk.internal.vm.annotation.ForceInline;
import jdk.internal.vm.vector.VectorSupport;
import java.nio.ByteOrder;
import java.util.function.IntUnaryOperator;
import static jdk.incubator.vector.VectorOperators.*;
@SuppressWarnings("cast")
abstract class AbstractVector<E> extends Vector<E> {
static final ByteOrder NATIVE_ENDIAN = ByteOrder.nativeOrder();
static final ByteOrder REGISTER_ENDIAN = ByteOrder.LITTLE_ENDIAN;
static final int OFFSET_IN_RANGE = 1;
static final int OFFSET_OUT_OF_RANGE = 0;
AbstractVector(Object bits) {
super(bits);
}
abstract AbstractSpecies<E> vspecies();
@Override
@ForceInline
public final VectorSpecies<E> species() {
return vspecies();
}
@Override
@ForceInline
public final
<F> Vector<F> check(VectorSpecies<F> species) {
return check0(species);
}
@ForceInline
@SuppressWarnings("unchecked")
final
<F> AbstractVector<F> check0(VectorSpecies<F> species) {
if (!sameSpecies(species)) {
throw AbstractSpecies.checkFailed(this, species);
}
return (AbstractVector<F>) this;
}
@Override
@ForceInline
public final
<F> Vector<F> check(Class<F> elementType) {
return check0(elementType);
}
@ForceInline
@SuppressWarnings("unchecked")
final
<F> AbstractVector<F> check0(Class<F> elementType) {
if (this.elementType() != elementType) {
throw AbstractSpecies.checkFailed(this, elementType);
}
return (AbstractVector<F>) this;
}
@ForceInline
@SuppressWarnings("unchecked")
final
<F> AbstractVector<F> check(Vector<F> other) {
if (!sameSpecies(other)) {
throw AbstractSpecies.checkFailed(this, other);
}
return (AbstractVector<F>) this;
}
@ForceInline
private boolean sameSpecies(Vector<?> other) {
boolean same = (this.getClass() == other.getClass());
assert(same == (this.species() == other.species())) : same;
return same;
}
@ForceInline
private boolean sameSpecies(VectorSpecies<?> species) {
AbstractVector<?> other = ((AbstractSpecies<?>)species).dummyVector();
boolean same = (this.getClass() == other.getClass());
assert(same == (this.species() == species)) : same;
return same;
}
@Override
@ForceInline
public final VectorMask<E> maskAll(boolean bit) {
return species().maskAll(bit);
}
abstract AbstractVector<?> asVectorRaw(LaneType laneType);
abstract ByteVector asByteVectorRaw();
@ForceInline
final AbstractVector<?> asVectorRawTemplate(LaneType laneType) {
return convert0('X', vspecies().withLanes(laneType));
}
@ForceInline
ByteVector asByteVectorRawTemplate() {
return (ByteVector) asVectorRawTemplate(LaneType.BYTE);
}
abstract AbstractMask<E> maskFromArray(boolean[] bits);
abstract AbstractShuffle<E> iotaShuffle();
abstract AbstractShuffle<E> iotaShuffle(int start, int step, boolean wrap);
abstract AbstractShuffle<E> shuffleFromBytes(byte[] reorder);
abstract AbstractShuffle<E> shuffleFromArray(int[] indexes, int i);
abstract AbstractShuffle<E> shuffleFromOp(IntUnaryOperator fn);
abstract AbstractVector<E> fromMemorySegment0(MemorySegment ms, long offset);
abstract AbstractVector<E> maybeSwap(ByteOrder bo);
@ForceInline
VectorShuffle<Byte> swapBytesShuffle() {
return vspecies().swapBytesShuffle();
}
@Override
@ForceInline
public ShortVector reinterpretAsShorts() {
return (ShortVector) asVectorRaw(LaneType.SHORT);
}
@Override
@ForceInline
public IntVector reinterpretAsInts() {
return (IntVector) asVectorRaw(LaneType.INT);
}
@Override
@ForceInline
public LongVector reinterpretAsLongs() {
return (LongVector) asVectorRaw(LaneType.LONG);
}
@Override
@ForceInline
public FloatVector reinterpretAsFloats() {
return (FloatVector) asVectorRaw(LaneType.FLOAT);
}
@Override
@ForceInline
public DoubleVector reinterpretAsDoubles() {
return (DoubleVector) asVectorRaw(LaneType.DOUBLE);
}
@Override
@ForceInline
public final <F>
Vector<F> convert(Conversion<E,F> conv, int part) {
ConversionImpl<E,F> c = (ConversionImpl<E,F>) conv;
@SuppressWarnings("unchecked")
VectorSpecies<F> rsp = (VectorSpecies<F>)
vspecies().withLanes(c.range());
return convertShape(conv, rsp, part);
}
@Override
@ForceInline
public final <F>
Vector<F> castShape(VectorSpecies<F> toSpecies, int part) {
AbstractSpecies<E> vsp = vspecies();
AbstractSpecies<F> rsp = (AbstractSpecies<F>) toSpecies;
@SuppressWarnings("unchecked")
ConversionImpl<E,F> c = (ConversionImpl<E,F>)
ConversionImpl.ofCast(vsp.laneType, rsp.laneType);
return convertShape(c, rsp, part);
}
@Override
@ForceInline
public abstract <F>
Vector<F> convertShape(Conversion<E,F> conv, VectorSpecies<F> rsp, int part);
@ForceInline
final <F>
AbstractVector<F> reinterpretShapeTemplate(VectorSpecies<F> toSpecies, int part) {
AbstractSpecies<F> rsp = (AbstractSpecies<F>) toSpecies;
AbstractSpecies<E> vsp = vspecies();
if (part == 0) {
return convert0('X', rsp);
} else {
int origin = shapeChangeOrigin(vsp, rsp, false, part);
if (part > 0) {                  return slice(origin).convert0('X', rsp);
} else {                  return rsp.zero().slice(rsp.laneCount() - origin,
convert0('X', rsp));
}
}
}
@Override
public abstract AbstractVector<E> slice(int origin, Vector<E> v1);
@Override
public abstract AbstractVector<E> slice(int origin);
@ForceInline
final <F>
AbstractVector<F> convertShapeTemplate(Conversion<E,F> conv, VectorSpecies<F> toSpecies, int part) {
ConversionImpl<E,F> c = (ConversionImpl<E,F>) conv;
AbstractSpecies<F> rsp = (AbstractSpecies<F>) toSpecies;
AbstractSpecies<E> vsp = vspecies();
char kind = c.kind();
switch (kind) {
case 'C':             break;
case 'I':              assert(c.sizeChangeLog2() == 0);
kind = 'X';
break;
case 'Z':              assert(c.sizeChangeLog2() > 0);
assert(c.range().elementKind == 'I');
break;
case 'R':              if (c.sizeChangeLog2() != 0) {
kind = 'Z';                  break;
}
kind = 'X';              break;
default:
throw new AssertionError(c);
}
vsp.check(c.domain());          rsp.check(c.range());           if (part == 0) {
return convert0(kind, rsp);
} else {
int origin = shapeChangeOrigin(vsp, rsp, true, part);
if (part > 0) {                  return slice(origin).convert0(kind, rsp);
} else {                  return rsp.zero().slice(rsp.laneCount() - origin,
convert0(kind, rsp));
}
}
}
@ForceInline
static
int shapeChangeOrigin(AbstractSpecies<?> dsp,
AbstractSpecies<?> rsp,
boolean lanewise,
int part) {
int domSizeLog2 = dsp.vectorShape.vectorBitSizeLog2;
int phySizeLog2 = rsp.vectorShape.vectorBitSizeLog2;
int laneChangeLog2 = 0;
if (lanewise) {
laneChangeLog2 = (rsp.laneType.elementSizeLog2 -
dsp.laneType.elementSizeLog2);
}
int resSizeLog2 = domSizeLog2 + laneChangeLog2;
assert(resSizeLog2 >= 0);
if (!partInRange(resSizeLog2, phySizeLog2, part)) {
} else if (resSizeLog2 > phySizeLog2) {
int s = phySizeLog2 - laneChangeLog2 - dsp.laneType.elementSizeLog2;
if ((s & 31) == s)                  return part << s;
} else {
int s = resSizeLog2 - rsp.laneType.elementSizeLog2;
if ((s & 31) == s)                  return -part << s;
}
throw wrongPart(dsp, rsp, lanewise, part);
}
@ForceInline
private static boolean partInRange(int resSizeLog2, int phySizeLog2, int part) {
int diff = (resSizeLog2 - phySizeLog2);
int sign = (diff >> -1);
int d = (diff ^ sign) - sign;
assert(d == Math.abs(diff) && d <= 16);                  int p = (part ^ sign) - sign;
boolean z = (p & (-1 << d)) == 0;
assert(z == partInRangeSlow(resSizeLog2, phySizeLog2, part)) : z;
return z;
}
private static boolean partInRangeSlow(int resSizeLog2, int phySizeLog2, int part) {
if (resSizeLog2 > phySizeLog2) {              int limit = 1 << (resSizeLog2 - phySizeLog2);
return part >= 0 && part < limit;
} else if (resSizeLog2 < phySizeLog2) {              int limit = 1 << (phySizeLog2 - resSizeLog2);
return part > -limit && part <= 0;
} else {
return (part == 0);
}
}
private static
ArrayIndexOutOfBoundsException
wrongPart(AbstractSpecies<?> dsp,
AbstractSpecies<?> rsp,
boolean lanewise,
int part) {
String laneChange = "";
String converting = "converting";
int dsize = dsp.elementSize(), rsize = rsp.elementSize();
if (!lanewise) {
converting = "reinterpreting";
} else if (dsize < rsize) {
laneChange = String.format(" (lanes are expanding by %d)",
rsize / dsize);
} else if (dsize > rsize) {
laneChange = String.format(" (lanes are contracting by %d)",
dsize / rsize);
}
String msg = String.format("bad part number %d %s %s -> %s%s",
part, converting, dsp, rsp, laneChange);
return new ArrayIndexOutOfBoundsException(msg);
}
ArithmeticException divZeroException() {
throw new ArithmeticException("zero vector lane in dividend "+this);
}
@ForceInline
final <F>
AbstractVector<F> defaultReinterpret(AbstractSpecies<F> rsp) {
int blen = Math.max(this.bitSize(), rsp.vectorBitSize()) / Byte.SIZE;
ByteOrder bo = ByteOrder.nativeOrder();
MemorySegment ms = MemorySegment.ofArray(new byte[blen]);
this.intoMemorySegment(ms, 0, bo);
VectorMask<F> m = rsp.maskAll(true);
switch (rsp.laneType.switchKey) {
case LaneType.SK_BYTE:
return ByteVector.fromMemorySegment(rsp.check(byte.class), ms, 0, bo, m.check(byte.class)).check0(rsp);
case LaneType.SK_SHORT:
return ShortVector.fromMemorySegment(rsp.check(short.class), ms, 0, bo, m.check(short.class)).check0(rsp);
case LaneType.SK_INT:
return IntVector.fromMemorySegment(rsp.check(int.class), ms, 0, bo, m.check(int.class)).check0(rsp);
case LaneType.SK_LONG:
return LongVector.fromMemorySegment(rsp.check(long.class), ms, 0, bo, m.check(long.class)).check0(rsp);
case LaneType.SK_FLOAT:
return FloatVector.fromMemorySegment(rsp.check(float.class), ms, 0, bo, m.check(float.class)).check0(rsp);
case LaneType.SK_DOUBLE:
return DoubleVector.fromMemorySegment(rsp.check(double.class), ms, 0, bo, m.check(double.class)).check0(rsp);
default:
throw new AssertionError(rsp.toString());
}
}
@ForceInline
final <F>
AbstractVector<F> defaultCast(AbstractSpecies<F> dsp) {
int rlength = dsp.laneCount;
if (vspecies().laneType.elementKind == 'F') {
double[] lanes = toDoubleArray();
int limit = Math.min(lanes.length, rlength);
switch (dsp.laneType.switchKey) {
case LaneType.SK_BYTE: {
byte[] a = new byte[rlength];
for (int i = 0; i < limit; i++) {
a[i] = (byte) lanes[i];
}
return ByteVector.fromArray(dsp.check(byte.class), a, 0).check0(dsp);
}
case LaneType.SK_SHORT: {
short[] a = new short[rlength];
for (int i = 0; i < limit; i++) {
a[i] = (short) lanes[i];
}
return ShortVector.fromArray(dsp.check(short.class), a, 0).check0(dsp);
}
case LaneType.SK_INT: {
int[] a = new int[rlength];
for (int i = 0; i < limit; i++) {
a[i] = (int) lanes[i];
}
return IntVector.fromArray(dsp.check(int.class), a, 0).check0(dsp);
}
case LaneType.SK_LONG: {
long[] a = new long[rlength];
for (int i = 0; i < limit; i++) {
a[i] = (long) lanes[i];
}
return LongVector.fromArray(dsp.check(long.class), a, 0).check0(dsp);
}
case LaneType.SK_FLOAT: {
float[] a = new float[rlength];
for (int i = 0; i < limit; i++) {
a[i] = (float) lanes[i];
}
return FloatVector.fromArray(dsp.check(float.class), a, 0).check0(dsp);
}
case LaneType.SK_DOUBLE: {
double[] a = new double[rlength];
for (int i = 0; i < limit; i++) {
a[i] = (double) lanes[i];
}
return DoubleVector.fromArray(dsp.check(double.class), a, 0).check0(dsp);
}
default: break;
}
} else {
long[] lanes = toLongArray();
int limit = Math.min(lanes.length, rlength);
switch (dsp.laneType.switchKey) {
case LaneType.SK_BYTE: {
byte[] a = new byte[rlength];
for (int i = 0; i < limit; i++) {
a[i] = (byte) lanes[i];
}
return ByteVector.fromArray(dsp.check(byte.class), a, 0).check0(dsp);
}
case LaneType.SK_SHORT: {
short[] a = new short[rlength];
for (int i = 0; i < limit; i++) {
a[i] = (short) lanes[i];
}
return ShortVector.fromArray(dsp.check(short.class), a, 0).check0(dsp);
}
case LaneType.SK_INT: {
int[] a = new int[rlength];
for (int i = 0; i < limit; i++) {
a[i] = (int) lanes[i];
}
return IntVector.fromArray(dsp.check(int.class), a, 0).check0(dsp);
}
case LaneType.SK_LONG: {
long[] a = new long[rlength];
for (int i = 0; i < limit; i++) {
a[i] = (long) lanes[i];
}
return LongVector.fromArray(dsp.check(long.class), a, 0).check0(dsp);
}
case LaneType.SK_FLOAT: {
float[] a = new float[rlength];
for (int i = 0; i < limit; i++) {
a[i] = (float) lanes[i];
}
return FloatVector.fromArray(dsp.check(float.class), a, 0).check0(dsp);
}
case LaneType.SK_DOUBLE: {
double[] a = new double[rlength];
for (int i = 0; i < limit; i++) {
a[i] = (double) lanes[i];
}
return DoubleVector.fromArray(dsp.check(double.class), a, 0).check0(dsp);
}
default: break;
}
}
throw new AssertionError();
}
@ForceInline
final <F>
AbstractVector<F> defaultUCast(AbstractSpecies<F> dsp) {
AbstractSpecies<?> vsp = this.vspecies();
if (vsp.elementSize() >= dsp.elementSize()) {
return this.convert0('C', dsp);
} else {
long mask = -1L >>> -vsp.elementSize();
return (AbstractVector<F>) this.convert0('C', dsp).lanewise(AND, dsp.broadcast(mask));
}
}
@ForceInline
final <F>
AbstractVector<F> convert0(char kind, AbstractSpecies<F> rsp) {
Class<?> vtype;
Class<?> etype;           int vlength;              Class<?> rvtype;          Class<?> rtype;
int rlength;
switch (kind) {
case 'Z':              AbstractSpecies<?> rspi = rsp.asIntegral();
AbstractSpecies<?> vsp = this.vspecies();
AbstractSpecies<?> vspi = vsp.asIntegral();
AbstractVector<?> biti = vspi == vsp ? this : this.convert0('X', vspi);
rtype = rspi.elementType();
rlength = rspi.laneCount();
etype = vspi.elementType();
vlength = vspi.laneCount();
rvtype = rspi.dummyVector().getClass();
vtype = vspi.dummyVector().getClass();
int opc = vspi.elementSize() < rspi.elementSize() ? VectorSupport.VECTOR_OP_UCAST : VectorSupport.VECTOR_OP_CAST;
AbstractVector<?> bitv = VectorSupport.convert(opc,
vtype, etype, vlength,
rvtype, rtype, rlength,
biti, rspi,
AbstractVector::defaultUCast);
return (rspi == rsp ? bitv.check0(rsp) : bitv.convert0('X', rsp));
case 'C':              rtype = rsp.elementType();
rlength = rsp.laneCount();
etype = this.elementType();             vlength = this.length();              rvtype = rsp.dummyVector().getClass();              vtype = this.getClass();
return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,
vtype, etype, vlength,
rvtype, rtype, rlength,
this, rsp,
AbstractVector::defaultCast);
case 'X':              rtype = rsp.elementType();
rlength = rsp.laneCount();
etype = this.elementType();             vlength = this.length();              rvtype = rsp.dummyVector().getClass();              vtype = this.getClass();
return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,
vtype, etype, vlength,
rvtype, rtype, rlength,
this, rsp,
AbstractVector::defaultReinterpret);
}
throw new AssertionError();
}
static {
assert(REGISTER_ENDIAN == ByteOrder.LITTLE_ENDIAN);
}
}
package org.w3c.dom.views;
public interface AbstractView {
public DocumentView getDocument();
}
package sun.nio.fs;
import java.nio.file.*;
import java.util.*;
abstract class AbstractWatchKey implements WatchKey {
static final int MAX_EVENT_LIST_SIZE    = 512;
static final Event<Object> OVERFLOW_EVENT =
new Event<Object>(StandardWatchEventKinds.OVERFLOW, null);
private static enum State { READY, SIGNALLED };
private final AbstractWatchService watcher;
private final Path dir;
private State state;
private List<WatchEvent<?>> events;
private Map<Object,WatchEvent<?>> lastModifyEvents;
protected AbstractWatchKey(Path dir, AbstractWatchService watcher) {
this.watcher = watcher;
this.dir = dir;
this.state = State.READY;
this.events = new ArrayList<>();
this.lastModifyEvents = new HashMap<>();
}
final AbstractWatchService watcher() {
return watcher;
}
@Override
public Path watchable() {
return dir;
}
final void signal() {
synchronized (this) {
if (state == State.READY) {
state = State.SIGNALLED;
watcher.enqueueKey(this);
}
}
}
@SuppressWarnings("unchecked")
final void signalEvent(WatchEvent.Kind<?> kind, Object context) {
boolean isModify = (kind == StandardWatchEventKinds.ENTRY_MODIFY);
synchronized (this) {
int size = events.size();
if (size > 0) {
WatchEvent<?> prev = events.get(size-1);
if ((prev.kind() == StandardWatchEventKinds.OVERFLOW) ||
((kind == prev.kind() &&
Objects.equals(context, prev.context()))))
{
((Event<?>)prev).increment();
return;
}
if (!lastModifyEvents.isEmpty()) {
if (isModify) {
WatchEvent<?> ev = lastModifyEvents.get(context);
if (ev != null) {
assert ev.kind() == StandardWatchEventKinds.ENTRY_MODIFY;
((Event<?>)ev).increment();
return;
}
} else {
lastModifyEvents.remove(context);
}
}
if (size >= MAX_EVENT_LIST_SIZE) {
kind = StandardWatchEventKinds.OVERFLOW;
isModify = false;
context = null;
}
}
Event<Object> ev =
new Event<>((WatchEvent.Kind<Object>)kind, context);
if (isModify) {
lastModifyEvents.put(context, ev);
} else if (kind == StandardWatchEventKinds.OVERFLOW) {
events.clear();
lastModifyEvents.clear();
}
events.add(ev);
signal();
}
}
@Override
public final List<WatchEvent<?>> pollEvents() {
synchronized (this) {
List<WatchEvent<?>> result = events;
events = new ArrayList<>();
lastModifyEvents.clear();
return result;
}
}
@Override
public final boolean reset() {
synchronized (this) {
if (state == State.SIGNALLED && isValid()) {
if (events.isEmpty()) {
state = State.READY;
} else {
watcher.enqueueKey(this);
}
}
return isValid();
}
}
private static class Event<T> implements WatchEvent<T> {
private final WatchEvent.Kind<T> kind;
private final T context;
private int count;
Event(WatchEvent.Kind<T> type, T context) {
this.kind = type;
this.context = context;
this.count = 1;
}
@Override
public WatchEvent.Kind<T> kind() {
return kind;
}
@Override
public T context() {
return context;
}
@Override
public int count() {
return count;
}
void increment() {
count++;
}
}
}
package sun.nio.fs;
import java.nio.file.*;
import java.util.concurrent.*;
import java.io.IOException;
abstract class AbstractWatchService implements WatchService {
private final LinkedBlockingDeque<WatchKey> pendingKeys =
new LinkedBlockingDeque<WatchKey>();
private final WatchKey CLOSE_KEY =
new AbstractWatchKey(null, null) {
@Override
public boolean isValid() {
return true;
}
@Override
public void cancel() {
}
};
private volatile boolean closed;
private final Object closeLock = new Object();
protected AbstractWatchService() {
}
abstract WatchKey register(Path path,
WatchEvent.Kind<?>[] events,
WatchEvent.Modifier... modifiers)
throws IOException;
final void enqueueKey(WatchKey key) {
pendingKeys.offer(key);
}
private void checkOpen() {
if (closed)
throw new ClosedWatchServiceException();
}
private void checkKey(WatchKey key) {
if (key == CLOSE_KEY) {
enqueueKey(key);
}
checkOpen();
}
@Override
public final WatchKey poll() {
checkOpen();
WatchKey key = pendingKeys.poll();
checkKey(key);
return key;
}
@Override
public final WatchKey poll(long timeout, TimeUnit unit)
throws InterruptedException
{
checkOpen();
WatchKey key = pendingKeys.poll(timeout, unit);
checkKey(key);
return key;
}
@Override
public final WatchKey take()
throws InterruptedException
{
checkOpen();
WatchKey key = pendingKeys.take();
checkKey(key);
return key;
}
final boolean isOpen() {
return !closed;
}
final Object closeLock() {
return closeLock;
}
abstract void implClose() throws IOException;
@Override
public final void close()
throws IOException
{
synchronized (closeLock) {
if (closed)
return;
closed = true;
implClose();
pendingKeys.clear();
pendingKeys.offer(CLOSE_KEY);
}
}
}
package jdk.internal.org.jline.terminal.impl;
import java.io.IOException;
import java.io.Writer;
public abstract class AbstractWindowsConsoleWriter extends Writer {
protected abstract void writeConsole(char[] text, int len) throws IOException;
@Override
public void write(char[] cbuf, int off, int len) throws IOException {
char[] text = cbuf;
if (off != 0) {
text = new char[len];
System.arraycopy(cbuf, off, text, 0, len);
}
synchronized (this.lock) {
writeConsole(text, len);
}
}
@Override
public void flush() {
}
@Override
public void close() {
}
}
package jdk.internal.org.jline.terminal.impl;
import jdk.internal.org.jline.terminal.Attributes;
import jdk.internal.org.jline.terminal.Size;
import jdk.internal.org.jline.utils.Curses;
import jdk.internal.org.jline.utils.InfoCmp;
import jdk.internal.org.jline.utils.Log;
import jdk.internal.org.jline.utils.NonBlocking;
import jdk.internal.org.jline.utils.NonBlockingInputStream;
import jdk.internal.org.jline.utils.NonBlockingPumpReader;
import jdk.internal.org.jline.utils.NonBlockingReader;
import jdk.internal.org.jline.utils.ShutdownHooks;
import jdk.internal.org.jline.utils.Signals;
import jdk.internal.org.jline.utils.WriterOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;
public abstract class AbstractWindowsTerminal extends AbstractTerminal {
public static final String TYPE_WINDOWS = "windows";
public static final String TYPE_WINDOWS_256_COLOR = "windows-256color";
public static final String TYPE_WINDOWS_CONEMU = "windows-conemu";
public static final String TYPE_WINDOWS_VTP = "windows-vtp";
public static final int ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004;
private static final int UTF8_CODE_PAGE = 65001;
protected static final int ENABLE_PROCESSED_INPUT = 0x0001;
protected static final int ENABLE_LINE_INPUT      = 0x0002;
protected static final int ENABLE_ECHO_INPUT      = 0x0004;
protected static final int ENABLE_WINDOW_INPUT    = 0x0008;
protected static final int ENABLE_MOUSE_INPUT     = 0x0010;
protected static final int ENABLE_INSERT_MODE     = 0x0020;
protected static final int ENABLE_QUICK_EDIT_MODE = 0x0040;
protected final Writer slaveInputPipe;
protected final InputStream input;
protected final OutputStream output;
protected final NonBlockingReader reader;
protected final PrintWriter writer;
protected final Map<Signal, Object> nativeHandlers = new HashMap<>();
protected final ShutdownHooks.Task closer;
protected final Attributes attributes = new Attributes();
protected final int originalConsoleMode;
protected final Object lock = new Object();
protected boolean paused = true;
protected Thread pump;
protected MouseTracking tracking = MouseTracking.Off;
protected boolean focusTracking = false;
private volatile boolean closing;
public AbstractWindowsTerminal(Writer writer, String name, String type, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {
super(name, type, selectCharset(encoding, codepage), signalHandler);
NonBlockingPumpReader reader = NonBlocking.nonBlockingPumpReader();
this.slaveInputPipe = reader.getWriter();
this.input = inputStreamWrapper.apply(NonBlocking.nonBlockingStream(reader, encoding()));
this.reader = NonBlocking.nonBlocking(name, input, encoding());
this.writer = new PrintWriter(writer);
this.output = new WriterOutputStream(writer, encoding());
parseInfoCmp();
originalConsoleMode = getConsoleMode();
attributes.setLocalFlag(Attributes.LocalFlag.ISIG, true);
attributes.setControlChar(Attributes.ControlChar.VINTR, ctrl('C'));
attributes.setControlChar(Attributes.ControlChar.VEOF,  ctrl('D'));
attributes.setControlChar(Attributes.ControlChar.VSUSP, ctrl('Z'));
if (nativeSignals) {
for (final Signal signal : Signal.values()) {
if (signalHandler == SignalHandler.SIG_DFL) {
nativeHandlers.put(signal, Signals.registerDefault(signal.name()));
} else {
nativeHandlers.put(signal, Signals.register(signal.name(), () -> raise(signal)));
}
}
}
closer = this::close;
ShutdownHooks.add(closer);
if (TYPE_WINDOWS_CONEMU.equals(getType())
&& !Boolean.getBoolean("org.jline.terminal.conemu.disable-activate")) {
writer.write("\u001b[9999E");
writer.flush();
}
}
private static Charset selectCharset(Charset encoding, int codepage) {
if (encoding != null) {
return encoding;
}
if (codepage >= 0) {
return getCodepageCharset(codepage);
}
return StandardCharsets.UTF_8;
}
private static Charset getCodepageCharset(int codepage) {
if (codepage == UTF8_CODE_PAGE) {
return StandardCharsets.UTF_8;
}
String charsetMS = "ms" + codepage;
if (Charset.isSupported(charsetMS)) {
return Charset.forName(charsetMS);
}
String charsetCP = "cp" + codepage;
if (Charset.isSupported(charsetCP)) {
return Charset.forName(charsetCP);
}
return Charset.defaultCharset();
}
@Override
public SignalHandler handle(Signal signal, SignalHandler handler) {
SignalHandler prev = super.handle(signal, handler);
if (prev != handler) {
if (handler == SignalHandler.SIG_DFL) {
Signals.registerDefault(signal.name());
} else {
Signals.register(signal.name(), () -> raise(signal));
}
}
return prev;
}
public NonBlockingReader reader() {
return reader;
}
public PrintWriter writer() {
return writer;
}
@Override
public InputStream input() {
return input;
}
@Override
public OutputStream output() {
return output;
}
public Attributes getAttributes() {
int mode = getConsoleMode();
if ((mode & ENABLE_ECHO_INPUT) != 0) {
attributes.setLocalFlag(Attributes.LocalFlag.ECHO, true);
}
if ((mode & ENABLE_LINE_INPUT) != 0) {
attributes.setLocalFlag(Attributes.LocalFlag.ICANON, true);
}
return new Attributes(attributes);
}
public void setAttributes(Attributes attr) {
attributes.copy(attr);
updateConsoleMode();
}
protected void updateConsoleMode() {
int mode = ENABLE_WINDOW_INPUT;
if (attributes.getLocalFlag(Attributes.LocalFlag.ECHO)) {
mode |= ENABLE_ECHO_INPUT;
}
if (attributes.getLocalFlag(Attributes.LocalFlag.ICANON)) {
mode |= ENABLE_LINE_INPUT;
}
if (tracking != MouseTracking.Off) {
mode |= ENABLE_MOUSE_INPUT;
}
setConsoleMode(mode);
}
protected int ctrl(char key) {
return (Character.toUpperCase(key) & 0x1f);
}
public void setSize(Size size) {
throw new UnsupportedOperationException("Can not resize windows terminal");
}
protected void doClose() throws IOException {
super.doClose();
closing = true;
if (pump != null) {
pump.interrupt();
}
ShutdownHooks.remove(closer);
for (Map.Entry<Signal, Object> entry : nativeHandlers.entrySet()) {
Signals.unregister(entry.getKey().name(), entry.getValue());
}
reader.close();
writer.close();
setConsoleMode(originalConsoleMode);
}
static final int SHIFT_FLAG = 0x01;
static final int ALT_FLAG =   0x02;
static final int CTRL_FLAG =  0x04;
static final int RIGHT_ALT_PRESSED =   0x0001;
static final int LEFT_ALT_PRESSED =    0x0002;
static final int RIGHT_CTRL_PRESSED =  0x0004;
static final int LEFT_CTRL_PRESSED =   0x0008;
static final int SHIFT_PRESSED =       0x0010;
static final int NUMLOCK_ON =          0x0020;
static final int SCROLLLOCK_ON =       0x0040;
static final int CAPSLOCK_ON =         0x0080;
protected void processKeyEvent(final boolean isKeyDown, final short virtualKeyCode, char ch, final int controlKeyState) throws IOException {
final boolean isCtrl = (controlKeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) > 0;
final boolean isAlt = (controlKeyState & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED)) > 0;
final boolean isShift = (controlKeyState & SHIFT_PRESSED) > 0;
if (isKeyDown && ch != '\3') {
if (ch != 0
&& (controlKeyState & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED | RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED | SHIFT_PRESSED))
== (RIGHT_ALT_PRESSED | LEFT_CTRL_PRESSED)) {
processInputChar(ch);
} else {
final String keySeq = getEscapeSequence(virtualKeyCode, (isCtrl ? CTRL_FLAG : 0) + (isAlt ? ALT_FLAG : 0) + (isShift ? SHIFT_FLAG : 0));
if (keySeq != null) {
for (char c : keySeq.toCharArray()) {
processInputChar(c);
}
return;
}
if (ch > 0) {
if (isAlt) {
processInputChar('\033');
}
if (isCtrl && ch != ' ' && ch != '\n' && ch != 0x7f) {
processInputChar((char) (ch == '?' ? 0x7f : Character.toUpperCase(ch) & 0x1f));
} else if (isCtrl && ch == '\n') {
processInputChar('\033');
processInputChar('\r');
} else {
processInputChar(ch);
}
} else if (isCtrl) {                     if (virtualKeyCode >= 'A' && virtualKeyCode <= 'Z') {
ch = (char) (virtualKeyCode - 0x40);
} else if (virtualKeyCode == 191) {                         ch = 127;
}
if (ch > 0) {
if (isAlt) {
processInputChar('\033');
}
processInputChar(ch);
}
}
}
} else if (isKeyDown && ch == '\3') {
processInputChar('\3');
}
else {
if (virtualKeyCode == 0x12  && ch > 0) {
processInputChar(ch);              }
}
}
protected String getEscapeSequence(short keyCode, int keyState) {
String escapeSequence = null;
switch (keyCode) {
case 0x08:                 escapeSequence = (keyState & ALT_FLAG) > 0 ? "\\E^H" : getRawSequence(InfoCmp.Capability.key_backspace);
break;
case 0x09:
escapeSequence = (keyState & SHIFT_FLAG) > 0 ? getRawSequence(InfoCmp.Capability.key_btab) : null;
break;
case 0x21:                 escapeSequence = getRawSequence(InfoCmp.Capability.key_ppage);
break;
case 0x22:                 escapeSequence = getRawSequence(InfoCmp.Capability.key_npage);
break;
case 0x23:                 escapeSequence = keyState > 0 ? "\\E[1;%p1%dF" : getRawSequence(InfoCmp.Capability.key_end);
break;
case 0x24:                 escapeSequence = keyState > 0 ? "\\E[1;%p1%dH" : getRawSequence(InfoCmp.Capability.key_home);
break;
case 0x25:                 escapeSequence = keyState > 0 ? "\\E[1;%p1%dD" : getRawSequence(InfoCmp.Capability.key_left);
break;
case 0x26:                 escapeSequence = keyState > 0 ? "\\E[1;%p1%dA" : getRawSequence(InfoCmp.Capability.key_up);
break;
case 0x27:                 escapeSequence = keyState > 0 ? "\\E[1;%p1%dC" : getRawSequence(InfoCmp.Capability.key_right);
break;
case 0x28:                 escapeSequence = keyState > 0 ? "\\E[1;%p1%dB" : getRawSequence(InfoCmp.Capability.key_down);
break;
case 0x2D:                 escapeSequence = getRawSequence(InfoCmp.Capability.key_ic);
break;
case 0x2E:                 escapeSequence = getRawSequence(InfoCmp.Capability.key_dc);
break;
case 0x70:                 escapeSequence = keyState > 0 ? "\\E[1;%p1%dP" : getRawSequence(InfoCmp.Capability.key_f1);
break;
case 0x71:                 escapeSequence = keyState > 0 ? "\\E[1;%p1%dQ" : getRawSequence(InfoCmp.Capability.key_f2);
break;
case 0x72:                 escapeSequence = keyState > 0 ? "\\E[1;%p1%dR" : getRawSequence(InfoCmp.Capability.key_f3);
break;
case 0x73:                 escapeSequence = keyState > 0 ? "\\E[1;%p1%dS" : getRawSequence(InfoCmp.Capability.key_f4);
break;
case 0x74:                 escapeSequence = keyState > 0 ? "\\E[15;%p1%d~" : getRawSequence(InfoCmp.Capability.key_f5);
break;
case 0x75:                 escapeSequence = keyState > 0 ? "\\E[17;%p1%d~" : getRawSequence(InfoCmp.Capability.key_f6);
break;
case 0x76:                 escapeSequence = keyState > 0 ? "\\E[18;%p1%d~" : getRawSequence(InfoCmp.Capability.key_f7);
break;
case 0x77:                 escapeSequence = keyState > 0 ? "\\E[19;%p1%d~" : getRawSequence(InfoCmp.Capability.key_f8);
break;
case 0x78:                 escapeSequence = keyState > 0 ? "\\E[20;%p1%d~" : getRawSequence(InfoCmp.Capability.key_f9);
break;
case 0x79:                 escapeSequence = keyState > 0 ? "\\E[21;%p1%d~" : getRawSequence(InfoCmp.Capability.key_f10);
break;
case 0x7A:                 escapeSequence = keyState > 0 ? "\\E[23;%p1%d~" : getRawSequence(InfoCmp.Capability.key_f11);
break;
case 0x7B:                 escapeSequence = keyState > 0 ? "\\E[24;%p1%d~" : getRawSequence(InfoCmp.Capability.key_f12);
break;
case 0x5D:             case 0x5B:             default:
return null;
}
return Curses.tputs(escapeSequence, keyState + 1);
}
protected String getRawSequence(InfoCmp.Capability cap) {
return strings.get(cap);
}
@Override
public boolean hasFocusSupport() {
return true;
}
@Override
public boolean trackFocus(boolean tracking) {
focusTracking = tracking;
return true;
}
@Override
public boolean canPauseResume() {
return true;
}
@Override
public void pause() {
synchronized (lock) {
paused = true;
}
}
@Override
public void pause(boolean wait) throws InterruptedException {
Thread p;
synchronized (lock) {
paused = true;
p = pump;
}
if (p != null) {
p.interrupt();
p.join();
}
}
@Override
public void resume() {
synchronized (lock) {
paused = false;
if (pump == null) {
pump = new Thread(this::pump, "WindowsStreamPump");
pump.setDaemon(true);
pump.start();
}
}
}
@Override
public boolean paused() {
synchronized (lock) {
return paused;
}
}
protected void pump() {
try {
while (!closing) {
synchronized (lock) {
if (paused) {
pump = null;
break;
}
}
if (processConsoleInput()) {
slaveInputPipe.flush();
}
}
} catch (IOException e) {
if (!closing) {
Log.warn("Error in WindowsStreamPump", e);
try {
close();
} catch (IOException e1) {
Log.warn("Error closing terminal", e);
}
}
} finally {
synchronized (lock) {
pump = null;
}
}
}
public void processInputChar(char c) throws IOException {
if (attributes.getLocalFlag(Attributes.LocalFlag.ISIG)) {
if (c == attributes.getControlChar(Attributes.ControlChar.VINTR)) {
raise(Signal.INT);
return;
} else if (c == attributes.getControlChar(Attributes.ControlChar.VQUIT)) {
raise(Signal.QUIT);
return;
} else if (c == attributes.getControlChar(Attributes.ControlChar.VSUSP)) {
raise(Signal.TSTP);
return;
} else if (c == attributes.getControlChar(Attributes.ControlChar.VSTATUS)) {
raise(Signal.INFO);
}
}
if (c == '\r') {
if (attributes.getInputFlag(Attributes.InputFlag.IGNCR)) {
return;
}
if (attributes.getInputFlag(Attributes.InputFlag.ICRNL)) {
c = '\n';
}
} else if (c == '\n' && attributes.getInputFlag(Attributes.InputFlag.INLCR)) {
c = '\r';
}
slaveInputPipe.write(c);
}
@Override
public boolean trackMouse(MouseTracking tracking) {
this.tracking = tracking;
updateConsoleMode();
return true;
}
protected abstract int getConsoleMode();
protected abstract void setConsoleMode(int mode);
protected abstract boolean processConsoleInput() throws IOException;
}
package javax.swing.text;
import java.io.Writer;
import java.io.IOException;
import java.util.Enumeration;
public abstract class AbstractWriter {
private ElementIterator it;
private Writer out;
private int indentLevel = 0;
private int indentSpace = 2;
private Document doc = null;
private int maxLineLength = 100;
private int currLength = 0;
private int startOffset = 0;
private int endOffset = 0;
private int offsetIndent = 0;
private String lineSeparator;
private boolean canWrapLines;
private boolean isLineEmpty;
private char[] indentChars;
private char[] tempChars;
private char[] newlineChars;
private Segment segment;
protected static final char NEWLINE = '\n';
protected AbstractWriter(Writer w, Document doc) {
this(w, doc, 0, doc.getLength());
}
protected AbstractWriter(Writer w, Document doc, int pos, int len) {
this.doc = doc;
it = new ElementIterator(doc.getDefaultRootElement());
out = w;
startOffset = pos;
endOffset = pos + len;
Object docNewline = doc.getProperty(DefaultEditorKit.
EndOfLineStringProperty);
if (docNewline instanceof String) {
setLineSeparator((String)docNewline);
}
else {
String newline = System.lineSeparator();
if (newline == null) {
newline = "\n";
}
setLineSeparator(newline);
}
canWrapLines = true;
}
protected AbstractWriter(Writer w, Element root) {
this(w, root, 0, root.getEndOffset());
}
protected AbstractWriter(Writer w, Element root, int pos, int len) {
this.doc = root.getDocument();
it = new ElementIterator(root);
out = w;
startOffset = pos;
endOffset = pos + len;
canWrapLines = true;
}
public int getStartOffset() {
return startOffset;
}
public int getEndOffset() {
return endOffset;
}
protected ElementIterator getElementIterator() {
return it;
}
protected Writer getWriter() {
return out;
}
protected Document getDocument() {
return doc;
}
protected boolean inRange(Element next) {
int startOffset = getStartOffset();
int endOffset = getEndOffset();
if ((next.getStartOffset() >= startOffset &&
next.getStartOffset()  < endOffset) ||
(startOffset >= next.getStartOffset() &&
startOffset < next.getEndOffset())) {
return true;
}
return false;
}
protected abstract void write() throws IOException, BadLocationException;
protected String getText(Element elem) throws BadLocationException {
return doc.getText(elem.getStartOffset(),
elem.getEndOffset() - elem.getStartOffset());
}
protected void text(Element elem) throws BadLocationException,
IOException {
int start = Math.max(getStartOffset(), elem.getStartOffset());
int end = Math.min(getEndOffset(), elem.getEndOffset());
if (start < end) {
if (segment == null) {
segment = new Segment();
}
getDocument().getText(start, end - start, segment);
if (segment.count > 0) {
write(segment.array, segment.offset, segment.count);
}
}
}
protected void setLineLength(int l) {
maxLineLength = l;
}
protected int getLineLength() {
return maxLineLength;
}
protected void setCurrentLineLength(int length) {
currLength = length;
isLineEmpty = (currLength == 0);
}
protected int getCurrentLineLength() {
return currLength;
}
protected boolean isLineEmpty() {
return isLineEmpty;
}
protected void setCanWrapLines(boolean newValue) {
canWrapLines = newValue;
}
protected boolean getCanWrapLines() {
return canWrapLines;
}
protected void setIndentSpace(int space) {
indentSpace = space;
}
protected int getIndentSpace() {
return indentSpace;
}
public void setLineSeparator(String value) {
lineSeparator = value;
}
public String getLineSeparator() {
return lineSeparator;
}
protected void incrIndent() {
if (offsetIndent > 0) {
offsetIndent++;
}
else {
if (++indentLevel * getIndentSpace() >= getLineLength()) {
offsetIndent++;
--indentLevel;
}
}
}
protected void decrIndent() {
if (offsetIndent > 0) {
--offsetIndent;
}
else {
indentLevel--;
}
}
protected int getIndentLevel() {
return indentLevel;
}
protected void indent() throws IOException {
int max = getIndentLevel() * getIndentSpace();
if (indentChars == null || max > indentChars.length) {
indentChars = new char[max];
for (int counter = 0; counter < max; counter++) {
indentChars[counter] = ' ';
}
}
int length = getCurrentLineLength();
boolean wasEmpty = isLineEmpty();
output(indentChars, 0, max);
if (wasEmpty && length == 0) {
isLineEmpty = true;
}
}
protected void write(char ch) throws IOException {
if (tempChars == null) {
tempChars = new char[128];
}
tempChars[0] = ch;
write(tempChars, 0, 1);
}
protected void write(String content) throws IOException {
if (content == null) {
return;
}
int size = content.length();
if (tempChars == null || tempChars.length < size) {
tempChars = new char[size];
}
content.getChars(0, size, tempChars, 0);
write(tempChars, 0, size);
}
protected void writeLineSeparator() throws IOException {
String newline = getLineSeparator();
int length = newline.length();
if (newlineChars == null || newlineChars.length < length) {
newlineChars = new char[length];
}
newline.getChars(0, length, newlineChars, 0);
output(newlineChars, 0, length);
setCurrentLineLength(0);
}
protected void write(char[] chars, int startIndex, int length)
throws IOException {
if (!getCanWrapLines()) {
int lastIndex = startIndex;
int endIndex = startIndex + length;
int newlineIndex = indexOf(chars, NEWLINE, startIndex, endIndex);
while (newlineIndex != -1) {
if (newlineIndex > lastIndex) {
output(chars, lastIndex, newlineIndex - lastIndex);
}
writeLineSeparator();
lastIndex = newlineIndex + 1;
newlineIndex = indexOf(chars, '\n', lastIndex, endIndex);
}
if (lastIndex < endIndex) {
output(chars, lastIndex, endIndex - lastIndex);
}
}
else {
int lastIndex = startIndex;
int endIndex = startIndex + length;
int lineLength = getCurrentLineLength();
int maxLength = getLineLength();
while (lastIndex < endIndex) {
int newlineIndex = indexOf(chars, NEWLINE, lastIndex,
endIndex);
boolean needsNewline = false;
boolean forceNewLine = false;
lineLength = getCurrentLineLength();
if (newlineIndex != -1 && (lineLength +
(newlineIndex - lastIndex)) < maxLength) {
if (newlineIndex > lastIndex) {
output(chars, lastIndex, newlineIndex - lastIndex);
}
lastIndex = newlineIndex + 1;
forceNewLine = true;
}
else if (newlineIndex == -1 && (lineLength +
(endIndex - lastIndex)) < maxLength) {
if (endIndex > lastIndex) {
output(chars, lastIndex, endIndex - lastIndex);
}
lastIndex = endIndex;
}
else {
int breakPoint = -1;
int maxBreak = Math.min(endIndex - lastIndex,
maxLength - lineLength - 1);
int counter = 0;
while (counter < maxBreak) {
if (Character.isWhitespace(chars[counter +
lastIndex])) {
breakPoint = counter;
}
counter++;
}
if (breakPoint != -1) {
breakPoint += lastIndex + 1;
output(chars, lastIndex, breakPoint - lastIndex);
lastIndex = breakPoint;
needsNewline = true;
}
else {
counter = Math.max(0, maxBreak);
maxBreak = endIndex - lastIndex;
while (counter < maxBreak) {
if (Character.isWhitespace(chars[counter +
lastIndex])) {
breakPoint = counter;
break;
}
counter++;
}
if (breakPoint == -1) {
output(chars, lastIndex, endIndex - lastIndex);
breakPoint = endIndex;
}
else {
breakPoint += lastIndex;
if (chars[breakPoint] == NEWLINE) {
output(chars, lastIndex, breakPoint++ -
lastIndex);
forceNewLine = true;
}
else {
output(chars, lastIndex, ++breakPoint -
lastIndex);
needsNewline = true;
}
}
lastIndex = breakPoint;
}
}
if (forceNewLine || needsNewline || lastIndex < endIndex) {
writeLineSeparator();
if (lastIndex < endIndex || !forceNewLine) {
indent();
}
}
}
}
}
protected void writeAttributes(AttributeSet attr) throws IOException {
Enumeration<?> names = attr.getAttributeNames();
while (names.hasMoreElements()) {
Object name = names.nextElement();
write(" " + name + "=" + attr.getAttribute(name));
}
}
protected void output(char[] content, int start, int length)
throws IOException {
getWriter().write(content, start, length);
setCurrentLineLength(getCurrentLineLength() + length);
}
private int indexOf(char[] chars, char sChar, int startIndex,
int endIndex) {
while(startIndex < endIndex) {
if (chars[startIndex] == sChar) {
return startIndex;
}
startIndex++;
}
return -1;
}
}
package com.sun.org.apache.xerces.internal.parsers;
import com.sun.org.apache.xerces.internal.xni.Augmentations;
import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
import com.sun.org.apache.xerces.internal.xni.QName;
import com.sun.org.apache.xerces.internal.xni.XMLAttributes;
import com.sun.org.apache.xerces.internal.xni.XMLDTDContentModelHandler;
import com.sun.org.apache.xerces.internal.xni.XMLDTDHandler;
import com.sun.org.apache.xerces.internal.xni.XMLDocumentHandler;
import com.sun.org.apache.xerces.internal.xni.XMLLocator;
import com.sun.org.apache.xerces.internal.xni.XMLResourceIdentifier;
import com.sun.org.apache.xerces.internal.xni.XMLString;
import com.sun.org.apache.xerces.internal.xni.XNIException;
import com.sun.org.apache.xerces.internal.xni.parser.XMLDTDContentModelSource;
import com.sun.org.apache.xerces.internal.xni.parser.XMLDTDSource;
import com.sun.org.apache.xerces.internal.xni.parser.XMLDocumentSource;
import com.sun.org.apache.xerces.internal.xni.parser.XMLParserConfiguration;
public abstract class AbstractXMLDocumentParser
extends XMLParser
implements XMLDocumentHandler, XMLDTDHandler, XMLDTDContentModelHandler {
protected boolean fInDTD;
protected XMLDocumentSource fDocumentSource;
protected XMLDTDSource fDTDSource;
protected XMLDTDContentModelSource fDTDContentModelSource;
protected AbstractXMLDocumentParser(XMLParserConfiguration config) {
super(config);
config.setDocumentHandler(this);
config.setDTDHandler(this);
config.setDTDContentModelHandler(this);
}
public void startDocument(XMLLocator locator, String encoding,
NamespaceContext namespaceContext, Augmentations augs)
throws XNIException {
}
public void xmlDecl(String version, String encoding, String standalone, Augmentations augs)
throws XNIException {
}
public void doctypeDecl(String rootElement, String publicId, String systemId, Augmentations augs)
throws XNIException {
}
public void startElement(QName element, XMLAttributes attributes, Augmentations augs)
throws XNIException {
}
public void emptyElement(QName element, XMLAttributes attributes, Augmentations augs)
throws XNIException {
startElement(element, attributes, augs);
endElement(element, augs);
}
public void characters(XMLString text, Augmentations augs) throws XNIException {
}
public void ignorableWhitespace(XMLString text, Augmentations augs) throws XNIException {
}
public void endElement(QName element, Augmentations augs) throws XNIException {
}
public void startCDATA(Augmentations augs) throws XNIException {
}
public void endCDATA(Augmentations augs) throws XNIException {
}
public void endDocument(Augmentations augs) throws XNIException {
}
public void startGeneralEntity(String name,
XMLResourceIdentifier identifier,
String encoding,
Augmentations augs) throws XNIException {
}
public void textDecl(String version, String encoding, Augmentations augs) throws XNIException {
}
public void endGeneralEntity(String name, Augmentations augs)
throws XNIException {
}
public void comment(XMLString text, Augmentations augs) throws XNIException {
}
public void processingInstruction(String target, XMLString data, Augmentations augs)
throws XNIException {
}
public void setDocumentSource(XMLDocumentSource source){
fDocumentSource = source;
}
public XMLDocumentSource getDocumentSource (){
return fDocumentSource;
}
public void startDTD(XMLLocator locator, Augmentations augs) throws XNIException {
fInDTD = true;
}
public void startExternalSubset(XMLResourceIdentifier identifier, Augmentations augmentations)
throws XNIException {
}
public void endExternalSubset(Augmentations augmentations)
throws XNIException {
}
public void startParameterEntity(String name,
XMLResourceIdentifier identifier,
String encoding,
Augmentations augs) throws XNIException {
}
public void endParameterEntity(String name, Augmentations augs)
throws XNIException {
}
public void ignoredCharacters(XMLString text, Augmentations augs) throws XNIException {
}
public void elementDecl(String name, String contentModel, Augmentations augs)
throws XNIException {
}
public void startAttlist(String elementName, Augmentations augs) throws XNIException {
}
public void attributeDecl(String elementName, String attributeName,
String type, String[] enumeration,
String defaultType, XMLString defaultValue,
XMLString nonNormalizedDefaultValue, Augmentations augs)
throws XNIException {
}
public void endAttlist(Augmentations augs) throws XNIException {
}
public void internalEntityDecl(String name, XMLString text,
XMLString nonNormalizedText, Augmentations augs)
throws XNIException {
}
public void externalEntityDecl(String name, XMLResourceIdentifier identifier,
Augmentations augs) throws XNIException {
}
public void unparsedEntityDecl(String name, XMLResourceIdentifier identifier,
String notation, Augmentations augs) throws XNIException {
}
public void notationDecl(String name, XMLResourceIdentifier identifier,
Augmentations augs)
throws XNIException {
}
public void startConditional(short type, Augmentations augs) throws XNIException  {
}
public void endConditional(Augmentations augs) throws XNIException {
}
public void endDTD(Augmentations augs) throws XNIException {
fInDTD = false;
}
public void setDTDSource(XMLDTDSource source) {
fDTDSource = source;
}
public XMLDTDSource getDTDSource() {
return fDTDSource;
}
public void startContentModel(String elementName, Augmentations augs) throws XNIException {
}
public void any(Augmentations augs) throws XNIException {
}
public void empty(Augmentations augs) throws XNIException {
}
public void startGroup(Augmentations augs) throws XNIException {
}
public void pcdata(Augmentations augs) throws XNIException {
}
public void element(String elementName, Augmentations augs) throws XNIException {
}
public void separator(short separator, Augmentations augs) throws XNIException {
}
public void occurrence(short occurrence, Augmentations augs) throws XNIException {
}
public void endGroup(Augmentations augs) throws XNIException {
}
public void endContentModel(Augmentations augs) throws XNIException {
}
public void setDTDContentModelSource(XMLDTDContentModelSource source) {
fDTDContentModelSource = source;
}
public XMLDTDContentModelSource getDTDContentModelSource() {
return fDTDContentModelSource;
}
protected void reset() throws XNIException {
super.reset();
fInDTD = false;
}
}
package com.sun.org.apache.xerces.internal.jaxp.validation;
import java.util.HashMap;
import java.util.Map;
import javax.xml.validation.Schema;
import javax.xml.validation.Validator;
import javax.xml.validation.ValidatorHandler;
abstract class AbstractXMLSchema extends Schema implements
XSGrammarPoolContainer {
private final Map<String, Boolean> fFeatures;
private final Map<String, Object> fProperties;
public AbstractXMLSchema() {
fFeatures = new HashMap<>();
fProperties = new HashMap<>();
}
public final Validator newValidator() {
return new ValidatorImpl(this);
}
public final ValidatorHandler newValidatorHandler() {
return new ValidatorHandlerImpl(this);
}
public final Boolean getFeature(String featureId) {
return fFeatures.get(featureId);
}
public final void setFeature(String featureId, boolean state) {
fFeatures.put(featureId, state ? Boolean.TRUE : Boolean.FALSE);
}
public final Object getProperty(String propertyId) {
return fProperties.get(propertyId);
}
public final void setProperty(String propertyId, Object state) {
fProperties.put(propertyId, state);
}
}
public class ACasLoadsStoresBadMem {
public static void main(String[] args) {
int[] dst = new int[5];
for (int i = 0; i < 20_000; i++) {
test1(dst, 1);
for (int j = 1; j < 5; j++) {
if (dst[j] != j) {
throw new RuntimeException("Bad copy ");
}
}
}
}
private static void test1(int[] dst, int dstPos) {
int[] src = new int[4];
not_inlined();
src[0] = 1;
src[1] = 2;
src[2] = 3;
src[3] = 4;
System.arraycopy(src, 0, dst, dstPos, 4);
}
private static void not_inlined() {
}
}
package sun.java2d.pipe.hw;
import java.awt.image.VolatileImage;
public interface AccelGraphicsConfig extends BufferedContextProvider {
public VolatileImage createCompatibleVolatileImage(int width, int height,
int transparency,
int type);
public ContextCapabilities getContextCapabilities();
}
package sun.java2d.pipe.hw;
import java.awt.Rectangle;
import sun.java2d.Surface;
import java.lang.annotation.Native;
public interface AccelSurface extends BufferedContextProvider, Surface {
@Native public static final int UNDEFINED       = 0;
@Native public static final int WINDOW          = 1;
@Native public static final int RT_PLAIN        = 2;
@Native public static final int TEXTURE         = 3;
@Native public static final int FLIP_BACKBUFFER = 4;
@Native public static final int RT_TEXTURE      = 5;
public int getType();
public long getNativeOps();
public long getNativeResource(int resType);
public void markDirty();
public boolean isValid();
public boolean isSurfaceLost();
public Rectangle getBounds();
public Rectangle getNativeBounds();
}
package sun.java2d.pipe.hw;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import sun.awt.image.SunVolatileImage;
import static sun.java2d.pipe.hw.AccelSurface.*;
public class AccelTypedVolatileImage extends SunVolatileImage {
public AccelTypedVolatileImage(GraphicsConfiguration graphicsConfig,
int width, int height, int transparency,
int accType)
{
super(null, graphicsConfig, width, height, null, transparency,
null, accType);
}
@Override
public Graphics2D createGraphics() {
if (getForcedAccelSurfaceType() == TEXTURE) {
throw new UnsupportedOperationException("Can't render " +
"to a non-RT Texture");
}
return super.createGraphics();
}
}
package sun.security.jgss.krb5;
import org.ietf.jgss.*;
import java.io.InputStream;
import java.io.IOException;
import sun.security.action.GetBooleanAction;
import sun.security.krb5.*;
class AcceptSecContextToken extends InitialToken {
private KrbApRep apRep = null;
public AcceptSecContextToken(Krb5Context context,
KrbApReq apReq)
throws KrbException, IOException, GSSException {
boolean useSubkey = GetBooleanAction
.privilegedGetProperty("sun.security.krb5.acceptor.subkey");
boolean useSequenceNumber = true;
EncryptionKey subKey = null;
if (useSubkey) {
subKey = new EncryptionKey(apReq.getCreds().getSessionKey());
context.setKey(Krb5Context.ACCEPTOR_SUBKEY, subKey);
}
apRep = new KrbApRep(apReq, useSequenceNumber, subKey);
context.resetMySequenceNumber(apRep.getSeqNumber().intValue());
}
public AcceptSecContextToken(Krb5Context context,
Credentials serviceCreds, KrbApReq apReq,
InputStream is)
throws IOException, GSSException, KrbException  {
int tokenId = ((is.read()<<8) | is.read());
if (tokenId != Krb5Token.AP_REP_ID)
throw new GSSException(GSSException.DEFECTIVE_TOKEN, -1,
"AP_REP token id does not match!");
byte[] apRepBytes =
new sun.security.util.DerValue(is).toByteArray();
KrbApRep apRep = new KrbApRep(apRepBytes, serviceCreds, apReq);
EncryptionKey subKey = apRep.getSubKey();
if (subKey != null) {
context.setKey(Krb5Context.ACCEPTOR_SUBKEY, subKey);
}
Integer apRepSeqNumber = apRep.getSeqNumber();
int peerSeqNumber = (apRepSeqNumber != null ?
apRepSeqNumber.intValue() :
0);
context.resetPeerSequenceNumber(peerSeqNumber);
}
public final byte[] encode() throws IOException {
byte[] apRepBytes = apRep.getMessage();
byte[] retVal = new byte[2 + apRepBytes.length];
writeInt(Krb5Token.AP_REP_ID, retVal, 0);
System.arraycopy(apRepBytes, 0, retVal, 2, apRepBytes.length);
return retVal;
}
}
package com.sun.java.accessibility.internal;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.IllegalComponentStateException;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.InvocationEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.awt.geom.AffineTransform;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Locale;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.WeakHashMap;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import javax.accessibility.Accessible;
import javax.accessibility.AccessibleAction;
import javax.accessibility.AccessibleComponent;
import javax.accessibility.AccessibleContext;
import javax.accessibility.AccessibleEditableText;
import javax.accessibility.AccessibleExtendedComponent;
import javax.accessibility.AccessibleExtendedTable;
import javax.accessibility.AccessibleHyperlink;
import javax.accessibility.AccessibleHypertext;
import javax.accessibility.AccessibleIcon;
import javax.accessibility.AccessibleKeyBinding;
import javax.accessibility.AccessibleRelation;
import javax.accessibility.AccessibleRelationSet;
import javax.accessibility.AccessibleRole;
import javax.accessibility.AccessibleSelection;
import javax.accessibility.AccessibleState;
import javax.accessibility.AccessibleStateSet;
import javax.accessibility.AccessibleTable;
import javax.accessibility.AccessibleText;
import javax.accessibility.AccessibleValue;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.JRootPane;
import javax.swing.JTable;
import javax.swing.JTree;
import javax.swing.KeyStroke;
import javax.swing.MenuElement;
import javax.swing.MenuSelectionManager;
import javax.swing.event.CaretEvent;
import javax.swing.event.CaretListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.plaf.TreeUI;
import javax.swing.table.TableCellRenderer;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;
import javax.swing.text.StyleConstants;
import javax.swing.text.TabSet;
import javax.swing.tree.TreeCellRenderer;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;
import com.sun.java.accessibility.util.AWTEventMonitor;
import com.sun.java.accessibility.util.AccessibilityEventMonitor;
import com.sun.java.accessibility.util.EventQueueMonitor;
import com.sun.java.accessibility.util.SwingEventMonitor;
import com.sun.java.accessibility.util.Translator;
import sun.awt.AWTAccessor;
import sun.awt.AppContext;
import sun.awt.SunToolkit;
public final class AccessBridge {
private static AccessBridge theAccessBridge;
private ObjectReferences references;
private EventHandler eventHandler;
private ConcurrentHashMap<String,AccessibleRole> accessibleRoleMap = new ConcurrentHashMap<>();
private ArrayList<AccessibleRole> extendedVirtualNameSearchRoles = new ArrayList<>();
private ArrayList<AccessibleRole> noExtendedVirtualNameSearchParentRoles = new ArrayList<>();
private static native boolean isSysWow();
static {
initStatic();
}
@SuppressWarnings("removal")
private static void initStatic() {
boolean is32on64 = false;
if (System.getProperty("os.arch").equals("x86")) {
java.security.AccessController.doPrivileged(
new java.security.PrivilegedAction<Void>() {
public Void run() {
System.loadLibrary("jabsysinfo");
return null;
}
}, null, new java.lang.RuntimePermission("loadLibrary.jabsysinfo")
);
if (isSysWow()) {
is32on64 = true;
java.security.AccessController.doPrivileged(
new java.security.PrivilegedAction<Void>() {
public Void run() {
System.loadLibrary("javaaccessbridge-32");
return null;
}
}, null, new java.lang.RuntimePermission("loadLibrary.javaaccessbridge-32")
);
}
}
if (!is32on64) {
java.security.AccessController.doPrivileged(
new java.security.PrivilegedAction<Void>() {
public Void run() {
System.loadLibrary("javaaccessbridge");
return null;
}
}, null, new java.lang.RuntimePermission("loadLibrary.javaaccessbridge")
);
}
}
public AccessBridge() {
theAccessBridge = this;
references = new ObjectReferences();
Runtime runTime = Runtime.getRuntime();
shutdownHook hook = new shutdownHook();
runTime.addShutdownHook(new Thread(hook));
initAccessibleRoleMap();
initHWNDcalls();
EventQueueMonitor.isGUIInitialized();
eventHandler = new EventHandler(this);
MenuSelectionManager.defaultManager().addChangeListener(eventHandler);
addNativeWindowHandler(new DefaultNativeWindowHandler());
Thread abthread = new Thread(new dllRunner());
abthread.setDaemon(true);
abthread.start();
debugString("[INFO]:AccessBridge started");
}
private class dllRunner implements Runnable {
public void run() {
runDLL();
}
}
private class shutdownHook implements Runnable {
public void run() {
debugString("[INFO]:***** shutdownHook: shutting down...");
javaShutdown();
}
}
private void initAccessibleRoleMap() {
try {
Class<?> clAccessibleRole = Class.forName ("javax.accessibility.AccessibleRole");
if (null != clAccessibleRole) {
AccessibleRole roleUnknown = AccessibleRole.UNKNOWN;
Field [] fields = clAccessibleRole.getFields ();
int i = 0;
for (i = 0; i < fields.length; i ++) {
Field f = fields [i];
if (javax.accessibility.AccessibleRole.class == f.getType ()) {
AccessibleRole nextRole = (AccessibleRole) (f.get (roleUnknown));
String nextRoleString = nextRole.toDisplayString (Locale.US);
accessibleRoleMap.put (nextRoleString, nextRole);
}
}
}
} catch (Exception e) {}
extendedVirtualNameSearchRoles.add (AccessibleRole.COMBO_BOX);
try {
extendedVirtualNameSearchRoles.add (AccessibleRole.DATE_EDITOR);
} catch (NoSuchFieldError e) {}
extendedVirtualNameSearchRoles.add (AccessibleRole.LIST);
extendedVirtualNameSearchRoles.add (AccessibleRole.PASSWORD_TEXT);
extendedVirtualNameSearchRoles.add (AccessibleRole.SLIDER);
try {
extendedVirtualNameSearchRoles.add (AccessibleRole.SPIN_BOX);
} catch (NoSuchFieldError e) {}
extendedVirtualNameSearchRoles.add (AccessibleRole.TABLE);
extendedVirtualNameSearchRoles.add (AccessibleRole.TEXT);
extendedVirtualNameSearchRoles.add (AccessibleRole.UNKNOWN);
noExtendedVirtualNameSearchParentRoles.add (AccessibleRole.TABLE);
noExtendedVirtualNameSearchParentRoles.add (AccessibleRole.TOOL_BAR);
}
private native void runDLL();
private native void sendDebugString(String debugStr);
private void debugString(String debugStr) {
sendDebugString(debugStr);
}
private void decrementReference(Object o) {
references.decrement(o);
}
private String getJavaVersionProperty() {
String s = System.getProperty("java.version");
if (s != null) {
references.increment(s);
return s;
}
return null;
}
private Method javaGetComponentFromNativeWindowHandleMethod;
private Method javaGetNativeWindowHandleFromComponentMethod;
private native int jawtGetNativeWindowHandleFromComponent(Component comp);
private native Component jawtGetComponentFromNativeWindowHandle(int handle);
Toolkit toolkit;
private void initHWNDcalls() {
Class<?>[] integerParemter = new Class<?>[1];
integerParemter[0] = Integer.TYPE;
Class<?>[] componentParemter = new Class<?>[1];
try {
componentParemter[0] = Class.forName("java.awt.Component");
} catch (ClassNotFoundException e) {
debugString("[ERROR]:Exception: " + e.toString());
}
toolkit = Toolkit.getDefaultToolkit();
return;
}
private interface NativeWindowHandler {
public Accessible getAccessibleFromNativeWindowHandle(int nativeHandle);
}
private static ConcurrentHashMap<Integer,AccessibleContext> windowHandleToContextMap = new ConcurrentHashMap<>();
private static ConcurrentHashMap<AccessibleContext,Integer> contextToWindowHandleMap = new ConcurrentHashMap<>();
private static void registerVirtualFrame(final Accessible a,
Integer nativeWindowHandle ) {
if (a != null) {
AccessibleContext ac = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
return a.getAccessibleContext();
}
}, a);
windowHandleToContextMap.put(nativeWindowHandle, ac);
contextToWindowHandleMap.put(ac, nativeWindowHandle);
}
}
private static void revokeVirtualFrame(final Accessible a,
Integer nativeWindowHandle ) {
AccessibleContext ac = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
return a.getAccessibleContext();
}
}, a);
windowHandleToContextMap.remove(nativeWindowHandle);
contextToWindowHandleMap.remove(ac);
}
private static Vector<NativeWindowHandler> nativeWindowHandlers = new Vector<>();
private static void addNativeWindowHandler(NativeWindowHandler handler) {
if (handler == null) {
throw new IllegalArgumentException();
}
nativeWindowHandlers.addElement(handler);
}
private static boolean removeNativeWindowHandler(NativeWindowHandler handler) {
if (handler == null) {
throw new IllegalArgumentException();
}
return nativeWindowHandlers.removeElement(handler);
}
private boolean isJavaWindow(int nativeHandle) {
AccessibleContext ac = getContextFromNativeWindowHandle(nativeHandle);
if (ac != null) {
saveContextToWindowHandleMapping(ac, nativeHandle);
return true;
}
return false;
}
private void saveContextToWindowHandleMapping(AccessibleContext ac,
int nativeHandle) {
debugString("[INFO]:saveContextToWindowHandleMapping...");
if (ac == null) {
return;
}
if (! contextToWindowHandleMap.containsKey(ac)) {
debugString("[INFO]: saveContextToWindowHandleMapping: ac = "+ac+"; handle = "+nativeHandle);
contextToWindowHandleMap.put(ac, nativeHandle);
}
}
private AccessibleContext getContextFromNativeWindowHandle(int nativeHandle) {
AccessibleContext ac = windowHandleToContextMap.get(nativeHandle);
if(ac!=null) {
saveContextToWindowHandleMapping(ac, nativeHandle);
return ac;
}
int numHandlers = nativeWindowHandlers.size();
for (int i = 0; i < numHandlers; i++) {
NativeWindowHandler nextHandler = nativeWindowHandlers.elementAt(i);
final Accessible a = nextHandler.getAccessibleFromNativeWindowHandle(nativeHandle);
if (a != null) {
ac = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
return a.getAccessibleContext();
}
}, a);
saveContextToWindowHandleMapping(ac, nativeHandle);
return ac;
}
}
return null;
}
private int getNativeWindowHandleFromContext(AccessibleContext ac) {
debugString("[INFO]: getNativeWindowHandleFromContext: ac = "+ac);
try {
return contextToWindowHandleMap.get(ac);
} catch (Exception ex) {
return 0;
}
}
private class DefaultNativeWindowHandler implements NativeWindowHandler {
public Accessible getAccessibleFromNativeWindowHandle(int nativeHandle) {
final Component c = jawtGetComponentFromNativeWindowHandle(nativeHandle);
if (c instanceof Accessible) {
AccessibleContext ac = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
return c.getAccessibleContext();
}
}, c);
saveContextToWindowHandleMapping(ac, nativeHandle);
return (Accessible)c;
} else {
return null;
}
}
}
private AccessibleContext getAccessibleContextAt(int x, int y,
AccessibleContext parent) {
if (parent == null) {
return null;
}
Point userSpaceXY = AccessibilityGraphicsEnvironment.toUserSpace(x, y);
x = userSpaceXY.x;
y = userSpaceXY.y;
if (windowHandleToContextMap != null &&
windowHandleToContextMap.containsValue(getRootAccessibleContext(parent))) {
return getAccessibleContextAt_1(x, y, parent);
} else {
return getAccessibleContextAt_2(x, y, parent);
}
}
private AccessibleContext getRootAccessibleContext(final AccessibleContext ac) {
if (ac == null) {
return null;
}
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
Accessible parent = ac.getAccessibleParent();
if (parent == null) {
return ac;
}
Accessible tmp = parent.getAccessibleContext().getAccessibleParent();
while (tmp != null) {
parent = tmp;
tmp = parent.getAccessibleContext().getAccessibleParent();
}
return parent.getAccessibleContext();
}
}, ac);
}
private AccessibleContext getAccessibleContextAt_1(final int x, final int y,
final AccessibleContext parent) {
debugString("[INFO]: getAccessibleContextAt_1 called");
debugString("   -> x = " + x + " y = " + y + " parent = " + parent);
if (parent == null) return null;
final AccessibleComponent acmp = InvocationUtils.invokeAndWait(new Callable<AccessibleComponent>() {
@Override
public AccessibleComponent call() throws Exception {
return parent.getAccessibleComponent();
}
}, parent);
if (acmp!=null) {
final Point loc = InvocationUtils.invokeAndWait(new Callable<Point>() {
@Override
public Point call() throws Exception {
return acmp.getLocation();
}
}, parent);
final Accessible a = InvocationUtils.invokeAndWait(new Callable<Accessible>() {
@Override
public Accessible call() throws Exception {
return acmp.getAccessibleAt(new Point(x - loc.x, y - loc.y));
}
}, parent);
if (a != null) {
AccessibleContext foundAC = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
return a.getAccessibleContext();
}
}, parent);
if (foundAC != null) {
if (foundAC != parent) {
return getAccessibleContextAt_1(x - loc.x, y - loc.y,
foundAC);
} else
return foundAC;
}
}
}
return parent;
}
private AccessibleContext getAccessibleContextAt_2(final int x, final int y,
AccessibleContext parent) {
debugString("[INFO]: getAccessibleContextAt_2 called");
debugString("   -> x = " + x + " y = " + y + " parent = " + parent);
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
Accessible a = EventQueueMonitor.getAccessibleAt(new Point(x, y));
if (a != null) {
AccessibleContext childAC = a.getAccessibleContext();
if (childAC != null) {
debugString("[INFO]:   returning childAC = " + childAC);
return childAC;
}
}
return null;
}
}, parent);
}
private AccessibleContext getAccessibleContextWithFocus() {
Component c = AWTEventMonitor.getComponentWithFocus();
if (c != null) {
final Accessible a = Translator.getAccessible(c);
if (a != null) {
AccessibleContext ac = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
return a.getAccessibleContext();
}
}, c);
if (ac != null) {
return ac;
}
}
}
return null;
}
private String getAccessibleNameFromContext(final AccessibleContext ac) {
debugString("[INFO]: ***** ac = "+ac.getClass());
if (ac != null) {
String s = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return ac.getAccessibleName();
}
}, ac);
if (s != null) {
references.increment(s);
debugString("[INFO]: Returning AccessibleName from Context: " + s);
return s;
} else {
return null;
}
} else {
debugString("[INFO]: getAccessibleNameFromContext; ac = null!");
return null;
}
}
private String getVirtualAccessibleNameFromContext(final AccessibleContext ac) {
if (null != ac) {
String nameString = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return ac.getAccessibleName();
}
}, ac);
if ( ( null != nameString ) && ( 0 != nameString.length () ) ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from AccessibleContext::getAccessibleName.");
references.increment (nameString);
return nameString;
}
String descriptionString = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return ac.getAccessibleDescription();
}
}, ac);
if ( ( null != descriptionString ) && ( 0 != descriptionString.length () ) ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from AccessibleContext::getAccessibleDescription.");
references.increment (descriptionString);
return descriptionString;
}
debugString ("[WARN]: The Virtual Accessible Name was not found using AccessibleContext::getAccessibleDescription. or getAccessibleName");
boolean bExtendedSearch = false;
AccessibleRole role = InvocationUtils.invokeAndWait(new Callable<AccessibleRole>() {
@Override
public AccessibleRole call() throws Exception {
return ac.getAccessibleRole();
}
}, ac);
AccessibleContext parentContext = null;
AccessibleRole parentRole = AccessibleRole.UNKNOWN;
if ( extendedVirtualNameSearchRoles.contains (role) ) {
parentContext = getAccessibleParentFromContext (ac);
if ( null != parentContext ) {
final AccessibleContext parentContextInnerTemp = parentContext;
parentRole = InvocationUtils.invokeAndWait(new Callable<AccessibleRole>() {
@Override
public AccessibleRole call() throws Exception {
return parentContextInnerTemp.getAccessibleRole();
}
}, ac);
if ( AccessibleRole.UNKNOWN != parentRole ) {
bExtendedSearch = true;
if ( noExtendedVirtualNameSearchParentRoles.contains (parentRole) ) {
bExtendedSearch = false;
}
}
}
}
if (false == bExtendedSearch) {
debugString ("[INFO]: bk -- getVirtualAccessibleNameFromContext will not use the extended name search algorithm.  role = " + ( role != null ? role.toDisplayString(Locale.US) : "null") );
if (AccessibleRole.LABEL == role) {
final AccessibleText at = InvocationUtils.invokeAndWait(new Callable<AccessibleText>() {
@Override
public AccessibleText call() throws Exception {
return ac.getAccessibleText();
}
}, ac);
if (null != at) {
int charCount = InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return at.getCharCount();
}
}, ac);
String text = getAccessibleTextRangeFromContext (ac, 0, charCount);
if (null != text) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from the Accessible Text of the LABEL object.");
references.increment (text);
return text;
}
}
debugString ("[INFO]: bk -- Attempting to obtain the Virtual Accessible Name from the Accessible Icon information.");
final AccessibleIcon [] ai = InvocationUtils.invokeAndWait(new Callable<AccessibleIcon[]>() {
@Override
public AccessibleIcon[] call() throws Exception {
return ac.getAccessibleIcon();
}
}, ac);
if ( (null != ai) && (ai.length > 0) ) {
String iconDescription = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return ai[0].getAccessibleIconDescription();
}
}, ac);
if (iconDescription != null){
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from the description of the first Accessible Icon found in the LABEL object.");
references.increment (iconDescription);
return iconDescription;
}
} else {
parentContext = getAccessibleParentFromContext (ac);
if ( null != parentContext ) {
final AccessibleContext parentContextInnerTemp = parentContext;
parentRole = InvocationUtils.invokeAndWait(new Callable<AccessibleRole>() {
@Override
public AccessibleRole call() throws Exception {
return parentContextInnerTemp.getAccessibleRole();
}
}, ac);
if ( AccessibleRole.TABLE == parentRole ) {
int indexInParent = InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return ac.getAccessibleIndexInParent();
}
}, ac);
final AccessibleContext acTableCell = getAccessibleChildFromContext (parentContext, indexInParent);
debugString ("[INFO]: bk -- Making a second attempt to obtain the Virtual Accessible Name from the Accessible Icon information for the Table Cell.");
if (acTableCell != null) {
final AccessibleIcon [] aiRet =InvocationUtils.invokeAndWait(new Callable<AccessibleIcon[]>() {
@Override
public AccessibleIcon[] call() throws Exception {
return acTableCell.getAccessibleIcon();
}
}, ac);
if ( (null != aiRet) && (aiRet.length > 0) ) {
String iconDescription = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return aiRet[0].getAccessibleIconDescription();
}
}, ac);
if (iconDescription != null){
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from the description of the first Accessible Icon found in the Table Cell object.");
references.increment (iconDescription);
return iconDescription;
}
}
}
}
}
}
} else if ( (AccessibleRole.TOGGLE_BUTTON == role) ||
(AccessibleRole.PUSH_BUTTON == role) ) {
debugString ("[INFO]: bk -- Attempting to obtain the Virtual Accessible Name from the Accessible Icon information.");
final AccessibleIcon [] ai = InvocationUtils.invokeAndWait(new Callable<AccessibleIcon[]>() {
@Override
public AccessibleIcon[] call() throws Exception {
return ac.getAccessibleIcon();
}
}, ac);
if ( (null != ai) && (ai.length > 0) ) {
String iconDescription = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return ai[0].getAccessibleIconDescription();
}
}, ac);
if (iconDescription != null){
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from the description of the first Accessible Icon found in the TOGGLE_BUTTON or PUSH_BUTTON object.");
references.increment (iconDescription);
return iconDescription;
}
}
} else if ( AccessibleRole.CHECK_BOX == role ) {
final AccessibleValue av = InvocationUtils.invokeAndWait(new Callable<AccessibleValue>() {
@Override
public AccessibleValue call() throws Exception {
return ac.getAccessibleValue();
}
}, ac);
if ( null != av ) {
nameString = null;
Number value = InvocationUtils.invokeAndWait(new Callable<Number>() {
@Override
public Number call() throws Exception {
return av.getCurrentAccessibleValue();
}
}, ac);
if ( null != value ) {
if ( 1 == value.intValue () ) {
nameString = Boolean.TRUE.toString ();
} else if ( 0 == value.intValue () ) {
nameString = Boolean.FALSE.toString ();
} else {
nameString = value.toString ();
}
if ( null != nameString ) {
references.increment (nameString);
return nameString;
}
}
}
}
return null;
}
final AccessibleContext parentContextOuterTemp = parentContext;
String parentName = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return parentContextOuterTemp.getAccessibleName();
}
}, ac);
String parentDescription = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return parentContextOuterTemp.getAccessibleDescription();
}
}, ac);
if ( (AccessibleRole.SLIDER == role) &&
(AccessibleRole.PANEL == parentRole) &&
(null != parentName) ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from the Accessible Name of the SLIDER object's parent object.");
references.increment (parentName);
return parentName;
}
boolean bIsEditCombo = false;
AccessibleContext testContext = ac;
if ( (AccessibleRole.TEXT == role) &&
(AccessibleRole.COMBO_BOX == parentRole) ) {
bIsEditCombo = true;
if (null != parentName) {
debugString ("[INFO]: bk -- The Virtual Accessible Name for this Edit Combo box was obtained from the Accessible Name of the object's parent object.");
references.increment (parentName);
return parentName;
} else if (null != parentDescription) {
debugString ("[INFO]: bk -- The Virtual Accessible Name for this Edit Combo box was obtained from the Accessible Description of the object's parent object.");
references.increment (parentDescription);
return parentDescription;
}
testContext = parentContext;
parentRole = AccessibleRole.UNKNOWN;
parentContext = getAccessibleParentFromContext (testContext);
if ( null != parentContext ) {
final AccessibleContext parentContextInnerTemp = parentContext;
parentRole = InvocationUtils.invokeAndWait(new Callable<AccessibleRole>() {
@Override
public AccessibleRole call() throws Exception {
return parentContextInnerTemp.getAccessibleRole();
}
}, ac);
}
}
{
final AccessibleContext parentContextTempInner = parentContext;
AccessibleRelationSet ars = InvocationUtils.invokeAndWait(new Callable<AccessibleRelationSet>() {
@Override
public AccessibleRelationSet call() throws Exception {
return parentContextTempInner.getAccessibleRelationSet();
}
}, ac);
if ( ars != null && (ars.size () > 0) && (ars.contains (AccessibleRelation.LABELED_BY)) ) {
AccessibleRelation labeledByRelation = ars.get (AccessibleRelation.LABELED_BY);
if (labeledByRelation != null) {
Object [] targets = labeledByRelation.getTarget ();
Object o = targets [0];
if (o instanceof Accessible) {
AccessibleContext labelContext = ((Accessible)o).getAccessibleContext ();
if (labelContext != null) {
String labelName = labelContext.getAccessibleName ();
String labelDescription = labelContext.getAccessibleDescription ();
if (null != labelName) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained using the LABELED_BY AccessibleRelation -- Name Case.");
references.increment (labelName);
return labelName;
} else if (null != labelDescription) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained using the LABELED_BY AccessibleRelation -- Description Case.");
references.increment (labelDescription);
return labelDescription;
}
}
}
}
}
}
int testIndexMax = 0;
int testX = 0;
int testY = 0;
int testWidth = 0;
int testHeight = 0;
int targetX = 0;
int targetY = 0;
final AccessibleContext tempContext = testContext;
int testIndex = InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return tempContext.getAccessibleIndexInParent();
}
}, ac);
if ( null != parentContext ) {
final AccessibleContext parentContextInnerTemp = parentContext;
testIndexMax =  InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return parentContextInnerTemp.getAccessibleChildrenCount() - 1;
}
}, ac);
}
testX = getAccessibleXcoordFromContext (testContext);
testY = getAccessibleYcoordFromContext (testContext);
testWidth = getAccessibleWidthFromContext (testContext);
testHeight = getAccessibleHeightFromContext (testContext);
targetX = testX + 2;
targetY = testY + 2;
int childIndex = testIndex - 1;
int childX = 0;
int childY = 0;
int childWidth = 0;
int childHeight = 0;
String childName = null;
String childDescription = null;
while (childIndex >= 0) {
final int childIndexTemp = childIndex;
final AccessibleContext parentContextInnerTemp = parentContext;
final Accessible child  =  InvocationUtils.invokeAndWait(new Callable<Accessible>() {
@Override
public Accessible call() throws Exception {
return parentContextInnerTemp.getAccessibleChild(childIndexTemp);
}
}, ac);
if ( null != child ) {
final AccessibleContext childContext = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
return child.getAccessibleContext();
}
}, ac);
if ( null != childContext ) {
AccessibleRole childRole = InvocationUtils.invokeAndWait(new Callable<AccessibleRole>() {
@Override
public AccessibleRole call() throws Exception {
return childContext.getAccessibleRole();
}
}, ac);
if ( AccessibleRole.LABEL == childRole ) {
childX = getAccessibleXcoordFromContext (childContext);
childY = getAccessibleYcoordFromContext (childContext);
childWidth = getAccessibleWidthFromContext (childContext);
childHeight = getAccessibleHeightFromContext (childContext);
if ( (childX < testX) &&
((childY <= targetY) && (targetY <= (childY + childHeight))) ) {
childName = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return childContext.getAccessibleName();
}
}, ac);
if ( null != childName ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from Accessible Name of a LABEL object positioned to the left of the object.");
references.increment (childName);
return childName;
}
childDescription = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return childContext.getAccessibleDescription();
}
}, ac);
if ( null != childDescription ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from Accessible Description of a LABEL object positioned to the left of the object.");
references.increment (childDescription);
return childDescription;
}
} else if ( (childY < targetY) &&
((childX <= targetX) && (targetX <= (childX + childWidth))) ) {
childName = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return childContext.getAccessibleName();
}
}, ac);
if ( null != childName ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from Accessible Name of a LABEL object positioned above the object.");
references.increment (childName);
return childName;
}
childDescription = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return childContext.getAccessibleDescription();
}
}, ac);
if ( null != childDescription ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from Accessible Description of a LABEL object positioned above the object.");
references.increment (childDescription);
return childDescription;
}
}
}
}
}
childIndex --;
}
childIndex = testIndex + 1;
while (childIndex <= testIndexMax) {
final int childIndexTemp = childIndex;
final AccessibleContext parentContextInnerTemp = parentContext;
final Accessible child  =  InvocationUtils.invokeAndWait(new Callable<Accessible>() {
@Override
public Accessible call() throws Exception {
return parentContextInnerTemp.getAccessibleChild(childIndexTemp);
}
}, ac);
if ( null != child ) {
final AccessibleContext childContext = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
return child.getAccessibleContext();
}
}, ac);
if ( null != childContext ) {
AccessibleRole childRole = InvocationUtils.invokeAndWait(new Callable<AccessibleRole>() {
@Override
public AccessibleRole call() throws Exception {
return childContext.getAccessibleRole();
}
}, ac);
if ( AccessibleRole.LABEL == childRole ) {
childX = getAccessibleXcoordFromContext (childContext);
childY = getAccessibleYcoordFromContext (childContext);
childWidth = getAccessibleWidthFromContext (childContext);
childHeight = getAccessibleHeightFromContext (childContext);
if ( (childX < testX) &&
((childY <= targetY) && (targetY <= (childY + childHeight))) ) {
childName = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return childContext.getAccessibleName();
}
}, ac);
if ( null != childName ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from Accessible Name of a LABEL object positioned to the left of the object.");
references.increment (childName);
return childName;
}
childDescription = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return childContext.getAccessibleDescription();
}
}, ac);
if ( null != childDescription ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from Accessible Description of a LABEL object positioned to the left of the object.");
references.increment (childDescription);
return childDescription;
}
} else if ( (childY < targetY) &&
((childX <= targetX) && (targetX <= (childX + childWidth))) ) {
childName = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return childContext.getAccessibleName();
}
}, ac);
if ( null != childName ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from Accessible Name of a LABEL object positioned above the object.");
references.increment (childName);
return childName;
}
childDescription = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return childContext.getAccessibleDescription();
}
}, ac);
if ( null != childDescription ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from Accessible Description of a LABEL object positioned above the object.");
references.increment (childDescription);
return childDescription;
}
}
}
}
}
childIndex ++;
}
if ( (AccessibleRole.TEXT == role) ||
(AccessibleRole.COMBO_BOX == role) ||
(bIsEditCombo) ) {
childIndex = testIndex - 1;
while (childIndex >= 0) {
final int childIndexTemp = childIndex;
final AccessibleContext parentContextInnerTemp = parentContext;
final Accessible child = InvocationUtils.invokeAndWait(new Callable<Accessible>() {
@Override
public Accessible call() throws Exception {
return parentContextInnerTemp.getAccessibleChild(childIndexTemp);
}
}, ac);
if ( null != child ) {
final AccessibleContext childContext = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
return child.getAccessibleContext();
}
}, ac);
if ( null != childContext ) {
AccessibleRole childRole = InvocationUtils.invokeAndWait(new Callable<AccessibleRole>() {
@Override
public AccessibleRole call() throws Exception {
return childContext.getAccessibleRole();
}
}, ac);
if ( ( AccessibleRole.PUSH_BUTTON == childRole ) ||
( AccessibleRole.TOGGLE_BUTTON == childRole )) {
childX = getAccessibleXcoordFromContext (childContext);
childY = getAccessibleYcoordFromContext (childContext);
childWidth = getAccessibleWidthFromContext (childContext);
childHeight = getAccessibleHeightFromContext (childContext);
if ( (childX < testX) &&
((childY <= targetY) && (targetY <= (childY + childHeight))) ) {
childName = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return childContext.getAccessibleName();
}
}, ac);
if ( null != childName ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from Accessible Name of a PUSH_BUTTON or TOGGLE_BUTTON object positioned to the left of the object.");
references.increment (childName);
return childName;
}
childDescription = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return childContext.getAccessibleDescription();
}
}, ac);
if ( null != childDescription ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from Accessible Description of a PUSH_BUTTON or TOGGLE_BUTTON object positioned to the left of the object.");
references.increment (childDescription);
return childDescription;
}
}
}
}
}
childIndex --;
}
childIndex = testIndex + 1;
while (childIndex <= testIndexMax) {
final int childIndexTemp = childIndex;
final AccessibleContext parentContextInnerTemp = parentContext;
final Accessible child  =  InvocationUtils.invokeAndWait(new Callable<Accessible>() {
@Override
public Accessible call() throws Exception {
return parentContextInnerTemp.getAccessibleChild(childIndexTemp);
}
}, ac);
if ( null != child ) {
final AccessibleContext childContext = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
return child.getAccessibleContext();
}
}, ac);
if ( null != childContext ) {
AccessibleRole childRole = InvocationUtils.invokeAndWait(new Callable<AccessibleRole>() {
@Override
public AccessibleRole call() throws Exception {
return childContext.getAccessibleRole();
}
}, ac);
if ( ( AccessibleRole.PUSH_BUTTON == childRole ) ||
( AccessibleRole.TOGGLE_BUTTON == childRole ) ) {
childX = getAccessibleXcoordFromContext (childContext);
childY = getAccessibleYcoordFromContext (childContext);
childWidth = getAccessibleWidthFromContext (childContext);
childHeight = getAccessibleHeightFromContext (childContext);
if ( (childX < testX) &&
((childY <= targetY) && (targetY <= (childY + childHeight))) ) {
childName = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return childContext.getAccessibleName();
}
}, ac);
if ( null != childName ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from Accessible Name of a PUSH_BUTTON or TOGGLE_BUTTON object positioned to the left of the object.");
references.increment (childName);
return childName;
}
childDescription = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return childContext.getAccessibleDescription();
}
}, ac);
if ( null != childDescription ) {
debugString ("[INFO]: bk -- The Virtual Accessible Name was obtained from Accessible Description of a PUSH_BUTTON or TOGGLE_BUTTON object positioned to the left of the object.");
references.increment (childDescription);
return childDescription;
}
}
}
}
}
childIndex ++;
}
}
return null;
} else {
debugString ("[ERROR]: AccessBridge::getVirtualAccessibleNameFromContext error - ac == null.");
return null;
}
}
private String getAccessibleDescriptionFromContext(final AccessibleContext ac) {
if (ac != null) {
String s = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return ac.getAccessibleDescription();
}
}, ac);
if (s != null) {
references.increment(s);
debugString("[INFO]: Returning AccessibleDescription from Context: " + s);
return s;
}
} else {
debugString("[ERROR]: getAccessibleDescriptionFromContext; ac = null");
}
return null;
}
private String getAccessibleRoleStringFromContext(final AccessibleContext ac) {
if (ac != null) {
AccessibleRole role = InvocationUtils.invokeAndWait(new Callable<AccessibleRole>() {
@Override
public AccessibleRole call() throws Exception {
return ac.getAccessibleRole();
}
}, ac);
if (role != null) {
String s = role.toDisplayString(Locale.US);
if (s != null) {
references.increment(s);
debugString("[INFO]: Returning AccessibleRole from Context: " + s);
return s;
}
}
} else {
debugString("[ERROR]: getAccessibleRoleStringFromContext; ac = null");
}
return null;
}
private String getAccessibleRoleStringFromContext_en_US(final AccessibleContext ac) {
return getAccessibleRoleStringFromContext(ac);
}
private String getAccessibleStatesStringFromContext(final AccessibleContext ac) {
if (ac != null) {
AccessibleStateSet stateSet = InvocationUtils.invokeAndWait(new Callable<AccessibleStateSet>() {
@Override
public AccessibleStateSet call() throws Exception {
return ac.getAccessibleStateSet();
}
}, ac);
if (stateSet != null) {
String s = stateSet.toString();
if (s != null &&
s.indexOf(AccessibleState.MANAGES_DESCENDANTS.toDisplayString(Locale.US)) == -1) {
AccessibleRole role = InvocationUtils.invokeAndWait(() -> {
return ac.getAccessibleRole();
}, ac);
if (role == AccessibleRole.LIST ||
role == AccessibleRole.TABLE ||
role == AccessibleRole.TREE) {
s += ",";
s += AccessibleState.MANAGES_DESCENDANTS.toDisplayString(Locale.US);
}
references.increment(s);
debugString("[INFO]: Returning AccessibleStateSet from Context: " + s);
return s;
}
}
} else {
debugString("[ERROR]: getAccessibleStatesStringFromContext; ac = null");
}
return null;
}
private String getAccessibleStatesStringFromContext_en_US(final AccessibleContext ac) {
if (ac != null) {
AccessibleStateSet stateSet = InvocationUtils.invokeAndWait(new Callable<AccessibleStateSet>() {
@Override
public AccessibleStateSet call() throws Exception {
return ac.getAccessibleStateSet();
}
}, ac);
if (stateSet != null) {
String s = "";
AccessibleState[] states = stateSet.toArray();
if (states != null && states.length > 0) {
s = states[0].toDisplayString(Locale.US);
for (int i = 1; i < states.length; i++) {
s = s + "," + states[i].toDisplayString(Locale.US);
}
}
references.increment(s);
debugString("[INFO]: Returning AccessibleStateSet en_US from Context: " + s);
return s;
}
}
debugString("[ERROR]: getAccessibleStatesStringFromContext; ac = null");
return null;
}
private AccessibleContext getAccessibleParentFromContext(final AccessibleContext ac) {
if (ac==null)
return null;
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
Accessible a = ac.getAccessibleParent();
if (a != null) {
AccessibleContext apc = a.getAccessibleContext();
if (apc != null) {
return apc;
}
}
return null;
}
}, ac);
}
private int getAccessibleIndexInParentFromContext(final AccessibleContext ac) {
if (ac==null)
return -1;
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return ac.getAccessibleIndexInParent();
}
}, ac);
}
private int getAccessibleChildrenCountFromContext(final AccessibleContext ac) {
if (ac==null)
return -1;
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return ac.getAccessibleChildrenCount();
}
}, ac);
}
private AccessibleContext getAccessibleChildFromContext(final AccessibleContext ac, final int index) {
if (ac == null) {
return null;
}
final JTable table = InvocationUtils.invokeAndWait(new Callable<JTable>() {
@Override
public JTable call() throws Exception {
Accessible parent = ac.getAccessibleParent();
if (parent != null) {
int indexInParent = ac.getAccessibleIndexInParent();
Accessible child =
parent.getAccessibleContext().getAccessibleChild(indexInParent);
if (child instanceof JTable) {
return (JTable) child;
}
}
return null;
}
}, ac);
if (table == null) {
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
Accessible a = ac.getAccessibleChild(index);
if (a != null) {
return a.getAccessibleContext();
}
return null;
}
}, ac);
}
final AccessibleTable at = getAccessibleTableFromContext(ac);
final int row = getAccessibleTableRow(at, index);
final int column = getAccessibleTableColumn(at, index);
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
TableCellRenderer renderer = table.getCellRenderer(row, column);
if (renderer == null) {
Class<?> columnClass = table.getColumnClass(column);
renderer = table.getDefaultRenderer(columnClass);
}
Component component =
renderer.getTableCellRendererComponent(table, table.getValueAt(row, column),
false, false, row, column);
if (component instanceof Accessible) {
return component.getAccessibleContext();
}
return null;
}
}, ac);
}
private Rectangle getAccessibleBoundsOnScreenFromContext(final AccessibleContext ac) {
if(ac==null)
return null;
return InvocationUtils.invokeAndWait(new Callable<Rectangle>() {
@Override
public Rectangle call() throws Exception {
AccessibleComponent acmp = ac.getAccessibleComponent();
if (acmp != null) {
Rectangle r = acmp.getBounds();
if (r != null) {
try {
Point p = acmp.getLocationOnScreen();
if (p != null) {
r.x = p.x;
r.y = p.y;
r = AccessibilityGraphicsEnvironment.toDeviceSpaceAbs(r);
return r;
}
} catch (Exception e) {
return null;
}
}
}
return null;
}
}, ac);
}
private int getAccessibleXcoordFromContext(AccessibleContext ac) {
if (ac != null) {
Rectangle r = getAccessibleBoundsOnScreenFromContext(ac);
if (r != null) {
debugString("[INFO]: Returning Accessible x coord from Context: " + r.x);
return r.x;
}
} else {
debugString("[ERROR]: getAccessibleXcoordFromContext ac = null");
}
return -1;
}
private int getAccessibleYcoordFromContext(AccessibleContext ac) {
debugString("[INFO]: getAccessibleYcoordFromContext() called");
if (ac != null) {
Rectangle r = getAccessibleBoundsOnScreenFromContext(ac);
if (r != null) {
return r.y;
}
} else {
debugString("[ERROR]: getAccessibleYcoordFromContext; ac = null");
}
return -1;
}
private int getAccessibleHeightFromContext(AccessibleContext ac) {
if (ac != null) {
Rectangle r = getAccessibleBoundsOnScreenFromContext(ac);
if (r != null) {
return r.height;
}
} else {
debugString("[ERROR]: getAccessibleHeightFromContext; ac = null");
}
return -1;
}
private int getAccessibleWidthFromContext(AccessibleContext ac) {
if (ac != null) {
Rectangle r = getAccessibleBoundsOnScreenFromContext(ac);
if (r != null) {
return r.width;
}
} else {
debugString("[ERROR]: getAccessibleWidthFromContext; ac = null");
}
return -1;
}
private AccessibleComponent getAccessibleComponentFromContext(AccessibleContext ac) {
if (ac != null) {
AccessibleComponent acmp = InvocationUtils.invokeAndWait(() -> {
return ac.getAccessibleComponent();
}, ac);
if (acmp != null) {
debugString("[INFO]: Returning AccessibleComponent Context");
return acmp;
}
} else {
debugString("[ERROR]: getAccessibleComponentFromContext; ac = null");
}
return null;
}
private AccessibleAction getAccessibleActionFromContext(final AccessibleContext ac) {
debugString("[INFO]: Returning AccessibleAction Context");
return ac == null ? null : InvocationUtils.invokeAndWait(new Callable<AccessibleAction>() {
@Override
public AccessibleAction call() throws Exception {
return ac.getAccessibleAction();
}
}, ac);
}
private AccessibleSelection getAccessibleSelectionFromContext(final AccessibleContext ac) {
return ac == null ? null : InvocationUtils.invokeAndWait(new Callable<AccessibleSelection>() {
@Override
public AccessibleSelection call() throws Exception {
return ac.getAccessibleSelection();
}
}, ac);
}
private AccessibleText getAccessibleTextFromContext(final AccessibleContext ac) {
return ac == null ? null : InvocationUtils.invokeAndWait(new Callable<AccessibleText>() {
@Override
public AccessibleText call() throws Exception {
return ac.getAccessibleText();
}
}, ac);
}
private AccessibleValue getAccessibleValueFromContext(final AccessibleContext ac) {
return ac == null ? null : InvocationUtils.invokeAndWait(new Callable<AccessibleValue>() {
@Override
public AccessibleValue call() throws Exception {
return ac.getAccessibleValue();
}
}, ac);
}
private Rectangle getCaretLocation(final AccessibleContext ac) {
debugString("[INFO]: getCaretLocation");
if (ac==null)
return null;
return InvocationUtils.invokeAndWait(new Callable<Rectangle>() {
@Override
public Rectangle call() throws Exception {
Rectangle r = null;
Accessible parent = ac.getAccessibleParent();
if (parent instanceof Accessible) {
int indexInParent = ac.getAccessibleIndexInParent();
Accessible child =
parent.getAccessibleContext().getAccessibleChild(indexInParent);
if (child instanceof JTextComponent) {
JTextComponent text = (JTextComponent) child;
try {
r = text.modelToView2D(text.getCaretPosition()).getBounds();
if (r != null) {
Point p = text.getLocationOnScreen();
r.translate(p.x, p.y);
}
} catch (BadLocationException ble) {
}
}
}
return r;
}
}, ac);
}
private int getCaretLocationX(AccessibleContext ac) {
Rectangle r = getCaretLocation(ac);
if (r != null) {
return r.x;
} else {
return -1;
}
}
private int getCaretLocationY(AccessibleContext ac) {
Rectangle r = getCaretLocation(ac);
if (r != null) {
return r.y;
} else {
return -1;
}
}
private int getCaretLocationHeight(AccessibleContext ac) {
Rectangle r = getCaretLocation(ac);
if (r != null) {
return r.height;
} else {
return -1;
}
}
private int getCaretLocationWidth(AccessibleContext ac) {
Rectangle r = getCaretLocation(ac);
if (r != null) {
return r.width;
} else {
return -1;
}
}
private int getAccessibleCharCountFromContext(final AccessibleContext ac) {
if (ac==null)
return -1;
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (at != null) {
return at.getCharCount();
}
return -1;
}
}, ac);
}
private int getAccessibleCaretPositionFromContext(final AccessibleContext ac) {
if (ac==null)
return -1;
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (at != null) {
return at.getCaretPosition();
}
return -1;
}
}, ac);
}
private int getAccessibleIndexAtPointFromContext(final AccessibleContext ac,
final int x, final int y) {
debugString("[INFO]: getAccessibleIndexAtPointFromContext: x = "+x+"; y = "+y);
if (ac==null)
return -1;
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
AccessibleText at = ac.getAccessibleText();
AccessibleComponent acomp = ac.getAccessibleComponent();
if (at != null && acomp != null) {
try {
Point p = acomp.getLocationOnScreen();
int x1, y1;
if (p != null) {
x1 = x - p.x;
if (x1 < 0) {
x1 = 0;
}
y1 = y - p.y;
if (y1 < 0) {
y1 = 0;
}
Point newPoint = new Point(x1, y1);
int indexAtPoint = at.getIndexAtPoint(new Point(x1, y1));
return indexAtPoint;
}
} catch (Exception e) {
}
}
return -1;
}
}, ac);
}
private String getAccessibleLetterAtIndexFromContext(final AccessibleContext ac, final int index) {
if (ac != null) {
String s = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (at == null) return null;
return at.getAtIndex(AccessibleText.CHARACTER, index);
}
}, ac);
if (s != null) {
references.increment(s);
return s;
}
} else {
debugString("[ERROR]: getAccessibleLetterAtIndexFromContext; ac = null");
}
return null;
}
private String getAccessibleWordAtIndexFromContext(final AccessibleContext ac, final int index) {
if (ac != null) {
String s = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (at == null) return null;
return at.getAtIndex(AccessibleText.WORD, index);
}
}, ac);
if (s != null) {
references.increment(s);
return s;
}
} else {
debugString("[ERROR]: getAccessibleWordAtIndexFromContext; ac = null");
}
return null;
}
private String getAccessibleSentenceAtIndexFromContext(final AccessibleContext ac, final int index) {
if (ac != null) {
String s = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (at == null) return null;
return at.getAtIndex(AccessibleText.SENTENCE, index);
}
}, ac);
if (s != null) {
references.increment(s);
return s;
}
} else {
debugString("[ERROR]: getAccessibleSentenceAtIndexFromContext; ac = null");
}
return null;
}
private int getAccessibleTextSelectionStartFromContext(final AccessibleContext ac) {
if (ac == null) return -1;
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (at != null) {
return at.getSelectionStart();
}
return -1;
}
}, ac);
}
private int getAccessibleTextSelectionEndFromContext(final AccessibleContext ac) {
if (ac == null)
return -1;
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (at != null) {
return at.getSelectionEnd();
}
return -1;
}
}, ac);
}
private String getAccessibleTextSelectedTextFromContext(final AccessibleContext ac) {
if (ac != null) {
String s = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (at == null) return null;
return at.getSelectedText();
}
}, ac);
if (s != null) {
references.increment(s);
return s;
}
} else {
debugString("[ERROR]: getAccessibleTextSelectedTextFromContext; ac = null");
}
return null;
}
private String getAccessibleAttributesAtIndexFromContext(final AccessibleContext ac,
final int index) {
if (ac == null)
return null;
AttributeSet as = InvocationUtils.invokeAndWait(new Callable<AttributeSet>() {
@Override
public AttributeSet call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (at != null) {
return at.getCharacterAttribute(index);
}
return null;
}
}, ac);
String s = expandStyleConstants(as);
if (s != null) {
references.increment(s);
return s;
}
return null;
}
private int getAccessibleTextLineLeftBoundsFromContext(final AccessibleContext ac,
final int index) {
if (ac == null)
return -1;
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (at != null) {
int lineStart;
int offset;
Rectangle charRect;
Rectangle indexRect = at.getCharacterBounds(index);
int textLen = at.getCharCount();
if (indexRect == null) {
return -1;
}
offset = 1;
lineStart = index - offset < 0 ? 0 : index - offset;
charRect = at.getCharacterBounds(lineStart);
while (charRect != null
&& charRect.y >= indexRect.y
&& lineStart > 0) {
offset = offset << 1;
lineStart = index - offset < 0 ? 0 : index - offset;
charRect = at.getCharacterBounds(lineStart);
}
if (lineStart == 0) {                                                } else {
offset = offset >> 1;                                                   while (offset > 0) {
charRect = at.getCharacterBounds(lineStart + offset);
if (charRect.y < indexRect.y) {                                 lineStart += offset;
} else {
}
offset = offset >> 1;
}
lineStart += 1;
}
return lineStart;
}
return -1;
}
}, ac);
}
private int getAccessibleTextLineRightBoundsFromContext(final AccessibleContext ac, final int index) {
if(ac == null)
return -1;
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (at != null) {
int lineEnd;
int offset;
Rectangle charRect;
Rectangle indexRect = at.getCharacterBounds(index);
int textLen = at.getCharCount();
if (indexRect == null) {
return -1;
}
offset = 1;
lineEnd = index + offset > textLen - 1
? textLen - 1 : index + offset;
charRect = at.getCharacterBounds(lineEnd);
while (charRect != null &&
charRect.y <= indexRect.y &&
lineEnd < textLen - 1) {
offset = offset << 1;
lineEnd = index + offset > textLen - 1
? textLen - 1 : index + offset;
charRect = at.getCharacterBounds(lineEnd);
}
if (lineEnd == textLen - 1) {                                                } else {
offset = offset >> 1;                                                   while (offset > 0) {
charRect = at.getCharacterBounds(lineEnd - offset);
if (charRect.y > indexRect.y) {                                 lineEnd -= offset;
} else {
}
offset = offset >> 1;
}
lineEnd -= 1;
}
return lineEnd;
}
return -1;
}
}, ac);
}
private String getAccessibleTextRangeFromContext(final AccessibleContext ac,
final int start, final int end) {
String s = InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
if (ac != null) {
AccessibleText at = ac.getAccessibleText();
if (at != null) {
if (start > end) {
return null;
}
if (end >= at.getCharCount()) {
return null;
}
StringBuffer buf = new StringBuffer(end - start + 1);
for (int i = start; i <= end; i++) {
buf.append(at.getAtIndex(AccessibleText.CHARACTER, i));
}
return buf.toString();
}
}
return null;
}
}, ac);
if (s != null) {
references.increment(s);
return s;
} else {
return null;
}
}
private AttributeSet getAccessibleAttributeSetAtIndexFromContext(final AccessibleContext ac,
final int index) {
return InvocationUtils.invokeAndWait(new Callable<AttributeSet>() {
@Override
public AttributeSet call() throws Exception {
if (ac != null) {
AccessibleText at = ac.getAccessibleText();
if (at != null) {
AttributeSet as = at.getCharacterAttribute(index);
if (as != null) {
AccessBridge.this.references.increment(as);
return as;
}
}
}
return null;
}
}, ac);
}
private Rectangle getAccessibleTextRectAtIndexFromContext(final AccessibleContext ac,
final int index) {
Rectangle r = InvocationUtils.invokeAndWait(new Callable<Rectangle>() {
@Override
public Rectangle call() throws Exception {
if (ac != null) {
AccessibleText at = ac.getAccessibleText();
if (at != null) {
Rectangle rect = at.getCharacterBounds(index);
if (rect != null) {
String s = at.getAtIndex(AccessibleText.CHARACTER, index);
if (s != null && s.equals("\n")) {
rect.width = 0;
}
rect = AccessibilityGraphicsEnvironment.toDeviceSpaceAbs(rect);
return rect;
}
}
}
return null;
}
}, ac);
Rectangle acRect = getAccessibleBoundsOnScreenFromContext(ac);
if (r != null && acRect != null) {
r.translate(acRect.x, acRect.y);
return r;
}
return null;
}
private int getAccessibleXcoordTextRectAtIndexFromContext(AccessibleContext ac, int index) {
if (ac != null) {
Rectangle r = getAccessibleTextRectAtIndexFromContext(ac, index);
if (r != null) {
return r.x;
}
} else {
debugString("[ERROR]: getAccessibleXcoordTextRectAtIndexFromContext; ac = null");
}
return -1;
}
private int getAccessibleYcoordTextRectAtIndexFromContext(AccessibleContext ac, int index) {
if (ac != null) {
Rectangle r = getAccessibleTextRectAtIndexFromContext(ac, index);
if (r != null) {
return r.y;
}
} else {
debugString("[ERROR]: getAccessibleYcoordTextRectAtIndexFromContext; ac = null");
}
return -1;
}
private int getAccessibleHeightTextRectAtIndexFromContext(AccessibleContext ac, int index) {
if (ac != null) {
Rectangle r = getAccessibleTextRectAtIndexFromContext(ac, index);
if (r != null) {
return r.height;
}
} else {
debugString("[ERROR]: getAccessibleHeightTextRectAtIndexFromContext; ac = null");
}
return -1;
}
private int getAccessibleWidthTextRectAtIndexFromContext(AccessibleContext ac, int index) {
if (ac != null) {
Rectangle r = getAccessibleTextRectAtIndexFromContext(ac, index);
if (r != null) {
return r.width;
}
} else {
debugString("[ERROR]: getAccessibleWidthTextRectAtIndexFromContext; ac = null");
}
return -1;
}
private boolean getBoldFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.isBold(as);
} else {
debugString("[ERROR]: getBoldFromAttributeSet; as = null");
}
return false;
}
private boolean getItalicFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.isItalic(as);
} else {
debugString("[ERROR]: getItalicFromAttributeSet; as = null");
}
return false;
}
private boolean getUnderlineFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.isUnderline(as);
} else {
debugString("[ERROR]: getUnderlineFromAttributeSet; as = null");
}
return false;
}
private boolean getStrikethroughFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.isStrikeThrough(as);
} else {
debugString("[ERROR]: getStrikethroughFromAttributeSet; as = null");
}
return false;
}
private boolean getSuperscriptFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.isSuperscript(as);
} else {
debugString("[ERROR]: getSuperscriptFromAttributeSet; as = null");
}
return false;
}
private boolean getSubscriptFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.isSubscript(as);
} else {
debugString("[ERROR]: getSubscriptFromAttributeSet; as = null");
}
return false;
}
private String getBackgroundColorFromAttributeSet(AttributeSet as) {
if (as != null) {
String s = StyleConstants.getBackground(as).toString();
if (s != null) {
references.increment(s);
return s;
}
} else {
debugString("[ERROR]: getBackgroundColorFromAttributeSet; as = null");
}
return null;
}
private String getForegroundColorFromAttributeSet(AttributeSet as) {
if (as != null) {
String s = StyleConstants.getForeground(as).toString();
if (s != null) {
references.increment(s);
return s;
}
} else {
debugString("[ERROR]: getForegroundColorFromAttributeSet; as = null");
}
return null;
}
private String getFontFamilyFromAttributeSet(AttributeSet as) {
if (as != null) {
String s = StyleConstants.getFontFamily(as).toString();
if (s != null) {
references.increment(s);
return s;
}
} else {
debugString("[ERROR]: getFontFamilyFromAttributeSet; as = null");
}
return null;
}
private int getFontSizeFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.getFontSize(as);
} else {
debugString("[ERROR]: getFontSizeFromAttributeSet; as = null");
}
return -1;
}
private int getAlignmentFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.getAlignment(as);
} else {
debugString("[ERROR]: getAlignmentFromAttributeSet; as = null");
}
return -1;
}
private int getBidiLevelFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.getBidiLevel(as);
} else {
debugString("[ERROR]: getBidiLevelFromAttributeSet; as = null");
}
return -1;
}
private float getFirstLineIndentFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.getFirstLineIndent(as);
} else {
debugString("[ERROR]: getFirstLineIndentFromAttributeSet; as = null");
}
return -1;
}
private float getLeftIndentFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.getLeftIndent(as);
} else {
debugString("[ERROR]: getLeftIndentFromAttributeSet; as = null");
}
return -1;
}
private float getRightIndentFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.getRightIndent(as);
} else {
debugString("[ERROR]: getRightIndentFromAttributeSet; as = null");
}
return -1;
}
private float getLineSpacingFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.getLineSpacing(as);
} else {
debugString("[ERROR]: getLineSpacingFromAttributeSet; as = null");
}
return -1;
}
private float getSpaceAboveFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.getSpaceAbove(as);
} else {
debugString("[ERROR]: getSpaceAboveFromAttributeSet; as = null");
}
return -1;
}
private float getSpaceBelowFromAttributeSet(AttributeSet as) {
if (as != null) {
return StyleConstants.getSpaceBelow(as);
} else {
debugString("[ERROR]: getSpaceBelowFromAttributeSet; as = null");
}
return -1;
}
private String expandStyleConstants(AttributeSet as) {
Color c;
Object o;
String attrString = "";
attrString += "BidiLevel = " + StyleConstants.getBidiLevel(as);
final Component comp = StyleConstants.getComponent(as);
if (comp != null) {
if (comp instanceof Accessible) {
final AccessibleContext ac = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
return comp.getAccessibleContext();
}
}, comp);
if (ac != null) {
attrString += "; Accessible Component = " + InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return ac.getAccessibleName();
}
}, ac);
} else {
attrString += "; Innaccessible Component = " + comp;
}
} else {
attrString += "; Innaccessible Component = " + comp;
}
}
Icon i = StyleConstants.getIcon(as);
if (i != null) {
if (i instanceof ImageIcon) {
attrString += "; ImageIcon = " + ((ImageIcon) i).getDescription();
} else {
attrString += "; Icon = " + i;
}
}
attrString += "; FontFamily = " + StyleConstants.getFontFamily(as);
attrString += "; FontSize = " + StyleConstants.getFontSize(as);
if (StyleConstants.isBold(as)) {
attrString += "; bold";
}
if (StyleConstants.isItalic(as)) {
attrString += "; italic";
}
if (StyleConstants.isUnderline(as)) {
attrString += "; underline";
}
if (StyleConstants.isStrikeThrough(as)) {
attrString += "; strikethrough";
}
if (StyleConstants.isSuperscript(as)) {
attrString += "; superscript";
}
if (StyleConstants.isSubscript(as)) {
attrString += "; subscript";
}
c = StyleConstants.getForeground(as);
if (c != null) {
attrString += "; Foreground = " + c;
}
c = StyleConstants.getBackground(as);
if (c != null) {
attrString += "; Background = " + c;
}
attrString += "; FirstLineIndent = " + StyleConstants.getFirstLineIndent(as);
attrString += "; RightIndent = " + StyleConstants.getRightIndent(as);
attrString += "; LeftIndent = " + StyleConstants.getLeftIndent(as);
attrString += "; LineSpacing = " + StyleConstants.getLineSpacing(as);
attrString += "; SpaceAbove = " + StyleConstants.getSpaceAbove(as);
attrString += "; SpaceBelow = " + StyleConstants.getSpaceBelow(as);
attrString += "; Alignment = " + StyleConstants.getAlignment(as);
TabSet ts = StyleConstants.getTabSet(as);
if (ts != null) {
attrString += "; TabSet = " + ts;
}
return attrString;
}
private String getCurrentAccessibleValueFromContext(final AccessibleContext ac) {
if (ac != null) {
final Number value = InvocationUtils.invokeAndWait(new Callable<Number>() {
@Override
public Number call() throws Exception {
AccessibleValue av = ac.getAccessibleValue();
if (av == null) return null;
return av.getCurrentAccessibleValue();
}
}, ac);
if (value != null) {
String s = value.toString();
if (s != null) {
references.increment(s);
return s;
}
}
} else {
debugString("[ERROR]: getCurrentAccessibleValueFromContext; ac = null");
}
return null;
}
private String getMaximumAccessibleValueFromContext(final AccessibleContext ac) {
if (ac != null) {
final Number value = InvocationUtils.invokeAndWait(new Callable<Number>() {
@Override
public Number call() throws Exception {
AccessibleValue av = ac.getAccessibleValue();
if (av == null) return null;
return av.getMaximumAccessibleValue();
}
}, ac);
if (value != null) {
String s = value.toString();
if (s != null) {
references.increment(s);
return s;
}
}
} else {
debugString("[ERROR]: getMaximumAccessibleValueFromContext; ac = null");
}
return null;
}
private String getMinimumAccessibleValueFromContext(final AccessibleContext ac) {
if (ac != null) {
final Number value = InvocationUtils.invokeAndWait(new Callable<Number>() {
@Override
public Number call() throws Exception {
AccessibleValue av = ac.getAccessibleValue();
if (av == null) return null;
return av.getMinimumAccessibleValue();
}
}, ac);
if (value != null) {
String s = value.toString();
if (s != null) {
references.increment(s);
return s;
}
}
} else {
debugString("[ERROR]: getMinimumAccessibleValueFromContext; ac = null");
}
return null;
}
private void addAccessibleSelectionFromContext(final AccessibleContext ac, final int i) {
try {
InvocationUtils.invokeAndWait(new Callable<Object>() {
@Override
public Object call() throws Exception {
if (ac != null) {
AccessibleSelection as = ac.getAccessibleSelection();
if (as != null) {
as.addAccessibleSelection(i);
}
}
return null;
}
}, ac);
} catch(Exception e){}
}
private void clearAccessibleSelectionFromContext(final AccessibleContext ac) {
try {
InvocationUtils.invokeAndWait(new Callable<Object>() {
@Override
public Object call() throws Exception {
AccessibleSelection as = ac.getAccessibleSelection();
if (as != null) {
as.clearAccessibleSelection();
}
return null;
}
}, ac);
} catch(Exception e){}
}
private AccessibleContext getAccessibleSelectionFromContext(final AccessibleContext ac, final int i) {
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
if (ac != null) {
AccessibleSelection as = ac.getAccessibleSelection();
if (as != null) {
Accessible a = as.getAccessibleSelection(i);
if (a == null)
return null;
else
return a.getAccessibleContext();
}
}
return null;
}
}, ac);
}
private int getAccessibleSelectionCountFromContext(final AccessibleContext ac) {
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
if (ac != null) {
AccessibleSelection as = ac.getAccessibleSelection();
if (as != null) {
return as.getAccessibleSelectionCount();
}
}
return -1;
}
}, ac);
}
private boolean isAccessibleChildSelectedFromContext(final AccessibleContext ac, final int i) {
return InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
if (ac != null) {
AccessibleSelection as = ac.getAccessibleSelection();
if (as != null) {
return as.isAccessibleChildSelected(i);
}
}
return false;
}
}, ac);
}
private void removeAccessibleSelectionFromContext(final AccessibleContext ac, final int i) {
InvocationUtils.invokeAndWait(new Callable<Object>() {
@Override
public Object call() throws Exception {
if (ac != null) {
AccessibleSelection as = ac.getAccessibleSelection();
if (as != null) {
as.removeAccessibleSelection(i);
}
}
return null;
}
}, ac);
}
private void selectAllAccessibleSelectionFromContext(final AccessibleContext ac) {
InvocationUtils.invokeAndWait(new Callable<Object>() {
@Override
public Object call() throws Exception {
if (ac != null) {
AccessibleSelection as = ac.getAccessibleSelection();
if (as != null) {
as.selectAllAccessibleSelection();
}
}
return null;
}
}, ac);
}
ConcurrentHashMap<AccessibleTable,AccessibleContext> hashtab = new ConcurrentHashMap<>();
private AccessibleTable getAccessibleTableFromContext(final AccessibleContext ac) {
return InvocationUtils.invokeAndWait(new Callable<AccessibleTable>() {
@Override
public AccessibleTable call() throws Exception {
if (ac != null) {
AccessibleTable at = ac.getAccessibleTable();
if (at != null) {
AccessBridge.this.hashtab.put(at, ac);
return at;
}
}
return null;
}
}, ac);
}
private AccessibleContext getContextFromAccessibleTable(AccessibleTable at) {
return hashtab.get(at);
}
private int getAccessibleTableRowCount(final AccessibleContext ac) {
debugString("[INFO]: ##### getAccessibleTableRowCount");
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
if (ac != null) {
AccessibleTable at = ac.getAccessibleTable();
if (at != null) {
return at.getAccessibleRowCount();
}
}
return -1;
}
}, ac);
}
private int getAccessibleTableColumnCount(final AccessibleContext ac) {
debugString("[INFO]: ##### getAccessibleTableColumnCount");
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
if (ac != null) {
AccessibleTable at = ac.getAccessibleTable();
if (at != null) {
return at.getAccessibleColumnCount();
}
}
return -1;
}
}, ac);
}
private AccessibleContext getAccessibleTableCellAccessibleContext(final AccessibleTable at,
final int row, final int column) {
debugString("[INFO]: getAccessibleTableCellAccessibleContext: at = "+at.getClass());
if (at == null) return null;
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
if (!(at instanceof AccessibleContext)) {
Accessible a = at.getAccessibleAt(row, column);
if (a != null) {
return a.getAccessibleContext();
}
} else {
AccessibleContext ac = (AccessibleContext) at;
Accessible parent = ac.getAccessibleParent();
if (parent != null) {
int indexInParent = ac.getAccessibleIndexInParent();
Accessible child =
parent.getAccessibleContext().getAccessibleChild(indexInParent);
if (child instanceof JTable) {
JTable table = (JTable) child;
TableCellRenderer renderer = table.getCellRenderer(row, column);
if (renderer == null) {
Class<?> columnClass = table.getColumnClass(column);
renderer = table.getDefaultRenderer(columnClass);
}
Component component =
renderer.getTableCellRendererComponent(table, table.getValueAt(row, column),
false, false, row, column);
if (component instanceof Accessible) {
return component.getAccessibleContext();
}
}
}
}
return null;
}
}, getContextFromAccessibleTable(at));
}
private int getAccessibleTableCellIndex(final AccessibleTable at, int row, int column) {
debugString("[INFO]: ##### getAccessibleTableCellIndex: at="+at);
if (at != null) {
int cellIndex = row *
InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return at.getAccessibleColumnCount();
}
}, getContextFromAccessibleTable(at)) +
column;
debugString("[INFO]:    ##### getAccessibleTableCellIndex="+cellIndex);
return cellIndex;
}
debugString("[ERROR]: ##### getAccessibleTableCellIndex FAILED");
return -1;
}
private int getAccessibleTableCellRowExtent(final AccessibleTable at, final int row, final int column) {
debugString("[INFO]: ##### getAccessibleTableCellRowExtent");
if (at != null) {
int rowExtent = InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return at.getAccessibleRowExtentAt(row, column);
}
},
getContextFromAccessibleTable(at));
debugString("[INFO]:   ##### getAccessibleTableCellRowExtent="+rowExtent);
return rowExtent;
}
debugString("[ERROR]: ##### getAccessibleTableCellRowExtent FAILED");
return -1;
}
private int getAccessibleTableCellColumnExtent(final AccessibleTable at, final int row, final int column) {
debugString("[INFO]: ##### getAccessibleTableCellColumnExtent");
if (at != null) {
int columnExtent = InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return at.getAccessibleColumnExtentAt(row, column);
}
},
getContextFromAccessibleTable(at));
debugString("[INFO]:   ##### getAccessibleTableCellColumnExtent="+columnExtent);
return columnExtent;
}
debugString("[ERROR]: ##### getAccessibleTableCellColumnExtent FAILED");
return -1;
}
private boolean isAccessibleTableCellSelected(final AccessibleTable at, final int row,
final int column) {
debugString("[INFO]: ##### isAccessibleTableCellSelected: ["+row+"]["+column+"]");
if (at == null)
return false;
return InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
boolean isSelected = false;
Accessible a = at.getAccessibleAt(row, column);
if (a != null) {
AccessibleContext ac = a.getAccessibleContext();
if (ac == null)
return false;
AccessibleStateSet as = ac.getAccessibleStateSet();
if (as != null) {
isSelected = as.contains(AccessibleState.SELECTED);
}
}
return isSelected;
}
}, getContextFromAccessibleTable(at));
}
private AccessibleTable getAccessibleTableRowHeader(final AccessibleContext ac) {
debugString("[INFO]: #####  getAccessibleTableRowHeader called");
AccessibleTable at = InvocationUtils.invokeAndWait(new Callable<AccessibleTable>() {
@Override
public AccessibleTable call() throws Exception {
if (ac != null) {
AccessibleTable at = ac.getAccessibleTable();
if (at != null) {
return at.getAccessibleRowHeader();
}
}
return null;
}
}, ac);
if (at != null) {
hashtab.put(at, ac);
}
return at;
}
private AccessibleTable getAccessibleTableColumnHeader(final AccessibleContext ac) {
debugString("[INFO]: ##### getAccessibleTableColumnHeader");
if (ac == null)
return null;
AccessibleTable at = InvocationUtils.invokeAndWait(new Callable<AccessibleTable>() {
@Override
public AccessibleTable call() throws Exception {
Accessible parent = ac.getAccessibleParent();
if (parent != null) {
int indexInParent = ac.getAccessibleIndexInParent();
Accessible child =
parent.getAccessibleContext().getAccessibleChild(indexInParent);
if (child instanceof JTable) {
JTable table = (JTable) child;
if (table.getTableHeader() == null) {
return null;
}
}
}
AccessibleTable at = ac.getAccessibleTable();
if (at != null) {
return at.getAccessibleColumnHeader();
}
return null;
}
}, ac);
if (at != null) {
hashtab.put(at, ac);
}
return at;
}
private int getAccessibleTableRowHeaderRowCount(AccessibleContext ac) {
debugString("[INFO]: #####  getAccessibleTableRowHeaderRowCount called");
if (ac != null) {
final AccessibleTable atRowHeader = getAccessibleTableRowHeader(ac);
if (atRowHeader != null) {
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
if (atRowHeader != null) {
return atRowHeader.getAccessibleRowCount();
}
return -1;
}
}, ac);
}
}
return -1;
}
private int getAccessibleTableRowHeaderColumnCount(AccessibleContext ac) {
debugString("[INFO]: #####  getAccessibleTableRowHeaderColumnCount called");
if (ac != null) {
final AccessibleTable atRowHeader = getAccessibleTableRowHeader(ac);
if (atRowHeader != null) {
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
if (atRowHeader != null) {
return atRowHeader.getAccessibleColumnCount();
}
return -1;
}
}, ac);
}
}
debugString("[ERROR]: ##### getAccessibleTableRowHeaderColumnCount FAILED");
return -1;
}
private int getAccessibleTableColumnHeaderRowCount(AccessibleContext ac) {
debugString("[INFO]: ##### getAccessibleTableColumnHeaderRowCount");
if (ac != null) {
final AccessibleTable atColumnHeader = getAccessibleTableColumnHeader(ac);
if (atColumnHeader != null) {
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
if (atColumnHeader != null) {
return atColumnHeader.getAccessibleRowCount();
}
return -1;
}
}, ac);
}
}
debugString("[ERROR]: ##### getAccessibleTableColumnHeaderRowCount FAILED");
return -1;
}
private int getAccessibleTableColumnHeaderColumnCount(AccessibleContext ac) {
debugString("[ERROR]: #####  getAccessibleTableColumnHeaderColumnCount");
if (ac != null) {
final AccessibleTable atColumnHeader = getAccessibleTableColumnHeader(ac);
if (atColumnHeader != null) {
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
if (atColumnHeader != null) {
return atColumnHeader.getAccessibleColumnCount();
}
return -1;
}
}, ac);
}
}
debugString("[ERROR]: ##### getAccessibleTableColumnHeaderColumnCount FAILED");
return -1;
}
private AccessibleContext getAccessibleTableRowDescription(final AccessibleTable table,
final int row) {
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
if (table != null) {
Accessible a = table.getAccessibleRowDescription(row);
if (a != null) {
return a.getAccessibleContext();
}
}
return null;
}
}, getContextFromAccessibleTable(table));
}
private AccessibleContext getAccessibleTableColumnDescription(final AccessibleTable at,
final int column) {
if (at == null)
return null;
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
Accessible a = at.getAccessibleColumnDescription(column);
if (a != null) {
return a.getAccessibleContext();
}
return null;
}
}, getContextFromAccessibleTable(at));
}
private int getAccessibleTableRowSelectionCount(final AccessibleTable at) {
if (at != null) {
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
int[] selections = at.getSelectedAccessibleRows();
if (selections != null)
return selections.length;
else
return -1;
}
}, getContextFromAccessibleTable(at));
}
return -1;
}
private int getAccessibleTableRowSelections(final AccessibleTable at, final int i) {
if (at != null) {
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
int[] selections = at.getSelectedAccessibleRows();
if (selections.length > i) {
return selections[i];
}
return -1;
}
}, getContextFromAccessibleTable(at));
}
return -1;
}
private boolean isAccessibleTableRowSelected(final AccessibleTable at,
final int row) {
if (at == null)
return false;
return InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
return at.isAccessibleRowSelected(row);
}
}, getContextFromAccessibleTable(at));
}
private boolean isAccessibleTableColumnSelected(final AccessibleTable at,
final int column) {
if (at == null)
return false;
return InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
return at.isAccessibleColumnSelected(column);
}
}, getContextFromAccessibleTable(at));
}
private int getAccessibleTableColumnSelectionCount(final AccessibleTable at) {
if (at == null)
return -1;
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
int[] selections = at.getSelectedAccessibleColumns();
if (selections != null)
return selections.length;
else
return -1;
}
}, getContextFromAccessibleTable(at));
}
private int getAccessibleTableColumnSelections(final AccessibleTable at, final int i) {
if (at == null)
return -1;
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
int[] selections = at.getSelectedAccessibleColumns();
if (selections != null && selections.length > i) {
return selections[i];
}
return -1;
}
}, getContextFromAccessibleTable(at));
}
private int getAccessibleTableRow(final AccessibleTable at, int index) {
if (at == null)
return -1;
int colCount=InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return at.getAccessibleColumnCount();
}
}, getContextFromAccessibleTable(at));
return index / colCount;
}
private int getAccessibleTableColumn(final AccessibleTable at, int index) {
if (at == null)
return -1;
int colCount=InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return at.getAccessibleColumnCount();
}
}, getContextFromAccessibleTable(at));
return index % colCount;
}
private int getAccessibleTableIndex(final AccessibleTable at, int row, int column) {
if (at == null)
return -1;
int colCount = InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return at.getAccessibleColumnCount();
}
}, getContextFromAccessibleTable(at));
return row * colCount + column;
}
private int getAccessibleRelationCount(final AccessibleContext ac) {
{
if (ac != null) {
AccessibleRelationSet ars = InvocationUtils.invokeAndWait(new Callable<AccessibleRelationSet>() {
@Override
public AccessibleRelationSet call() throws Exception {
return ac.getAccessibleRelationSet();
}
}, ac);
if (ars != null)
return ars.size();
}
}
return 0;
}
private String getAccessibleRelationKey(final AccessibleContext ac, final int i) {
return InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
if (ac != null) {
AccessibleRelationSet ars = ac.getAccessibleRelationSet();
if (ars != null) {
AccessibleRelation[] relations = ars.toArray();
if (relations != null && i >= 0 && i < relations.length) {
return relations[i].getKey();
}
}
}
return null;
}
}, ac);
}
private int getAccessibleRelationTargetCount(final AccessibleContext ac, final int i) {
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
if (ac != null) {
AccessibleRelationSet ars = ac.getAccessibleRelationSet();
if (ars != null) {
AccessibleRelation[] relations = ars.toArray();
if (relations != null && i >= 0 && i < relations.length) {
Object[] targets = relations[i].getTarget();
return targets.length;
}
}
}
return -1;
}
}, ac);
}
private AccessibleContext getAccessibleRelationTarget(final AccessibleContext ac,
final int i, final int j) {
debugString("[INFO]: ***** getAccessibleRelationTarget");
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
if (ac != null) {
AccessibleRelationSet ars = ac.getAccessibleRelationSet();
if (ars != null) {
AccessibleRelation[] relations = ars.toArray();
if (relations != null && i >= 0 && i < relations.length) {
Object[] targets = relations[i].getTarget();
if (targets != null && j >= 0 & j < targets.length) {
Object o = targets[j];
if (o instanceof Accessible) {
return ((Accessible) o).getAccessibleContext();
}
}
}
}
}
return null;
}
}, ac);
}
private Map<AccessibleHypertext, AccessibleContext> hyperTextContextMap = new WeakHashMap<>();
private Map<AccessibleHyperlink, AccessibleContext> hyperLinkContextMap = new WeakHashMap<>();
private AccessibleHypertext getAccessibleHypertext(final AccessibleContext ac) {
debugString("[INFO]: getAccessibleHyperlink");
if (ac==null)
return null;
AccessibleHypertext hypertext = InvocationUtils.invokeAndWait(new Callable<AccessibleHypertext>() {
@Override
public AccessibleHypertext call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (!(at instanceof AccessibleHypertext)) {
return null;
}
return ((AccessibleHypertext) at);
}
}, ac);
hyperTextContextMap.put(hypertext, ac);
return hypertext;
}
private int getAccessibleHyperlinkCount(AccessibleContext ac) {
debugString("[INFO]: getAccessibleHyperlinkCount");
if (ac == null) {
return 0;
}
final AccessibleHypertext hypertext = getAccessibleHypertext(ac);
if (hypertext == null) {
return 0;
}
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return hypertext.getLinkCount();
}
}, ac);
}
private AccessibleHyperlink getAccessibleHyperlink(final AccessibleHypertext hypertext, final int i) {
debugString("[INFO]: getAccessibleHyperlink");
if (hypertext == null) {
return null;
}
AccessibleContext ac = hyperTextContextMap.get(hypertext);
if ( i < 0 || i >=
InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return hypertext.getLinkCount();
}
}, ac) ) {
return null;
}
AccessibleHyperlink acLink = InvocationUtils.invokeAndWait(new Callable<AccessibleHyperlink>() {
@Override
public AccessibleHyperlink call() throws Exception {
AccessibleHyperlink link = hypertext.getLink(i);
if (link == null || (!link.isValid())) {
return null;
}
return link;
}
}, ac);
hyperLinkContextMap.put(acLink, ac);
return acLink;
}
private String getAccessibleHyperlinkText(final AccessibleHyperlink link) {
debugString("[INFO]: getAccessibleHyperlinkText");
if (link == null) {
return null;
}
return InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
Object o = link.getAccessibleActionDescription(0);
if (o != null) {
return o.toString();
}
return null;
}
}, hyperLinkContextMap.get(link));
}
private String getAccessibleHyperlinkURL(final AccessibleHyperlink link) {
debugString("[INFO]: getAccessibleHyperlinkURL");
if (link == null) {
return null;
}
return InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
Object o = link.getAccessibleActionObject(0);
if (o != null) {
return o.toString();
} else {
return null;
}
}
}, hyperLinkContextMap.get(link));
}
private int getAccessibleHyperlinkStartIndex(final AccessibleHyperlink link) {
debugString("[INFO]: getAccessibleHyperlinkStartIndex");
if (link == null) {
return -1;
}
return  InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return link.getStartIndex();
}
}, hyperLinkContextMap.get(link));
}
private int getAccessibleHyperlinkEndIndex(final AccessibleHyperlink link) {
debugString("[INFO]: getAccessibleHyperlinkEndIndex");
if (link == null) {
return -1;
}
return  InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return link.getEndIndex();
}
}, hyperLinkContextMap.get(link));
}
private int getAccessibleHypertextLinkIndex(final AccessibleHypertext hypertext, final int charIndex) {
debugString("[INFO]: getAccessibleHypertextLinkIndex: charIndex = "+charIndex);
if (hypertext == null) {
return -1;
}
int linkIndex = InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return hypertext.getLinkIndex(charIndex);
}
}, hyperTextContextMap.get(hypertext));
debugString("[INFO]: getAccessibleHypertextLinkIndex returning "+linkIndex);
return linkIndex;
}
private boolean activateAccessibleHyperlink(final AccessibleContext ac,
final AccessibleHyperlink link) {
if (link == null) {
return false;
}
boolean retval = InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
return link.doAccessibleAction(0);
}
}, ac);
debugString("[INFO]: activateAccessibleHyperlink: returning = "+retval);
return retval;
}
private KeyStroke getMnemonic(final AccessibleContext ac) {
if (ac == null)
return null;
return InvocationUtils.invokeAndWait(new Callable<KeyStroke>() {
@Override
public KeyStroke call() throws Exception {
AccessibleComponent comp = ac.getAccessibleComponent();
if (!(comp instanceof AccessibleExtendedComponent)) {
return null;
}
AccessibleExtendedComponent aec = (AccessibleExtendedComponent) comp;
if (aec != null) {
AccessibleKeyBinding akb = aec.getAccessibleKeyBinding();
if (akb != null) {
Object o = akb.getAccessibleKeyBinding(0);
if (o instanceof KeyStroke) {
return (KeyStroke) o;
}
}
}
return null;
}
}, ac);
}
private KeyStroke getAccelerator(final AccessibleContext ac) {
if (ac == null)
return null;
return InvocationUtils.invokeAndWait(new Callable<KeyStroke>() {
@Override
public KeyStroke call() throws Exception {
Accessible parent = ac.getAccessibleParent();
if (parent instanceof Accessible) {
int indexInParent = ac.getAccessibleIndexInParent();
Accessible child =
parent.getAccessibleContext().getAccessibleChild(indexInParent);
if (child instanceof JMenuItem) {
JMenuItem menuItem = (JMenuItem) child;
if (menuItem == null)
return null;
KeyStroke keyStroke = menuItem.getAccelerator();
return keyStroke;
}
}
return null;
}
}, ac);
}
private int fKeyNumber(KeyStroke keyStroke) {
if (keyStroke == null)
return 0;
int fKey = 0;
String keyText = KeyEvent.getKeyText(keyStroke.getKeyCode());
if (keyText != null && (keyText.length() == 2 || keyText.length() == 3)) {
String prefix = keyText.substring(0, 1);
if (prefix.equals("F")) {
try {
int suffix = Integer.parseInt(keyText.substring(1));
if (suffix >= 1 && suffix <= 24) {
fKey = suffix;
}
} catch (Exception e) {                 }
}
}
return fKey;
}
private int controlCode(KeyStroke keyStroke) {
if (keyStroke == null)
return 0;
int code = keyStroke.getKeyCode();
switch (code) {
case KeyEvent.VK_BACK_SPACE:
case KeyEvent.VK_DELETE:
case KeyEvent.VK_DOWN:
case KeyEvent.VK_END:
case KeyEvent.VK_HOME:
case KeyEvent.VK_INSERT:
case KeyEvent.VK_KP_DOWN:
case KeyEvent.VK_KP_LEFT:
case KeyEvent.VK_KP_RIGHT:
case KeyEvent.VK_KP_UP:
case KeyEvent.VK_LEFT:
case KeyEvent.VK_PAGE_DOWN:
case KeyEvent.VK_PAGE_UP:
case KeyEvent.VK_RIGHT:
case KeyEvent.VK_UP:
break;
default:
code = 0;
break;
}
return code;
}
private char getKeyChar(KeyStroke keyStroke) {
if (keyStroke == null)
return 0;
int fKey = fKeyNumber(keyStroke);
if (fKey != 0) {
debugString("[INFO]:   Shortcut is: F" + fKey);
return (char)fKey;
}
int keyCode = controlCode(keyStroke);
if (keyCode != 0) {
debugString("[INFO]:   Shortcut is control character: " + Integer.toHexString(keyCode));
return (char)keyCode;
}
String keyText = KeyEvent.getKeyText(keyStroke.getKeyCode());
debugString("[INFO]:   Shortcut is: " + keyText);
if (keyText != null || keyText.length() > 0) {
CharSequence seq = keyText.subSequence(0, 1);
if (seq != null || seq.length() > 0) {
return seq.charAt(0);
}
}
return 0;
}
private int getModifiers(KeyStroke keyStroke) {
if (keyStroke == null)
return 0;
debugString("[INFO]: In AccessBridge.getModifiers");
int modifiers = 0;
if (fKeyNumber(keyStroke) != 0) {
modifiers |= 1 << 8;
}
if (controlCode(keyStroke) != 0) {
modifiers |= 1 << 9;
}
StringTokenizer st = new StringTokenizer(keyStroke.toString());
while (st.hasMoreTokens()) {
String text = st.nextToken();
if (text.startsWith("met")) {
debugString("[INFO]:   found meta");
modifiers |= ActionEvent.META_MASK;
}
if (text.startsWith("ctr")) {
debugString("[INFO]:   found ctrl");
modifiers |= ActionEvent.CTRL_MASK;
}
if (text.startsWith("alt")) {
debugString("[INFO]:   found alt");
modifiers |= ActionEvent.ALT_MASK;
}
if (text.startsWith("shi")) {
debugString("   found shift");
modifiers |= ActionEvent.SHIFT_MASK;
}
}
debugString("[INFO]:   returning modifiers: 0x" + Integer.toHexString(modifiers));
return modifiers;
}
private int getAccessibleKeyBindingsCount(AccessibleContext ac) {
if (ac == null)
return 0;
int count = 0;
if (getMnemonic(ac) != null) {
count++;
}
if (getAccelerator(ac) != null) {
count++;
}
return count;
}
private char getAccessibleKeyBindingChar(AccessibleContext ac, int index) {
if (ac == null)
return 0;
if((index == 0) && getMnemonic(ac)==null) {            KeyStroke keyStroke = getAccelerator(ac);
if (keyStroke != null) {
return getKeyChar(keyStroke);
}
}
if (index == 0) {               KeyStroke keyStroke = getMnemonic(ac);
if (keyStroke != null) {
return getKeyChar(keyStroke);
}
} else if (index == 1) {             KeyStroke keyStroke = getAccelerator(ac);
if (keyStroke != null) {
return getKeyChar(keyStroke);
}
}
return 0;
}
private int getAccessibleKeyBindingModifiers(AccessibleContext ac, int index) {
if (ac == null)
return 0;
if((index == 0) && getMnemonic(ac)==null) {            KeyStroke keyStroke = getAccelerator(ac);
if (keyStroke != null) {
return getModifiers(keyStroke);
}
}
if (index == 0) {               KeyStroke keyStroke = getMnemonic(ac);
if (keyStroke != null) {
return getModifiers(keyStroke);
}
} else if (index == 1) {             KeyStroke keyStroke = getAccelerator(ac);
if (keyStroke != null) {
return getModifiers(keyStroke);
}
}
return 0;
}
private int getAccessibleIconsCount(final AccessibleContext ac) {
debugString("[INFO]: getAccessibleIconsCount");
if (ac == null) {
return 0;
}
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
AccessibleIcon[] ai = ac.getAccessibleIcon();
if (ai == null) {
return 0;
}
return ai.length;
}
}, ac);
}
private String getAccessibleIconDescription(final AccessibleContext ac, final int index) {
debugString("[INFO]: getAccessibleIconDescription: index = "+index);
if (ac == null) {
return null;
}
return InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
AccessibleIcon[] ai = ac.getAccessibleIcon();
if (ai == null || index < 0 || index >= ai.length) {
return null;
}
return ai[index].getAccessibleIconDescription();
}
}, ac);
}
private int getAccessibleIconHeight(final AccessibleContext ac, final int index) {
debugString("[INFO]: getAccessibleIconHeight: index = "+index);
if (ac == null) {
return 0;
}
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
AccessibleIcon[] ai = ac.getAccessibleIcon();
if (ai == null || index < 0 || index >= ai.length) {
return 0;
}
return ai[index].getAccessibleIconHeight();
}
}, ac);
}
private int getAccessibleIconWidth(final AccessibleContext ac, final int index) {
debugString("[INFO]: getAccessibleIconWidth: index = "+index);
if (ac == null) {
return 0;
}
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
AccessibleIcon[] ai = ac.getAccessibleIcon();
if (ai == null || index < 0 || index >= ai.length) {
return 0;
}
return ai[index].getAccessibleIconWidth();
}
}, ac);
}
private int getAccessibleActionsCount(final AccessibleContext ac) {
debugString("[INFO]: getAccessibleActionsCount");
if (ac == null) {
return 0;
}
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
AccessibleAction aa = ac.getAccessibleAction();
if (aa == null)
return 0;
return aa.getAccessibleActionCount();
}
}, ac);
}
private String getAccessibleActionName(final AccessibleContext ac, final int index) {
debugString("[INFO]: getAccessibleActionName: index = "+index);
if (ac == null) {
return null;
}
return InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
AccessibleAction aa = ac.getAccessibleAction();
if (aa == null) {
return null;
}
return aa.getAccessibleActionDescription(index);
}
}, ac);
}
private boolean doAccessibleActions(final AccessibleContext ac, final String name) {
debugString("[INFO]: doAccessibleActions: action name = "+name);
if (ac == null || name == null) {
return false;
}
return InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
AccessibleAction aa = ac.getAccessibleAction();
if (aa == null) {
return false;
}
int index = -1;
int numActions = aa.getAccessibleActionCount();
for (int i = 0; i < numActions; i++) {
String actionName = aa.getAccessibleActionDescription(i);
if (name.equals(actionName)) {
index = i;
break;
}
}
if (index == -1) {
return false;
}
boolean retval = aa.doAccessibleAction(index);
return retval;
}
}, ac);
}
private boolean setTextContents(final AccessibleContext ac, final String text) {
debugString("[INFO]: setTextContents: ac = "+ac+"; text = "+text);
if (! (ac instanceof AccessibleEditableText)) {
debugString("[WARN]:   ac not instanceof AccessibleEditableText: "+ac);
return false;
}
if (text == null) {
debugString("[WARN]:   text is null");
return false;
}
return InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
AccessibleStateSet ass = ac.getAccessibleStateSet();
if (!ass.contains(AccessibleState.ENABLED)) {
return false;
}
((AccessibleEditableText) ac).setTextContents(text);
return true;
}
}, ac);
}
private AccessibleContext getInternalFrame (AccessibleContext ac) {
return getParentWithRole(ac, AccessibleRole.INTERNAL_FRAME.toString());
}
private AccessibleContext getTopLevelObject (final AccessibleContext ac) {
debugString("[INFO]: getTopLevelObject; ac = "+ac);
if (ac == null) {
return null;
}
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
if (ac.getAccessibleRole() == AccessibleRole.DIALOG) {
return ac;
}
Accessible parent = ac.getAccessibleParent();
if (parent == null) {
return ac;
}
Accessible tmp = parent;
while (tmp != null && tmp.getAccessibleContext() != null) {
AccessibleContext ac2 = tmp.getAccessibleContext();
if (ac2 != null && ac2.getAccessibleRole() == AccessibleRole.DIALOG) {
return ac2;
}
parent = tmp;
tmp = parent.getAccessibleContext().getAccessibleParent();
}
return parent.getAccessibleContext();
}
}, ac);
}
private AccessibleContext getParentWithRole (final AccessibleContext ac,
final String roleName) {
debugString("[INFO]: getParentWithRole; ac = "+ac + "\n role = "+roleName);
if (ac == null || roleName == null) {
return null;
}
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
AccessibleRole role = AccessBridge.this.accessibleRoleMap.get(roleName);
if (role == null) {
return ac;
}
Accessible parent = ac.getAccessibleParent();
if (parent == null && ac.getAccessibleRole() == role) {
return ac;
}
Accessible tmp = parent;
AccessibleContext tmp_ac = null;
while (tmp != null && (tmp_ac = tmp.getAccessibleContext()) != null) {
AccessibleRole ar = tmp_ac.getAccessibleRole();
if (ar == role) {
return tmp_ac;
}
parent = tmp;
tmp = parent.getAccessibleContext().getAccessibleParent();
}
return null;
}
}, ac);
}
private AccessibleContext getParentWithRoleElseRoot (AccessibleContext ac,
String roleName) {
AccessibleContext retval = getParentWithRole(ac, roleName);
if (retval == null) {
retval = getTopLevelObject(ac);
}
return retval;
}
private int getObjectDepth(final AccessibleContext ac) {
debugString("[INFO]: getObjectDepth: ac = "+ac);
if (ac == null) {
return -1;
}
return InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
int count = 0;
Accessible parent = ac.getAccessibleParent();
if (parent == null) {
return count;
}
Accessible tmp = parent;
while (tmp != null && tmp.getAccessibleContext() != null) {
parent = tmp;
tmp = parent.getAccessibleContext().getAccessibleParent();
count++;
}
return count;
}
}, ac);
}
private AccessibleContext getActiveDescendent (final AccessibleContext ac) {
debugString("[INFO]: getActiveDescendent: ac = "+ac);
if (ac == null) {
return null;
}
final Accessible parent = InvocationUtils.invokeAndWait(new Callable<Accessible>() {
@Override
public Accessible call() throws Exception {
return ac.getAccessibleParent();
}
}, ac);
if (parent != null) {
Accessible child = InvocationUtils.invokeAndWait(new Callable<Accessible>() {
@Override
public Accessible call() throws Exception {
int indexInParent = ac.getAccessibleIndexInParent();
return parent.getAccessibleContext().getAccessibleChild(indexInParent);
}
}, ac);
if (child instanceof JTree) {
final JTree tree = (JTree)child;
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
return new AccessibleJTreeNode(tree,
tree.getSelectionPath(),
null);
}
}, child);
}
}
return InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
AccessibleSelection as = ac.getAccessibleSelection();
if (as == null) {
return null;
}
if (as.getAccessibleSelectionCount() != 1) {
return null;
}
Accessible a = as.getAccessibleSelection(0);
if (a == null) {
return null;
}
return a.getAccessibleContext();
}
}, ac);
}
private String getJAWSAccessibleName(final AccessibleContext ac) {
debugString("[INFO]:  getJAWSAccessibleName");
if (ac == null) {
return null;
}
return InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return ac.getAccessibleName();
}
}, ac);
}
private boolean requestFocus(final AccessibleContext ac) {
debugString("[INFO]:  requestFocus");
if (ac == null) {
return false;
}
return InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
AccessibleComponent acomp = ac.getAccessibleComponent();
if (acomp == null) {
return false;
}
acomp.requestFocus();
return ac.getAccessibleStateSet().contains(AccessibleState.FOCUSED);
}
}, ac);
}
private boolean selectTextRange(final AccessibleContext ac, final int startIndex, final int endIndex) {
debugString("[INFO]:  selectTextRange: start = "+startIndex+"; end = "+endIndex);
if (ac == null) {
return false;
}
return InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (!(at instanceof AccessibleEditableText)) {
return false;
}
((AccessibleEditableText) at).selectText(startIndex, endIndex);
boolean result = at.getSelectionStart() == startIndex &&
at.getSelectionEnd() == endIndex;
return result;
}
}, ac);
}
private boolean setCaretPosition(final AccessibleContext ac, final int position) {
debugString("[INFO]: setCaretPosition: position = "+position);
if (ac == null) {
return false;
}
return InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
AccessibleText at = ac.getAccessibleText();
if (!(at instanceof AccessibleEditableText)) {
return false;
}
((AccessibleEditableText) at).selectText(position, position);
return at.getCaretPosition() == position;
}
}, ac);
}
private int _visibleChildrenCount;
private AccessibleContext _visibleChild;
private int _currentVisibleIndex;
private boolean _foundVisibleChild;
private int getVisibleChildrenCount(AccessibleContext ac) {
debugString("[INFO]: getVisibleChildrenCount");
if (ac == null) {
return -1;
}
_visibleChildrenCount = 0;
_getVisibleChildrenCount(ac);
debugString("[INFO]:   _visibleChildrenCount = "+_visibleChildrenCount);
return _visibleChildrenCount;
}
private void _getVisibleChildrenCount(final AccessibleContext ac) {
if (ac == null)
return;
if(ac instanceof AccessibleExtendedTable) {
_getVisibleChildrenCount((AccessibleExtendedTable)ac);
return;
}
int numChildren = InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return ac.getAccessibleChildrenCount();
}
}, ac);
for (int i = 0; i < numChildren; i++) {
final int idx = i;
final AccessibleContext ac2 = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
Accessible a = ac.getAccessibleChild(idx);
if (a != null)
return a.getAccessibleContext();
else
return null;
}
}, ac);
if ( ac2 == null ||
(!InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
return ac2.getAccessibleStateSet().contains(AccessibleState.SHOWING);
}
}, ac))
) {
continue;
}
_visibleChildrenCount++;
if (InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return ac2.getAccessibleChildrenCount();
}
}, ac) > 0 ) {
_getVisibleChildrenCount(ac2);
}
}
}
private void _getVisibleChildrenCount(final AccessibleExtendedTable acTable) {
if (acTable == null)
return;
int lastVisibleRow = -1;
int lastVisibleColumn = -1;
boolean foundVisible = false;
int rowCount = InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return acTable.getAccessibleRowCount();
}
}, acTable);
int columnCount = InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return acTable.getAccessibleColumnCount();
}
}, acTable);
for (int rowIdx = 0; rowIdx < rowCount; rowIdx++) {
for (int columnIdx = 0; columnIdx < columnCount; columnIdx++) {
if (lastVisibleRow != -1 && rowIdx > lastVisibleRow) {
continue;
}
if (lastVisibleColumn != -1 && columnIdx > lastVisibleColumn) {
continue;
}
int finalRowIdx = rowIdx;
int finalColumnIdx = columnIdx;
final AccessibleContext ac2 = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
Accessible a = acTable.getAccessibleAt(finalRowIdx, finalColumnIdx);
if (a == null)
return null;
else
return a.getAccessibleContext();
}
}, acTable);
if (ac2 == null ||
(!InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
return ac2.getAccessibleStateSet().contains(AccessibleState.SHOWING);
}
}, acTable))
) {
if (foundVisible) {
if (columnIdx != 0 && lastVisibleColumn == -1) {
lastVisibleColumn = columnIdx - 1;
} else if (columnIdx == 0 && lastVisibleRow == -1) {
lastVisibleRow = rowIdx - 1;
}
}
continue;
}
foundVisible = true;
_visibleChildrenCount++;
if (InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return ac2.getAccessibleChildrenCount();
}
}, acTable) > 0) {
_getVisibleChildrenCount(ac2);
}
}
}
}
private AccessibleContext getVisibleChild(AccessibleContext ac, int index) {
debugString("[INFO]: getVisibleChild: index = "+index);
if (ac == null) {
return null;
}
_visibleChild = null;
_currentVisibleIndex = 0;
_foundVisibleChild = false;
_getVisibleChild(ac, index);
if (_visibleChild != null) {
debugString( "[INFO]:     getVisibleChild: found child = " +
InvocationUtils.invokeAndWait(new Callable<String>() {
@Override
public String call() throws Exception {
return AccessBridge.this._visibleChild.getAccessibleName();
}
}, ac) );
}
return _visibleChild;
}
private void _getVisibleChild(final AccessibleContext ac, final int index) {
if (_visibleChild != null) {
return;
}
if(ac instanceof AccessibleExtendedTable) {
_getVisibleChild((AccessibleExtendedTable)ac, index);
return;
}
int numChildren = InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return ac.getAccessibleChildrenCount();
}
}, ac);
for (int i = 0; i < numChildren; i++) {
final int idx=i;
final AccessibleContext ac2 = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
Accessible a = ac.getAccessibleChild(idx);
if (a == null)
return null;
else
return a.getAccessibleContext();
}
}, ac);
if (ac2 == null ||
(!InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
return ac2.getAccessibleStateSet().contains(AccessibleState.SHOWING);
}
}, ac))) {
continue;
}
if (!_foundVisibleChild && _currentVisibleIndex == index) {
_visibleChild = ac2;
_foundVisibleChild = true;
return;
}
_currentVisibleIndex++;
if ( InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return ac2.getAccessibleChildrenCount();
}
}, ac) > 0 ) {
_getVisibleChild(ac2, index);
}
}
}
private void _getVisibleChild(final AccessibleExtendedTable acTable, final int index) {
if (_visibleChild != null) {
return;
}
int lastVisibleRow = -1;
int lastVisibleColumn = -1;
boolean foundVisible = false;
int rowCount = InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return acTable.getAccessibleRowCount();
}
}, acTable);
int columnCount = InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return acTable.getAccessibleColumnCount();
}
}, acTable);
for (int rowIdx = 0; rowIdx < rowCount; rowIdx++) {
for (int columnIdx = 0; columnIdx < columnCount; columnIdx++) {
if (lastVisibleRow != -1 && rowIdx > lastVisibleRow) {
continue;
}
if (lastVisibleColumn != -1 && columnIdx > lastVisibleColumn) {
continue;
}
int finalRowIdx = rowIdx;
int finalColumnIdx = columnIdx;
final AccessibleContext ac2 = InvocationUtils.invokeAndWait(new Callable<AccessibleContext>() {
@Override
public AccessibleContext call() throws Exception {
Accessible a = acTable.getAccessibleAt(finalRowIdx, finalColumnIdx);
if (a == null)
return null;
else
return a.getAccessibleContext();
}
}, acTable);
if (ac2 == null ||
(!InvocationUtils.invokeAndWait(new Callable<Boolean>() {
@Override
public Boolean call() throws Exception {
return ac2.getAccessibleStateSet().contains(AccessibleState.SHOWING);
}
}, acTable))) {
if (foundVisible) {
if (columnIdx != 0 && lastVisibleColumn == -1) {
lastVisibleColumn = columnIdx - 1;
} else if (columnIdx == 0 && lastVisibleRow == -1) {
lastVisibleRow = rowIdx - 1;
}
}
continue;
}
foundVisible = true;
if (!_foundVisibleChild && _currentVisibleIndex == index) {
_visibleChild = ac2;
_foundVisibleChild = true;
return;
}
_currentVisibleIndex++;
if (InvocationUtils.invokeAndWait(new Callable<Integer>() {
@Override
public Integer call() throws Exception {
return ac2.getAccessibleChildrenCount();
}
}, acTable) > 0) {
_getVisibleChild(ac2, index);
}
}
}
}
private class ObjectReferences {
private class Reference {
private int value;
Reference(int i) {
value = i;
}
public String toString() {
return ("refCount: " + value);
}
}
private ConcurrentHashMap<Object,Reference> refs;
ObjectReferences() {
refs = new ConcurrentHashMap<>(4);
}
String dump() {
return refs.toString();
}
void increment(Object o) {
if (o == null){
debugString("[WARN]: ObjectReferences::increment - Passed in object is null");
return;
}
if (refs.containsKey(o)) {
(refs.get(o)).value++;
} else {
refs.put(o, new Reference(1));
}
}
void decrement(Object o) {
Reference aRef = refs.get(o);
if (aRef != null) {
aRef.value--;
if (aRef.value == 0) {
refs.remove(o);
} else if (aRef.value < 0) {
debugString("[ERROR]: decrementing reference count below 0");
}
} else {
debugString("[ERROR]: object to decrement not in ObjectReferences table");
}
}
}
private native void propertyCaretChange(PropertyChangeEvent e,
AccessibleContext src,
int oldValue, int newValue);
private native void propertyDescriptionChange(PropertyChangeEvent e,
AccessibleContext src,
String oldValue, String newValue);
private native void propertyNameChange(PropertyChangeEvent e,
AccessibleContext src,
String oldValue, String newValue);
private native void propertySelectionChange(PropertyChangeEvent e,
AccessibleContext src);
private native void propertyStateChange(PropertyChangeEvent e,
AccessibleContext src,
String oldValue, String newValue);
private native void propertyTextChange(PropertyChangeEvent e,
AccessibleContext src);
private native void propertyValueChange(PropertyChangeEvent e,
AccessibleContext src,
String oldValue, String newValue);
private native void propertyVisibleDataChange(PropertyChangeEvent e,
AccessibleContext src);
private native void propertyChildChange(PropertyChangeEvent e,
AccessibleContext src,
AccessibleContext oldValue,
AccessibleContext newValue);
private native void propertyActiveDescendentChange(PropertyChangeEvent e,
AccessibleContext src,
AccessibleContext oldValue,
AccessibleContext newValue);
private native void javaShutdown();
private native void focusGained(FocusEvent e, AccessibleContext src);
private native void focusLost(FocusEvent e, AccessibleContext src);
private native void caretUpdate(CaretEvent e, AccessibleContext src);
private native void mouseClicked(MouseEvent e, AccessibleContext src);
private native void mouseEntered(MouseEvent e, AccessibleContext src);
private native void mouseExited(MouseEvent e, AccessibleContext src);
private native void mousePressed(MouseEvent e, AccessibleContext src);
private native void mouseReleased(MouseEvent e, AccessibleContext src);
private native void menuCanceled(MenuEvent e, AccessibleContext src);
private native void menuDeselected(MenuEvent e, AccessibleContext src);
private native void menuSelected(MenuEvent e, AccessibleContext src);
private native void popupMenuCanceled(PopupMenuEvent e, AccessibleContext src);
private native void popupMenuWillBecomeInvisible(PopupMenuEvent e,
AccessibleContext src);
private native void popupMenuWillBecomeVisible(PopupMenuEvent e,
AccessibleContext src);
private static final long PROPERTY_CHANGE_EVENTS = 1;
private static final long FOCUS_GAINED_EVENTS = 2;
private static final long FOCUS_LOST_EVENTS = 4;
private static final long FOCUS_EVENTS = (FOCUS_GAINED_EVENTS | FOCUS_LOST_EVENTS);
private static final long CARET_UPATE_EVENTS = 8;
private static final long CARET_EVENTS = CARET_UPATE_EVENTS;
private static final long MOUSE_CLICKED_EVENTS = 16;
private static final long MOUSE_ENTERED_EVENTS = 32;
private static final long MOUSE_EXITED_EVENTS = 64;
private static final long MOUSE_PRESSED_EVENTS = 128;
private static final long MOUSE_RELEASED_EVENTS = 256;
private static final long MOUSE_EVENTS = (MOUSE_CLICKED_EVENTS | MOUSE_ENTERED_EVENTS |
MOUSE_EXITED_EVENTS | MOUSE_PRESSED_EVENTS |
MOUSE_RELEASED_EVENTS);
private static final long MENU_CANCELED_EVENTS = 512;
private static final long MENU_DESELECTED_EVENTS = 1024;
private static final long MENU_SELECTED_EVENTS = 2048;
private static final long MENU_EVENTS = (MENU_CANCELED_EVENTS | MENU_DESELECTED_EVENTS |
MENU_SELECTED_EVENTS);
private static final long POPUPMENU_CANCELED_EVENTS = 4096;
private static final long POPUPMENU_WILL_BECOME_INVISIBLE_EVENTS = 8192;
private static final long POPUPMENU_WILL_BECOME_VISIBLE_EVENTS = 16384;
private static final long POPUPMENU_EVENTS = (POPUPMENU_CANCELED_EVENTS |
POPUPMENU_WILL_BECOME_INVISIBLE_EVENTS |
POPUPMENU_WILL_BECOME_VISIBLE_EVENTS);
private static final long PROPERTY_NAME_CHANGE_EVENTS = 1;
private static final long PROPERTY_DESCRIPTION_CHANGE_EVENTS = 2;
private static final long PROPERTY_STATE_CHANGE_EVENTS = 4;
private static final long PROPERTY_VALUE_CHANGE_EVENTS = 8;
private static final long PROPERTY_SELECTION_CHANGE_EVENTS = 16;
private static final long PROPERTY_TEXT_CHANGE_EVENTS = 32;
private static final long PROPERTY_CARET_CHANGE_EVENTS = 64;
private static final long PROPERTY_VISIBLEDATA_CHANGE_EVENTS = 128;
private static final long PROPERTY_CHILD_CHANGE_EVENTS = 256;
private static final long PROPERTY_ACTIVEDESCENDENT_CHANGE_EVENTS = 512;
private static final long PROPERTY_EVENTS = (PROPERTY_NAME_CHANGE_EVENTS |
PROPERTY_DESCRIPTION_CHANGE_EVENTS |
PROPERTY_STATE_CHANGE_EVENTS |
PROPERTY_VALUE_CHANGE_EVENTS |
PROPERTY_SELECTION_CHANGE_EVENTS |
PROPERTY_TEXT_CHANGE_EVENTS |
PROPERTY_CARET_CHANGE_EVENTS |
PROPERTY_VISIBLEDATA_CHANGE_EVENTS |
PROPERTY_CHILD_CHANGE_EVENTS |
PROPERTY_ACTIVEDESCENDENT_CHANGE_EVENTS);
private class EventHandler implements PropertyChangeListener,
FocusListener, CaretListener,
MenuListener, PopupMenuListener,
MouseListener, WindowListener,
ChangeListener {
private AccessBridge accessBridge;
private long javaEventMask = 0;
private long accessibilityEventMask = 0;
EventHandler(AccessBridge bridge) {
accessBridge = bridge;
}
public void windowOpened(WindowEvent e) {
Object o = null;
if (e != null)
o = e.getSource();
if (o instanceof NativeWindowHandler) {
addNativeWindowHandler((NativeWindowHandler)o);
}
}
public void windowClosing(WindowEvent e) {}
public void windowClosed(WindowEvent e) {
Object o = null;
if (e != null)
o = e.getSource();
if (o instanceof NativeWindowHandler) {
removeNativeWindowHandler((NativeWindowHandler)o);
}
}
public void windowIconified(WindowEvent e) {}
public void windowDeiconified(WindowEvent e) {}
public void windowActivated(WindowEvent e) {}
public void windowDeactivated(WindowEvent e) {}
void addJavaEventNotification(long type) {
long newEventMask = javaEventMask | type;
if ( ((javaEventMask & FOCUS_EVENTS) == 0) &&
((newEventMask & FOCUS_EVENTS) != 0) ) {
SwingEventMonitor.addFocusListener(this);
}
if ( ((javaEventMask & CARET_EVENTS) == 0) &&
((newEventMask & CARET_EVENTS) != 0) ) {
SwingEventMonitor.addCaretListener(this);
}
if ( ((javaEventMask & MOUSE_EVENTS) == 0) &&
((newEventMask & MOUSE_EVENTS) != 0) ) {
SwingEventMonitor.addMouseListener(this);
}
if ( ((javaEventMask & MENU_EVENTS) == 0) &&
((newEventMask & MENU_EVENTS) != 0) ) {
SwingEventMonitor.addMenuListener(this);
SwingEventMonitor.addPopupMenuListener(this);
}
if ( ((javaEventMask & POPUPMENU_EVENTS) == 0) &&
((newEventMask & POPUPMENU_EVENTS) != 0) ) {
SwingEventMonitor.addPopupMenuListener(this);
}
javaEventMask = newEventMask;
}
void removeJavaEventNotification(long type) {
long newEventMask = javaEventMask & (~type);
if (((javaEventMask & FOCUS_EVENTS) != 0) &&
((newEventMask & FOCUS_EVENTS) == 0)) {
SwingEventMonitor.removeFocusListener(this);
}
if (((javaEventMask & CARET_EVENTS) != 0) &&
((newEventMask & CARET_EVENTS) == 0)) {
SwingEventMonitor.removeCaretListener(this);
}
if (((javaEventMask & MOUSE_EVENTS) == 0) &&
((newEventMask & MOUSE_EVENTS) != 0)) {
SwingEventMonitor.removeMouseListener(this);
}
if (((javaEventMask & MENU_EVENTS) == 0) &&
((newEventMask & MENU_EVENTS) != 0)) {
SwingEventMonitor.removeMenuListener(this);
}
if (((javaEventMask & POPUPMENU_EVENTS) == 0) &&
((newEventMask & POPUPMENU_EVENTS) != 0)) {
SwingEventMonitor.removePopupMenuListener(this);
}
javaEventMask = newEventMask;
}
void addAccessibilityEventNotification(long type) {
long newEventMask = accessibilityEventMask | type;
if ( ((accessibilityEventMask & PROPERTY_EVENTS) == 0) &&
((newEventMask & PROPERTY_EVENTS) != 0) ) {
AccessibilityEventMonitor.addPropertyChangeListener(this);
}
accessibilityEventMask = newEventMask;
}
void removeAccessibilityEventNotification(long type) {
long newEventMask = accessibilityEventMask & (~type);
if ( ((accessibilityEventMask & PROPERTY_EVENTS) != 0) &&
((newEventMask & PROPERTY_EVENTS) == 0) ) {
AccessibilityEventMonitor.removePropertyChangeListener(this);
}
accessibilityEventMask = newEventMask;
}
public void propertyChange(PropertyChangeEvent e) {
accessBridge.debugString("[INFO]: propertyChange(" + e.toString() + ") called");
if (e != null && (accessibilityEventMask & PROPERTY_EVENTS) != 0) {
Object o = e.getSource();
AccessibleContext ac;
if (o instanceof AccessibleContext) {
ac = (AccessibleContext) o;
} else {
Accessible a = Translator.getAccessible(e.getSource());
if (a == null)
return;
else
ac = a.getAccessibleContext();
}
if (ac != null) {
InvocationUtils.registerAccessibleContext(ac, AppContext.getAppContext());
accessBridge.debugString("[INFO]: AccessibleContext: " + ac);
String propertyName = e.getPropertyName();
if (propertyName.equals(AccessibleContext.ACCESSIBLE_CARET_PROPERTY)) {
int oldValue = 0;
int newValue = 0;
if (e.getOldValue() instanceof Integer) {
oldValue = ((Integer) e.getOldValue()).intValue();
}
if (e.getNewValue() instanceof Integer) {
newValue = ((Integer) e.getNewValue()).intValue();
}
accessBridge.debugString("[INFO]:  - about to call propertyCaretChange()   old value: " + oldValue + "new value: " + newValue);
accessBridge.propertyCaretChange(e, ac, oldValue, newValue);
} else if (propertyName.equals(AccessibleContext.ACCESSIBLE_DESCRIPTION_PROPERTY)) {
String oldValue = null;
String newValue = null;
if (e.getOldValue() != null) {
oldValue = e.getOldValue().toString();
}
if (e.getNewValue() != null) {
newValue = e.getNewValue().toString();
}
accessBridge.debugString("[INFO]:  - about to call propertyDescriptionChange()   old value: " + oldValue + "new value: " + newValue);
accessBridge.propertyDescriptionChange(e, ac, oldValue, newValue);
} else if (propertyName.equals(AccessibleContext.ACCESSIBLE_NAME_PROPERTY)) {
String oldValue = null;
String newValue = null;
if (e.getOldValue() != null) {
oldValue = e.getOldValue().toString();
}
if (e.getNewValue() != null) {
newValue = e.getNewValue().toString();
}
accessBridge.debugString("[INFO]:  - about to call propertyNameChange()   old value: " + oldValue + " new value: " + newValue);
accessBridge.propertyNameChange(e, ac, oldValue, newValue);
} else if (propertyName.equals(AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY)) {
accessBridge.debugString("[INFO]:  - about to call propertySelectionChange() " + ac +  "   " + Thread.currentThread() + "   " + e.getSource());
accessBridge.propertySelectionChange(e, ac);
} else if (propertyName.equals(AccessibleContext.ACCESSIBLE_STATE_PROPERTY)) {
String oldValue = null;
String newValue = null;
if (e.getOldValue() != null) {
AccessibleState oldState = (AccessibleState) e.getOldValue();
oldValue = oldState.toDisplayString(Locale.US);
}
if (e.getNewValue() != null) {
AccessibleState newState = (AccessibleState) e.getNewValue();
newValue = newState.toDisplayString(Locale.US);
}
accessBridge.debugString("[INFO]:  - about to call propertyStateChange()");
accessBridge.propertyStateChange(e, ac, oldValue, newValue);
} else if (propertyName.equals(AccessibleContext.ACCESSIBLE_TEXT_PROPERTY)) {
accessBridge.debugString("[INFO]:  - about to call propertyTextChange()");
accessBridge.propertyTextChange(e, ac);
} else if (propertyName.equals(AccessibleContext.ACCESSIBLE_VALUE_PROPERTY)) {                          String oldValue = null;
String newValue = null;
if (e.getOldValue() != null) {
oldValue = e.getOldValue().toString();
}
if (e.getNewValue() != null) {
newValue = e.getNewValue().toString();
}
accessBridge.debugString("[INFO]:  - about to call propertyDescriptionChange()");
accessBridge.propertyValueChange(e, ac, oldValue, newValue);
} else if (propertyName.equals(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY)) {
accessBridge.propertyVisibleDataChange(e, ac);
} else if (propertyName.equals(AccessibleContext.ACCESSIBLE_CHILD_PROPERTY)) {
AccessibleContext oldAC = null;
AccessibleContext newAC = null;
Accessible a;
if (e.getOldValue() instanceof AccessibleContext) {
oldAC = (AccessibleContext) e.getOldValue();
InvocationUtils.registerAccessibleContext(oldAC, AppContext.getAppContext());
}
if (e.getNewValue() instanceof AccessibleContext) {
newAC = (AccessibleContext) e.getNewValue();
InvocationUtils.registerAccessibleContext(newAC, AppContext.getAppContext());
}
accessBridge.debugString("[INFO]:  - about to call propertyChildChange()   old AC: " + oldAC + "new AC: " + newAC);
accessBridge.propertyChildChange(e, ac, oldAC, newAC);
} else if (propertyName.equals(AccessibleContext.ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY)) {
handleActiveDescendentEvent(e, ac);
}
}
}
}
private AccessibleContext prevAC = null;
private void handleActiveDescendentEvent(PropertyChangeEvent e,
AccessibleContext ac) {
if (e == null || ac == null)
return;
AccessibleContext oldAC = null;
AccessibleContext newAC = null;
Accessible a;
if (e.getOldValue() instanceof Accessible) {
oldAC = ((Accessible) e.getOldValue()).getAccessibleContext();
} else if (e.getOldValue() instanceof Component) {
a = Translator.getAccessible(e.getOldValue());
if (a != null) {
oldAC = a.getAccessibleContext();
}
}
if (oldAC != null) {
Accessible parent = oldAC.getAccessibleParent();
if (parent instanceof JTree) {
oldAC = prevAC;
}
}
if (e.getNewValue() instanceof Accessible) {
newAC = ((Accessible) e.getNewValue()).getAccessibleContext();
} else if (e.getNewValue() instanceof Component) {
a = Translator.getAccessible(e.getNewValue());
if (a != null) {
newAC = a.getAccessibleContext();
}
}
if (newAC != null) {
Accessible parent = newAC.getAccessibleParent();
if (parent instanceof JTree) {
JTree tree = (JTree)parent;
newAC = new AccessibleJTreeNode(tree,
tree.getSelectionPath(),
null);
}
}
prevAC = newAC;
accessBridge.debugString("[INFO]:   - about to call propertyActiveDescendentChange()   AC: " + ac + "   old AC: " + oldAC + "new AC: " + newAC);
InvocationUtils.registerAccessibleContext(oldAC, AppContext.getAppContext());
InvocationUtils.registerAccessibleContext(newAC, AppContext.getAppContext());
accessBridge.propertyActiveDescendentChange(e, ac, oldAC, newAC);
}
private boolean stateChangeListenerAdded = false;
public void focusGained(FocusEvent e) {
processFocusGained();
}
public void stateChanged(ChangeEvent e) {
processFocusGained();
}
private void processFocusGained() {
Component focusOwner = KeyboardFocusManager.
getCurrentKeyboardFocusManager().getFocusOwner();
if (focusOwner == null) {
return;
}
if (focusOwner instanceof JRootPane) {
MenuElement [] path =
MenuSelectionManager.defaultManager().getSelectedPath();
if (path.length > 1) {
Component penult = path[path.length-2].getComponent();
Component last = path[path.length-1].getComponent();
if (last instanceof JPopupMenu) {
FocusEvent e = new FocusEvent(penult, FocusEvent.FOCUS_GAINED);
AccessibleContext context = penult.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, SunToolkit.targetToAppContext(penult));
accessBridge.focusGained(e, context);
} else if (penult instanceof JPopupMenu) {
FocusEvent e =
new FocusEvent(last, FocusEvent.FOCUS_GAINED);
AccessibleContext focusedAC = last.getAccessibleContext();
InvocationUtils.registerAccessibleContext(focusedAC, SunToolkit.targetToAppContext(last));
accessBridge.debugString("[INFO]:  - about to call focusGained()   AC: " + focusedAC);
accessBridge.focusGained(e, focusedAC);
}
}
} else {
if (focusOwner instanceof Accessible) {
FocusEvent e = new FocusEvent(focusOwner,
FocusEvent.FOCUS_GAINED);
AccessibleContext focusedAC = focusOwner.getAccessibleContext();
InvocationUtils.registerAccessibleContext(focusedAC, SunToolkit.targetToAppContext(focusOwner));
accessBridge.debugString("[INFO]:  - about to call focusGained()   AC: " + focusedAC);
accessBridge.focusGained(e, focusedAC);
}
}
}
public void focusLost(FocusEvent e) {
if (e != null && (javaEventMask & FOCUS_LOST_EVENTS) != 0) {
Accessible a = Translator.getAccessible(e.getSource());
if (a != null) {
accessBridge.debugString("[INFO]:  - about to call focusLost()   AC: " + a.getAccessibleContext());
AccessibleContext context = a.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, AppContext.getAppContext());
accessBridge.focusLost(e, context);
}
}
}
public void caretUpdate(CaretEvent e) {
if (e != null && (javaEventMask & CARET_UPATE_EVENTS) != 0) {
Accessible a = Translator.getAccessible(e.getSource());
if (a != null) {
AccessibleContext context = a.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, AppContext.getAppContext());
accessBridge.caretUpdate(e, context);
}
}
}
public void mouseClicked(MouseEvent e) {
if (e != null && (javaEventMask & MOUSE_CLICKED_EVENTS) != 0) {
Accessible a = Translator.getAccessible(e.getSource());
if (a != null) {
AccessibleContext context = a.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, AppContext.getAppContext());
accessBridge.mouseClicked(e, context);
}
}
}
public void mouseEntered(MouseEvent e) {
if (e != null && (javaEventMask & MOUSE_ENTERED_EVENTS) != 0) {
Accessible a = Translator.getAccessible(e.getSource());
if (a != null) {
AccessibleContext context = a.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, AppContext.getAppContext());
accessBridge.mouseEntered(e, context);
}
}
}
public void mouseExited(MouseEvent e) {
if (e != null && (javaEventMask & MOUSE_EXITED_EVENTS) != 0) {
Accessible a = Translator.getAccessible(e.getSource());
if (a != null) {
AccessibleContext context = a.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, AppContext.getAppContext());
accessBridge.mouseExited(e, context);
}
}
}
public void mousePressed(MouseEvent e) {
if (e != null && (javaEventMask & MOUSE_PRESSED_EVENTS) != 0) {
Accessible a = Translator.getAccessible(e.getSource());
if (a != null) {
AccessibleContext context = a.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, AppContext.getAppContext());
accessBridge.mousePressed(e, context);
}
}
}
public void mouseReleased(MouseEvent e) {
if (e != null && (javaEventMask & MOUSE_RELEASED_EVENTS) != 0) {
Accessible a = Translator.getAccessible(e.getSource());
if (a != null) {
AccessibleContext context = a.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, AppContext.getAppContext());
accessBridge.mouseReleased(e, context);
}
}
}
public void menuCanceled(MenuEvent e) {
if (e != null && (javaEventMask & MENU_CANCELED_EVENTS) != 0) {
Accessible a = Translator.getAccessible(e.getSource());
if (a != null) {
AccessibleContext context = a.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, AppContext.getAppContext());
accessBridge.menuCanceled(e, context);
}
}
}
public void menuDeselected(MenuEvent e) {
if (e != null && (javaEventMask & MENU_DESELECTED_EVENTS) != 0) {
Accessible a = Translator.getAccessible(e.getSource());
if (a != null) {
AccessibleContext context = a.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, AppContext.getAppContext());
accessBridge.menuDeselected(e, context);
}
}
}
public void menuSelected(MenuEvent e) {
if (e != null && (javaEventMask & MENU_SELECTED_EVENTS) != 0) {
Accessible a = Translator.getAccessible(e.getSource());
if (a != null) {
AccessibleContext context = a.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, AppContext.getAppContext());
accessBridge.menuSelected(e, context);
}
}
}
public void popupMenuCanceled(PopupMenuEvent e) {
if (e != null && (javaEventMask & POPUPMENU_CANCELED_EVENTS) != 0) {
Accessible a = Translator.getAccessible(e.getSource());
if (a != null) {
AccessibleContext context = a.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, AppContext.getAppContext());
accessBridge.popupMenuCanceled(e, context);
}
}
}
public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
if (e != null && (javaEventMask & POPUPMENU_WILL_BECOME_INVISIBLE_EVENTS) != 0) {
Accessible a = Translator.getAccessible(e.getSource());
if (a != null) {
AccessibleContext context = a.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, AppContext.getAppContext());
accessBridge.popupMenuWillBecomeInvisible(e, context);
}
}
}
public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
if (e != null && (javaEventMask & POPUPMENU_WILL_BECOME_VISIBLE_EVENTS) != 0) {
Accessible a = Translator.getAccessible(e.getSource());
if (a != null) {
AccessibleContext context = a.getAccessibleContext();
InvocationUtils.registerAccessibleContext(context, AppContext.getAppContext());
accessBridge.popupMenuWillBecomeVisible(e, context);
}
}
}
}
private void addJavaEventNotification(final long type) {
EventQueue.invokeLater(new Runnable() {
public void run(){
eventHandler.addJavaEventNotification(type);
}
});
}
private void removeJavaEventNotification(final long type) {
EventQueue.invokeLater(new Runnable() {
public void run(){
eventHandler.removeJavaEventNotification(type);
}
});
}
private void addAccessibilityEventNotification(final long type) {
EventQueue.invokeLater(new Runnable() {
public void run(){
eventHandler.addAccessibilityEventNotification(type);
}
});
}
private void removeAccessibilityEventNotification(final long type) {
EventQueue.invokeLater(new Runnable() {
public void run(){
eventHandler.removeAccessibilityEventNotification(type);
}
});
}
private AccessibleRole [] allAccessibleRoles = {
AccessibleRole.ALERT,
AccessibleRole.COLUMN_HEADER,
AccessibleRole.CANVAS,
AccessibleRole.COMBO_BOX,
AccessibleRole.DESKTOP_ICON,
AccessibleRole.INTERNAL_FRAME,
AccessibleRole.DESKTOP_PANE,
AccessibleRole.OPTION_PANE,
AccessibleRole.WINDOW,
AccessibleRole.FRAME,
AccessibleRole.DIALOG,
AccessibleRole.COLOR_CHOOSER,
AccessibleRole.DIRECTORY_PANE,
AccessibleRole.FILE_CHOOSER,
AccessibleRole.FILLER,
AccessibleRole.ICON,
AccessibleRole.LABEL,
AccessibleRole.ROOT_PANE,
AccessibleRole.GLASS_PANE,
AccessibleRole.LAYERED_PANE,
AccessibleRole.LIST,
AccessibleRole.LIST_ITEM,
AccessibleRole.MENU_BAR,
AccessibleRole.POPUP_MENU,
AccessibleRole.MENU,
AccessibleRole.MENU_ITEM,
AccessibleRole.SEPARATOR,
AccessibleRole.PAGE_TAB_LIST,
AccessibleRole.PAGE_TAB,
AccessibleRole.PANEL,
AccessibleRole.PROGRESS_BAR,
AccessibleRole.PASSWORD_TEXT,
AccessibleRole.PUSH_BUTTON,
AccessibleRole.TOGGLE_BUTTON,
AccessibleRole.CHECK_BOX,
AccessibleRole.RADIO_BUTTON,
AccessibleRole.ROW_HEADER,
AccessibleRole.SCROLL_PANE,
AccessibleRole.SCROLL_BAR,
AccessibleRole.VIEWPORT,
AccessibleRole.SLIDER,
AccessibleRole.SPLIT_PANE,
AccessibleRole.TABLE,
AccessibleRole.TEXT,
AccessibleRole.TREE,
AccessibleRole.TOOL_BAR,
AccessibleRole.TOOL_TIP,
AccessibleRole.AWT_COMPONENT,
AccessibleRole.SWING_COMPONENT,
AccessibleRole.UNKNOWN,
};
private class AccessibleJTreeNode extends AccessibleContext
implements Accessible, AccessibleComponent, AccessibleSelection,
AccessibleAction {
private JTree tree = null;
private TreeModel treeModel = null;
private Object obj = null;
private TreePath path = null;
private Accessible accessibleParent = null;
private int index = 0;
private boolean isLeaf = false;
AccessibleJTreeNode(JTree t, TreePath p, Accessible ap) {
tree = t;
path = p;
accessibleParent = ap;
if (t != null)
treeModel = t.getModel();
if (p != null) {
obj = p.getLastPathComponent();
if (treeModel != null && obj != null) {
isLeaf = treeModel.isLeaf(obj);
}
}
debugString("[INFO]: AccessibleJTreeNode: name = "+getAccessibleName()+"; TreePath = "+p+"; parent = "+ap);
}
private TreePath getChildTreePath(int i) {
if (i < 0 || i >= getAccessibleChildrenCount() || path == null || treeModel == null) {
return null;
} else {
Object childObj = treeModel.getChild(obj, i);
Object[] objPath = path.getPath();
Object[] objChildPath = new Object[objPath.length+1];
java.lang.System.arraycopy(objPath, 0, objChildPath, 0, objPath.length);
objChildPath[objChildPath.length-1] = childObj;
return new TreePath(objChildPath);
}
}
public AccessibleContext getAccessibleContext() {
return this;
}
private AccessibleContext getCurrentAccessibleContext() {
Component c = getCurrentComponent();
if (c instanceof Accessible) {
return (c.getAccessibleContext());
} else {
return null;
}
}
private Component getCurrentComponent() {
debugString("[INFO]: AccessibleJTreeNode: getCurrentComponent");
if (tree != null && tree.isVisible(path)) {
TreeCellRenderer r = tree.getCellRenderer();
if (r == null) {
debugString("[WARN]:  returning null 1");
return null;
}
TreeUI ui = tree.getUI();
if (ui != null) {
int row = ui.getRowForPath(tree, path);
boolean selected = tree.isPathSelected(path);
boolean expanded = tree.isExpanded(path);
boolean hasFocus = false;                     Component retval = r.getTreeCellRendererComponent(tree, obj,
selected, expanded,
isLeaf, row, hasFocus);
debugString("[INFO]:   returning = "+retval.getClass());
return retval;
}
}
debugString("[WARN]:  returning null 2");
return null;
}
public String getAccessibleName() {
debugString("[INFO]: AccessibleJTreeNode: getAccessibleName");
AccessibleContext ac = getCurrentAccessibleContext();
if (ac != null) {
String name = ac.getAccessibleName();
if ((name != null) && (!name.isEmpty())) {
String retval = ac.getAccessibleName();
debugString("[INFO]:     returning "+retval);
return retval;
} else {
return null;
}
}
if ((accessibleName != null) && (accessibleName.isEmpty())) {
return accessibleName;
} else {
return null;
}
}
public void setAccessibleName(String s) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac != null) {
ac.setAccessibleName(s);
} else {
super.setAccessibleName(s);
}
}
public String getAccessibleDescription() {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac != null) {
return ac.getAccessibleDescription();
} else {
return super.getAccessibleDescription();
}
}
public void setAccessibleDescription(String s) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac != null) {
ac.setAccessibleDescription(s);
} else {
super.setAccessibleDescription(s);
}
}
public AccessibleRole getAccessibleRole() {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac != null) {
return ac.getAccessibleRole();
} else {
return AccessibleRole.UNKNOWN;
}
}
public AccessibleStateSet getAccessibleStateSet() {
if (tree == null)
return null;
AccessibleContext ac = getCurrentAccessibleContext();
AccessibleStateSet states;
int row = tree.getUI().getRowForPath(tree,path);
int lsr = tree.getLeadSelectionRow();
if (ac != null) {
states = ac.getAccessibleStateSet();
} else {
states = new AccessibleStateSet();
}
if (isShowing()) {
states.add(AccessibleState.SHOWING);
} else if (states.contains(AccessibleState.SHOWING)) {
states.remove(AccessibleState.SHOWING);
}
if (isVisible()) {
states.add(AccessibleState.VISIBLE);
} else if (states.contains(AccessibleState.VISIBLE)) {
states.remove(AccessibleState.VISIBLE);
}
if (tree.isPathSelected(path)){
states.add(AccessibleState.SELECTED);
}
if (lsr == row) {
states.add(AccessibleState.ACTIVE);
}
if (!isLeaf) {
states.add(AccessibleState.EXPANDABLE);
}
if (tree.isExpanded(path)) {
states.add(AccessibleState.EXPANDED);
} else {
states.add(AccessibleState.COLLAPSED);
}
if (tree.isEditable()) {
states.add(AccessibleState.EDITABLE);
}
return states;
}
public Accessible getAccessibleParent() {
if (accessibleParent == null && path != null) {
Object[] objPath = path.getPath();
if (objPath.length > 1) {
Object objParent = objPath[objPath.length-2];
if (treeModel != null) {
index = treeModel.getIndexOfChild(objParent, obj);
}
Object[] objParentPath = new Object[objPath.length-1];
java.lang.System.arraycopy(objPath, 0, objParentPath,
0, objPath.length-1);
TreePath parentPath = new TreePath(objParentPath);
accessibleParent = new AccessibleJTreeNode(tree,
parentPath,
null);
this.setAccessibleParent(accessibleParent);
} else if (treeModel != null) {
accessibleParent = tree;                     index = 0;                     this.setAccessibleParent(accessibleParent);
}
}
return accessibleParent;
}
public int getAccessibleIndexInParent() {
if (accessibleParent == null) {
getAccessibleParent();
}
if (path != null) {
Object[] objPath = path.getPath();
if (objPath.length > 1) {
Object objParent = objPath[objPath.length-2];
if (treeModel != null) {
index = treeModel.getIndexOfChild(objParent, obj);
}
}
}
return index;
}
public int getAccessibleChildrenCount() {
if (obj != null && treeModel != null) {
return treeModel.getChildCount(obj);
}
return 0;
}
public Accessible getAccessibleChild(int i) {
if (i < 0 || i >= getAccessibleChildrenCount() || path == null || treeModel == null) {
return null;
} else {
Object childObj = treeModel.getChild(obj, i);
Object[] objPath = path.getPath();
Object[] objChildPath = new Object[objPath.length+1];
java.lang.System.arraycopy(objPath, 0, objChildPath, 0, objPath.length);
objChildPath[objChildPath.length-1] = childObj;
TreePath childPath = new TreePath(objChildPath);
return new AccessibleJTreeNode(tree, childPath, this);
}
}
public Locale getLocale() {
if (tree == null)
return null;
AccessibleContext ac = getCurrentAccessibleContext();
if (ac != null) {
return ac.getLocale();
} else {
return tree.getLocale();
}
}
public void addPropertyChangeListener(PropertyChangeListener l) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac != null) {
ac.addPropertyChangeListener(l);
} else {
super.addPropertyChangeListener(l);
}
}
public void removePropertyChangeListener(PropertyChangeListener l) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac != null) {
ac.removePropertyChangeListener(l);
} else {
super.removePropertyChangeListener(l);
}
}
public AccessibleAction getAccessibleAction() {
return this;
}
public AccessibleComponent getAccessibleComponent() {
return this;         }
public AccessibleSelection getAccessibleSelection() {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac != null && isLeaf) {
return getCurrentAccessibleContext().getAccessibleSelection();
} else {
return this;
}
}
public AccessibleText getAccessibleText() {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac != null) {
return getCurrentAccessibleContext().getAccessibleText();
} else {
return null;
}
}
public AccessibleValue getAccessibleValue() {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac != null) {
return getCurrentAccessibleContext().getAccessibleValue();
} else {
return null;
}
}
public Color getBackground() {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
return ((AccessibleComponent) ac).getBackground();
} else {
Component c = getCurrentComponent();
if (c != null) {
return c.getBackground();
} else {
return null;
}
}
}
public void setBackground(Color c) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
((AccessibleComponent) ac).setBackground(c);
} else {
Component cp = getCurrentComponent();
if (    cp != null) {
cp.setBackground(c);
}
}
}
public Color getForeground() {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
return ((AccessibleComponent) ac).getForeground();
} else {
Component c = getCurrentComponent();
if (c != null) {
return c.getForeground();
} else {
return null;
}
}
}
public void setForeground(Color c) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
((AccessibleComponent) ac).setForeground(c);
} else {
Component cp = getCurrentComponent();
if (cp != null) {
cp.setForeground(c);
}
}
}
public Cursor getCursor() {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
return ((AccessibleComponent) ac).getCursor();
} else {
Component c = getCurrentComponent();
if (c != null) {
return c.getCursor();
} else {
Accessible ap = getAccessibleParent();
if (ap instanceof AccessibleComponent) {
return ((AccessibleComponent) ap).getCursor();
} else {
return null;
}
}
}
}
public void setCursor(Cursor c) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
((AccessibleComponent) ac).setCursor(c);
} else {
Component cp = getCurrentComponent();
if (cp != null) {
cp.setCursor(c);
}
}
}
public Font getFont() {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
return ((AccessibleComponent) ac).getFont();
} else {
Component c = getCurrentComponent();
if (c != null) {
return c.getFont();
} else {
return null;
}
}
}
public void setFont(Font f) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
((AccessibleComponent) ac).setFont(f);
} else {
Component c = getCurrentComponent();
if (c != null) {
c.setFont(f);
}
}
}
public FontMetrics getFontMetrics(Font f) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
return ((AccessibleComponent) ac).getFontMetrics(f);
} else {
Component c = getCurrentComponent();
if (c != null) {
return c.getFontMetrics(f);
} else {
return null;
}
}
}
public boolean isEnabled() {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
return ((AccessibleComponent) ac).isEnabled();
} else {
Component c = getCurrentComponent();
if (c != null) {
return c.isEnabled();
} else {
return false;
}
}
}
public void setEnabled(boolean b) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
((AccessibleComponent) ac).setEnabled(b);
} else {
Component c = getCurrentComponent();
if (c != null) {
c.setEnabled(b);
}
}
}
public boolean isVisible() {
if (tree == null)
return false;
Rectangle pathBounds = tree.getPathBounds(path);
Rectangle parentBounds = tree.getVisibleRect();
if ( pathBounds != null && parentBounds != null &&
parentBounds.intersects(pathBounds) ) {
return true;
} else {
return false;
}
}
public void setVisible(boolean b) {
}
public boolean isShowing() {
return (tree.isShowing() && isVisible());
}
public boolean contains(Point p) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
Rectangle r = ((AccessibleComponent) ac).getBounds();
return r.contains(p);
} else {
Component c = getCurrentComponent();
if (c != null) {
Rectangle r = c.getBounds();
return r.contains(p);
} else {
return getBounds().contains(p);
}
}
}
public Point getLocationOnScreen() {
if (tree != null) {
Point treeLocation = tree.getLocationOnScreen();
Rectangle pathBounds = tree.getPathBounds(path);
if (treeLocation != null && pathBounds != null) {
Point nodeLocation = new Point(pathBounds.x,
pathBounds.y);
nodeLocation.translate(treeLocation.x, treeLocation.y);
return nodeLocation;
} else {
return null;
}
} else {
return null;
}
}
private Point getLocationInJTree() {
Rectangle r = tree.getPathBounds(path);
if (r != null) {
return r.getLocation();
} else {
return null;
}
}
public Point getLocation() {
Rectangle r = getBounds();
if (r != null) {
return r.getLocation();
} else {
return null;
}
}
public void setLocation(Point p) {
}
public Rectangle getBounds() {
if (tree == null)
return null;
Rectangle r = tree.getPathBounds(path);
Accessible parent = getAccessibleParent();
if (parent instanceof AccessibleJTreeNode) {
Point parentLoc = ((AccessibleJTreeNode) parent).getLocationInJTree();
if (parentLoc != null && r != null) {
r.translate(-parentLoc.x, -parentLoc.y);
} else {
return null;                        }
}
return r;
}
public void setBounds(Rectangle r) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
((AccessibleComponent) ac).setBounds(r);
} else {
Component c = getCurrentComponent();
if (c != null) {
c.setBounds(r);
}
}
}
public Dimension getSize() {
return getBounds().getSize();
}
public void setSize (Dimension d) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
((AccessibleComponent) ac).setSize(d);
} else {
Component c = getCurrentComponent();
if (c != null) {
c.setSize(d);
}
}
}
public Accessible getAccessibleAt(Point p) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
return ((AccessibleComponent) ac).getAccessibleAt(p);
} else {
return null;
}
}
public boolean isFocusTraversable() {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
return ((AccessibleComponent) ac).isFocusTraversable();
} else {
Component c = getCurrentComponent();
if (c != null) {
return c.isFocusable();
} else {
return false;
}
}
}
public void requestFocus() {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
((AccessibleComponent) ac).requestFocus();
} else {
Component c = getCurrentComponent();
if (c != null) {
c.requestFocus();
}
}
}
public void addFocusListener(FocusListener l) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
((AccessibleComponent) ac).addFocusListener(l);
} else {
Component c = getCurrentComponent();
if (c != null) {
c.addFocusListener(l);
}
}
}
public void removeFocusListener(FocusListener l) {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac instanceof AccessibleComponent) {
((AccessibleComponent) ac).removeFocusListener(l);
} else {
Component c = getCurrentComponent();
if (c != null) {
c.removeFocusListener(l);
}
}
}
public int getAccessibleSelectionCount() {
int count = 0;
int childCount = getAccessibleChildrenCount();
for (int i = 0; i < childCount; i++) {
TreePath childPath = getChildTreePath(i);
if (tree.isPathSelected(childPath)) {
count++;
}
}
return count;
}
public Accessible getAccessibleSelection(int i) {
int childCount = getAccessibleChildrenCount();
if (i < 0 || i >= childCount) {
return null;                    }
int count = 0;
for (int j = 0; j < childCount && i >= count; j++) {
TreePath childPath = getChildTreePath(j);
if (tree.isPathSelected(childPath)) {
if (count == i) {
return new AccessibleJTreeNode(tree, childPath, this);
} else {
count++;
}
}
}
return null;
}
public boolean isAccessibleChildSelected(int i) {
int childCount = getAccessibleChildrenCount();
if (i < 0 || i >= childCount) {
return false;                   } else {
TreePath childPath = getChildTreePath(i);
return tree.isPathSelected(childPath);
}
}
public void addAccessibleSelection(int i) {
if (tree == null)
return;
TreeModel model = tree.getModel();
if (model != null) {
if (i >= 0 && i < getAccessibleChildrenCount()) {
TreePath path = getChildTreePath(i);
tree.addSelectionPath(path);
}
}
}
public void removeAccessibleSelection(int i) {
if (tree == null)
return;
TreeModel model = tree.getModel();
if (model != null) {
if (i >= 0 && i < getAccessibleChildrenCount()) {
TreePath path = getChildTreePath(i);
tree.removeSelectionPath(path);
}
}
}
public void clearAccessibleSelection() {
int childCount = getAccessibleChildrenCount();
for (int i = 0; i < childCount; i++) {
removeAccessibleSelection(i);
}
}
public void selectAllAccessibleSelection() {
if (tree == null)
return;
TreeModel model = tree.getModel();
if (model != null) {
int childCount = getAccessibleChildrenCount();
TreePath path;
for (int i = 0; i < childCount; i++) {
path = getChildTreePath(i);
tree.addSelectionPath(path);
}
}
}
public int getAccessibleActionCount() {
AccessibleContext ac = getCurrentAccessibleContext();
if (ac != null) {
AccessibleAction aa = ac.getAccessibleAction();
if (aa != null) {
return (aa.getAccessibleActionCount() + (isLeaf ? 0 : 1));
}
}
return isLeaf ? 0 : 1;
}
public String getAccessibleActionDescription(int i) {
if (i < 0 || i >= getAccessibleActionCount()) {
return null;
}
AccessibleContext ac = getCurrentAccessibleContext();
if (i == 0) {
return "toggle expand";
} else if (ac != null) {
AccessibleAction aa = ac.getAccessibleAction();
if (aa != null) {
return aa.getAccessibleActionDescription(i - 1);
}
}
return null;
}
public boolean doAccessibleAction(int i) {
if (i < 0 || i >= getAccessibleActionCount()) {
return false;
}
AccessibleContext ac = getCurrentAccessibleContext();
if (i == 0) {
if (tree.isExpanded(path)) {
tree.collapsePath(path);
} else {
tree.expandPath(path);
}
return true;
} else if (ac != null) {
AccessibleAction aa = ac.getAccessibleAction();
if (aa != null) {
return aa.doAccessibleAction(i - 1);
}
}
return false;
}
}
private static class InvocationUtils {
public static <T> T invokeAndWait(final Callable<T> callable,
final AccessibleExtendedTable accessibleTable) {
if (accessibleTable instanceof AccessibleContext) {
return invokeAndWait(callable, (AccessibleContext)accessibleTable);
}
throw new RuntimeException("Unmapped AccessibleContext used to dispatch event: " + accessibleTable);
}
public static <T> T invokeAndWait(final Callable<T> callable,
final Accessible accessible) {
if (accessible instanceof Component) {
return invokeAndWait(callable, (Component)accessible);
}
if (accessible instanceof AccessibleContext) {
return invokeAndWait(callable, (AccessibleContext)accessible);
}
throw new RuntimeException("Unmapped Accessible used to dispatch event: " + accessible);
}
public static <T> T invokeAndWait(final Callable<T> callable,
final Component component) {
return invokeAndWait(callable, SunToolkit.targetToAppContext(component));
}
public static <T> T invokeAndWait(final Callable<T> callable,
final AccessibleContext accessibleContext) {
AppContext targetContext = AWTAccessor.getAccessibleContextAccessor()
.getAppContext(accessibleContext);
if (targetContext != null) {
return invokeAndWait(callable, targetContext);
} else {
if (accessibleContext instanceof Translator) {
Object source = ((Translator)accessibleContext).getSource();
if (source instanceof Component) {
return invokeAndWait(callable, (Component)source);
}
}
}
throw new RuntimeException("Unmapped AccessibleContext used to dispatch event: " + accessibleContext);
}
private static <T> T invokeAndWait(final Callable<T> callable,
final AppContext targetAppContext) {
final CallableWrapper<T> wrapper = new CallableWrapper<T>(callable);
try {
invokeAndWait(wrapper, targetAppContext);
T result = wrapper.getResult();
updateAppContextMap(result, targetAppContext);
return result;
} catch (final Exception e) {
throw new RuntimeException(e);
}
}
private static void invokeAndWait(final Runnable runnable,
final AppContext appContext)
throws InterruptedException, InvocationTargetException {
EventQueue eq = SunToolkit.getSystemEventQueueImplPP(appContext);
Object lock = new Object();
Toolkit source = Toolkit.getDefaultToolkit();
InvocationEvent event =
new InvocationEvent(source, runnable, lock, true);
synchronized (lock) {
eq.postEvent(event);
lock.wait();
}
Throwable eventThrowable = event.getThrowable();
if (eventThrowable != null) {
throw new InvocationTargetException(eventThrowable);
}
}
public static void registerAccessibleContext(final AccessibleContext accessibleContext,
final AppContext targetContext) {
if (accessibleContext != null) {
AWTAccessor.getAccessibleContextAccessor().setAppContext(accessibleContext, targetContext);
}
}
private static <T> void updateAppContextMap(final T accessibleContext,
final AppContext targetContext) {
if (accessibleContext instanceof AccessibleContext) {
registerAccessibleContext((AccessibleContext)accessibleContext, targetContext);
}
}
private static class CallableWrapper<T> implements Runnable {
private final Callable<T> callable;
private volatile T object;
private Exception e;
CallableWrapper(final Callable<T> callable) {
this.callable = callable;
}
public void run() {
try {
if (callable != null) {
object = callable.call();
}
} catch (final Exception e) {
this.e = e;
}
}
T getResult() throws Exception {
if (e != null)
throw e;
return object;
}
}
}
private static abstract class AccessibilityGraphicsEnvironment extends GraphicsEnvironment {
public static GraphicsConfiguration getGraphicsConfigurationAtPoint(double x, double y) {
GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment()
.getDefaultScreenDevice().getDefaultConfiguration();
return getGraphicsConfigurationAtPoint(gc, x, y);
}
public static GraphicsConfiguration getGraphicsConfigurationAtPoint(
GraphicsConfiguration current, double x, double y) {
if (containsUserSpacePoint(current, x, y)) {
return current;
}
GraphicsEnvironment env = getLocalGraphicsEnvironment();
for (GraphicsDevice device : env.getScreenDevices()) {
GraphicsConfiguration config = device.getDefaultConfiguration();
if (containsUserSpacePoint(config, x, y)) {
return config;
}
}
return current;
}
public static GraphicsConfiguration getGraphicsConfigurationAtDevicePoint(double x, double y) {
GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment()
.getDefaultScreenDevice().getDefaultConfiguration();
return getGraphicsConfigurationAtDevicePoint(gc, x, y);
}
public static GraphicsConfiguration getGraphicsConfigurationAtDevicePoint(
GraphicsConfiguration current, double x, double y) {
if (containsDeviceSpacePoint(current, x, y)) {
return current;
}
GraphicsEnvironment env = getLocalGraphicsEnvironment();
for (GraphicsDevice device : env.getScreenDevices()) {
GraphicsConfiguration config = device.getDefaultConfiguration();
if (containsDeviceSpacePoint(config, x, y)) {
return config;
}
}
return current;
}
private static boolean containsDeviceSpacePoint(GraphicsConfiguration config, double x, double y) {
Rectangle bounds = config.getBounds();
bounds = toDeviceSpaceAbs(config, bounds.x, bounds.y, bounds.width, bounds.height);
return bounds.contains(x, y);
}
private static boolean containsUserSpacePoint(GraphicsConfiguration config, double x, double y) {
Rectangle bounds = config.getBounds();
return bounds.contains(x, y);
}
public static Point toUserSpace(int x, int y) {
GraphicsConfiguration gc = getGraphicsConfigurationAtDevicePoint(x, y);
return toUserSpace(gc, x, y);
}
public static Point toUserSpace(GraphicsConfiguration gc, int x, int y) {
AffineTransform tx = gc.getDefaultTransform();
Rectangle screen = gc.getBounds();
int userX = screen.x + clipRound((x - screen.x) / tx.getScaleX());
int userY = screen.y + clipRound((y - screen.y) / tx.getScaleY());
return new Point(userX, userY);
}
public static Rectangle toDeviceSpaceAbs(Rectangle rect) {
GraphicsConfiguration gc = getGraphicsConfigurationAtPoint(rect.x, rect.y);
return toDeviceSpaceAbs(gc, rect.x, rect.y, rect.width, rect.height);
}
public static Rectangle toDeviceSpaceAbs(GraphicsConfiguration gc,
int x, int y, int w, int h) {
AffineTransform tx = gc.getDefaultTransform();
Rectangle screen = gc.getBounds();
return new Rectangle(
screen.x + clipRound((x - screen.x) * tx.getScaleX()),
screen.y + clipRound((y - screen.y) * tx.getScaleY()),
clipRound(w * tx.getScaleX()),
clipRound(h * tx.getScaleY())
);
}
private static int clipRound(final double coordinate) {
final double newv = coordinate - 0.5;
if (newv < Integer.MIN_VALUE) {
return Integer.MIN_VALUE;
}
if (newv > Integer.MAX_VALUE) {
return Integer.MAX_VALUE;
}
return (int) Math.ceil(newv);
}
}
}
package sun.jvm.hotspot.debugger.cdbg;
public interface AccessControl {
public static final int NO_PROTECTION = 0;
public static final int PRIVATE       = 1;
public static final int PROTECTED     = 2;
public static final int PUBLIC        = 3;
}
package java.security;
import java.util.ArrayList;
import java.util.List;
import sun.security.util.Debug;
import sun.security.util.FilePermCompat;
import sun.security.util.SecurityConstants;
@Deprecated(since="17", forRemoval=true)
public final class AccessControlContext {
private ProtectionDomain[] context;
private boolean isPrivileged;
private boolean isAuthorized = false;
private AccessControlContext privilegedContext;
@SuppressWarnings("removal")
private DomainCombiner combiner = null;
private Permission[] permissions;
private AccessControlContext parent;
private boolean isWrapped;
private boolean isLimited;
private ProtectionDomain[] limitedContext;
private static boolean debugInit = false;
private static Debug debug = null;
@SuppressWarnings("removal")
static Debug getDebug()
{
if (debugInit)
return debug;
else {
if (Policy.isSet()) {
debug = Debug.getInstance("access");
debugInit = true;
}
return debug;
}
}
public AccessControlContext(ProtectionDomain[] context)
{
if (context.length == 0) {
this.context = null;
} else if (context.length == 1) {
if (context[0] != null) {
this.context = context.clone();
} else {
this.context = null;
}
} else {
List<ProtectionDomain> v = new ArrayList<>(context.length);
for (int i =0; i< context.length; i++) {
if ((context[i] != null) &&  (!v.contains(context[i])))
v.add(context[i]);
}
if (!v.isEmpty()) {
this.context = new ProtectionDomain[v.size()];
this.context = v.toArray(this.context);
}
}
}
public AccessControlContext(AccessControlContext acc,
@SuppressWarnings("removal") DomainCombiner combiner) {
this(acc, combiner, false);
}
AccessControlContext(AccessControlContext acc,
@SuppressWarnings("removal") DomainCombiner combiner,
boolean preauthorized) {
if (!preauthorized) {
@SuppressWarnings("removal")
SecurityManager sm = System.getSecurityManager();
if (sm != null) {
sm.checkPermission(SecurityConstants.CREATE_ACC_PERMISSION);
this.isAuthorized = true;
}
} else {
this.isAuthorized = true;
}
this.context = acc.context;
this.combiner = combiner;
}
AccessControlContext(ProtectionDomain caller, @SuppressWarnings("removal") DomainCombiner combiner,
AccessControlContext parent, AccessControlContext context,
Permission[] perms)
{
ProtectionDomain[] callerPDs = null;
if (caller != null) {
callerPDs = new ProtectionDomain[] { caller };
}
if (context != null) {
if (combiner != null) {
this.context = combiner.combine(callerPDs, context.context);
} else {
this.context = combine(callerPDs, context.context);
}
} else {
if (combiner != null) {
this.context = combiner.combine(callerPDs, null);
} else {
this.context = combine(callerPDs, null);
}
}
this.combiner = combiner;
Permission[] tmp = null;
if (perms != null) {
tmp = new Permission[perms.length];
for (int i=0; i < perms.length; i++) {
if (perms[i] == null) {
throw new NullPointerException("permission can't be null");
}
if (perms[i].getClass() == AllPermission.class) {
parent = null;
}
tmp[i] = FilePermCompat.newPermPlusAltPath(perms[i]);
}
}
if (parent != null) {
this.limitedContext = combine(parent.context, parent.limitedContext);
this.isLimited = true;
this.isWrapped = true;
this.permissions = tmp;
this.parent = parent;
this.privilegedContext = context;         }
this.isAuthorized = true;
}
AccessControlContext(ProtectionDomain[] context,
boolean isPrivileged)
{
this.context = context;
this.isPrivileged = isPrivileged;
this.isAuthorized = true;
}
AccessControlContext(ProtectionDomain[] context,
AccessControlContext privilegedContext)
{
this.context = context;
this.privilegedContext = privilegedContext;
this.isPrivileged = true;
}
ProtectionDomain[] getContext() {
return context;
}
boolean isPrivileged()
{
return isPrivileged;
}
@SuppressWarnings("removal")
DomainCombiner getAssignedCombiner() {
AccessControlContext acc;
if (isPrivileged) {
acc = privilegedContext;
} else {
acc = AccessController.getInheritedAccessControlContext();
}
if (acc != null) {
return acc.combiner;
}
return null;
}
@SuppressWarnings("removal")
public DomainCombiner getDomainCombiner() {
SecurityManager sm = System.getSecurityManager();
if (sm != null) {
sm.checkPermission(SecurityConstants.GET_COMBINER_PERMISSION);
}
return getCombiner();
}
@SuppressWarnings("removal")
DomainCombiner getCombiner() {
return combiner;
}
boolean isAuthorized() {
return isAuthorized;
}
@SuppressWarnings("removal")
public void checkPermission(Permission perm)
throws AccessControlException
{
boolean dumpDebug = false;
if (perm == null) {
throw new NullPointerException("permission can't be null");
}
if (getDebug() != null) {
dumpDebug = !Debug.isOn("codebase=");
if (!dumpDebug) {
for (int i = 0; context != null && i < context.length; i++) {
if (context[i].getCodeSource() != null &&
context[i].getCodeSource().getLocation() != null &&
Debug.isOn("codebase=" + context[i].getCodeSource().getLocation().toString())) {
dumpDebug = true;
break;
}
}
}
dumpDebug &= !Debug.isOn("permission=") ||
Debug.isOn("permission=" + perm.getClass().getCanonicalName());
if (dumpDebug && Debug.isOn("stack")) {
Thread.dumpStack();
}
if (dumpDebug && Debug.isOn("domain")) {
if (context == null) {
debug.println("domain (context is null)");
} else {
for (int i=0; i< context.length; i++) {
debug.println("domain "+i+" "+context[i]);
}
}
}
}
if (context == null) {
checkPermission2(perm);
return;
}
for (int i=0; i< context.length; i++) {
if (context[i] != null && !context[i].impliesWithAltFilePerm(perm)) {
if (dumpDebug) {
debug.println("access denied " + perm);
}
if (Debug.isOn("failure") && debug != null) {
if (!dumpDebug) {
debug.println("access denied " + perm);
}
Thread.dumpStack();
final ProtectionDomain pd = context[i];
final Debug db = debug;
AccessController.doPrivileged (new PrivilegedAction<>() {
public Void run() {
db.println("domain that failed "+pd);
return null;
}
});
}
throw new AccessControlException("access denied "+perm, perm);
}
}
if (dumpDebug) {
debug.println("access allowed "+perm);
}
checkPermission2(perm);
}
private void checkPermission2(Permission perm) {
if (!isLimited) {
return;
}
if (privilegedContext != null) {
privilegedContext.checkPermission2(perm);
}
if (isWrapped) {
return;
}
if (permissions != null) {
Class<?> permClass = perm.getClass();
for (int i=0; i < permissions.length; i++) {
Permission limit = permissions[i];
if (limit.getClass().equals(permClass) && limit.implies(perm)) {
return;
}
}
}
if (parent != null) {
if (permissions == null) {
parent.checkPermission2(perm);
} else {
parent.checkPermission(perm);
}
}
}
@SuppressWarnings("removal")
AccessControlContext optimize() {
AccessControlContext acc;
DomainCombiner combiner = null;
AccessControlContext parent = null;
Permission[] permissions = null;
if (isPrivileged) {
acc = privilegedContext;
if (acc != null) {
if (acc.isWrapped) {
permissions = acc.permissions;
parent = acc.parent;
}
}
} else {
acc = AccessController.getInheritedAccessControlContext();
if (acc != null) {
if (acc.isLimited) {
parent = acc;
}
}
}
boolean skipStack = (context == null);
boolean skipAssigned = (acc == null || acc.context == null);
ProtectionDomain[] assigned = (skipAssigned) ? null : acc.context;
ProtectionDomain[] pd;
boolean skipLimited = ((acc == null || !acc.isWrapped) && parent == null);
if (acc != null && acc.combiner != null) {
if (getDebug() != null) {
debug.println("AccessControlContext invoking the Combiner");
}
combiner = acc.combiner;
pd = combiner.combine(context, assigned);
} else {
if (skipStack) {
if (skipAssigned) {
calculateFields(acc, parent, permissions);
return this;
} else if (skipLimited) {
return acc;
}
} else if (assigned != null) {
if (skipLimited) {
if (context.length == 1 && context[0] == assigned[0]) {
return acc;
}
}
}
pd = combine(context, assigned);
if (skipLimited && !skipAssigned && pd == assigned) {
return acc;
} else if (skipAssigned && pd == context) {
calculateFields(acc, parent, permissions);
return this;
}
}
this.context = pd;
this.combiner = combiner;
this.isPrivileged = false;
calculateFields(acc, parent, permissions);
return this;
}
private static ProtectionDomain[] combine(ProtectionDomain[] current,
ProtectionDomain[] assigned) {
boolean skipStack = (current == null);
boolean skipAssigned = (assigned == null);
int slen = (skipStack) ? 0 : current.length;
if (skipAssigned && slen <= 2) {
return current;
}
int n = (skipAssigned) ? 0 : assigned.length;
ProtectionDomain[] pd = new ProtectionDomain[slen + n];
if (!skipAssigned) {
System.arraycopy(assigned, 0, pd, 0, n);
}
outer:
for (int i = 0; i < slen; i++) {
ProtectionDomain sd = current[i];
if (sd != null) {
for (int j = 0; j < n; j++) {
if (sd == pd[j]) {
continue outer;
}
}
pd[n++] = sd;
}
}
if (n != pd.length) {
if (!skipAssigned && n == assigned.length) {
return assigned;
} else if (skipAssigned && n == slen) {
return current;
}
ProtectionDomain[] tmp = new ProtectionDomain[n];
System.arraycopy(pd, 0, tmp, 0, n);
pd = tmp;
}
return pd;
}
private void calculateFields(AccessControlContext assigned,
AccessControlContext parent, Permission[] permissions)
{
ProtectionDomain[] parentLimit = null;
ProtectionDomain[] assignedLimit = null;
ProtectionDomain[] newLimit;
parentLimit = (parent != null)? parent.limitedContext: null;
assignedLimit = (assigned != null)? assigned.limitedContext: null;
newLimit = combine(parentLimit, assignedLimit);
if (newLimit != null) {
if (context == null || !containsAllPDs(newLimit, context)) {
this.limitedContext = newLimit;
this.permissions = permissions;
this.parent = parent;
this.isLimited = true;
}
}
}
public boolean equals(Object obj) {
if (obj == this)
return true;
return obj instanceof AccessControlContext that
&& equalContext(that)
&& equalLimitedContext(that);
}
private boolean equalContext(AccessControlContext that) {
if (!equalPDs(this.context, that.context))
return false;
if (this.combiner == null && that.combiner != null)
return false;
if (this.combiner != null && !this.combiner.equals(that.combiner))
return false;
return true;
}
private boolean equalPDs(ProtectionDomain[] a, ProtectionDomain[] b) {
if (a == null) {
return (b == null);
}
if (b == null)
return false;
if (!(containsAllPDs(a, b) && containsAllPDs(b, a)))
return false;
return true;
}
private boolean equalLimitedContext(AccessControlContext that) {
if (that == null)
return false;
if (!this.isLimited && !that.isLimited)
return true;
if (!(this.isLimited && that.isLimited))
return false;
if ((this.isWrapped && !that.isWrapped) ||
(!this.isWrapped && that.isWrapped)) {
return false;
}
if (this.permissions == null && that.permissions != null)
return false;
if (this.permissions != null && that.permissions == null)
return false;
if (!(this.containsAllLimits(that) && that.containsAllLimits(this)))
return false;
AccessControlContext thisNextPC = getNextPC(this);
AccessControlContext thatNextPC = getNextPC(that);
if (thisNextPC == null && thatNextPC != null && thatNextPC.isLimited)
return false;
if (thisNextPC != null && !thisNextPC.equalLimitedContext(thatNextPC))
return false;
if (this.parent == null && that.parent != null)
return false;
if (this.parent != null && !this.parent.equals(that.parent))
return false;
return true;
}
private static AccessControlContext getNextPC(AccessControlContext acc) {
while (acc != null && acc.privilegedContext != null) {
acc = acc.privilegedContext;
if (!acc.isWrapped)
return acc;
}
return null;
}
private static boolean containsAllPDs(ProtectionDomain[] thisContext,
ProtectionDomain[] thatContext) {
boolean match = false;
ProtectionDomain thisPd;
for (int i = 0; i < thisContext.length; i++) {
match = false;
if ((thisPd = thisContext[i]) == null) {
for (int j = 0; (j < thatContext.length) && !match; j++) {
match = (thatContext[j] == null);
}
} else {
Class<?> thisPdClass = thisPd.getClass();
ProtectionDomain thatPd;
for (int j = 0; (j < thatContext.length) && !match; j++) {
thatPd = thatContext[j];
match = (thatPd != null &&
thisPdClass == thatPd.getClass() && thisPd.equals(thatPd));
}
}
if (!match) return false;
}
return match;
}
private boolean containsAllLimits(AccessControlContext that) {
boolean match = false;
if (this.permissions == null && that.permissions == null)
return true;
for (int i = 0; i < this.permissions.length; i++) {
Permission limit = this.permissions[i];
Class <?> limitClass = limit.getClass();
match = false;
for (int j = 0; (j < that.permissions.length) && !match; j++) {
Permission perm = that.permissions[j];
match = (limitClass.equals(perm.getClass()) &&
limit.equals(perm));
}
if (!match) return false;
}
return match;
}
public int hashCode() {
int hashCode = 0;
if (context == null)
return hashCode;
for (int i =0; i < context.length; i++) {
if (context[i] != null)
hashCode ^= context[i].hashCode();
}
return hashCode;
}
}
package jdk.dynalink.internal;
import java.security.AccessControlContext;
import java.security.Permission;
import java.security.Permissions;
import java.security.ProtectionDomain;
import java.util.stream.Stream;
public final class AccessControlContextFactory {
private AccessControlContextFactory () {
}
@SuppressWarnings("removal")
public static AccessControlContext createAccessControlContext() {
return createAccessControlContext(new Permission[0]);
}
@SuppressWarnings("removal")
public static AccessControlContext createAccessControlContext(final Permission... permissions) {
final Permissions perms = new Permissions();
for(final Permission permission: permissions) {
perms.add(permission);
}
return new AccessControlContext(new ProtectionDomain[] { new ProtectionDomain(null, perms) });
}
@SuppressWarnings("removal")
public static AccessControlContext createAccessControlContext(final String... runtimePermissionNames) {
return createAccessControlContext(makeRuntimePermissions(runtimePermissionNames));
}
private static Permission[] makeRuntimePermissions(final String... runtimePermissionNames) {
return Stream.of(runtimePermissionNames).map(RuntimePermission::new).toArray(Permission[]::new);
}
}
package java.security;
@Deprecated(since="17", forRemoval=true)
public class AccessControlException extends SecurityException {
@java.io.Serial
private static final long serialVersionUID = 5138225684096988535L;
private Permission perm;
public AccessControlException(String s) {
super(s);
}
public AccessControlException(String s, Permission p) {
super(s);
perm = p;
}
public Permission getPermission() {
return perm;
}
}
package java.security;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.ref.Reference;
import jdk.internal.vm.annotation.Hidden;
import sun.security.util.Debug;
import sun.security.util.SecurityConstants;
import jdk.internal.reflect.CallerSensitive;
import jdk.internal.reflect.Reflection;
import jdk.internal.vm.annotation.DontInline;
import jdk.internal.vm.annotation.ForceInline;
import jdk.internal.vm.annotation.ReservedStackAccess;
@Deprecated(since="17", forRemoval=true)
public final class AccessController {
private AccessController() { }
@CallerSensitive
public static <T> T doPrivileged(PrivilegedAction<T> action)
{
return executePrivileged(action, null, Reflection.getCallerClass());
}
@CallerSensitive
public static <T> T doPrivilegedWithCombiner(PrivilegedAction<T> action) {
@SuppressWarnings("removal")
AccessControlContext acc = getStackAccessControlContext();
if (acc == null) {
return AccessController.doPrivileged(action);
}
@SuppressWarnings("removal")
DomainCombiner dc = acc.getAssignedCombiner();
return AccessController.doPrivileged(action,
preserveCombiner(dc, Reflection.getCallerClass()));
}
@CallerSensitive
public static <T> T doPrivileged(PrivilegedAction<T> action,
@SuppressWarnings("removal") AccessControlContext context)
{
Class<?> caller = Reflection.getCallerClass();
context = checkContext(context, caller);
return executePrivileged(action, context, caller);
}
@CallerSensitive
public static <T> T doPrivileged(PrivilegedAction<T> action,
@SuppressWarnings("removal") AccessControlContext context,
Permission... perms) {
@SuppressWarnings("removal")
AccessControlContext parent = getContext();
if (perms == null) {
throw new NullPointerException("null permissions parameter");
}
Class<?> caller = Reflection.getCallerClass();
@SuppressWarnings("removal")
DomainCombiner dc = (context == null) ? null : context.getCombiner();
return AccessController.doPrivileged(action, createWrapper(dc,
caller, parent, context, perms));
}
@CallerSensitive
public static <T> T doPrivilegedWithCombiner(PrivilegedAction<T> action,
@SuppressWarnings("removal") AccessControlContext context,
Permission... perms) {
@SuppressWarnings("removal")
AccessControlContext parent = getContext();
@SuppressWarnings("removal")
DomainCombiner dc = parent.getCombiner();
if (dc == null && context != null) {
dc = context.getCombiner();
}
if (perms == null) {
throw new NullPointerException("null permissions parameter");
}
Class<?> caller = Reflection.getCallerClass();
return AccessController.doPrivileged(action, createWrapper(dc, caller,
parent, context, perms));
}
@CallerSensitive
public static <T> T
doPrivileged(PrivilegedExceptionAction<T> action)
throws PrivilegedActionException
{
@SuppressWarnings("removal")
AccessControlContext context = null;
Class<?> caller = Reflection.getCallerClass();
try {
return executePrivileged(action, context, caller);
} catch (RuntimeException e) {
throw e;
} catch (Exception e) {
throw wrapException(e);
}
}
@CallerSensitive
public static <T> T doPrivilegedWithCombiner(PrivilegedExceptionAction<T> action)
throws PrivilegedActionException
{
@SuppressWarnings("removal")
AccessControlContext acc = getStackAccessControlContext();
if (acc == null) {
return AccessController.doPrivileged(action);
}
@SuppressWarnings("removal")
DomainCombiner dc = acc.getAssignedCombiner();
return AccessController.doPrivileged(action,
preserveCombiner(dc, Reflection.getCallerClass()));
}
@SuppressWarnings("removal")
private static AccessControlContext preserveCombiner(DomainCombiner combiner,
Class<?> caller)
{
return createWrapper(combiner, caller, null, null, null);
}
@SuppressWarnings("removal")
private static AccessControlContext
createWrapper(DomainCombiner combiner, Class<?> caller,
AccessControlContext parent, AccessControlContext context,
Permission[] perms)
{
ProtectionDomain callerPD = getProtectionDomain(caller);
if (System.getSecurityManager() != null &&
context != null && !context.isAuthorized() &&
!callerPD.implies(SecurityConstants.CREATE_ACC_PERMISSION))
{
return getInnocuousAcc();
} else {
return new AccessControlContext(callerPD, combiner, parent,
context, perms);
}
}
private static class AccHolder {
@SuppressWarnings("removal")
static final AccessControlContext innocuousAcc =
new AccessControlContext(new ProtectionDomain[] {
new ProtectionDomain(null, null) });
}
@SuppressWarnings("removal")
private static AccessControlContext getInnocuousAcc() {
return AccHolder.innocuousAcc;
}
private static native ProtectionDomain getProtectionDomain(final Class<?> caller);
@CallerSensitive
public static <T> T
doPrivileged(PrivilegedExceptionAction<T> action,
@SuppressWarnings("removal") AccessControlContext context)
throws PrivilegedActionException
{
Class<?> caller = Reflection.getCallerClass();
context = checkContext(context, caller);
try {
return executePrivileged(action, context, caller);
} catch (RuntimeException e) {
throw e;
} catch (Exception e) {
throw wrapException(e);
}
}
@SuppressWarnings("removal")
private static AccessControlContext checkContext(AccessControlContext context,
Class<?> caller)
{
if (System.getSecurityManager() != null &&
context != null && !context.isAuthorized() &&
context != getInnocuousAcc())
{
ProtectionDomain callerPD = getProtectionDomain(caller);
if (callerPD != null && !callerPD.implies(SecurityConstants.CREATE_ACC_PERMISSION)) {
return getInnocuousAcc();
}
}
return context;
}
@Hidden
private static native void ensureMaterializedForStackWalk(Object o);
private static boolean isPrivileged() {
@SuppressWarnings("removal")
AccessControlContext ctx = getStackAccessControlContext();
return ctx == null || ctx.isPrivileged();
}
@Hidden
@ForceInline
private static <T> T
executePrivileged(PrivilegedAction<T> action,
@SuppressWarnings("removal") AccessControlContext context,
Class<?> caller)
{
if (context != null) {
ensureMaterializedForStackWalk(context);
}
assert isPrivileged();         T result = action.run();
assert isPrivileged();
Reference.reachabilityFence(context);
Reference.reachabilityFence(caller);
return result;
}
@Hidden
@ForceInline
private static <T> T
executePrivileged(PrivilegedExceptionAction<T> action,
@SuppressWarnings("removal") AccessControlContext context,
Class<?> caller)
throws Exception
{
if (context != null) {
ensureMaterializedForStackWalk(context);
}
assert isPrivileged();         T result = action.run();
assert isPrivileged();
Reference.reachabilityFence(context);
Reference.reachabilityFence(caller);
return result;
}
@Hidden
@ForceInline
@ReservedStackAccess
private static PrivilegedActionException wrapException(Exception e) {
return new PrivilegedActionException(e);
}
@CallerSensitive
public static <T> T doPrivileged(PrivilegedExceptionAction<T> action,
@SuppressWarnings("removal") AccessControlContext context,
Permission... perms)
throws PrivilegedActionException
{
@SuppressWarnings("removal")
AccessControlContext parent = getContext();
if (perms == null) {
throw new NullPointerException("null permissions parameter");
}
Class<?> caller = Reflection.getCallerClass();
@SuppressWarnings("removal")
DomainCombiner dc = (context == null) ? null : context.getCombiner();
return AccessController.doPrivileged(action, createWrapper(dc, caller, parent, context, perms));
}
@CallerSensitive
public static <T> T doPrivilegedWithCombiner(PrivilegedExceptionAction<T> action,
@SuppressWarnings("removal") AccessControlContext context,
Permission... perms)
throws PrivilegedActionException
{
@SuppressWarnings("removal")
AccessControlContext parent = getContext();
@SuppressWarnings("removal")
DomainCombiner dc = parent.getCombiner();
if (dc == null && context != null) {
dc = context.getCombiner();
}
if (perms == null) {
throw new NullPointerException("null permissions parameter");
}
Class<?> caller = Reflection.getCallerClass();
return AccessController.doPrivileged(action, createWrapper(dc, caller,
parent, context, perms));
}
@SuppressWarnings("removal")
private static native AccessControlContext getStackAccessControlContext();
@SuppressWarnings("removal")
static native AccessControlContext getInheritedAccessControlContext();
@SuppressWarnings("removal")
public static AccessControlContext getContext()
{
AccessControlContext acc = getStackAccessControlContext();
if (acc == null) {
return new AccessControlContext(null, true);
} else {
return acc.optimize();
}
}
@SuppressWarnings("removal")
public static void checkPermission(Permission perm)
throws AccessControlException
{
if (perm == null) {
throw new NullPointerException("permission can't be null");
}
AccessControlContext stack = getStackAccessControlContext();
if (stack == null) {
Debug debug = AccessControlContext.getDebug();
boolean dumpDebug = false;
if (debug != null) {
dumpDebug = !Debug.isOn("codebase=");
dumpDebug &= !Debug.isOn("permission=") ||
Debug.isOn("permission=" + perm.getClass().getCanonicalName());
}
if (dumpDebug && Debug.isOn("stack")) {
Thread.dumpStack();
}
if (dumpDebug && Debug.isOn("domain")) {
debug.println("domain (context is null)");
}
if (dumpDebug) {
debug.println("access allowed "+perm);
}
return;
}
AccessControlContext acc = stack.optimize();
acc.checkPermission(perm);
}
}
package java.nio.file;
public class AccessDeniedException
extends FileSystemException
{
@java.io.Serial
private static final long serialVersionUID = 4943049599949219617L;
public AccessDeniedException(String file) {
super(file);
}
public AccessDeniedException(String file, String other, String reason) {
super(file, other, reason);
}
}
package sun.security.x509;
import java.io.IOException;
import sun.security.util.*;
public final class AccessDescription {
private int myhash = -1;
private ObjectIdentifier accessMethod;
private GeneralName accessLocation;
public static final ObjectIdentifier Ad_OCSP_Id =
ObjectIdentifier.of(KnownOIDs.OCSP);
public static final ObjectIdentifier Ad_CAISSUERS_Id =
ObjectIdentifier.of(KnownOIDs.caIssuers);
public static final ObjectIdentifier Ad_TIMESTAMPING_Id =
ObjectIdentifier.of(KnownOIDs.AD_TimeStamping);
public static final ObjectIdentifier Ad_CAREPOSITORY_Id =
ObjectIdentifier.of(KnownOIDs.caRepository);
public AccessDescription(ObjectIdentifier accessMethod, GeneralName accessLocation) {
this.accessMethod = accessMethod;
this.accessLocation = accessLocation;
}
public AccessDescription(DerValue derValue) throws IOException {
DerInputStream derIn = derValue.getData();
accessMethod = derIn.getOID();
accessLocation = new GeneralName(derIn.getDerValue());
}
public ObjectIdentifier getAccessMethod() {
return accessMethod;
}
public GeneralName getAccessLocation() {
return accessLocation;
}
public void encode(DerOutputStream out) throws IOException {
DerOutputStream tmp = new DerOutputStream();
tmp.putOID(accessMethod);
accessLocation.encode(tmp);
out.write(DerValue.tag_Sequence, tmp);
}
public int hashCode() {
if (myhash == -1) {
myhash = accessMethod.hashCode() + accessLocation.hashCode();
}
return myhash;
}
public boolean equals(Object obj) {
if (!(obj instanceof AccessDescription that)) {
return false;
}
if (this == that) {
return true;
}
return (accessMethod.equals(that.getAccessMethod()) &&
accessLocation.equals(that.getAccessLocation()));
}
public String toString() {
String method = null;
if (accessMethod.equals(Ad_CAISSUERS_Id)) {
method = "caIssuers";
} else if (accessMethod.equals(Ad_CAREPOSITORY_Id)) {
method = "caRepository";
} else if (accessMethod.equals(Ad_TIMESTAMPING_Id)) {
method = "timeStamping";
} else if (accessMethod.equals(Ad_OCSP_Id)) {
method = "ocsp";
} else {
method = accessMethod.toString();
}
return ("\n   accessMethod: " + method +
"\n   accessLocation: " + accessLocation.toString() + "\n");
}
}
package java.rmi;
public class AccessException extends java.rmi.RemoteException {
private static final long serialVersionUID = 6314925228044966088L;
public AccessException(String s) {
super(s);
}
public AccessException(String s, Exception ex) {
super(s, ex);
}
}
package java.lang.reflect;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import static java.util.Map.entry;
@SuppressWarnings("doclint:reference") public enum AccessFlag {
PUBLIC(Modifier.PUBLIC, true,
Set.of(Location.CLASS, Location.FIELD, Location.METHOD,
Location.INNER_CLASS)),
PRIVATE(Modifier.PRIVATE, true, Location.SET_FIELD_METHOD_INNER_CLASS),
PROTECTED(Modifier.PROTECTED, true, Location.SET_FIELD_METHOD_INNER_CLASS),
STATIC(Modifier.STATIC, true, Location.SET_FIELD_METHOD_INNER_CLASS),
FINAL(Modifier.FINAL, true,
Set.of(Location.CLASS, Location.FIELD, Location.METHOD,
Location.INNER_CLASS, Location.METHOD_PARAMETER)),
SUPER(0x0000_0020, false, Location.SET_CLASS),
OPEN(0x0000_0020, false, Set.of(Location.MODULE)),
TRANSITIVE(0x0000_0020, false, Location.SET_MODULE_REQUIRES),
SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD),
STATIC_PHASE(0x0000_0040, false, Location.SET_MODULE_REQUIRES),
VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD),
BRIDGE(Modifier.BRIDGE, false, Location.SET_METHOD),
TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD),
VARARGS(Modifier.VARARGS, false, Location.SET_METHOD),
NATIVE(Modifier.NATIVE, true, Location.SET_METHOD),
INTERFACE(Modifier.INTERFACE, false, Location.SET_CLASS_INNER_CLASS),
ABSTRACT(Modifier.ABSTRACT, true,
Set.of(Location.CLASS, Location.METHOD, Location.INNER_CLASS)),
STRICT(Modifier.STRICT, true, Location.SET_METHOD),
SYNTHETIC(Modifier.SYNTHETIC, false,
Set.of(Location.CLASS, Location.FIELD, Location.METHOD,
Location.INNER_CLASS, Location.METHOD_PARAMETER,
Location.MODULE, Location.MODULE_REQUIRES,
Location.MODULE_EXPORTS, Location.MODULE_OPENS)),
ANNOTATION(Modifier.ANNOTATION, false, Location.SET_CLASS_INNER_CLASS),
ENUM(Modifier.ENUM, false,
Set.of(Location.CLASS, Location.FIELD, Location.INNER_CLASS)),
MANDATED(Modifier.MANDATED, false,
Set.of(Location.METHOD_PARAMETER,
Location.MODULE, Location.MODULE_REQUIRES,
Location.MODULE_EXPORTS, Location.MODULE_OPENS)),
MODULE(0x0000_8000, false, Location.SET_CLASS)
;
private final int mask;
private final boolean sourceModifier;
private final Set<Location> locations;
private AccessFlag(int mask, boolean sourceModifier, Set<Location> locations) {
this.mask = mask;
this.sourceModifier = sourceModifier;
this.locations = locations;
}
public int mask() {
return mask;
}
public boolean sourceModifier() {
return sourceModifier;
}
public Set<Location> locations() {
return locations;
}
public static Set<AccessFlag> maskToAccessFlags(int mask, Location location) {
Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);
for (var accessFlag : LocationToFlags.locationToFlags.get(location)) {
int accessMask = accessFlag.mask();
if ((mask &  accessMask) != 0) {
result.add(accessFlag);
mask = mask & ~accessMask;
}
}
if (mask != 0) {
throw new IllegalArgumentException("Unmatched bit position 0x" +
Integer.toHexString(mask) +
" for location " + location);
}
return Collections.unmodifiableSet(result);
}
public enum Location {
CLASS,
FIELD,
METHOD,
INNER_CLASS,
METHOD_PARAMETER,
MODULE,
MODULE_REQUIRES,
MODULE_EXPORTS,
MODULE_OPENS;
private static final Set<Location> SET_FIELD_METHOD_INNER_CLASS =
Set.of(FIELD, METHOD, INNER_CLASS);
private static final Set<Location> SET_METHOD = Set.of(METHOD);
private static final Set<Location> SET_FIELD = Set.of(FIELD);
private static final Set<Location> SET_CLASS = Set.of(CLASS);
private static final Set<Location> SET_CLASS_INNER_CLASS =
Set.of(CLASS, INNER_CLASS);
private static final Set<Location> SET_MODULE_REQUIRES =
Set.of(MODULE_REQUIRES);
}
private static class LocationToFlags {
private static Map<Location, Set<AccessFlag>> locationToFlags =
Map.ofEntries(entry(Location.CLASS,
Set.of(PUBLIC, FINAL, SUPER,
INTERFACE, ABSTRACT,
SYNTHETIC, ANNOTATION,
ENUM, AccessFlag.MODULE)),
entry(Location.FIELD,
Set.of(PUBLIC, PRIVATE, PROTECTED,
STATIC, FINAL, VOLATILE,
TRANSIENT, SYNTHETIC, ENUM)),
entry(Location.METHOD,
Set.of(PUBLIC, PRIVATE, PROTECTED,
STATIC, FINAL, SYNCHRONIZED,
BRIDGE, VARARGS, NATIVE,
ABSTRACT, STRICT, SYNTHETIC)),
entry(Location.INNER_CLASS,
Set.of(PUBLIC, PRIVATE, PROTECTED,
STATIC, FINAL, INTERFACE, ABSTRACT,
SYNTHETIC, ANNOTATION, ENUM)),
entry(Location.METHOD_PARAMETER,
Set.of(FINAL, SYNTHETIC, MANDATED)),
entry(Location.MODULE,
Set.of(OPEN, SYNTHETIC, MANDATED)),
entry(Location.MODULE_REQUIRES,
Set.of(TRANSITIVE, STATIC_PHASE, SYNTHETIC, MANDATED)),
entry(Location.MODULE_EXPORTS,
Set.of(SYNTHETIC, MANDATED)),
entry(Location.MODULE_OPENS,
Set.of(SYNTHETIC, MANDATED)));
}
}
package com.sun.org.apache.bcel.internal.classfile;
import com.sun.org.apache.bcel.internal.Const;
public abstract class AccessFlags {
private int access_flags;
public AccessFlags() {
}
public AccessFlags(final int a) {
access_flags = a;
}
public final int getAccessFlags() {
return access_flags;
}
public final int getModifiers() {
return access_flags;
}
public final void setAccessFlags(final int access_flags) {
this.access_flags = access_flags;
}
public final void setModifiers(final int access_flags) {
setAccessFlags(access_flags);
}
private void setFlag(final int flag, final boolean set) {
if ((access_flags & flag) != 0) {             if (!set) {
access_flags ^= flag;
}
} else {             if (set) {
access_flags |= flag;
}
}
}
public final void isPublic(final boolean flag) {
setFlag(Const.ACC_PUBLIC, flag);
}
public final boolean isPublic() {
return (access_flags & Const.ACC_PUBLIC) != 0;
}
public final void isPrivate(final boolean flag) {
setFlag(Const.ACC_PRIVATE, flag);
}
public final boolean isPrivate() {
return (access_flags & Const.ACC_PRIVATE) != 0;
}
public final void isProtected(final boolean flag) {
setFlag(Const.ACC_PROTECTED, flag);
}
public final boolean isProtected() {
return (access_flags & Const.ACC_PROTECTED) != 0;
}
public final void isStatic(final boolean flag) {
setFlag(Const.ACC_STATIC, flag);
}
public final boolean isStatic() {
return (access_flags & Const.ACC_STATIC) != 0;
}
public final void isFinal(final boolean flag) {
setFlag(Const.ACC_FINAL, flag);
}
public final boolean isFinal() {
return (access_flags & Const.ACC_FINAL) != 0;
}
public final void isSynchronized(final boolean flag) {
setFlag(Const.ACC_SYNCHRONIZED, flag);
}
public final boolean isSynchronized() {
return (access_flags & Const.ACC_SYNCHRONIZED) != 0;
}
public final void isVolatile(final boolean flag) {
setFlag(Const.ACC_VOLATILE, flag);
}
public final boolean isVolatile() {
return (access_flags & Const.ACC_VOLATILE) != 0;
}
public final void isTransient(final boolean flag) {
setFlag(Const.ACC_TRANSIENT, flag);
}
public final boolean isTransient() {
return (access_flags & Const.ACC_TRANSIENT) != 0;
}
public final void isNative(final boolean flag) {
setFlag(Const.ACC_NATIVE, flag);
}
public final boolean isNative() {
return (access_flags & Const.ACC_NATIVE) != 0;
}
public final void isInterface(final boolean flag) {
setFlag(Const.ACC_INTERFACE, flag);
}
public final boolean isInterface() {
return (access_flags & Const.ACC_INTERFACE) != 0;
}
public final void isAbstract(final boolean flag) {
setFlag(Const.ACC_ABSTRACT, flag);
}
public final boolean isAbstract() {
return (access_flags & Const.ACC_ABSTRACT) != 0;
}
public final void isStrictfp(final boolean flag) {
setFlag(Const.ACC_STRICT, flag);
}
public final boolean isStrictfp() {
return (access_flags & Const.ACC_STRICT) != 0;
}
public final void isSynthetic(final boolean flag) {
setFlag(Const.ACC_SYNTHETIC, flag);
}
public final boolean isSynthetic() {
return (access_flags & Const.ACC_SYNTHETIC) != 0;
}
public final void isAnnotation(final boolean flag) {
setFlag(Const.ACC_ANNOTATION, flag);
}
public final boolean isAnnotation() {
return (access_flags & Const.ACC_ANNOTATION) != 0;
}
public final void isEnum(final boolean flag) {
setFlag(Const.ACC_ENUM, flag);
}
public final boolean isEnum() {
return (access_flags & Const.ACC_ENUM) != 0;
}
public final void isVarArgs(final boolean flag) {
setFlag(Const.ACC_VARARGS, flag);
}
public final boolean isVarArgs() {
return (access_flags & Const.ACC_VARARGS) != 0;
}
}
package com.sun.java.accessibility.util;
import java.beans.*;
import java.awt.*;
import javax.accessibility.*;
public class AccessibilityEventMonitor {
public AccessibilityEventMonitor() {}
protected static final AccessibilityListenerList listenerList =
new AccessibilityListenerList();
private static final AccessibilityEventListener accessibilityListener =
new AccessibilityEventListener();
public static void addPropertyChangeListener(PropertyChangeListener l) {
if (listenerList.getListenerCount(PropertyChangeListener.class) == 0) {
accessibilityListener.installListeners();
}
listenerList.add(PropertyChangeListener.class, l);
}
public static void removePropertyChangeListener(PropertyChangeListener l) {
listenerList.remove(PropertyChangeListener.class, l);
if (listenerList.getListenerCount(PropertyChangeListener.class) == 0) {
accessibilityListener.removeListeners();
}
}
static class AccessibilityEventListener implements TopLevelWindowListener,
PropertyChangeListener {
public AccessibilityEventListener() {
EventQueueMonitor.addTopLevelWindowListener(this);
}
protected void installListeners() {
Window[] topLevelWindows = EventQueueMonitor.getTopLevelWindows();
if (topLevelWindows != null) {
for (int i = 0; i < topLevelWindows.length; i++) {
if (topLevelWindows[i] instanceof Accessible) {
installListeners((Accessible) topLevelWindows[i]);
}
}
}
}
protected void installListeners(Accessible a) {
installListeners(a.getAccessibleContext());
}
private void installListeners(AccessibleContext ac) {
if (ac != null) {
AccessibleStateSet states = ac.getAccessibleStateSet();
if (!states.contains(AccessibleState.TRANSIENT)) {
ac.addPropertyChangeListener(this);
AccessibleStateSet set = ac.getAccessibleStateSet();
if (set.contains(_AccessibleState.MANAGES_DESCENDANTS)) {
return;
}
AccessibleRole role = ac.getAccessibleRole();
if (role == AccessibleRole.LIST ||
role == AccessibleRole.TREE) {
return;
}
if (role == AccessibleRole.TABLE) {
Accessible child = ac.getAccessibleChild(0);
if (child != null) {
AccessibleContext ac2 = child.getAccessibleContext();
if (ac2 != null) {
role = ac2.getAccessibleRole();
if (role != null && role != AccessibleRole.TABLE) {
return;
}
}
}
}
int count = ac.getAccessibleChildrenCount();
for (int i = 0; i < count; i++) {
Accessible child = ac.getAccessibleChild(i);
if (child != null) {
installListeners(child);
}
}
}
}
}
protected void removeListeners() {
Window[] topLevelWindows = EventQueueMonitor.getTopLevelWindows();
if (topLevelWindows != null) {
for (int i = 0; i < topLevelWindows.length; i++) {
if (topLevelWindows[i] instanceof Accessible) {
removeListeners((Accessible) topLevelWindows[i]);
}
}
}
}
protected void removeListeners(Accessible a) {
removeListeners(a.getAccessibleContext());
}
private void removeListeners(AccessibleContext ac) {
if (ac != null) {
AccessibleStateSet states = ac.getAccessibleStateSet();
if (!states.contains(AccessibleState.TRANSIENT)) {
ac.removePropertyChangeListener(this);
if (states.contains(_AccessibleState.MANAGES_DESCENDANTS)) {
return;
}
AccessibleRole role = ac.getAccessibleRole();
if (role == AccessibleRole.LIST ||
role == AccessibleRole.TABLE ||
role == AccessibleRole.TREE) {
return;
}
int count = ac.getAccessibleChildrenCount();
for (int i = 0; i < count; i++) {
Accessible child = ac.getAccessibleChild(i);
if (child != null) {
removeListeners(child);
}
}
}
}
}
public void topLevelWindowCreated(Window w) {
if (w instanceof Accessible) {
installListeners((Accessible) w);
}
}
public void topLevelWindowDestroyed(Window w) {
if (w instanceof Accessible) {
removeListeners((Accessible) w);
}
}
public void propertyChange(PropertyChangeEvent e) {
Object[] listeners =
AccessibilityEventMonitor.listenerList.getListenerList();
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==PropertyChangeListener.class) {
((PropertyChangeListener)listeners[i+1]).propertyChange(e);
}
}
String name = e.getPropertyName();
if (name.equals(AccessibleContext.ACCESSIBLE_CHILD_PROPERTY)) {
Object oldValue = e.getOldValue();
Object newValue = e.getNewValue();
if ((oldValue == null) ^ (newValue == null)) {                     if (oldValue != null) {
if (oldValue instanceof Accessible) {
Accessible a = (Accessible) oldValue;
removeListeners(a.getAccessibleContext());
} else if (oldValue instanceof AccessibleContext) {
removeListeners((AccessibleContext) oldValue);
}
} else if (newValue != null) {
if (newValue instanceof Accessible) {
Accessible a = (Accessible) newValue;
installListeners(a.getAccessibleContext());
} else if (newValue instanceof AccessibleContext) {
installListeners((AccessibleContext) newValue);
}
}
} else {
System.out.println("ERROR in usage of PropertyChangeEvents for: " + e.toString());
}
}
}
}
}
class _AccessibleState extends AccessibleState {
public static final _AccessibleState MANAGES_DESCENDANTS
= new _AccessibleState ("managesDescendants");
protected _AccessibleState(String key) {
super(key);
}
}
package com.sun.java.accessibility.util;
import java.util.*;
import java.beans.*;
import java.awt.*;
import java.awt.event.*;
import javax.accessibility.*;
public class AccessibilityListenerList {
private static final Object[] NULL_ARRAY = new Object[0];
protected transient Object[] listenerList = NULL_ARRAY;
public AccessibilityListenerList() {}
public Object[] getListenerList() {
return listenerList;
}
public int getListenerCount() {
return listenerList.length/2;
}
public int getListenerCount(Class<? extends EventListener> t) {
int count = 0;
Object[] lList = listenerList;
for (int i = 0; i < lList.length; i+=2) {
if (t == (Class)lList[i])
count++;
}
return count;
}
public synchronized void add(Class<? extends EventListener> t, EventListener l) {
if (!t.isInstance(l)) {
throw new IllegalArgumentException("Listener " + l +
" is not of type " + t);
}
if (l ==null) {
throw new IllegalArgumentException("Listener " + l +
" is null");
}
if (listenerList == NULL_ARRAY) {
listenerList = new Object[] { t, l };
} else {
int i = listenerList.length;
Object[] tmp = new Object[i+2];
System.arraycopy(listenerList, 0, tmp, 0, i);
tmp[i] = t;
tmp[i+1] = l;
listenerList = tmp;
}
}
public synchronized void remove(Class<? extends EventListener> t, EventListener l) {
if (!t.isInstance(l)) {
throw new IllegalArgumentException("Listener " + l +
" is not of type " + t);
}
if (l ==null) {
throw new IllegalArgumentException("Listener " + l +
" is null");
}
int index = -1;
for (int i = listenerList.length-2; i>=0; i-=2) {
if ((listenerList[i]==t) && (listenerList[i+1] == l)) {
index = i;
break;
}
}
if (index != -1) {
Object[] tmp = new Object[listenerList.length-2];
System.arraycopy(listenerList, 0, tmp, 0, index);
if (index < tmp.length)
System.arraycopy(listenerList, index+2, tmp, index,
tmp.length - index);
listenerList = (tmp.length == 0) ? NULL_ARRAY : tmp;
}
}
public String toString() {
Object[] lList = listenerList;
String s = "EventListenerList: ";
s += lList.length/2 + " listeners: ";
for (int i = 0 ; i <= lList.length-2 ; i+=2) {
s += " type " + ((Class)lList[i]).getName();
s += " listener " + lList[i+1];
}
return s;
}
}
package javax.accessibility;
public abstract class AccessibilityProvider {
protected AccessibilityProvider() {
this(checkPermission());
}
private AccessibilityProvider(Void ignore) { }
private static Void checkPermission() {
@SuppressWarnings("removal")
SecurityManager sm = System.getSecurityManager();
if (sm != null)
sm.checkPermission(new RuntimePermission("accessibilityProvider"));
return null;
}
public abstract String getName();
public abstract void activate();
}
package javax.accessibility;
public interface Accessible {
public AccessibleContext getAccessibleContext();
}
package javax.accessibility;
public interface AccessibleAction {
public static final String TOGGLE_EXPAND =
new String ("toggleexpand");
public static final String INCREMENT =
new String ("increment");
public static final String DECREMENT =
new String ("decrement");
public static final String CLICK = new String("click");
public static final String TOGGLE_POPUP = new String("toggle popup");
public int getAccessibleActionCount();
public String getAccessibleActionDescription(int i);
public boolean doAccessibleAction(int i);
}
package javax.accessibility;
import javax.swing.text.AttributeSet;
public class AccessibleAttributeSequence {
public int startIndex;
public int endIndex;
public AttributeSet attributes;
public AccessibleAttributeSequence(int start, int end, AttributeSet attr) {
startIndex = start;
endIndex = end;
attributes = attr;
}
};
package javax.accessibility;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import sun.awt.AWTAccessor;
public abstract class AccessibleBundle {
private final String defaultResourceBundleName
= "com.sun.accessibility.internal.resources.accessibility";
static {
AWTAccessor.setAccessibleBundleAccessor(
new AWTAccessor.AccessibleBundleAccessor() {
@Override
public String getKey(AccessibleBundle accessibleBundle) {
return accessibleBundle.key;
}
});
}
public AccessibleBundle() {
}
protected String key = null;
protected String toDisplayString(final String name, final Locale locale) {
try {
return ResourceBundle.getBundle(name, locale).getString(key);
} catch (ClassCastException | MissingResourceException ignored) {
return key;         }
}
public String toDisplayString(Locale locale) {
return toDisplayString(defaultResourceBundleName, locale);
}
public String toDisplayString() {
return toDisplayString(Locale.getDefault());
}
public String toString() {
return toDisplayString();
}
}
package javax.accessibility;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.FocusListener;
public interface AccessibleComponent {
public Color getBackground();
public void setBackground(Color c);
public Color getForeground();
public void setForeground(Color c);
public Cursor getCursor();
public void setCursor(Cursor cursor);
public Font getFont();
public void setFont(Font f);
public FontMetrics getFontMetrics(Font f);
public boolean isEnabled();
public void setEnabled(boolean b);
public boolean isVisible();
public void setVisible(boolean b);
public boolean isShowing();
public boolean contains(Point p);
public Point getLocationOnScreen();
public Point getLocation();
public void setLocation(Point p);
public Rectangle getBounds();
public void setBounds(Rectangle r);
public Dimension getSize();
public void setSize(Dimension d);
public Accessible getAccessibleAt(Point p);
public boolean isFocusTraversable();
public void requestFocus();
public void addFocusListener(FocusListener l);
public void removeFocusListener(FocusListener l);
}
package javax.accessibility;
import java.awt.IllegalComponentStateException;
import java.beans.BeanProperty;
import java.beans.JavaBean;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.util.Locale;
import sun.awt.AWTAccessor;
import sun.awt.AppContext;
@JavaBean(description = "Minimal information that all accessible objects return")
public abstract class AccessibleContext {
protected AccessibleContext() {}
private volatile AppContext targetAppContext;
static {
AWTAccessor.setAccessibleContextAccessor(new AWTAccessor.AccessibleContextAccessor() {
@Override
public void setAppContext(AccessibleContext accessibleContext, AppContext appContext) {
accessibleContext.targetAppContext = appContext;
}
@Override
public AppContext getAppContext(AccessibleContext accessibleContext) {
return accessibleContext.targetAppContext;
}
@Override
public Object getNativeAXResource(AccessibleContext accessibleContext) {
return accessibleContext.nativeAXResource;
}
@Override
public void setNativeAXResource(AccessibleContext accessibleContext, Object value) {
accessibleContext.nativeAXResource = value;
}
});
}
public static final String ACCESSIBLE_NAME_PROPERTY = "AccessibleName";
public static final String ACCESSIBLE_DESCRIPTION_PROPERTY = "AccessibleDescription";
public static final String ACCESSIBLE_STATE_PROPERTY = "AccessibleState";
public static final String ACCESSIBLE_VALUE_PROPERTY = "AccessibleValue";
public static final String ACCESSIBLE_SELECTION_PROPERTY = "AccessibleSelection";
public static final String ACCESSIBLE_CARET_PROPERTY = "AccessibleCaret";
public static final String ACCESSIBLE_VISIBLE_DATA_PROPERTY = "AccessibleVisibleData";
public static final String ACCESSIBLE_CHILD_PROPERTY = "AccessibleChild";
public static final String ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY = "AccessibleActiveDescendant";
public static final String ACCESSIBLE_TABLE_CAPTION_CHANGED =
"accessibleTableCaptionChanged";
public static final String ACCESSIBLE_TABLE_SUMMARY_CHANGED =
"accessibleTableSummaryChanged";
public static final String ACCESSIBLE_TABLE_MODEL_CHANGED =
"accessibleTableModelChanged";
public static final String ACCESSIBLE_TABLE_ROW_HEADER_CHANGED =
"accessibleTableRowHeaderChanged";
public static final String ACCESSIBLE_TABLE_ROW_DESCRIPTION_CHANGED =
"accessibleTableRowDescriptionChanged";
public static final String ACCESSIBLE_TABLE_COLUMN_HEADER_CHANGED =
"accessibleTableColumnHeaderChanged";
public static final String ACCESSIBLE_TABLE_COLUMN_DESCRIPTION_CHANGED =
"accessibleTableColumnDescriptionChanged";
public static final String ACCESSIBLE_ACTION_PROPERTY =
"accessibleActionProperty";
public static final String ACCESSIBLE_HYPERTEXT_OFFSET =
"AccessibleHypertextOffset";
public static final String ACCESSIBLE_TEXT_PROPERTY
= "AccessibleText";
public static final String ACCESSIBLE_INVALIDATE_CHILDREN =
"accessibleInvalidateChildren";
public static final String ACCESSIBLE_TEXT_ATTRIBUTES_CHANGED =
"accessibleTextAttributesChanged";
public static final String ACCESSIBLE_COMPONENT_BOUNDS_CHANGED =
"accessibleComponentBoundsChanged";
protected Accessible accessibleParent = null;
protected String accessibleName = null;
protected String accessibleDescription = null;
private PropertyChangeSupport accessibleChangeSupport = null;
private AccessibleRelationSet relationSet
= new AccessibleRelationSet();
private Object nativeAXResource;
public String getAccessibleName() {
return accessibleName;
}
@BeanProperty(preferred = true, description
= "Sets the accessible name for the component.")
public void setAccessibleName(String s) {
String oldName = accessibleName;
accessibleName = s;
firePropertyChange(ACCESSIBLE_NAME_PROPERTY,oldName,accessibleName);
}
public String getAccessibleDescription() {
return accessibleDescription;
}
@BeanProperty(preferred = true, description
= "Sets the accessible description for the component.")
public void setAccessibleDescription(String s) {
String oldDescription = accessibleDescription;
accessibleDescription = s;
firePropertyChange(ACCESSIBLE_DESCRIPTION_PROPERTY,
oldDescription,accessibleDescription);
}
public abstract AccessibleRole getAccessibleRole();
public abstract AccessibleStateSet getAccessibleStateSet();
public Accessible getAccessibleParent() {
return accessibleParent;
}
public void setAccessibleParent(Accessible a) {
accessibleParent = a;
}
public abstract int getAccessibleIndexInParent();
public abstract int getAccessibleChildrenCount();
public abstract Accessible getAccessibleChild(int i);
public abstract Locale getLocale() throws IllegalComponentStateException;
public void addPropertyChangeListener(PropertyChangeListener listener) {
if (accessibleChangeSupport == null) {
accessibleChangeSupport = new PropertyChangeSupport(this);
}
accessibleChangeSupport.addPropertyChangeListener(listener);
}
public void removePropertyChangeListener(PropertyChangeListener listener) {
if (accessibleChangeSupport != null) {
accessibleChangeSupport.removePropertyChangeListener(listener);
}
}
public AccessibleAction getAccessibleAction() {
return null;
}
public AccessibleComponent getAccessibleComponent() {
return null;
}
public AccessibleSelection getAccessibleSelection() {
return null;
}
public AccessibleText getAccessibleText() {
return null;
}
public AccessibleEditableText getAccessibleEditableText() {
return null;
}
public AccessibleValue getAccessibleValue() {
return null;
}
public AccessibleIcon [] getAccessibleIcon() {
return null;
}
public AccessibleRelationSet getAccessibleRelationSet() {
return relationSet;
}
public AccessibleTable getAccessibleTable() {
return null;
}
public void firePropertyChange(String propertyName,
Object oldValue,
Object newValue) {
if (accessibleChangeSupport != null) {
if (newValue instanceof PropertyChangeEvent) {
PropertyChangeEvent pce = (PropertyChangeEvent)newValue;
accessibleChangeSupport.firePropertyChange(pce);
} else {
accessibleChangeSupport.firePropertyChange(propertyName,
oldValue,
newValue);
}
}
}
}
package javax.accessibility;
import javax.swing.text.AttributeSet;
public interface AccessibleEditableText extends AccessibleText {
public void setTextContents(String s);
public void insertTextAtIndex(int index, String s);
public String getTextRange(int startIndex, int endIndex);
public void delete(int startIndex, int endIndex);
public void cut(int startIndex, int endIndex);
public void paste(int startIndex);
public void replaceText(int startIndex, int endIndex, String s);
public void selectText(int startIndex, int endIndex);
public void setAttributes(int startIndex, int endIndex, AttributeSet as);
}
package javax.accessibility;
public interface AccessibleExtendedComponent extends AccessibleComponent {
public String getToolTipText();
public String getTitledBorderText();
public AccessibleKeyBinding getAccessibleKeyBinding();
}
package javax.accessibility;
public interface AccessibleExtendedTable extends AccessibleTable {
public int getAccessibleRow(int index);
public int getAccessibleColumn(int index);
public int getAccessibleIndex(int r, int c);
}
package javax.accessibility;
import java.awt.Rectangle;
public interface AccessibleExtendedText {
public static final int LINE = 4;
public static final int ATTRIBUTE_RUN = 5;
public String getTextRange(int startIndex, int endIndex);
public AccessibleTextSequence getTextSequenceAt(int part, int index);
public AccessibleTextSequence getTextSequenceAfter(int part, int index);
public AccessibleTextSequence getTextSequenceBefore(int part, int index);
public Rectangle getTextBounds(int startIndex, int endIndex);
}
package javax.swing.text.html;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.util.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.accessibility.*;
import java.text.BreakIterator;
class AccessibleHTML implements Accessible {
private JEditorPane editor;
private Document model;
private DocumentListener docListener;
private PropertyChangeListener propChangeListener;
private ElementInfo rootElementInfo;
private RootHTMLAccessibleContext rootHTMLAccessibleContext;
public AccessibleHTML(JEditorPane pane) {
editor = pane;
propChangeListener = new PropertyChangeHandler();
setDocument(editor.getDocument());
docListener = new DocumentHandler();
}
private void setDocument(Document document) {
if (model != null) {
model.removeDocumentListener(docListener);
}
if (editor != null) {
editor.removePropertyChangeListener(propChangeListener);
}
this.model = document;
if (model != null) {
if (rootElementInfo != null) {
rootElementInfo.invalidate(false);
}
buildInfo();
model.addDocumentListener(docListener);
}
else {
rootElementInfo = null;
}
if (editor != null) {
editor.addPropertyChangeListener(propChangeListener);
}
}
private Document getDocument() {
return model;
}
private JEditorPane getTextComponent() {
return editor;
}
private ElementInfo getRootInfo() {
return rootElementInfo;
}
private View getRootView() {
return getTextComponent().getUI().getRootView(getTextComponent());
}
private Rectangle getRootEditorRect() {
Rectangle alloc = getTextComponent().getBounds();
if ((alloc.width > 0) && (alloc.height > 0)) {
alloc.x = alloc.y = 0;
Insets insets = editor.getInsets();
alloc.x += insets.left;
alloc.y += insets.top;
alloc.width -= insets.left + insets.right;
alloc.height -= insets.top + insets.bottom;
return alloc;
}
return null;
}
private Object lock() {
Document document = getDocument();
if (document instanceof AbstractDocument) {
((AbstractDocument)document).readLock();
return document;
}
return null;
}
private void unlock(Object key) {
if (key != null) {
((AbstractDocument)key).readUnlock();
}
}
private void buildInfo() {
Object lock = lock();
try {
Document doc = getDocument();
Element root = doc.getDefaultRootElement();
rootElementInfo = new ElementInfo(root);
rootElementInfo.validate();
} finally {
unlock(lock);
}
}
ElementInfo createElementInfo(Element e, ElementInfo parent) {
AttributeSet attrs = e.getAttributes();
if (attrs != null) {
Object name = attrs.getAttribute(StyleConstants.NameAttribute);
if (name == HTML.Tag.IMG) {
return new IconElementInfo(e, parent);
}
else if (name == HTML.Tag.CONTENT || name == HTML.Tag.CAPTION) {
return new TextElementInfo(e, parent);
}
else if (name == HTML.Tag.TABLE) {
return new TableElementInfo(e, parent);
}
}
return null;
}
public AccessibleContext getAccessibleContext() {
if (rootHTMLAccessibleContext == null) {
rootHTMLAccessibleContext =
new RootHTMLAccessibleContext(rootElementInfo);
}
return rootHTMLAccessibleContext;
}
private class RootHTMLAccessibleContext extends HTMLAccessibleContext {
public RootHTMLAccessibleContext(ElementInfo elementInfo) {
super(elementInfo);
}
public String getAccessibleName() {
if (model != null) {
return (String)model.getProperty(Document.TitleProperty);
} else {
return null;
}
}
public String getAccessibleDescription() {
return editor.getContentType();
}
public AccessibleRole getAccessibleRole() {
return AccessibleRole.TEXT;
}
}
protected abstract class HTMLAccessibleContext extends AccessibleContext
implements Accessible, AccessibleComponent {
protected ElementInfo elementInfo;
public HTMLAccessibleContext(ElementInfo elementInfo) {
this.elementInfo = elementInfo;
}
public AccessibleContext getAccessibleContext() {
return this;
}
public AccessibleStateSet getAccessibleStateSet() {
AccessibleStateSet states = new AccessibleStateSet();
JTextComponent comp = getTextComponent();
if (comp.isEnabled()) {
states.add(AccessibleState.ENABLED);
}
if (comp.isEditable()) {
states.add(AccessibleState.EDITABLE);
states.add(AccessibleState.FOCUSABLE);
}
if (comp.isVisible()) {
states.add(AccessibleState.VISIBLE);
}
if (comp.isShowing()) {
states.add(AccessibleState.SHOWING);
}
return states;
}
public int getAccessibleIndexInParent() {
return elementInfo.getIndexInParent();
}
public int getAccessibleChildrenCount() {
return elementInfo.getChildCount();
}
public Accessible getAccessibleChild(int i) {
ElementInfo childInfo = elementInfo.getChild(i);
if (childInfo instanceof Accessible accessibleChild) {
return accessibleChild;
} else {
return null;
}
}
public Locale getLocale() throws IllegalComponentStateException {
return editor.getLocale();
}
public AccessibleComponent getAccessibleComponent() {
return this;
}
public Color getBackground() {
return getTextComponent().getBackground();
}
public void setBackground(Color c) {
getTextComponent().setBackground(c);
}
public Color getForeground() {
return getTextComponent().getForeground();
}
public void setForeground(Color c) {
getTextComponent().setForeground(c);
}
public Cursor getCursor() {
return getTextComponent().getCursor();
}
public void setCursor(Cursor cursor) {
getTextComponent().setCursor(cursor);
}
public Font getFont() {
return getTextComponent().getFont();
}
public void setFont(Font f) {
getTextComponent().setFont(f);
}
public FontMetrics getFontMetrics(Font f) {
return getTextComponent().getFontMetrics(f);
}
public boolean isEnabled() {
return getTextComponent().isEnabled();
}
public void setEnabled(boolean b) {
getTextComponent().setEnabled(b);
}
public boolean isVisible() {
return getTextComponent().isVisible();
}
public void setVisible(boolean b) {
getTextComponent().setVisible(b);
}
public boolean isShowing() {
return getTextComponent().isShowing();
}
public boolean contains(Point p) {
Rectangle r = getBounds();
if (r != null) {
return r.contains(p.x, p.y);
} else {
return false;
}
}
public Point getLocationOnScreen() {
Point editorLocation = getTextComponent().getLocationOnScreen();
Rectangle r = getBounds();
if (r != null) {
return new Point(editorLocation.x + r.x,
editorLocation.y + r.y);
} else {
return null;
}
}
public Point getLocation() {
Rectangle r = getBounds();
if (r != null) {
return new Point(r.x, r.y);
} else {
return null;
}
}
public void setLocation(Point p) {
}
public Rectangle getBounds() {
return elementInfo.getBounds();
}
public void setBounds(Rectangle r) {
}
public Dimension getSize() {
Rectangle r = getBounds();
if (r != null) {
return new Dimension(r.width, r.height);
} else {
return null;
}
}
public void setSize(Dimension d) {
Component comp = getTextComponent();
comp.setSize(d);
}
public Accessible getAccessibleAt(Point p) {
ElementInfo innerMostElement = getElementInfoAt(rootElementInfo, p);
if (innerMostElement instanceof Accessible) {
return (Accessible)innerMostElement;
} else {
return null;
}
}
private ElementInfo getElementInfoAt(ElementInfo elementInfo, Point p) {
if (elementInfo.getBounds() == null) {
return null;
}
if (elementInfo.getChildCount() == 0 &&
elementInfo.getBounds().contains(p)) {
return elementInfo;
} else {
if (elementInfo instanceof TableElementInfo) {
ElementInfo captionInfo =
((TableElementInfo)elementInfo).getCaptionInfo();
if (captionInfo != null) {
Rectangle bounds = captionInfo.getBounds();
if (bounds != null && bounds.contains(p)) {
return captionInfo;
}
}
}
for (int i = 0; i < elementInfo.getChildCount(); i++)
{
ElementInfo childInfo = elementInfo.getChild(i);
ElementInfo retValue = getElementInfoAt(childInfo, p);
if (retValue != null) {
return retValue;
}
}
}
return null;
}
public boolean isFocusTraversable() {
JTextComponent comp = getTextComponent();
if (comp != null && comp.isEditable()) {
return true;
}
return false;
}
public void requestFocus() {
if (! isFocusTraversable()) {
return;
}
JTextComponent comp = getTextComponent();
if (comp != null) {
comp.requestFocusInWindow();
try {
if (elementInfo.validateIfNecessary()) {
Element elem = elementInfo.getElement();
comp.setCaretPosition(elem.getStartOffset());
AccessibleContext ac = editor.getAccessibleContext();
PropertyChangeEvent pce = new PropertyChangeEvent(this,
AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
null, AccessibleState.FOCUSED);
ac.firePropertyChange(
AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
null, pce);
}
} catch (IllegalArgumentException e) {
}
}
}
public void addFocusListener(FocusListener l) {
getTextComponent().addFocusListener(l);
}
public void removeFocusListener(FocusListener l) {
getTextComponent().removeFocusListener(l);
}
}
class TextElementInfo extends ElementInfo implements Accessible {
TextElementInfo(Element element, ElementInfo parent) {
super(element, parent);
}
private AccessibleContext accessibleContext;
public AccessibleContext getAccessibleContext() {
if (accessibleContext == null) {
accessibleContext = new TextAccessibleContext(this);
}
return accessibleContext;
}
public class TextAccessibleContext extends HTMLAccessibleContext
implements AccessibleText {
public TextAccessibleContext(ElementInfo elementInfo) {
super(elementInfo);
}
public AccessibleText getAccessibleText() {
return this;
}
public String getAccessibleName() {
if (model != null) {
return (String)model.getProperty(Document.TitleProperty);
} else {
return null;
}
}
public String getAccessibleDescription() {
return editor.getContentType();
}
public AccessibleRole getAccessibleRole() {
return AccessibleRole.TEXT;
}
@SuppressWarnings("deprecation")
public int getIndexAtPoint(Point p) {
View v = getView();
if (v != null) {
return v.viewToModel(p.x, p.y, getBounds());
} else {
return -1;
}
}
@SuppressWarnings("deprecation")
public Rectangle getCharacterBounds(int i) {
try {
return editor.getUI().modelToView(editor, i);
} catch (BadLocationException e) {
return null;
}
}
public int getCharCount() {
if (validateIfNecessary()) {
Element elem = elementInfo.getElement();
return elem.getEndOffset() - elem.getStartOffset();
}
return 0;
}
public int getCaretPosition() {
View v = getView();
if (v == null) {
return -1;
}
Container c = v.getContainer();
if (c == null) {
return -1;
}
if (c instanceof JTextComponent) {
return ((JTextComponent)c).getCaretPosition();
} else {
return -1;
}
}
private class IndexedSegment extends Segment {
public int modelOffset;
}
public String getAtIndex(int part, int index) {
return getAtIndex(part, index, 0);
}
public String getAfterIndex(int part, int index) {
return getAtIndex(part, index, 1);
}
public String getBeforeIndex(int part, int index) {
return getAtIndex(part, index, -1);
}
private String getAtIndex(int part, int index, int direction) {
if (model instanceof AbstractDocument) {
((AbstractDocument)model).readLock();
}
try {
if (index < 0 || index >= model.getLength()) {
return null;
}
switch (part) {
case AccessibleText.CHARACTER:
if (index + direction < model.getLength() &&
index + direction >= 0) {
return model.getText(index + direction, 1);
}
break;
case AccessibleText.WORD:
case AccessibleText.SENTENCE:
IndexedSegment seg = getSegmentAt(part, index);
if (seg != null) {
if (direction != 0) {
int next;
if (direction < 0) {
next = seg.modelOffset - 1;
}
else {
next = seg.modelOffset + direction * seg.count;
}
if (next >= 0 && next <= model.getLength()) {
seg = getSegmentAt(part, next);
}
else {
seg = null;
}
}
if (seg != null) {
return new String(seg.array, seg.offset,
seg.count);
}
}
break;
default:
break;
}
} catch (BadLocationException e) {
} finally {
if (model instanceof AbstractDocument) {
((AbstractDocument)model).readUnlock();
}
}
return null;
}
private Element getParagraphElement(int index) {
if (model instanceof PlainDocument ) {
PlainDocument sdoc = (PlainDocument)model;
return sdoc.getParagraphElement(index);
} else if (model instanceof StyledDocument) {
StyledDocument sdoc = (StyledDocument)model;
return sdoc.getParagraphElement(index);
} else {
Element para;
for (para = model.getDefaultRootElement(); ! para.isLeaf(); ) {
int pos = para.getElementIndex(index);
para = para.getElement(pos);
}
if (para == null) {
return null;
}
return para.getParentElement();
}
}
private IndexedSegment getParagraphElementText(int index)
throws BadLocationException {
Element para = getParagraphElement(index);
if (para != null) {
IndexedSegment segment = new IndexedSegment();
try {
int length = para.getEndOffset() - para.getStartOffset();
model.getText(para.getStartOffset(), length, segment);
} catch (BadLocationException e) {
return null;
}
segment.modelOffset = para.getStartOffset();
return segment;
}
return null;
}
private IndexedSegment getSegmentAt(int part, int index)
throws BadLocationException {
IndexedSegment seg = getParagraphElementText(index);
if (seg == null) {
return null;
}
BreakIterator iterator;
switch (part) {
case AccessibleText.WORD:
iterator = BreakIterator.getWordInstance(getLocale());
break;
case AccessibleText.SENTENCE:
iterator = BreakIterator.getSentenceInstance(getLocale());
break;
default:
return null;
}
seg.first();
iterator.setText(seg);
int end = iterator.following(index - seg.modelOffset + seg.offset);
if (end == BreakIterator.DONE) {
return null;
}
if (end > seg.offset + seg.count) {
return null;
}
int begin = iterator.previous();
if (begin == BreakIterator.DONE ||
begin >= seg.offset + seg.count) {
return null;
}
seg.modelOffset = seg.modelOffset + begin - seg.offset;
seg.offset = begin;
seg.count = end - begin;
return seg;
}
public AttributeSet getCharacterAttribute(int i) {
if (model instanceof StyledDocument) {
StyledDocument doc = (StyledDocument)model;
Element elem = doc.getCharacterElement(i);
if (elem != null) {
return elem.getAttributes();
}
}
return null;
}
public int getSelectionStart() {
return editor.getSelectionStart();
}
public int getSelectionEnd() {
return editor.getSelectionEnd();
}
public String getSelectedText() {
return editor.getSelectedText();
}
private String getText(int offset, int length)
throws BadLocationException {
if (model instanceof StyledDocument doc) {
return doc.getText(offset, length);
} else {
return null;
}
}
}
}
private class IconElementInfo extends ElementInfo implements Accessible {
private int width = -1;
private int height = -1;
IconElementInfo(Element element, ElementInfo parent) {
super(element, parent);
}
protected void invalidate(boolean first) {
super.invalidate(first);
width = height = -1;
}
private int getImageSize(Object key) {
if (validateIfNecessary()) {
int size = getIntAttr(getAttributes(), key, -1);
if (size == -1) {
View v = getView();
size = 0;
if (v instanceof ImageView) {
Image img = ((ImageView)v).getImage();
if (img != null) {
if (key == HTML.Attribute.WIDTH) {
size = img.getWidth(null);
}
else {
size = img.getHeight(null);
}
}
}
}
return size;
}
return 0;
}
private AccessibleContext accessibleContext;
public AccessibleContext getAccessibleContext() {
if (accessibleContext == null) {
accessibleContext = new IconAccessibleContext(this);
}
return accessibleContext;
}
protected class IconAccessibleContext extends HTMLAccessibleContext
implements AccessibleIcon  {
public IconAccessibleContext(ElementInfo elementInfo) {
super(elementInfo);
}
public String getAccessibleName() {
return getAccessibleIconDescription();
}
public String getAccessibleDescription() {
return editor.getContentType();
}
public AccessibleRole getAccessibleRole() {
return AccessibleRole.ICON;
}
public AccessibleIcon [] getAccessibleIcon() {
AccessibleIcon [] icons = new AccessibleIcon[1];
icons[0] = this;
return icons;
}
public String getAccessibleIconDescription() {
return ((ImageView)getView()).getAltText();
}
public void setAccessibleIconDescription(String description) {
}
public int getAccessibleIconWidth() {
if (width == -1) {
width = getImageSize(HTML.Attribute.WIDTH);
}
return width;
}
public int getAccessibleIconHeight() {
if (height == -1) {
height = getImageSize(HTML.Attribute.HEIGHT);
}
return height;
}
}
}
private class TableElementInfo extends ElementInfo
implements Accessible {
protected ElementInfo caption;
private TableCellElementInfo[][] grid;
TableElementInfo(Element e, ElementInfo parent) {
super(e, parent);
}
public ElementInfo getCaptionInfo() {
return caption;
}
protected void validate() {
super.validate();
updateGrid();
}
protected void loadChildren(Element e) {
for (int counter = 0; counter < e.getElementCount(); counter++) {
Element child = e.getElement(counter);
AttributeSet attrs = child.getAttributes();
if (attrs.getAttribute(StyleConstants.NameAttribute) ==
HTML.Tag.TR) {
addChild(new TableRowElementInfo(child, this, counter));
} else if (attrs.getAttribute(StyleConstants.NameAttribute) ==
HTML.Tag.CAPTION) {
caption = createElementInfo(child, this);
}
}
}
private void updateGrid() {
int delta = 0;
int maxCols = 0;
int rows;
for (int counter = 0; counter < getChildCount(); counter++) {
TableRowElementInfo row = getRow(counter);
int prev = 0;
for (int y = 0; y < delta; y++) {
prev = Math.max(prev, getRow(counter - y - 1).
getColumnCount(y + 2));
}
delta = Math.max(row.getRowCount(), delta);
delta--;
maxCols = Math.max(maxCols, row.getColumnCount() + prev);
}
rows = getChildCount() + delta;
grid = new TableCellElementInfo[rows][];
for (int counter = 0; counter < rows; counter++) {
grid[counter] = new TableCellElementInfo[maxCols];
}
for (int counter = 0; counter < rows; counter++) {
getRow(counter).updateGrid(counter);
}
}
public TableRowElementInfo getRow(int index) {
return (TableRowElementInfo)getChild(index);
}
public TableCellElementInfo getCell(int r, int c) {
if (validateIfNecessary() && r < grid.length &&
c < grid[0].length) {
return grid[r][c];
}
return null;
}
public int getRowExtentAt(int r, int c) {
TableCellElementInfo cell = getCell(r, c);
if (cell != null) {
int rows = cell.getRowCount();
int delta = 1;
while ((r - delta) >= 0 && grid[r - delta][c] == cell) {
delta++;
}
return rows - delta + 1;
}
return 0;
}
public int getColumnExtentAt(int r, int c) {
TableCellElementInfo cell = getCell(r, c);
if (cell != null) {
int cols = cell.getColumnCount();
int delta = 1;
while ((c - delta) >= 0 && grid[r][c - delta] == cell) {
delta++;
}
return cols - delta + 1;
}
return 0;
}
public int getRowCount() {
if (validateIfNecessary()) {
return grid.length;
}
return 0;
}
public int getColumnCount() {
if (validateIfNecessary() && grid.length > 0) {
return grid[0].length;
}
return 0;
}
private AccessibleContext accessibleContext;
public AccessibleContext getAccessibleContext() {
if (accessibleContext == null) {
accessibleContext = new TableAccessibleContext(this);
}
return accessibleContext;
}
public class TableAccessibleContext extends HTMLAccessibleContext
implements AccessibleTable {
private AccessibleHeadersTable rowHeadersTable;
public TableAccessibleContext(ElementInfo elementInfo) {
super(elementInfo);
}
public String getAccessibleName() {
return getAccessibleRole().toString();
}
public String getAccessibleDescription() {
return editor.getContentType();
}
public AccessibleRole getAccessibleRole() {
return AccessibleRole.TABLE;
}
public int getAccessibleIndexInParent() {
return elementInfo.getIndexInParent();
}
public int getAccessibleChildrenCount() {
return ((TableElementInfo)elementInfo).getRowCount() *
((TableElementInfo)elementInfo).getColumnCount();
}
public Accessible getAccessibleChild(int i) {
int rowCount = ((TableElementInfo)elementInfo).getRowCount();
int columnCount = ((TableElementInfo)elementInfo).getColumnCount();
int r = i / rowCount;
int c = i % columnCount;
if (r < 0 || r >= rowCount || c < 0 || c >= columnCount) {
return null;
} else {
return getAccessibleAt(r, c);
}
}
public AccessibleTable getAccessibleTable() {
return this;
}
public Accessible getAccessibleCaption() {
ElementInfo captionInfo = getCaptionInfo();
if (captionInfo instanceof Accessible) {
return (Accessible)caption;
} else {
return null;
}
}
public void setAccessibleCaption(Accessible a) {
}
public Accessible getAccessibleSummary() {
return null;
}
public void setAccessibleSummary(Accessible a) {
}
public int getAccessibleRowCount() {
return ((TableElementInfo)elementInfo).getRowCount();
}
public int getAccessibleColumnCount() {
return ((TableElementInfo)elementInfo).getColumnCount();
}
public Accessible getAccessibleAt(int r, int c) {
TableCellElementInfo cellInfo = getCell(r, c);
if (cellInfo != null) {
return cellInfo.getAccessible();
} else {
return null;
}
}
public int getAccessibleRowExtentAt(int r, int c) {
return ((TableElementInfo)elementInfo).getRowExtentAt(r, c);
}
public int getAccessibleColumnExtentAt(int r, int c) {
return ((TableElementInfo)elementInfo).getColumnExtentAt(r, c);
}
public AccessibleTable getAccessibleRowHeader() {
return rowHeadersTable;
}
public void setAccessibleRowHeader(AccessibleTable table) {
}
public AccessibleTable getAccessibleColumnHeader() {
return null;
}
public void setAccessibleColumnHeader(AccessibleTable table) {
}
public Accessible getAccessibleRowDescription(int r) {
return null;
}
public void setAccessibleRowDescription(int r, Accessible a) {
}
public Accessible getAccessibleColumnDescription(int c) {
return null;
}
public void setAccessibleColumnDescription(int c, Accessible a) {
}
public boolean isAccessibleSelected(int r, int c) {
if (validateIfNecessary()) {
if (r < 0 || r >= getAccessibleRowCount() ||
c < 0 || c >= getAccessibleColumnCount()) {
return false;
}
TableCellElementInfo cell = getCell(r, c);
if (cell != null) {
Element elem = cell.getElement();
int start = elem.getStartOffset();
int end = elem.getEndOffset();
return start >= editor.getSelectionStart() &&
end <= editor.getSelectionEnd();
}
}
return false;
}
public boolean isAccessibleRowSelected(int r) {
if (validateIfNecessary()) {
if (r < 0 || r >= getAccessibleRowCount()) {
return false;
}
int nColumns = getAccessibleColumnCount();
TableCellElementInfo startCell = getCell(r, 0);
if (startCell == null) {
return false;
}
int start = startCell.getElement().getStartOffset();
TableCellElementInfo endCell = getCell(r, nColumns-1);
if (endCell == null) {
return false;
}
int end = endCell.getElement().getEndOffset();
return start >= editor.getSelectionStart() &&
end <= editor.getSelectionEnd();
}
return false;
}
public boolean isAccessibleColumnSelected(int c) {
if (validateIfNecessary()) {
if (c < 0 || c >= getAccessibleColumnCount()) {
return false;
}
int nRows = getAccessibleRowCount();
TableCellElementInfo startCell = getCell(0, c);
if (startCell == null) {
return false;
}
int start = startCell.getElement().getStartOffset();
TableCellElementInfo endCell = getCell(nRows-1, c);
if (endCell == null) {
return false;
}
int end = endCell.getElement().getEndOffset();
return start >= editor.getSelectionStart() &&
end <= editor.getSelectionEnd();
}
return false;
}
public int [] getSelectedAccessibleRows() {
if (validateIfNecessary()) {
int nRows = getAccessibleRowCount();
ArrayList<Integer> vec = new ArrayList<Integer>();
for (int i = 0; i < nRows; i++) {
if (isAccessibleRowSelected(i)) {
vec.add(Integer.valueOf(i));
}
}
int[] retval = new int[vec.size()];
for (int i = 0; i < retval.length; i++) {
retval[i] = vec.get(i).intValue();
}
return retval;
}
return new int[0];
}
public int [] getSelectedAccessibleColumns() {
if (validateIfNecessary()) {
int nColumns = getAccessibleRowCount();
ArrayList<Integer> vec = new ArrayList<Integer>();
for (int i = 0; i < nColumns; i++) {
if (isAccessibleColumnSelected(i)) {
vec.add(Integer.valueOf(i));
}
}
int[] retval = new int[vec.size()];
for (int i = 0; i < retval.length; i++) {
retval[i] = vec.get(i).intValue();
}
return retval;
}
return new int[0];
}
public int getAccessibleRow(int index) {
if (validateIfNecessary()) {
int numCells = getAccessibleColumnCount() *
getAccessibleRowCount();
if (index >= numCells) {
return -1;
} else {
return index / getAccessibleColumnCount();
}
}
return -1;
}
public int getAccessibleColumn(int index) {
if (validateIfNecessary()) {
int numCells = getAccessibleColumnCount() *
getAccessibleRowCount();
if (index >= numCells) {
return -1;
} else {
return index % getAccessibleColumnCount();
}
}
return -1;
}
public int getAccessibleIndex(int r, int c) {
if (validateIfNecessary()) {
if (r >= getAccessibleRowCount() ||
c >= getAccessibleColumnCount()) {
return -1;
} else {
return r * getAccessibleColumnCount() + c;
}
}
return -1;
}
public String getAccessibleRowHeader(int r) {
if (validateIfNecessary()) {
TableCellElementInfo cellInfo = getCell(r, 0);
if (cellInfo.isHeaderCell()) {
View v = cellInfo.getView();
if (v != null && model != null) {
try {
return model.getText(v.getStartOffset(),
v.getEndOffset() -
v.getStartOffset());
} catch (BadLocationException e) {
return null;
}
}
}
}
return null;
}
public String getAccessibleColumnHeader(int c) {
if (validateIfNecessary()) {
TableCellElementInfo cellInfo = getCell(0, c);
if (cellInfo.isHeaderCell()) {
View v = cellInfo.getView();
if (v != null && model != null) {
try {
return model.getText(v.getStartOffset(),
v.getEndOffset() -
v.getStartOffset());
} catch (BadLocationException e) {
return null;
}
}
}
}
return null;
}
public void addRowHeader(TableCellElementInfo cellInfo, int rowNumber) {
if (rowHeadersTable == null) {
rowHeadersTable = new AccessibleHeadersTable();
}
rowHeadersTable.addHeader(cellInfo, rowNumber);
}
protected class AccessibleHeadersTable implements AccessibleTable {
private Hashtable<Integer, ArrayList<TableCellElementInfo>> headers =
new Hashtable<Integer, ArrayList<TableCellElementInfo>>();
private int rowCount = 0;
private int columnCount = 0;
public void addHeader(TableCellElementInfo cellInfo, int rowNumber) {
Integer rowInteger = Integer.valueOf(rowNumber);
ArrayList<TableCellElementInfo> list = headers.get(rowInteger);
if (list == null) {
list = new ArrayList<TableCellElementInfo>();
headers.put(rowInteger, list);
}
list.add(cellInfo);
}
public Accessible getAccessibleCaption() {
return null;
}
public void setAccessibleCaption(Accessible a) {
}
public Accessible getAccessibleSummary() {
return null;
}
public void setAccessibleSummary(Accessible a) {
}
public int getAccessibleRowCount() {
return rowCount;
}
public int getAccessibleColumnCount() {
return columnCount;
}
private TableCellElementInfo getElementInfoAt(int r, int c) {
ArrayList<TableCellElementInfo> list = headers.get(Integer.valueOf(r));
if (list != null) {
return list.get(c);
} else {
return null;
}
}
public Accessible getAccessibleAt(int r, int c) {
ElementInfo elementInfo = getElementInfoAt(r, c);
if (elementInfo instanceof Accessible) {
return (Accessible)elementInfo;
} else {
return null;
}
}
public int getAccessibleRowExtentAt(int r, int c) {
TableCellElementInfo elementInfo = getElementInfoAt(r, c);
if (elementInfo != null) {
return elementInfo.getRowCount();
} else {
return 0;
}
}
public int getAccessibleColumnExtentAt(int r, int c) {
TableCellElementInfo elementInfo = getElementInfoAt(r, c);
if (elementInfo != null) {
return elementInfo.getRowCount();
} else {
return 0;
}
}
public AccessibleTable getAccessibleRowHeader() {
return null;
}
public void setAccessibleRowHeader(AccessibleTable table) {
}
public AccessibleTable getAccessibleColumnHeader() {
return null;
}
public void setAccessibleColumnHeader(AccessibleTable table) {
}
public Accessible getAccessibleRowDescription(int r) {
return null;
}
public void setAccessibleRowDescription(int r, Accessible a) {
}
public Accessible getAccessibleColumnDescription(int c) {
return null;
}
public void setAccessibleColumnDescription(int c, Accessible a) {
}
public boolean isAccessibleSelected(int r, int c) {
return false;
}
public boolean isAccessibleRowSelected(int r) {
return false;
}
public boolean isAccessibleColumnSelected(int c) {
return false;
}
public int [] getSelectedAccessibleRows() {
return new int [0];
}
public int [] getSelectedAccessibleColumns() {
return new int [0];
}
}
}
private class TableRowElementInfo extends ElementInfo {
private TableElementInfo parent;
private int rowNumber;
TableRowElementInfo(Element e, TableElementInfo parent, int rowNumber) {
super(e, parent);
this.parent = parent;
this.rowNumber = rowNumber;
}
protected void loadChildren(Element e) {
for (int x = 0; x < e.getElementCount(); x++) {
AttributeSet attrs = e.getElement(x).getAttributes();
if (attrs.getAttribute(StyleConstants.NameAttribute) ==
HTML.Tag.TH) {
TableCellElementInfo headerElementInfo =
new TableCellElementInfo(e.getElement(x), this, true);
addChild(headerElementInfo);
AccessibleTable at =
parent.getAccessibleContext().getAccessibleTable();
TableAccessibleContext tableElement =
(TableAccessibleContext)at;
tableElement.addRowHeader(headerElementInfo, rowNumber);
} else if (attrs.getAttribute(StyleConstants.NameAttribute) ==
HTML.Tag.TD) {
addChild(new TableCellElementInfo(e.getElement(x), this,
false));
}
}
}
public int getRowCount() {
int rowCount = 1;
if (validateIfNecessary()) {
for (int counter = 0; counter < getChildCount();
counter++) {
TableCellElementInfo cell = (TableCellElementInfo)
getChild(counter);
if (cell.validateIfNecessary()) {
rowCount = Math.max(rowCount, cell.getRowCount());
}
}
}
return rowCount;
}
public int getColumnCount() {
int colCount = 0;
if (validateIfNecessary()) {
for (int counter = 0; counter < getChildCount();
counter++) {
TableCellElementInfo cell = (TableCellElementInfo)
getChild(counter);
if (cell.validateIfNecessary()) {
colCount += cell.getColumnCount();
}
}
}
return colCount;
}
protected void invalidate(boolean first) {
super.invalidate(first);
getParent().invalidate(true);
}
private void updateGrid(int row) {
if (validateIfNecessary()) {
boolean emptyRow = false;
while (!emptyRow) {
for (int counter = 0; counter < grid[row].length;
counter++) {
if (grid[row][counter] == null) {
emptyRow = true;
break;
}
}
if (!emptyRow) {
row++;
}
}
for (int col = 0, counter = 0; counter < getChildCount();
counter++) {
TableCellElementInfo cell = (TableCellElementInfo)
getChild(counter);
while (grid[row][col] != null) {
col++;
}
for (int rowCount = cell.getRowCount() - 1;
rowCount >= 0; rowCount--) {
for (int colCount = cell.getColumnCount() - 1;
colCount >= 0; colCount--) {
grid[row + rowCount][col + colCount] = cell;
}
}
col += cell.getColumnCount();
}
}
}
private int getColumnCount(int rowspan) {
if (validateIfNecessary()) {
int cols = 0;
for (int counter = 0; counter < getChildCount();
counter++) {
TableCellElementInfo cell = (TableCellElementInfo)
getChild(counter);
if (cell.getRowCount() >= rowspan) {
cols += cell.getColumnCount();
}
}
return cols;
}
return 0;
}
}
private class TableCellElementInfo extends ElementInfo {
private Accessible accessible;
private boolean isHeaderCell;
TableCellElementInfo(Element e, ElementInfo parent) {
super(e, parent);
this.isHeaderCell = false;
}
TableCellElementInfo(Element e, ElementInfo parent,
boolean isHeaderCell) {
super(e, parent);
this.isHeaderCell = isHeaderCell;
}
public boolean isHeaderCell() {
return this.isHeaderCell;
}
public Accessible getAccessible() {
accessible = null;
getAccessible(this);
return accessible;
}
private void getAccessible(ElementInfo elementInfo) {
if (elementInfo instanceof Accessible) {
accessible = (Accessible)elementInfo;
} else {
for (int i = 0; i < elementInfo.getChildCount(); i++) {
getAccessible(elementInfo.getChild(i));
}
}
}
public int getRowCount() {
if (validateIfNecessary()) {
return Math.max(1, getIntAttr(getAttributes(),
HTML.Attribute.ROWSPAN, 1));
}
return 0;
}
public int getColumnCount() {
if (validateIfNecessary()) {
return Math.max(1, getIntAttr(getAttributes(),
HTML.Attribute.COLSPAN, 1));
}
return 0;
}
protected void invalidate(boolean first) {
super.invalidate(first);
getParent().invalidate(true);
}
}
}
private class ElementInfo {
private ArrayList<ElementInfo> children;
private Element element;
private ElementInfo parent;
private boolean isValid;
private boolean canBeValid;
ElementInfo(Element element) {
this(element, null);
}
ElementInfo(Element element, ElementInfo parent) {
this.element = element;
this.parent = parent;
isValid = false;
canBeValid = true;
}
protected void validate() {
isValid = true;
loadChildren(getElement());
}
protected void loadChildren(Element parent) {
if (!parent.isLeaf()) {
for (int counter = 0, maxCounter = parent.getElementCount();
counter < maxCounter; counter++) {
Element e = parent.getElement(counter);
ElementInfo childInfo = createElementInfo(e, this);
if (childInfo != null) {
addChild(childInfo);
}
else {
loadChildren(e);
}
}
}
}
public int getIndexInParent() {
if (parent == null || !parent.isValid()) {
return -1;
}
return parent.indexOf(this);
}
public Element getElement() {
return element;
}
public ElementInfo getParent() {
return parent;
}
public int indexOf(ElementInfo child) {
ArrayList<ElementInfo> children = this.children;
if (children != null) {
return children.indexOf(child);
}
return -1;
}
public ElementInfo getChild(int index) {
if (validateIfNecessary()) {
ArrayList<ElementInfo> children = this.children;
if (children != null && index >= 0 &&
index < children.size()) {
return children.get(index);
}
}
return null;
}
public int getChildCount() {
validateIfNecessary();
return (children == null) ? 0 : children.size();
}
protected void addChild(ElementInfo child) {
if (children == null) {
children = new ArrayList<ElementInfo>();
}
children.add(child);
}
protected View getView() {
if (!validateIfNecessary()) {
return null;
}
Object lock = lock();
try {
View rootView = getRootView();
Element e = getElement();
int start = e.getStartOffset();
if (rootView != null) {
return getView(rootView, e, start);
}
return null;
} finally {
unlock(lock);
}
}
public Rectangle getBounds() {
if (!validateIfNecessary()) {
return null;
}
Object lock = lock();
try {
Rectangle bounds = getRootEditorRect();
View rootView = getRootView();
Element e = getElement();
if (bounds != null && rootView != null) {
try {
return rootView.modelToView(e.getStartOffset(),
Position.Bias.Forward,
e.getEndOffset(),
Position.Bias.Backward,
bounds).getBounds();
} catch (BadLocationException ble) { }
}
} finally {
unlock(lock);
}
return null;
}
protected boolean isValid() {
return isValid;
}
protected AttributeSet getAttributes() {
if (validateIfNecessary()) {
return getElement().getAttributes();
}
return null;
}
protected AttributeSet getViewAttributes() {
if (validateIfNecessary()) {
View view = getView();
if (view != null) {
return view.getElement().getAttributes();
}
return getElement().getAttributes();
}
return null;
}
protected int getIntAttr(AttributeSet attrs, Object key, int deflt) {
if (attrs != null && attrs.isDefined(key)) {
int i;
String val = (String)attrs.getAttribute(key);
if (val == null) {
i = deflt;
}
else {
try {
i = Math.max(0, Integer.parseInt(val));
} catch (NumberFormatException x) {
i = deflt;
}
}
return i;
}
return deflt;
}
protected boolean validateIfNecessary() {
if (!isValid() && canBeValid) {
children = null;
Object lock = lock();
try {
validate();
} finally {
unlock(lock);
}
}
return isValid();
}
protected void invalidate(boolean first) {
if (!isValid()) {
if (canBeValid && !first) {
canBeValid = false;
}
return;
}
isValid = false;
canBeValid = first;
if (children != null) {
for (ElementInfo child : children) {
child.invalidate(false);
}
children = null;
}
}
private View getView(View parent, Element e, int start) {
if (parent.getElement() == e) {
return parent;
}
int index = parent.getViewIndex(start, Position.Bias.Forward);
if (index != -1 && index < parent.getViewCount()) {
return getView(parent.getView(index), e, start);
}
return null;
}
private int getClosestInfoIndex(int index) {
for (int counter = 0; counter < getChildCount(); counter++) {
ElementInfo info = getChild(counter);
if (index < info.getElement().getEndOffset() ||
index == info.getElement().getStartOffset()) {
return counter;
}
}
return -1;
}
private void update(DocumentEvent e) {
if (!isValid()) {
return;
}
ElementInfo parent = getParent();
Element element = getElement();
do {
DocumentEvent.ElementChange ec = e.getChange(element);
if (ec != null) {
if (element == getElement()) {
invalidate(true);
}
else if (parent != null) {
parent.invalidate(parent == getRootInfo());
}
return;
}
element = element.getParentElement();
} while (parent != null && element != null &&
element != parent.getElement());
if (getChildCount() > 0) {
Element elem = getElement();
int pos = e.getOffset();
int index0 = getClosestInfoIndex(pos);
if (index0 == -1 &&
e.getType() == DocumentEvent.EventType.REMOVE &&
pos >= elem.getEndOffset()) {
index0 = getChildCount() - 1;
}
ElementInfo info = (index0 >= 0) ? getChild(index0) : null;
if (info != null &&
(info.getElement().getStartOffset() == pos) && (pos > 0)) {
index0 = Math.max(index0 - 1, 0);
}
int index1;
if (e.getType() != DocumentEvent.EventType.REMOVE) {
index1 = getClosestInfoIndex(pos + e.getLength());
if (index1 < 0) {
index1 = getChildCount() - 1;
}
}
else {
index1 = index0;
while ((index1 + 1) < getChildCount() &&
getChild(index1 + 1).getElement().getEndOffset() ==
getChild(index1 + 1).getElement().getStartOffset()){
index1++;
}
}
index0 = Math.max(index0, 0);
for (int i = index0; i <= index1 && isValid(); i++) {
getChild(i).update(e);
}
}
}
}
private class DocumentHandler implements DocumentListener {
public void insertUpdate(DocumentEvent e) {
getRootInfo().update(e);
}
public void removeUpdate(DocumentEvent e) {
getRootInfo().update(e);
}
public void changedUpdate(DocumentEvent e) {
getRootInfo().update(e);
}
}
private class PropertyChangeHandler implements PropertyChangeListener {
public void propertyChange(PropertyChangeEvent evt) {
if (evt.getPropertyName().equals("document")) {
setDocument(editor.getDocument());
}
}
}
}
package javax.accessibility;
public abstract class AccessibleHyperlink implements AccessibleAction {
protected AccessibleHyperlink() {}
public abstract boolean isValid();
public abstract int getAccessibleActionCount();
public abstract boolean doAccessibleAction(int i);
public abstract String getAccessibleActionDescription(int i);
public abstract Object getAccessibleActionObject(int i);
public abstract Object getAccessibleActionAnchor(int i);
public abstract int getStartIndex();
public abstract int getEndIndex();
}
package javax.accessibility;
public interface AccessibleHypertext extends AccessibleText {
public abstract int getLinkCount();
public abstract AccessibleHyperlink getLink(int linkIndex);
public abstract int getLinkIndex(int charIndex);
}
package javax.accessibility;
public interface AccessibleIcon {
public String getAccessibleIconDescription();
public void setAccessibleIconDescription(String description);
public int getAccessibleIconWidth();
public int getAccessibleIconHeight();
}
package javax.accessibility;
public interface AccessibleKeyBinding {
public int getAccessibleKeyBindingCount();
public Object getAccessibleKeyBinding(int i);
}
package jdk.dynalink.beans;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
class AccessibleMembersLookup {
private final Map<MethodSignature, Method> methods;
private final Map<String, Class<?>> innerClasses;
private final boolean instance;
AccessibleMembersLookup(final Class<?> clazz, final boolean instance) {
this.methods = new HashMap<>();
this.innerClasses = new LinkedHashMap<>();
this.instance = instance;
lookupAccessibleMembers(clazz);
}
Collection<Method> getMethods() {
return methods.values();
}
Class<?>[] getInnerClasses() {
return innerClasses.values().toArray(new Class<?>[0]);
}
Method getAccessibleMethod(final Method m) {
return methods.get(new MethodSignature(m));
}
static final class MethodSignature {
private final String name;
private final Class<?>[] args;
MethodSignature(final String name, final Class<?>[] args) {
this.name = name;
this.args = args;
}
MethodSignature(final Method method) {
this(method.getName(), method.getParameterTypes());
}
@Override
public boolean equals(final Object o) {
if(o instanceof MethodSignature) {
final MethodSignature ms = (MethodSignature)o;
return ms.name.equals(name) && Arrays.equals(args, ms.args);
}
return false;
}
@Override
public int hashCode() {
return name.hashCode() ^ Arrays.hashCode(args);
}
@Override
public String toString() {
final StringBuilder b = new StringBuilder();
b.append("[MethodSignature ").append(name).append('(');
if(args.length > 0) {
b.append(args[0].getCanonicalName());
for(int i = 1; i < args.length; ++i) {
b.append(", ").append(args[i].getCanonicalName());
}
}
return b.append(")]").toString();
}
}
private void lookupAccessibleMembers(final Class<?> clazz) {
boolean searchSuperTypes;
if(!CheckRestrictedPackage.isRestrictedClass(clazz)) {
searchSuperTypes = false;
for(final Method method: clazz.getMethods()) {
final boolean isStatic = Modifier.isStatic(method.getModifiers());
if(instance != isStatic) {
final MethodSignature sig = new MethodSignature(method);
if(!methods.containsKey(sig)) {
final Class<?> declaringClass = method.getDeclaringClass();
if(declaringClass != clazz && CheckRestrictedPackage.isRestrictedClass(declaringClass)) {
searchSuperTypes = true;
} else {
if (!isStatic || clazz == declaringClass) {
methods.put(sig, method);
}
}
}
}
}
for(final Class<?> innerClass: clazz.getClasses()) {
Class<?> previousClass = innerClasses.get(innerClass.getSimpleName());
if (previousClass == null || previousClass.getDeclaringClass().isAssignableFrom(innerClass.getDeclaringClass())) {
innerClasses.put(innerClass.getSimpleName(), innerClass);
}
}
} else {
searchSuperTypes = true;
}
if(instance && searchSuperTypes) {
for (final Class<?> itf: clazz.getInterfaces()) {
lookupAccessibleMembers(itf);
}
final Class<?> superclass = clazz.getSuperclass();
if(superclass != null) {
lookupAccessibleMembers(superclass);
}
}
}
}
package java.lang.reflect;
import java.lang.annotation.Annotation;
import java.lang.invoke.MethodHandle;
import java.lang.ref.WeakReference;
import java.security.AccessController;
import jdk.internal.access.SharedSecrets;
import jdk.internal.misc.VM;
import jdk.internal.reflect.CallerSensitive;
import jdk.internal.reflect.Reflection;
import jdk.internal.reflect.ReflectionFactory;
import sun.security.action.GetPropertyAction;
import sun.security.util.SecurityConstants;
public class AccessibleObject implements AnnotatedElement {
static {
SharedSecrets.setJavaLangReflectAccess(new ReflectAccess());
}
static void checkPermission() {
@SuppressWarnings("removal")
SecurityManager sm = System.getSecurityManager();
if (sm != null) {
sm.checkPermission(SecurityConstants.ACCESS_PERMISSION);
}
}
@CallerSensitive
public static void setAccessible(AccessibleObject[] array, boolean flag) {
checkPermission();
if (flag) {
Class<?> caller = Reflection.getCallerClass();
array = array.clone();
for (AccessibleObject ao : array) {
ao.checkCanSetAccessible(caller);
}
}
for (AccessibleObject ao : array) {
ao.setAccessible0(flag);
}
}
@CallerSensitive       public void setAccessible(boolean flag) {
AccessibleObject.checkPermission();
setAccessible0(flag);
}
boolean setAccessible0(boolean flag) {
this.override = flag;
return flag;
}
@CallerSensitive
public final boolean trySetAccessible() {
AccessibleObject.checkPermission();
if (override == true) return true;
if (!Member.class.isInstance(this)) {
return setAccessible0(true);
}
Class<?> declaringClass = ((Member) this).getDeclaringClass();
if (declaringClass == Class.class && this instanceof Constructor) {
return false;
}
if (checkCanSetAccessible(Reflection.getCallerClass(),
declaringClass,
false)) {
return setAccessible0(true);
} else {
return false;
}
}
void checkCanSetAccessible(Class<?> caller) {
}
final void checkCanSetAccessible(Class<?> caller, Class<?> declaringClass) {
checkCanSetAccessible(caller, declaringClass, true);
}
private boolean checkCanSetAccessible(Class<?> caller,
Class<?> declaringClass,
boolean throwExceptionIfDenied) {
if (caller == MethodHandle.class) {
throw new IllegalCallerException();           }
if (caller == null) {
boolean canAccess = Reflection.verifyPublicMemberAccess(declaringClass, declaringClass.getModifiers());
if (!canAccess && throwExceptionIfDenied) {
throwInaccessibleObjectException(caller, declaringClass);
}
return canAccess;
}
Module callerModule = caller.getModule();
Module declaringModule = declaringClass.getModule();
if (callerModule == declaringModule) return true;
if (callerModule == Object.class.getModule()) return true;
if (!declaringModule.isNamed()) return true;
String pn = declaringClass.getPackageName();
int modifiers = ((Member)this).getModifiers();
boolean isClassPublic = Modifier.isPublic(declaringClass.getModifiers());
if (isClassPublic && declaringModule.isExported(pn, callerModule)) {
if (Modifier.isPublic(modifiers)) {
return true;
}
if (Modifier.isProtected(modifiers)
&& Modifier.isStatic(modifiers)
&& isSubclassOf(caller, declaringClass)) {
return true;
}
}
if (declaringModule.isOpen(pn, callerModule)) {
return true;
}
if (throwExceptionIfDenied) {
throwInaccessibleObjectException(caller, declaringClass);
}
return false;
}
private void throwInaccessibleObjectException(Class<?> caller, Class<?> declaringClass) {
boolean isClassPublic = Modifier.isPublic(declaringClass.getModifiers());
String pn = declaringClass.getPackageName();
int modifiers = ((Member)this).getModifiers();
String msg = "Unable to make ";
if (this instanceof Field)
msg += "field ";
msg += this + " accessible";
msg += caller == null ? " by JNI attached native thread with no caller frame: " : ": ";
msg += declaringClass.getModule() + " does not \"";
if (isClassPublic && Modifier.isPublic(modifiers))
msg += "exports";
else
msg += "opens";
msg += " " + pn + "\"" ;
if (caller != null)
msg += " to " + caller.getModule();
InaccessibleObjectException e = new InaccessibleObjectException(msg);
if (printStackTraceWhenAccessFails()) {
e.printStackTrace(System.err);
}
throw e;
}
private boolean isSubclassOf(Class<?> queryClass, Class<?> ofClass) {
while (queryClass != null) {
if (queryClass == ofClass) {
return true;
}
queryClass = queryClass.getSuperclass();
}
return false;
}
String toShortString() {
return toString();
}
@Deprecated(since="9")
public boolean isAccessible() {
return override;
}
@CallerSensitive
public final boolean canAccess(Object obj) {
if (!Member.class.isInstance(this)) {
return override;
}
Class<?> declaringClass = ((Member) this).getDeclaringClass();
int modifiers = ((Member) this).getModifiers();
if (!Modifier.isStatic(modifiers) &&
(this instanceof Method || this instanceof Field)) {
if (obj == null) {
throw new IllegalArgumentException("null object for " + this);
}
if (!declaringClass.isInstance(obj)) {
throw new IllegalArgumentException("object is not an instance of "
+ declaringClass.getName());
}
} else if (obj != null) {
throw new IllegalArgumentException("non-null object for " + this);
}
if (override) return true;
Class<?> caller = Reflection.getCallerClass();
Class<?> targetClass;
if (this instanceof Constructor) {
targetClass = declaringClass;
} else {
targetClass = Modifier.isStatic(modifiers) ? null : obj.getClass();
}
return verifyAccess(caller, declaringClass, targetClass, modifiers);
}
@Deprecated(since="17")
protected AccessibleObject() {}
boolean override;
@SuppressWarnings("removal")
static final ReflectionFactory reflectionFactory =
AccessController.doPrivileged(
new ReflectionFactory.GetReflectionFactoryAction());
@Override
public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
throw new UnsupportedOperationException("All subclasses should override this method");
}
@Override
public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {
return AnnotatedElement.super.isAnnotationPresent(annotationClass);
}
@Override
public <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass) {
throw new UnsupportedOperationException("All subclasses should override this method");
}
@Override
public Annotation[] getAnnotations() {
return getDeclaredAnnotations();
}
@Override
public <T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass) {
return getAnnotation(annotationClass);
}
@Override
public <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass) {
return getAnnotationsByType(annotationClass);
}
@Override
public Annotation[] getDeclaredAnnotations()  {
throw new UnsupportedOperationException("All subclasses should override this method");
}
volatile Object accessCheckCache;
private static class Cache {
final WeakReference<Class<?>> callerRef;
final WeakReference<Class<?>> targetRef;
Cache(Class<?> caller, Class<?> target) {
this.callerRef = new WeakReference<>(caller);
this.targetRef = new WeakReference<>(target);
}
boolean isCacheFor(Class<?> caller, Class<?> refc) {
return callerRef.refersTo(caller) && targetRef.refersTo(refc);
}
static Object protectedMemberCallerCache(Class<?> caller, Class<?> refc) {
return new Cache(caller, refc);
}
}
private boolean isAccessChecked(Class<?> caller, Class<?> targetClass) {
Object cache = accessCheckCache;          if (cache instanceof Cache) {
return ((Cache) cache).isCacheFor(caller, targetClass);
}
return false;
}
private boolean isAccessChecked(Class<?> caller) {
Object cache = accessCheckCache;          if (cache instanceof WeakReference) {
@SuppressWarnings("unchecked")
WeakReference<Class<?>> ref = (WeakReference<Class<?>>) cache;
return ref.refersTo(caller);
}
return false;
}
final void checkAccess(Class<?> caller, Class<?> memberClass,
Class<?> targetClass, int modifiers)
throws IllegalAccessException
{
if (!verifyAccess(caller, memberClass, targetClass, modifiers)) {
IllegalAccessException e = Reflection.newIllegalAccessException(
caller, memberClass, targetClass, modifiers);
if (printStackTraceWhenAccessFails()) {
e.printStackTrace(System.err);
}
throw e;
}
}
final boolean verifyAccess(Class<?> caller, Class<?> memberClass,
Class<?> targetClass, int modifiers)
{
if (caller == memberClass) {              return true;                     }
if (targetClass != null             && Modifier.isProtected(modifiers)
&& targetClass != memberClass) {
if (isAccessChecked(caller, targetClass)) {
return true;                     }
} else if (isAccessChecked(caller)) {
return true;                     }
return slowVerifyAccess(caller, memberClass, targetClass, modifiers);
}
private boolean slowVerifyAccess(Class<?> caller, Class<?> memberClass,
Class<?> targetClass, int modifiers)
{
if (caller == null) {
return Reflection.verifyPublicMemberAccess(memberClass, modifiers);
}
if (!Reflection.verifyMemberAccess(caller, memberClass, targetClass, modifiers)) {
return false;
}
Object cache = (targetClass != null
&& Modifier.isProtected(modifiers)
&& targetClass != memberClass)
? Cache.protectedMemberCallerCache(caller, targetClass)
: new WeakReference<>(caller);
accessCheckCache = cache;                 return true;
}
private static volatile boolean printStackWhenAccessFails;
private static volatile boolean printStackPropertiesSet;
private static boolean printStackTraceWhenAccessFails() {
if (!printStackPropertiesSet && VM.initLevel() >= 1) {
String s = GetPropertyAction.privilegedGetProperty(
"sun.reflect.debugModuleAccessChecks");
if (s != null) {
printStackWhenAccessFails = !s.equalsIgnoreCase("false");
}
printStackPropertiesSet = true;
}
return printStackWhenAccessFails;
}
AccessibleObject getRoot() {
throw new InternalError();
}
}
package javax.accessibility;
public class AccessibleRelation extends AccessibleBundle {
private Object [] target = new Object[0];
public static final String LABEL_FOR = new String("labelFor");
public static final String LABELED_BY = new String("labeledBy");
public static final String MEMBER_OF = new String("memberOf");
public static final String CONTROLLER_FOR = new String("controllerFor");
public static final String CONTROLLED_BY = new String("controlledBy");
public static final String FLOWS_TO = "flowsTo";
public static final String FLOWS_FROM = "flowsFrom";
public static final String SUBWINDOW_OF = "subwindowOf";
public static final String PARENT_WINDOW_OF = "parentWindowOf";
public static final String EMBEDS = "embeds";
public static final String EMBEDDED_BY = "embeddedBy";
public static final String CHILD_NODE_OF = "childNodeOf";
public static final String LABEL_FOR_PROPERTY = "labelForProperty";
public static final String LABELED_BY_PROPERTY = "labeledByProperty";
public static final String MEMBER_OF_PROPERTY = "memberOfProperty";
public static final String CONTROLLER_FOR_PROPERTY = "controllerForProperty";
public static final String CONTROLLED_BY_PROPERTY = "controlledByProperty";
public static final String FLOWS_TO_PROPERTY = "flowsToProperty";
public static final String FLOWS_FROM_PROPERTY = "flowsFromProperty";
public static final String SUBWINDOW_OF_PROPERTY = "subwindowOfProperty";
public static final String PARENT_WINDOW_OF_PROPERTY = "parentWindowOfProperty";
public static final String EMBEDS_PROPERTY = "embedsProperty";
public static final String EMBEDDED_BY_PROPERTY = "embeddedByProperty";
public static final String CHILD_NODE_OF_PROPERTY = "childNodeOfProperty";
public AccessibleRelation(String key) {
this.key = key;
this.target = null;
}
public AccessibleRelation(String key, Object target) {
this.key = key;
this.target = new Object[1];
this.target[0] = target;
}
public AccessibleRelation(String key, Object[] target) {
this.key = key;
this.target = target;
}
public String getKey() {
return this.key;
}
public Object [] getTarget() {
if (target == null) {
target = new Object[0];
}
Object [] retval = new Object[target.length];
for (int i = 0; i < target.length; i++) {
retval[i] = target[i];
}
return retval;
}
public void setTarget(Object target) {
this.target = new Object[1];
this.target[0] = target;
}
public void setTarget(Object [] target) {
this.target = target;
}
}
package javax.accessibility;
import java.util.Vector;
public class AccessibleRelationSet {
protected Vector<AccessibleRelation> relations = null;
public AccessibleRelationSet() {
relations = null;
}
public AccessibleRelationSet(AccessibleRelation[] relations) {
if (relations.length != 0) {
this.relations = new Vector<>(relations.length);
for (int i = 0; i < relations.length; i++) {
add(relations[i]);
}
}
}
public boolean add(AccessibleRelation relation) {
if (relations == null) {
relations = new Vector<>();
}
AccessibleRelation existingRelation = get(relation.getKey());
if (existingRelation == null) {
relations.addElement(relation);
return true;
} else {
Object [] existingTarget = existingRelation.getTarget();
Object [] newTarget = relation.getTarget();
int mergedLength = existingTarget.length + newTarget.length;
Object [] mergedTarget = new Object[mergedLength];
for (int i = 0; i < existingTarget.length; i++) {
mergedTarget[i] = existingTarget[i];
}
for (int i = existingTarget.length, j = 0;
i < mergedLength;
i++, j++) {
mergedTarget[i] = newTarget[j];
}
existingRelation.setTarget(mergedTarget);
}
return true;
}
public void addAll(AccessibleRelation[] relations) {
if (relations.length != 0) {
if (this.relations == null) {
this.relations = new Vector<>(relations.length);
}
for (int i = 0; i < relations.length; i++) {
add(relations[i]);
}
}
}
public boolean remove(AccessibleRelation relation) {
if (relations == null) {
return false;
} else {
return relations.removeElement(relation);
}
}
public void clear() {
if (relations != null) {
relations.removeAllElements();
}
}
public int size() {
if (relations == null) {
return 0;
} else {
return relations.size();
}
}
public boolean contains(String key) {
return get(key) != null;
}
public AccessibleRelation get(String key) {
if (relations == null) {
return null;
} else {
int len = relations.size();
for (int i = 0; i < len; i++) {
AccessibleRelation relation = relations.elementAt(i);
if (relation != null && relation.getKey().equals(key)) {
return relation;
}
}
return null;
}
}
public AccessibleRelation[] toArray() {
if (relations == null) {
return new AccessibleRelation[0];
} else {
AccessibleRelation[] relationArray
= new AccessibleRelation[relations.size()];
for (int i = 0; i < relationArray.length; i++) {
relationArray[i] = relations.elementAt(i);
}
return relationArray;
}
}
public String toString() {
String ret = "";
if ((relations != null) && (relations.size() > 0)) {
ret = (relations.elementAt(0)).toDisplayString();
for (int i = 1; i < relations.size(); i++) {
ret = ret + ","
+ (relations.elementAt(i)).toDisplayString();
}
}
return ret;
}
}
package javax.accessibility;
import java.util.ListResourceBundle;
@Deprecated
public class AccessibleResourceBundle extends ListResourceBundle {
public AccessibleResourceBundle() {}
public Object[][] getContents() {
return new Object[][] {
{ "alert","alert" },
{ "awtcomponent","AWT component" },
{ "checkbox","check box" },
{ "colorchooser","color chooser" },
{ "columnheader","column header" },
{ "combobox","combo box" },
{ "canvas","canvas" },
{ "desktopicon","desktop icon" },
{ "desktoppane","desktop pane" },
{ "dialog","dialog" },
{ "directorypane","directory pane" },
{ "glasspane","glass pane" },
{ "filechooser","file chooser" },
{ "filler","filler" },
{ "frame","frame" },
{ "internalframe","internal frame" },
{ "label","label" },
{ "layeredpane","layered pane" },
{ "list","list" },
{ "listitem","list item" },
{ "menubar","menu bar" },
{ "menu","menu" },
{ "menuitem","menu item" },
{ "optionpane","option pane" },
{ "pagetab","page tab" },
{ "pagetablist","page tab list" },
{ "panel","panel" },
{ "passwordtext","password text" },
{ "popupmenu","popup menu" },
{ "progressbar","progress bar" },
{ "pushbutton","push button" },
{ "radiobutton","radio button" },
{ "rootpane","root pane" },
{ "rowheader","row header" },
{ "scrollbar","scroll bar" },
{ "scrollpane","scroll pane" },
{ "separator","separator" },
{ "slider","slider" },
{ "splitpane","split pane" },
{ "swingcomponent","swing component" },
{ "table","table" },
{ "text","text" },
{ "tree","tree" },
{ "togglebutton","toggle button" },
{ "toolbar","tool bar" },
{ "tooltip","tool tip" },
{ "unknown","unknown" },
{ "viewport","viewport" },
{ "window","window" },
{ "labelFor","label for" },
{ "labeledBy","labeled by" },
{ "memberOf","member of" },
{ "controlledBy","controlledBy" },
{ "controllerFor","controllerFor" },
{ "active","active" },
{ "armed","armed" },
{ "busy","busy" },
{ "checked","checked" },
{ "collapsed", "collapsed" },
{ "editable","editable" },
{ "expandable", "expandable" },
{ "expanded", "expanded" },
{ "enabled","enabled" },
{ "focusable","focusable" },
{ "focused","focused" },
{ "iconified", "iconified" },
{ "modal", "modal" },
{ "multiline", "multiple line" },
{ "multiselectable","multiselectable" },
{ "opaque", "opaque" },
{ "pressed","pressed" },
{ "resizable", "resizable" },
{ "selectable","selectable" },
{ "selected","selected" },
{ "showing","showing" },
{ "singleline", "single line" },
{ "transient", "transient" },
{ "visible","visible" },
{ "vertical","vertical" },
{ "horizontal","horizontal" }
};
}
}
package javax.accessibility;
public class AccessibleRole extends AccessibleBundle {
public static final AccessibleRole ALERT
= new AccessibleRole("alert");
public static final AccessibleRole COLUMN_HEADER
= new AccessibleRole("columnheader");
public static final AccessibleRole CANVAS
= new AccessibleRole("canvas");
public static final AccessibleRole COMBO_BOX
= new AccessibleRole("combobox");
public static final AccessibleRole DESKTOP_ICON
= new AccessibleRole("desktopicon");
public static final AccessibleRole HTML_CONTAINER
= new AccessibleRole("htmlcontainer");
public static final AccessibleRole INTERNAL_FRAME
= new AccessibleRole("internalframe");
public static final AccessibleRole DESKTOP_PANE
= new AccessibleRole("desktoppane");
public static final AccessibleRole OPTION_PANE
= new AccessibleRole("optionpane");
public static final AccessibleRole WINDOW
= new AccessibleRole("window");
public static final AccessibleRole FRAME
= new AccessibleRole("frame");
public static final AccessibleRole DIALOG
= new AccessibleRole("dialog");
public static final AccessibleRole COLOR_CHOOSER
= new AccessibleRole("colorchooser");
public static final AccessibleRole DIRECTORY_PANE
= new AccessibleRole("directorypane");
public static final AccessibleRole FILE_CHOOSER
= new AccessibleRole("filechooser");
public static final AccessibleRole FILLER
= new AccessibleRole("filler");
public static final AccessibleRole HYPERLINK
= new AccessibleRole("hyperlink");
public static final AccessibleRole ICON
= new AccessibleRole("icon");
public static final AccessibleRole LABEL
= new AccessibleRole("label");
public static final AccessibleRole ROOT_PANE
= new AccessibleRole("rootpane");
public static final AccessibleRole GLASS_PANE
= new AccessibleRole("glasspane");
public static final AccessibleRole LAYERED_PANE
= new AccessibleRole("layeredpane");
public static final AccessibleRole LIST
= new AccessibleRole("list");
public static final AccessibleRole LIST_ITEM
= new AccessibleRole("listitem");
public static final AccessibleRole MENU_BAR
= new AccessibleRole("menubar");
public static final AccessibleRole POPUP_MENU
= new AccessibleRole("popupmenu");
public static final AccessibleRole MENU
= new AccessibleRole("menu");
public static final AccessibleRole MENU_ITEM
= new AccessibleRole("menuitem");
public static final AccessibleRole SEPARATOR
= new AccessibleRole("separator");
public static final AccessibleRole PAGE_TAB_LIST
= new AccessibleRole("pagetablist");
public static final AccessibleRole PAGE_TAB
= new AccessibleRole("pagetab");
public static final AccessibleRole PANEL
= new AccessibleRole("panel");
public static final AccessibleRole PROGRESS_BAR
= new AccessibleRole("progressbar");
public static final AccessibleRole PASSWORD_TEXT
= new AccessibleRole("passwordtext");
public static final AccessibleRole PUSH_BUTTON
= new AccessibleRole("pushbutton");
public static final AccessibleRole TOGGLE_BUTTON
= new AccessibleRole("togglebutton");
public static final AccessibleRole CHECK_BOX
= new AccessibleRole("checkbox");
public static final AccessibleRole RADIO_BUTTON
= new AccessibleRole("radiobutton");
public static final AccessibleRole ROW_HEADER
= new AccessibleRole("rowheader");
public static final AccessibleRole SCROLL_PANE
= new AccessibleRole("scrollpane");
public static final AccessibleRole SCROLL_BAR
= new AccessibleRole("scrollbar");
public static final AccessibleRole VIEWPORT
= new AccessibleRole("viewport");
public static final AccessibleRole SLIDER
= new AccessibleRole("slider");
public static final AccessibleRole SPLIT_PANE
= new AccessibleRole("splitpane");
public static final AccessibleRole TABLE
= new AccessibleRole("table");
public static final AccessibleRole TEXT
= new AccessibleRole("text");
public static final AccessibleRole TREE
= new AccessibleRole("tree");
public static final AccessibleRole TOOL_BAR
= new AccessibleRole("toolbar");
public static final AccessibleRole TOOL_TIP
= new AccessibleRole("tooltip");
public static final AccessibleRole AWT_COMPONENT
= new AccessibleRole("awtcomponent");
public static final AccessibleRole SWING_COMPONENT
= new AccessibleRole("swingcomponent");
public static final AccessibleRole UNKNOWN
= new AccessibleRole("unknown");
public static final AccessibleRole STATUS_BAR
= new AccessibleRole("statusbar");
public static final AccessibleRole DATE_EDITOR
= new AccessibleRole("dateeditor");
public static final AccessibleRole SPIN_BOX
= new AccessibleRole("spinbox");
public static final AccessibleRole FONT_CHOOSER
= new AccessibleRole("fontchooser");
public static final AccessibleRole GROUP_BOX
= new AccessibleRole("groupbox");
public static final AccessibleRole HEADER =
new AccessibleRole("header");
public static final AccessibleRole FOOTER =
new AccessibleRole("footer");
public static final AccessibleRole PARAGRAPH =
new AccessibleRole("paragraph");
public static final AccessibleRole RULER =
new AccessibleRole("ruler");
public static final AccessibleRole EDITBAR =
new AccessibleRole("editbar");
public static final AccessibleRole PROGRESS_MONITOR =
new AccessibleRole("progressMonitor");
protected AccessibleRole(String key) {
this.key = key;
}
}
package javax.accessibility;
public interface AccessibleSelection {
public int getAccessibleSelectionCount();
public Accessible getAccessibleSelection(int i);
public boolean isAccessibleChildSelected(int i);
public void addAccessibleSelection(int i);
public void removeAccessibleSelection(int i);
public void clearAccessibleSelection();
public void selectAllAccessibleSelection();
}
package javax.accessibility;
public class AccessibleState extends AccessibleBundle {
public static final AccessibleState ACTIVE
= new AccessibleState("active");
public static final AccessibleState PRESSED
= new AccessibleState("pressed");
public static final AccessibleState ARMED
= new AccessibleState("armed");
public static final AccessibleState BUSY
= new AccessibleState("busy");
public static final AccessibleState CHECKED
= new AccessibleState("checked");
public static final AccessibleState EDITABLE
= new AccessibleState("editable");
public static final AccessibleState EXPANDABLE
= new AccessibleState("expandable");
public static final AccessibleState COLLAPSED
= new AccessibleState("collapsed");
public static final AccessibleState EXPANDED
= new AccessibleState("expanded");
public static final AccessibleState ENABLED
= new AccessibleState("enabled");
public static final AccessibleState FOCUSABLE
= new AccessibleState("focusable");
public static final AccessibleState FOCUSED
= new AccessibleState("focused");
public static final AccessibleState ICONIFIED
= new AccessibleState("iconified");
public static final AccessibleState MODAL
= new AccessibleState("modal");
public static final AccessibleState OPAQUE
= new AccessibleState("opaque");
public static final AccessibleState RESIZABLE
= new AccessibleState("resizable");
public static final AccessibleState MULTISELECTABLE
= new AccessibleState("multiselectable");
public static final AccessibleState SELECTABLE
= new AccessibleState("selectable");
public static final AccessibleState SELECTED
= new AccessibleState("selected");
public static final AccessibleState SHOWING
= new AccessibleState("showing");
public static final AccessibleState VISIBLE
= new AccessibleState("visible");
public static final AccessibleState VERTICAL
= new AccessibleState("vertical");
public static final AccessibleState HORIZONTAL
= new AccessibleState("horizontal");
public static final AccessibleState SINGLE_LINE
= new AccessibleState("singleline");
public static final AccessibleState MULTI_LINE
= new AccessibleState("multiline");
public static final AccessibleState TRANSIENT
= new AccessibleState("transient");
public static final AccessibleState MANAGES_DESCENDANTS
= new AccessibleState ("managesDescendants");
public static final AccessibleState INDETERMINATE
= new AccessibleState ("indeterminate");
public static final AccessibleState TRUNCATED
=  new AccessibleState("truncated");
protected AccessibleState(String key) {
this.key = key;
}
}
package javax.accessibility;
import java.util.Vector;
public class AccessibleStateSet {
protected Vector<AccessibleState> states = null;
public AccessibleStateSet() {
states = null;
}
public AccessibleStateSet(AccessibleState[] states) {
if (states.length != 0) {
this.states = new Vector<>(states.length);
for (int i = 0; i < states.length; i++) {
if (!this.states.contains(states[i])) {
this.states.addElement(states[i]);
}
}
}
}
public boolean add(AccessibleState state) {
if (states == null) {
states = new Vector<>();
}
if (!states.contains(state)) {
states.addElement(state);
return true;
} else {
return false;
}
}
public void addAll(AccessibleState[] states) {
if (states.length != 0) {
if (this.states == null) {
this.states = new Vector<>(states.length);
}
for (int i = 0; i < states.length; i++) {
if (!this.states.contains(states[i])) {
this.states.addElement(states[i]);
}
}
}
}
public boolean remove(AccessibleState state) {
if (states == null) {
return false;
} else {
return states.removeElement(state);
}
}
public void clear() {
if (states != null) {
states.removeAllElements();
}
}
public boolean contains(AccessibleState state) {
if (states == null) {
return false;
} else {
return states.contains(state);
}
}
public AccessibleState[] toArray() {
if (states == null) {
return new AccessibleState[0];
} else {
AccessibleState[] stateArray = new AccessibleState[states.size()];
for (int i = 0; i < stateArray.length; i++) {
stateArray[i] = states.elementAt(i);
}
return stateArray;
}
}
public String toString() {
String ret = null;
if ((states != null) && (states.size() > 0)) {
ret = states.elementAt(0).toDisplayString();
for (int i = 1; i < states.size(); i++) {
ret = ret + ","
+ states.elementAt(i).toDisplayString();
}
}
return ret;
}
}
package javax.accessibility;
import java.awt.datatransfer.DataFlavor;
import java.io.InputStream;
public interface AccessibleStreamable {
DataFlavor[] getMimeTypes();
InputStream getStream(DataFlavor flavor);
}
package javax.accessibility;
public interface AccessibleTable {
public Accessible getAccessibleCaption();
public void setAccessibleCaption(Accessible a);
public Accessible getAccessibleSummary();
public void setAccessibleSummary(Accessible a);
public int getAccessibleRowCount();
public int getAccessibleColumnCount();
public Accessible getAccessibleAt(int r, int c);
public int getAccessibleRowExtentAt(int r, int c);
public int getAccessibleColumnExtentAt(int r, int c);
public AccessibleTable getAccessibleRowHeader();
public void setAccessibleRowHeader(AccessibleTable table);
public AccessibleTable getAccessibleColumnHeader();
public void setAccessibleColumnHeader(AccessibleTable table);
public Accessible getAccessibleRowDescription(int r);
public void setAccessibleRowDescription(int r, Accessible a);
public Accessible getAccessibleColumnDescription(int c);
public void setAccessibleColumnDescription(int c, Accessible a);
public boolean isAccessibleSelected(int r, int c);
public boolean isAccessibleRowSelected(int r);
public boolean isAccessibleColumnSelected(int c);
public int[] getSelectedAccessibleRows();
public int[] getSelectedAccessibleColumns();
}
package javax.accessibility;
public interface AccessibleTableModelChange {
public static final int INSERT =  1;
public static final int UPDATE =  0;
public static final int DELETE = -1;
public int getType();
public int getFirstRow();
public int getLastRow();
public int getFirstColumn();
public int getLastColumn();
}
package javax.accessibility;
import java.awt.Point;
import java.awt.Rectangle;
import javax.swing.text.AttributeSet;
public interface AccessibleText {
public static final int CHARACTER = 1;
public static final int WORD = 2;
public static final int SENTENCE = 3;
public int getIndexAtPoint(Point p);
public Rectangle getCharacterBounds(int i);
public int getCharCount();
public int getCaretPosition();
public String getAtIndex(int part, int index);
public String getAfterIndex(int part, int index);
public String getBeforeIndex(int part, int index);
public AttributeSet getCharacterAttribute(int i);
public int getSelectionStart();
public int getSelectionEnd();
public String getSelectedText();
}
package javax.accessibility;
public class AccessibleTextSequence {
public int startIndex;
public int endIndex;
public String text;
public AccessibleTextSequence(int start, int end, String txt) {
startIndex = start;
endIndex = end;
text = txt;
}
};
package javax.accessibility;
public interface AccessibleValue {
public Number getCurrentAccessibleValue();
public boolean setCurrentAccessibleValue(Number n);
public Number getMinimumAccessibleValue();
public Number getMaximumAccessibleValue();
}
package jdk.javadoc.internal.tool;
public enum AccessKind {
PUBLIC,
PROTECTED,
PACKAGE,
PRIVATE;
}
package java.nio.file;
public enum AccessMode {
READ,
WRITE,
EXECUTE;
}
package com.sun.beans.decoder;
abstract class AccessorElementHandler extends ElementHandler {
private String name;
private ValueObject value;
@Override
public void addAttribute(String name, String value) {
if (name.equals("name")) {             this.name = value;
} else {
super.addAttribute(name, value);
}
}
@Override
protected final void addArgument(Object argument) {
if (this.value != null) {
throw new IllegalStateException("Could not add argument to evaluated element");
}
setValue(this.name, argument);
this.value = ValueObjectImpl.VOID;
}
@Override
protected final ValueObject getValueObject() {
if (this.value == null) {
this.value = ValueObjectImpl.create(getValue(this.name));
}
return this.value;
}
protected abstract Object getValue(String name);
protected abstract void setValue(String name, Object value);
}
package jdk.internal.reflect;
import java.lang.reflect.*;
import jdk.internal.misc.Unsafe;
class AccessorGenerator implements ClassFileConstants {
static final Unsafe unsafe = Unsafe.getUnsafe();
protected static final short S0 = (short) 0;
protected static final short S1 = (short) 1;
protected static final short S2 = (short) 2;
protected static final short S3 = (short) 3;
protected static final short S4 = (short) 4;
protected static final short S5 = (short) 5;
protected static final short S6 = (short) 6;
protected ClassFileAssembler asm;
protected int   modifiers;
protected short thisClass;
protected short superClass;
protected short targetClass;
protected short throwableClass;
protected short classCastClass;
protected short nullPointerClass;
protected short illegalArgumentClass;
protected short invocationTargetClass;
protected short initIdx;
protected short initNameAndTypeIdx;
protected short initStringNameAndTypeIdx;
protected short nullPointerCtorIdx;
protected short illegalArgumentCtorIdx;
protected short illegalArgumentStringCtorIdx;
protected short invocationTargetCtorIdx;
protected short superCtorIdx;
protected short objectClass;
protected short toStringIdx;
protected short codeIdx;
protected short exceptionsIdx;
protected short valueOfIdx;
protected short booleanIdx;
protected short booleanBoxIdx;
protected short booleanUnboxIdx;
protected short byteIdx;
protected short byteBoxIdx;
protected short byteUnboxIdx;
protected short characterIdx;
protected short characterBoxIdx;
protected short characterUnboxIdx;
protected short doubleIdx;
protected short doubleBoxIdx;
protected short doubleUnboxIdx;
protected short floatIdx;
protected short floatBoxIdx;
protected short floatUnboxIdx;
protected short integerIdx;
protected short integerBoxIdx;
protected short integerUnboxIdx;
protected short longIdx;
protected short longBoxIdx;
protected short longUnboxIdx;
protected short shortIdx;
protected short shortBoxIdx;
protected short shortUnboxIdx;
protected final short NUM_COMMON_CPOOL_ENTRIES = (short) 30;
protected final short NUM_BOXING_CPOOL_ENTRIES = (short) 73;
protected void emitCommonConstantPoolEntries() {
asm.emitConstantPoolUTF8("java/lang/Throwable");
asm.emitConstantPoolClass(asm.cpi());
throwableClass = asm.cpi();
asm.emitConstantPoolUTF8("java/lang/ClassCastException");
asm.emitConstantPoolClass(asm.cpi());
classCastClass = asm.cpi();
asm.emitConstantPoolUTF8("java/lang/NullPointerException");
asm.emitConstantPoolClass(asm.cpi());
nullPointerClass = asm.cpi();
asm.emitConstantPoolUTF8("java/lang/IllegalArgumentException");
asm.emitConstantPoolClass(asm.cpi());
illegalArgumentClass = asm.cpi();
asm.emitConstantPoolUTF8("java/lang/reflect/InvocationTargetException");
asm.emitConstantPoolClass(asm.cpi());
invocationTargetClass = asm.cpi();
asm.emitConstantPoolUTF8("<init>");
initIdx = asm.cpi();
asm.emitConstantPoolUTF8("()V");
asm.emitConstantPoolNameAndType(initIdx, asm.cpi());
initNameAndTypeIdx = asm.cpi();
asm.emitConstantPoolMethodref(nullPointerClass, initNameAndTypeIdx);
nullPointerCtorIdx = asm.cpi();
asm.emitConstantPoolMethodref(illegalArgumentClass, initNameAndTypeIdx);
illegalArgumentCtorIdx = asm.cpi();
asm.emitConstantPoolUTF8("(Ljava/lang/String;)V");
asm.emitConstantPoolNameAndType(initIdx, asm.cpi());
initStringNameAndTypeIdx = asm.cpi();
asm.emitConstantPoolMethodref(illegalArgumentClass, initStringNameAndTypeIdx);
illegalArgumentStringCtorIdx = asm.cpi();
asm.emitConstantPoolUTF8("(Ljava/lang/Throwable;)V");
asm.emitConstantPoolNameAndType(initIdx, asm.cpi());
asm.emitConstantPoolMethodref(invocationTargetClass, asm.cpi());
invocationTargetCtorIdx = asm.cpi();
asm.emitConstantPoolMethodref(superClass, initNameAndTypeIdx);
superCtorIdx = asm.cpi();
asm.emitConstantPoolUTF8("java/lang/Object");
asm.emitConstantPoolClass(asm.cpi());
objectClass = asm.cpi();
asm.emitConstantPoolUTF8("toString");
asm.emitConstantPoolUTF8("()Ljava/lang/String;");
asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());
asm.emitConstantPoolMethodref(objectClass, asm.cpi());
toStringIdx = asm.cpi();
asm.emitConstantPoolUTF8("Code");
codeIdx = asm.cpi();
asm.emitConstantPoolUTF8("Exceptions");
exceptionsIdx = asm.cpi();
}
protected void emitBoxingContantPoolEntries() {
asm.emitConstantPoolUTF8("valueOf");
valueOfIdx = asm.cpi();
asm.emitConstantPoolUTF8("java/lang/Boolean");
asm.emitConstantPoolClass(asm.cpi());
booleanIdx = asm.cpi();
asm.emitConstantPoolUTF8("(Z)Ljava/lang/Boolean;");
asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());
booleanBoxIdx = asm.cpi();
asm.emitConstantPoolUTF8("booleanValue");
asm.emitConstantPoolUTF8("()Z");
asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());
booleanUnboxIdx = asm.cpi();
asm.emitConstantPoolUTF8("java/lang/Byte");
asm.emitConstantPoolClass(asm.cpi());
byteIdx = asm.cpi();
asm.emitConstantPoolUTF8("(B)Ljava/lang/Byte;");
asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());
byteBoxIdx = asm.cpi();
asm.emitConstantPoolUTF8("byteValue");
asm.emitConstantPoolUTF8("()B");
asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());
byteUnboxIdx = asm.cpi();
asm.emitConstantPoolUTF8("java/lang/Character");
asm.emitConstantPoolClass(asm.cpi());
characterIdx = asm.cpi();
asm.emitConstantPoolUTF8("(C)Ljava/lang/Character;");
asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());
characterBoxIdx = asm.cpi();
asm.emitConstantPoolUTF8("charValue");
asm.emitConstantPoolUTF8("()C");
asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());
characterUnboxIdx = asm.cpi();
asm.emitConstantPoolUTF8("java/lang/Double");
asm.emitConstantPoolClass(asm.cpi());
doubleIdx = asm.cpi();
asm.emitConstantPoolUTF8("(D)Ljava/lang/Double;");
asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());
doubleBoxIdx = asm.cpi();
asm.emitConstantPoolUTF8("doubleValue");
asm.emitConstantPoolUTF8("()D");
asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());
doubleUnboxIdx = asm.cpi();
asm.emitConstantPoolUTF8("java/lang/Float");
asm.emitConstantPoolClass(asm.cpi());
floatIdx = asm.cpi();
asm.emitConstantPoolUTF8("(F)Ljava/lang/Float;");
asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());
floatBoxIdx = asm.cpi();
asm.emitConstantPoolUTF8("floatValue");
asm.emitConstantPoolUTF8("()F");
asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());
floatUnboxIdx = asm.cpi();
asm.emitConstantPoolUTF8("java/lang/Integer");
asm.emitConstantPoolClass(asm.cpi());
integerIdx = asm.cpi();
asm.emitConstantPoolUTF8("(I)Ljava/lang/Integer;");
asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());
integerBoxIdx = asm.cpi();
asm.emitConstantPoolUTF8("intValue");
asm.emitConstantPoolUTF8("()I");
asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());
integerUnboxIdx = asm.cpi();
asm.emitConstantPoolUTF8("java/lang/Long");
asm.emitConstantPoolClass(asm.cpi());
longIdx = asm.cpi();
asm.emitConstantPoolUTF8("(J)Ljava/lang/Long;");
asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());
longBoxIdx = asm.cpi();
asm.emitConstantPoolUTF8("longValue");
asm.emitConstantPoolUTF8("()J");
asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());
longUnboxIdx = asm.cpi();
asm.emitConstantPoolUTF8("java/lang/Short");
asm.emitConstantPoolClass(asm.cpi());
shortIdx = asm.cpi();
asm.emitConstantPoolUTF8("(S)Ljava/lang/Short;");
asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());
shortBoxIdx = asm.cpi();
asm.emitConstantPoolUTF8("shortValue");
asm.emitConstantPoolUTF8("()S");
asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());
asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());
shortUnboxIdx = asm.cpi();
}
protected static short add(short s1, short s2) {
return (short) (s1 + s2);
}
protected static short sub(short s1, short s2) {
return (short) (s1 - s2);
}
protected boolean isStatic() {
return Modifier.isStatic(modifiers);
}
protected boolean isPrivate() {
return Modifier.isPrivate(modifiers);
}
protected static String getClassName
(Class<?> c, boolean addPrefixAndSuffixForNonPrimitiveTypes)
{
if (c.isPrimitive()) {
if (c == Boolean.TYPE) {
return "Z";
} else if (c == Byte.TYPE) {
return "B";
} else if (c == Character.TYPE) {
return "C";
} else if (c == Double.TYPE) {
return "D";
} else if (c == Float.TYPE) {
return "F";
} else if (c == Integer.TYPE) {
return "I";
} else if (c == Long.TYPE) {
return "J";
} else if (c == Short.TYPE) {
return "S";
} else if (c == Void.TYPE) {
return "V";
}
throw new InternalError("Should have found primitive type");
} else if (c.isArray()) {
return "[" + getClassName(c.getComponentType(), true);
} else {
if (addPrefixAndSuffixForNonPrimitiveTypes) {
return internalize("L" + c.getName() + ";");
} else {
return internalize(c.getName());
}
}
}
private static String internalize(String className) {
return className.replace('.', '/');
}
protected void emitConstructor() {
ClassFileAssembler cb = new ClassFileAssembler();
cb.setMaxLocals(1);
cb.opc_aload_0();
cb.opc_invokespecial(superCtorIdx, 0, 0);
cb.opc_return();
emitMethod(initIdx, cb.getMaxLocals(), cb, null, null);
}
protected void emitMethod(short nameIdx,
int numArgs,
ClassFileAssembler code,
ClassFileAssembler exceptionTable,
short[] checkedExceptionIndices)
{
int codeLen = code.getLength();
int excLen  = 0;
if (exceptionTable != null) {
excLen = exceptionTable.getLength();
if ((excLen % 8) != 0) {
throw new IllegalArgumentException("Illegal exception table");
}
}
int attrLen = 12 + codeLen + excLen;
excLen = excLen / 8;
asm.emitShort(ACC_PUBLIC);
asm.emitShort(nameIdx);
asm.emitShort(add(nameIdx, S1));
if (checkedExceptionIndices == null) {
asm.emitShort(S1);
} else {
asm.emitShort(S2);
}
asm.emitShort(codeIdx);
asm.emitInt(attrLen);
asm.emitShort(code.getMaxStack());
asm.emitShort((short) Math.max(numArgs, code.getMaxLocals()));
asm.emitInt(codeLen);
asm.append(code);
asm.emitShort((short) excLen);
if (exceptionTable != null) {
asm.append(exceptionTable);
}
asm.emitShort(S0);         if (checkedExceptionIndices != null) {
asm.emitShort(exceptionsIdx);
asm.emitInt(2 + 2 * checkedExceptionIndices.length);
asm.emitShort((short) checkedExceptionIndices.length);
for (int i = 0; i < checkedExceptionIndices.length; i++) {
asm.emitShort(checkedExceptionIndices[i]);
}
}
}
protected short indexForPrimitiveType(Class<?> type) {
if (type == Boolean.TYPE) {
return booleanIdx;
} else if (type == Byte.TYPE) {
return byteIdx;
} else if (type == Character.TYPE) {
return characterIdx;
} else if (type == Double.TYPE) {
return doubleIdx;
} else if (type == Float.TYPE) {
return floatIdx;
} else if (type == Integer.TYPE) {
return integerIdx;
} else if (type == Long.TYPE) {
return longIdx;
} else if (type == Short.TYPE) {
return shortIdx;
}
throw new InternalError("Should have found primitive type");
}
protected short boxingMethodForPrimitiveType(Class<?> type) {
if (type == Boolean.TYPE) {
return booleanBoxIdx;
} else if (type == Byte.TYPE) {
return byteBoxIdx;
} else if (type == Character.TYPE) {
return characterBoxIdx;
} else if (type == Double.TYPE) {
return doubleBoxIdx;
} else if (type == Float.TYPE) {
return floatBoxIdx;
} else if (type == Integer.TYPE) {
return integerBoxIdx;
} else if (type == Long.TYPE) {
return longBoxIdx;
} else if (type == Short.TYPE) {
return shortBoxIdx;
}
throw new InternalError("Should have found primitive type");
}
protected static boolean canWidenTo(Class<?> type, Class<?> otherType) {
if (!type.isPrimitive()) {
return false;
}
if (type == Boolean.TYPE) {
if (otherType == Boolean.TYPE) {
return true;
}
} else if (type == Byte.TYPE) {
if (   otherType == Byte.TYPE
|| otherType == Short.TYPE
|| otherType == Integer.TYPE
|| otherType == Long.TYPE
|| otherType == Float.TYPE
|| otherType == Double.TYPE) {
return true;
}
} else if (type == Short.TYPE) {
if (   otherType == Short.TYPE
|| otherType == Integer.TYPE
|| otherType == Long.TYPE
|| otherType == Float.TYPE
|| otherType == Double.TYPE) {
return true;
}
} else if (type == Character.TYPE) {
if (   otherType == Character.TYPE
|| otherType == Integer.TYPE
|| otherType == Long.TYPE
|| otherType == Float.TYPE
|| otherType == Double.TYPE) {
return true;
}
} else if (type == Integer.TYPE) {
if (   otherType == Integer.TYPE
|| otherType == Long.TYPE
|| otherType == Float.TYPE
|| otherType == Double.TYPE) {
return true;
}
} else if (type == Long.TYPE) {
if (   otherType == Long.TYPE
|| otherType == Float.TYPE
|| otherType == Double.TYPE) {
return true;
}
} else if (type == Float.TYPE) {
if (   otherType == Float.TYPE
|| otherType == Double.TYPE) {
return true;
}
} else if (type == Double.TYPE) {
if (otherType == Double.TYPE) {
return true;
}
}
return false;
}
protected static void emitWideningBytecodeForPrimitiveConversion
(ClassFileAssembler cb,
Class<?> fromType,
Class<?> toType)
{
if (   fromType == Byte.TYPE
|| fromType == Short.TYPE
|| fromType == Character.TYPE
|| fromType == Integer.TYPE) {
if (toType == Long.TYPE) {
cb.opc_i2l();
} else if (toType == Float.TYPE) {
cb.opc_i2f();
} else if (toType == Double.TYPE) {
cb.opc_i2d();
}
} else if (fromType == Long.TYPE) {
if (toType == Float.TYPE) {
cb.opc_l2f();
} else if (toType == Double.TYPE) {
cb.opc_l2d();
}
} else if (fromType == Float.TYPE) {
if (toType == Double.TYPE) {
cb.opc_f2d();
}
}
}
protected short unboxingMethodForPrimitiveType(Class<?> primType) {
if (primType == Boolean.TYPE) {
return booleanUnboxIdx;
} else if (primType == Byte.TYPE) {
return byteUnboxIdx;
} else if (primType == Character.TYPE) {
return characterUnboxIdx;
} else if (primType == Short.TYPE) {
return shortUnboxIdx;
} else if (primType == Integer.TYPE) {
return integerUnboxIdx;
} else if (primType == Long.TYPE) {
return longUnboxIdx;
} else if (primType == Float.TYPE) {
return floatUnboxIdx;
} else if (primType == Double.TYPE) {
return doubleUnboxIdx;
}
throw new InternalError("Illegal primitive type " + primType.getName());
}
protected static final Class<?>[] primitiveTypes = new Class<?>[] {
Boolean.TYPE,
Byte.TYPE,
Character.TYPE,
Short.TYPE,
Integer.TYPE,
Long.TYPE,
Float.TYPE,
Double.TYPE
};
protected static boolean isPrimitive(Class<?> c) {
return (c.isPrimitive() && c != Void.TYPE);
}
protected int typeSizeInStackSlots(Class<?> c) {
if (c == Void.TYPE) {
return 0;
}
if (c == Long.TYPE || c == Double.TYPE) {
return 2;
}
return 1;
}
private ClassFileAssembler illegalArgumentCodeBuffer;
protected ClassFileAssembler illegalArgumentCodeBuffer() {
if (illegalArgumentCodeBuffer == null) {
illegalArgumentCodeBuffer = new ClassFileAssembler();
illegalArgumentCodeBuffer.opc_new(illegalArgumentClass);
illegalArgumentCodeBuffer.opc_dup();
illegalArgumentCodeBuffer.opc_invokespecial(illegalArgumentCtorIdx, 0, 0);
illegalArgumentCodeBuffer.opc_athrow();
}
return illegalArgumentCodeBuffer;
}
}
package jdk.internal.reflect;
import java.lang.invoke.WrongMethodTypeException;
import java.util.Set;
public class AccessorUtils {
static boolean isIllegalArgument(Class<?> accessorType, RuntimeException e) {
assert(e instanceof ClassCastException || e instanceof NullPointerException ||
e instanceof WrongMethodTypeException);
StackTraceElement[] stackTrace = e.getStackTrace();
if (stackTrace.length == 0) {
return false;               }
int i = 0;
StackTraceElement frame = stackTrace[0];
if ((frame.getClassName().equals("java.lang.Class") && frame.getMethodName().equals("cast"))
|| (frame.getClassName().equals("java.util.Objects") && frame.getMethodName().equals("requiresNonNull"))) {
i++;
}
for (; i < stackTrace.length; i++) {
frame = stackTrace[i];
String cname = frame.getClassName();
if (cname.equals(accessorType.getName())) {
return true;
}
if (frame.getModuleName() == null || !frame.getModuleName().equals("java.base")) {
return false;
}
int index = cname.lastIndexOf(".");
String pn = index > 0 ? cname.substring(0, index) : "";
if (!IMPL_PACKAGES.contains(pn)) {
return false;
}
if ((accessorType == DirectMethodHandleAccessor.class
&& cname.startsWith(DirectConstructorHandleAccessor.class.getName()))
|| (accessorType == DirectConstructorHandleAccessor.class
&& cname.startsWith(DirectMethodHandleAccessor.class.getName()))) {
return false;
}
}
return false;
}
private static final Set<String> IMPL_PACKAGES = Set.of(
"java.lang.reflect",
"java.lang.invoke",
"jdk.internal.reflect",
"sun.invoke.util"
);
}
package com.sun.jdi.event;
import com.sun.jdi.VirtualMachine;
public interface AccessWatchpointEvent extends WatchpointEvent {
}
package com.sun.jdi.request;
import com.sun.jdi.event.AccessWatchpointEvent;
import com.sun.jdi.event.EventQueue;
import com.sun.jdi.event.EventSet;
public interface AccessWatchpointRequest extends WatchpointRequest {
}
package com.sun.tools.example.debug.tty;
import com.sun.jdi.*;
import com.sun.jdi.request.*;
class AccessWatchpointSpec extends WatchpointSpec {
AccessWatchpointSpec(ReferenceTypeSpec refSpec, String fieldId)
throws MalformedMemberNameException {
super(refSpec, fieldId);
}
@Override
EventRequest resolveEventRequest(ReferenceType refType)
throws NoSuchFieldException {
Field field = refType.fieldByName(fieldId);
EventRequestManager em = refType.virtualMachine().eventRequestManager();
EventRequest wp = em.createAccessWatchpointRequest(field);
wp.setSuspendPolicy(suspendPolicy);
wp.enable();
return wp;
}
@Override
public String toString() {
return MessageOutput.format("watch accesses of",
new Object [] {refSpec.toString(),
fieldId});
}
}
import jdk.internal.org.objectweb.asm.*;
public class ACCModule52 {
static final String CLASS_NAME = "ACCModule52Pkg";
public static void main(String[] args) throws Exception {
int ACC_MODULE = 0x8000;
ClassWriter cw = new ClassWriter(0);
cw.visit(Opcodes.V1_8,
Opcodes.ACC_INTERFACE + Opcodes.ACC_ABSTRACT + Opcodes.ACC_SYNTHETIC + ACC_MODULE,
CLASS_NAME,
null,
"java/lang/Object",
null);
cw.visitEnd();
byte[] bytes = cw.toByteArray();
ClassLoader loader = new ClassLoader(ACCModule52.class.getClassLoader()) {
@Override
protected Class<?> findClass(String cn)throws ClassNotFoundException {
if (cn.equals(CLASS_NAME)) {
Class superClass = super.defineClass(cn, bytes, 0, bytes.length);
} else {
throw new ClassNotFoundException(cn);
}
return null;
}
};
Class<?> clazz = loader.loadClass(CLASS_NAME);
}
}
package javax.security.auth.login;
public class AccountException extends LoginException {
@java.io.Serial
private static final long serialVersionUID = -2112878680072211787L;
public AccountException() {
super();
}
public AccountException(String msg) {
super(msg);
}
}
package javax.security.auth.login;
public class AccountExpiredException extends AccountException {
@java.io.Serial
private static final long serialVersionUID = -6064064890162661560L;
public AccountExpiredException() {
super();
}
public AccountExpiredException(String msg) {
super(msg);
}
}
package javax.security.auth.login;
public class AccountLockedException extends AccountException {
@java.io.Serial
private static final long serialVersionUID = 8280345554014066334L;
public AccountLockedException() {
super();
}
public AccountLockedException(String msg) {
super(msg);
}
}
package javax.security.auth.login;
public class AccountNotFoundException extends AccountException {
@java.io.Serial
private static final long serialVersionUID = 1498349563916294614L;
public AccountNotFoundException() {
super();
}
public AccountNotFoundException(String msg) {
super(msg);
}
}
package sun.swing;
import java.util.*;
import java.lang.reflect.Array;
import javax.swing.SwingUtilities;
public abstract class AccumulativeRunnable<T> implements Runnable {
private List<T> arguments = null;
protected abstract void run(List<T> args);
public final void run() {
run(flush());
}
@SafeVarargs
@SuppressWarnings("varargs")     public final synchronized void add(T... args) {
boolean isSubmitted = true;
if (arguments == null) {
isSubmitted = false;
arguments = new ArrayList<T>();
}
Collections.addAll(arguments, args);
if (!isSubmitted) {
submit();
}
}
protected void submit() {
SwingUtilities.invokeLater(this);
}
private synchronized List<T> flush() {
List<T> list = arguments;
arguments = null;
return list;
}
}
package java2d.demos.Composite;
import static java.awt.Color.BLACK;
import static java.awt.Color.BLUE;
import static java.awt.Color.CYAN;
import static java.awt.Color.GREEN;
import static java.awt.Color.LIGHT_GRAY;
import static java.awt.Color.MAGENTA;
import static java.awt.Color.ORANGE;
import static java.awt.Color.PINK;
import static java.awt.Color.RED;
import static java.awt.Color.WHITE;
import static java.awt.Color.YELLOW;
import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Shape;
import java.awt.font.TextLayout;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RoundRectangle2D;
import java2d.Surface;
@SuppressWarnings("serial")
public class ACimages extends Surface {
private static final String[] s = { "box", "fight", "magnify",
"boxwave", "globe", "snooze",
"tip", "thumbsup", "dukeplug" };
private static Image[] imgs = new Image[s.length];
private static Color[] colors = { BLUE, CYAN, GREEN,
MAGENTA, ORANGE, PINK, RED, YELLOW, LIGHT_GRAY };
public ACimages() {
setBackground(WHITE);
for (int i = 0; i < imgs.length; i++) {
imgs[i] = getImage(s[i] + ".png");
}
}
@Override
public void render(int w, int h, Graphics2D g2) {
float alpha = 0.0f;
int iw = w / 3;
int ih = (h - 45) / 3;
float xx = 0, yy = 15;
for (int i = 0; i < imgs.length; i++) {
xx = (i % 3 == 0) ? 0 : xx + w / 3;
switch (i) {
case 3:
yy = h / 3 + 15;
break;
case 6:
yy = h / 3 * 2 + 15;
}
g2.setComposite(AlphaComposite.SrcOver);
g2.setColor(BLACK);
AlphaComposite ac = AlphaComposite.SrcOver.derive(alpha += .1f);
String str = "a=" + Float.toString(alpha).substring(0, 3);
new TextLayout(str, g2.getFont(), g2.getFontRenderContext()).draw(g2, xx
+ 3, yy - 2);
Shape shape = null;
switch (i % 3) {
case 0:
shape = new Ellipse2D.Float(xx, yy, iw, ih);
break;
case 1:
shape = new RoundRectangle2D.Float(xx, yy, iw, ih, 25, 25);
break;
case 2:
shape = new Rectangle2D.Float(xx, yy, iw, ih);
break;
}
g2.setColor(colors[i]);
g2.setComposite(ac);
g2.fill(shape);
g2.drawImage(imgs[i], (int) xx, (int) yy, iw, ih, null);
}
}
public static void main(String[] s) {
createDemoFrame(new ACimages());
}
}
package java.nio.file.attribute;
import java.util.*;
public final class AclEntry {
private final AclEntryType type;
private final UserPrincipal who;
private final Set<AclEntryPermission> perms;
private final Set<AclEntryFlag> flags;
private volatile int hash;
private AclEntry(AclEntryType type,
UserPrincipal who,
Set<AclEntryPermission> perms,
Set<AclEntryFlag> flags)
{
this.type = type;
this.who = who;
this.perms = perms;
this.flags = flags;
}
public static final class Builder {
private AclEntryType type;
private UserPrincipal who;
private Set<AclEntryPermission> perms;
private Set<AclEntryFlag> flags;
private Builder(AclEntryType type,
UserPrincipal who,
Set<AclEntryPermission> perms,
Set<AclEntryFlag> flags)
{
assert perms != null && flags != null;
this.type = type;
this.who = who;
this.perms = perms;
this.flags = flags;
}
public AclEntry build() {
if (type == null)
throw new IllegalStateException("Missing type component");
if (who == null)
throw new IllegalStateException("Missing who component");
return new AclEntry(type, who, perms, flags);
}
public Builder setType(AclEntryType type) {
if (type == null)
throw new NullPointerException();
this.type = type;
return this;
}
public Builder setPrincipal(UserPrincipal who) {
if (who == null)
throw new NullPointerException();
this.who = who;
return this;
}
private static void checkSet(Set<?> set, Class<?> type) {
for (Object e: set) {
if (e == null)
throw new NullPointerException();
type.cast(e);
}
}
public Builder setPermissions(Set<AclEntryPermission> perms) {
if (perms.isEmpty()) {
perms = Collections.emptySet();
} else {
perms = EnumSet.copyOf(perms);
checkSet(perms, AclEntryPermission.class);
}
this.perms = perms;
return this;
}
public Builder setPermissions(AclEntryPermission... perms) {
Set<AclEntryPermission> set = EnumSet.noneOf(AclEntryPermission.class);
for (AclEntryPermission p: perms) {
if (p == null)
throw new NullPointerException();
set.add(p);
}
this.perms = set;
return this;
}
public Builder setFlags(Set<AclEntryFlag> flags) {
if (flags.isEmpty()) {
flags = Collections.emptySet();
} else {
flags = EnumSet.copyOf(flags);
checkSet(flags, AclEntryFlag.class);
}
this.flags = flags;
return this;
}
public Builder setFlags(AclEntryFlag... flags) {
Set<AclEntryFlag> set = EnumSet.noneOf(AclEntryFlag.class);
for (AclEntryFlag f: flags) {
if (f == null)
throw new NullPointerException();
set.add(f);
}
this.flags = set;
return this;
}
}
public static Builder newBuilder() {
Set<AclEntryPermission> perms = Collections.emptySet();
Set<AclEntryFlag> flags = Collections.emptySet();
return new Builder(null, null, perms, flags);
}
public static Builder newBuilder(AclEntry entry) {
return new Builder(entry.type, entry.who, entry.perms, entry.flags);
}
public AclEntryType type() {
return type;
}
public UserPrincipal principal() {
return who;
}
public Set<AclEntryPermission> permissions() {
return new HashSet<>(perms);
}
public Set<AclEntryFlag> flags() {
return new HashSet<>(flags);
}
@Override
public boolean equals(Object ob) {
if (ob == this)
return true;
if (!(ob instanceof AclEntry other))
return false;
if (this.type != other.type)
return false;
if (!this.who.equals(other.who))
return false;
if (!this.perms.equals(other.perms))
return false;
if (!this.flags.equals(other.flags))
return false;
return true;
}
private static int hash(int h, Object o) {
return h * 127 + o.hashCode();
}
@Override
public int hashCode() {
if (hash != 0)
return hash;
int h = type.hashCode();
h = hash(h, who);
h = hash(h, perms);
h = hash(h, flags);
hash = h;
return hash;
}
@Override
public String toString() {
StringBuilder sb = new StringBuilder();
sb.append(who.getName());
sb.append(':');
for (AclEntryPermission perm: perms) {
sb.append(perm.name());
sb.append('/');
}
sb.setLength(sb.length()-1);         sb.append(':');
if (!flags.isEmpty()) {
for (AclEntryFlag flag: flags) {
sb.append(flag.name());
sb.append('/');
}
sb.setLength(sb.length()-1);              sb.append(':');
}
sb.append(type.name());
return sb.toString();
}
}
package java.nio.file.attribute;
public enum AclEntryFlag {
FILE_INHERIT,
DIRECTORY_INHERIT,
NO_PROPAGATE_INHERIT,
INHERIT_ONLY;
}
package java.nio.file.attribute;
public enum AclEntryPermission {
READ_DATA,
WRITE_DATA,
APPEND_DATA,
READ_NAMED_ATTRS,
WRITE_NAMED_ATTRS,
EXECUTE,
DELETE_CHILD,
READ_ATTRIBUTES,
WRITE_ATTRIBUTES,
DELETE,
READ_ACL,
WRITE_ACL,
WRITE_OWNER,
SYNCHRONIZE;
public static final AclEntryPermission LIST_DIRECTORY = READ_DATA;
public static final AclEntryPermission ADD_FILE = WRITE_DATA;
public static final AclEntryPermission ADD_SUBDIRECTORY = APPEND_DATA;
}
package java.nio.file.attribute;
public enum AclEntryType {
ALLOW,
DENY,
AUDIT,
ALARM
}
package java.nio.file.attribute;
import java.nio.file.*;
import java.util.List;
import java.io.IOException;
public interface AclFileAttributeView
extends FileOwnerAttributeView
{
@Override
String name();
List<AclEntry> getAcl() throws IOException;
void setAcl(List<AclEntry> acl) throws IOException;
}
package com.sun.org.apache.bcel.internal.generic;
public class ACONST_NULL extends Instruction implements PushInstruction, TypedInstruction {
public ACONST_NULL() {
super(com.sun.org.apache.bcel.internal.Const.ACONST_NULL, (short) 1);
}
@Override
public Type getType( final ConstantPoolGen cp ) {
return Type.NULL;
}
@Override
public void accept( final Visitor v ) {
v.visitStackProducer(this);
v.visitPushInstruction(this);
v.visitTypedInstruction(this);
v.visitACONST_NULL(this);
}
}
package java2d.demos.Composite;
import static java.awt.AlphaComposite.Clear;
import static java.awt.AlphaComposite.Dst;
import static java.awt.AlphaComposite.DstAtop;
import static java.awt.AlphaComposite.DstIn;
import static java.awt.AlphaComposite.DstOut;
import static java.awt.AlphaComposite.DstOver;
import static java.awt.AlphaComposite.Src;
import static java.awt.AlphaComposite.SrcAtop;
import static java.awt.AlphaComposite.SrcIn;
import static java.awt.AlphaComposite.SrcOut;
import static java.awt.AlphaComposite.SrcOver;
import static java.awt.AlphaComposite.Xor;
import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Font;
import java.awt.GradientPaint;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.font.FontRenderContext;
import java.awt.font.LineMetrics;
import java.awt.font.TextLayout;
import java.awt.geom.GeneralPath;
import java.awt.image.BufferedImage;
import java2d.AnimatingSurface;
@SuppressWarnings("serial")
public class ACrules extends AnimatingSurface {
private static String[] compNames = {
"Src",
"SrcOver",
"SrcIn",
"SrcOut",
"SrcAtop",
"Clear",
"Dst",
"DstOver",
"DstIn",
"DstOut",
"DstAtop",
"Xor", };
private static final AlphaComposite[] compObjs = {
Src, SrcOver, SrcIn, SrcOut, SrcAtop, Clear,
Dst, DstOver, DstIn, DstOut, DstAtop, Xor, };
private static final int NUM_RULES = compObjs.length;
private static final int HALF_NUM_RULES = NUM_RULES / 2;
private int fadeIndex;
private static float[][] fadeValues = {
{ 1.0f, -0.1f, 0.0f, 1.0f, 0.0f, 1.0f },
{ 0.0f, 0.1f, 1.0f, 1.0f, -0.1f, 0.0f },
{ 1.0f, 0.0f, 1.0f, 0.0f, 0.1f, 1.0f }, };
private static String[] fadeNames = {
"Src => transparent, Dest opaque",
"Src => opaque, Dest => transparent",
"Src opaque, Dest => opaque", };
private static Font f = new Font("serif", Font.PLAIN, 10);
private float srca = fadeValues[fadeIndex][0];
private float dsta = fadeValues[fadeIndex][3];
private String fadeLabel = fadeNames[0];
private BufferedImage statBI, animBI;
private int PADLEFT, PADRIGHT, HPAD;
private int PADABOVE, PADBELOW, VPAD;
private int RECTWIDTH, RECTHEIGHT;
private int PADDEDHEIGHT;
private GeneralPath srcpath = new GeneralPath();
private GeneralPath dstpath = new GeneralPath();
private LineMetrics lm;
private BufferedImage dBI, sBI;
private GradientPaint gradientDst, gradientSrc;
public ACrules() {
setBackground(Color.white);
}
@Override
public void reset(int w, int h) {
setSleepAmount(400);
FontRenderContext frc = new FontRenderContext(null, false, false);
lm = f.getLineMetrics(compNames[0], frc);
PADLEFT = (w < 150) ? 10 : 15;
PADRIGHT = (w < 150) ? 10 : 15;
HPAD = (PADLEFT + PADRIGHT);
PADBELOW = (h < 250) ? 1 : 2;
PADABOVE = PADBELOW + (int) lm.getHeight();
VPAD = (PADABOVE + PADBELOW);
RECTWIDTH = w / 4 - HPAD;
RECTWIDTH = (RECTWIDTH < 6) ? 6 : RECTWIDTH;
RECTHEIGHT = (h - VPAD) / HALF_NUM_RULES - VPAD;
RECTHEIGHT = (RECTHEIGHT < 6) ? 6 : RECTHEIGHT;
PADDEDHEIGHT = (RECTHEIGHT + VPAD);
srcpath.reset();
srcpath.moveTo(0, 0);
srcpath.lineTo(RECTWIDTH, 0);
srcpath.lineTo(0, RECTHEIGHT);
srcpath.closePath();
dstpath.reset();
dstpath.moveTo(0, 0);
dstpath.lineTo(RECTWIDTH, RECTHEIGHT);
dstpath.lineTo(RECTWIDTH, 0);
dstpath.closePath();
dBI = new BufferedImage(RECTWIDTH, RECTHEIGHT,
BufferedImage.TYPE_INT_ARGB);
sBI = new BufferedImage(RECTWIDTH, RECTHEIGHT,
BufferedImage.TYPE_INT_ARGB);
gradientDst = new GradientPaint(0, 0,
new Color(1.0f, 0.0f, 0.0f, 1.0f),
0, RECTHEIGHT,
new Color(1.0f, 0.0f, 0.0f, 0.0f));
gradientSrc = new GradientPaint(0, 0,
new Color(0.0f, 0.0f, 1.0f, 1.0f),
RECTWIDTH, 0,
new Color(0.0f, 0.0f, 1.0f, 0.0f));
statBI = new BufferedImage(w / 2, h, BufferedImage.TYPE_INT_RGB);
statBI = drawCompBI(statBI, true);
animBI = new BufferedImage(w / 2, h, BufferedImage.TYPE_INT_RGB);
}
@Override
public void step(int w, int h) {
if (getSleepAmount() == 5000) {
setSleepAmount(200);
}
srca = srca + fadeValues[fadeIndex][1];
dsta = dsta + fadeValues[fadeIndex][4];
fadeLabel = fadeNames[fadeIndex];
if (srca < 0 || srca > 1.0 || dsta < 0 || dsta > 1.0) {
setSleepAmount(5000);
srca = fadeValues[fadeIndex][2];
dsta = fadeValues[fadeIndex][5];
if (fadeIndex++ == fadeValues.length - 1) {
fadeIndex = 0;
}
}
}
@Override
public void render(int w, int h, Graphics2D g2) {
if (statBI == null || animBI == null) {
return;
}
g2.drawImage(statBI, 0, 0, null);
g2.drawImage(drawCompBI(animBI, false), w / 2, 0, null);
g2.setColor(Color.black);
FontRenderContext frc = g2.getFontRenderContext();
TextLayout tl = new TextLayout("AC Rules", g2.getFont(), frc);
tl.draw(g2, 15.0f, (float) tl.getBounds().getHeight() + 3.0f);
tl = new TextLayout(fadeLabel, f, frc);
float x = (float) (w * 0.75 - tl.getBounds().getWidth() / 2);
if ((x + tl.getBounds().getWidth()) > w) {
x = (float) (w - tl.getBounds().getWidth());
}
tl.draw(g2, x, (float) tl.getBounds().getHeight() + 3.0f);
}
private BufferedImage drawCompBI(BufferedImage bi, boolean doGradient) {
Graphics2D big = bi.createGraphics();
big.setColor(getBackground());
big.fillRect(0, 0, bi.getWidth(), bi.getHeight());
big.setRenderingHint(RenderingHints.KEY_ANTIALIASING, AntiAlias);
big.setFont(f);
Graphics2D gD = dBI.createGraphics();
gD.setRenderingHint(RenderingHints.KEY_ANTIALIASING, AntiAlias);
Graphics2D gS = sBI.createGraphics();
gS.setRenderingHint(RenderingHints.KEY_ANTIALIASING, AntiAlias);
int x = 0, y = 0;
int yy = (int) lm.getHeight() + VPAD;
for (int i = 0; i < compNames.length; i++) {
y = (i == 0 || i == HALF_NUM_RULES) ? yy : y + PADDEDHEIGHT;
x = (i >= HALF_NUM_RULES) ? bi.getWidth() / 2 + PADLEFT : PADLEFT;
big.translate(x, y);
gD.setComposite(Clear);
gD.fillRect(0, 0, RECTWIDTH, RECTHEIGHT);
gD.setComposite(Src);
if (doGradient) {
gD.setPaint(gradientDst);
gD.fillRect(0, 0, RECTWIDTH, RECTHEIGHT);
} else {
gD.setPaint(new Color(1.0f, 0.0f, 0.0f, dsta));
gD.fill(dstpath);
}
gS.setComposite(Clear);
gS.fillRect(0, 0, RECTWIDTH, RECTHEIGHT);
gS.setComposite(Src);
if (doGradient) {
gS.setPaint(gradientSrc);
gS.fillRect(0, 0, RECTWIDTH, RECTHEIGHT);
} else {
gS.setPaint(new Color(0.0f, 0.0f, 1.0f, srca));
gS.fill(srcpath);
}
gD.setComposite(compObjs[i]);
gD.drawImage(sBI, 0, 0, null);
big.drawImage(dBI, 0, 0, null);
big.setColor(Color.black);
big.drawString(compNames[i], 0, -lm.getDescent());
big.drawRect(0, 0, RECTWIDTH, RECTHEIGHT);
big.translate(-x, -y);
}
gD.dispose();
gS.dispose();
big.dispose();
return bi;
}
public static void main(String[] argv) {
createDemoFrame(new ACrules());
}
}
package javax.swing;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
public interface Action extends ActionListener {
public static final String DEFAULT = "Default";
public static final String NAME = "Name";
public static final String SHORT_DESCRIPTION = "ShortDescription";
public static final String LONG_DESCRIPTION = "LongDescription";
public static final String SMALL_ICON = "SmallIcon";
public static final String ACTION_COMMAND_KEY = "ActionCommandKey";
public static final String ACCELERATOR_KEY="AcceleratorKey";
public static final String MNEMONIC_KEY="MnemonicKey";
public static final String SELECTED_KEY = "SwingSelectedKey";
public static final String DISPLAYED_MNEMONIC_INDEX_KEY =
"SwingDisplayedMnemonicIndexKey";
public static final String LARGE_ICON_KEY = "SwingLargeIconKey";
public Object getValue(String key);
public void putValue(String key, Object value);
public void setEnabled(boolean b);
public boolean isEnabled();
default boolean accept(Object sender) {
return isEnabled();
}
public void addPropertyChangeListener(PropertyChangeListener listener);
public void removePropertyChangeListener(PropertyChangeListener listener);
}
package java.awt.event;
import java.awt.AWTEvent;
import java.io.Serial;
import java.lang.annotation.Native;
public class ActionEvent extends AWTEvent {
public static final int SHIFT_MASK = 1 << 0;
public static final int CTRL_MASK = 1 << 1;
public static final int META_MASK = 1 << 2;
public static final int ALT_MASK = 1 << 3;
public static final int ACTION_FIRST                = 1001;
public static final int ACTION_LAST                 = 1001;
@Native public static final int ACTION_PERFORMED    = ACTION_FIRST;
String actionCommand;
long when;
int modifiers;
@Serial
private static final long serialVersionUID = -7671078796273832149L;
public ActionEvent(Object source, int id, String command) {
this(source, id, command, 0);
}
public ActionEvent(Object source, int id, String command, int modifiers) {
this(source, id, command, 0, modifiers);
}
public ActionEvent(Object source, int id, String command, long when,
int modifiers) {
super(source, id);
this.actionCommand = command;
this.when = when;
this.modifiers = modifiers;
}
public String getActionCommand() {
return actionCommand;
}
public long getWhen() {
return when;
}
public int getModifiers() {
return modifiers;
}
@SuppressWarnings("deprecation")
public String paramString() {
String typeStr;
switch(id) {
case ACTION_PERFORMED:
typeStr = "ACTION_PERFORMED";
break;
default:
typeStr = "unknown type";
}
return typeStr + ",cmd="+actionCommand+",when="+when+",modifiers="+
KeyEvent.getKeyModifiersText(modifiers);
}
}
package jdk.test.failurehandler.action;
import jdk.test.failurehandler.value.InvalidValueException;
import jdk.test.failurehandler.value.Value;
import jdk.test.failurehandler.value.ValueHandler;
import jdk.test.failurehandler.HtmlSection;
import jdk.test.failurehandler.Stopwatch;
import jdk.test.failurehandler.Utils;
import java.io.BufferedReader;
import java.io.CharArrayReader;
import java.io.CharArrayWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Writer;
import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Properties;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.TimeUnit;
public class ActionHelper {
private final Path workDir;
@Value(name = "execSuffix")
private String executableSuffix = "";
private Path[] paths;
private final PatternAction getChildren;
public ActionHelper(Path workDir, String prefix, Properties properties,
Path... jdks) throws InvalidValueException {
this.workDir = workDir.toAbsolutePath();
getChildren = new PatternAction(null,
Utils.prependPrefix(prefix, "getChildren"), properties);
ValueHandler.apply(this, properties, prefix);
String[] pathStrings = System.getenv("PATH").split(File.pathSeparator);
paths = new Path[pathStrings.length];
for (int i = 0; i < paths.length; ++i) {
paths[i] = Paths.get(pathStrings[i]);
}
addJdks(jdks);
}
public List<Long> getChildren(HtmlSection section, long pid) {
String pidStr = "" + pid;
ProcessBuilder pb = getChildren.prepareProcess(section, this, pidStr);
PrintWriter log = getChildren.getSection(section).getWriter();
CharArrayWriter writer = new CharArrayWriter();
ExitCode code = run(log, writer, pb, getChildren.getParameters());
Reader output = new CharArrayReader(writer.toCharArray());
if (!ExitCode.OK.equals(code)) {
log.println("WARNING: get children pids action failed");
try {
Utils.copyStream(output, log);
} catch (IOException e) {
e.printStackTrace(log);
}
return Collections.emptyList();
}
List<Long> result = new ArrayList<>();
try {
try (BufferedReader reader = new BufferedReader(output)) {
String line;
while ((line = reader.readLine()) != null) {
String value = line.trim();
if (value.isEmpty()) {
continue;
}
try {
result.add(Long.valueOf(value));
} catch (NumberFormatException e) {
log.printf("WARNING: can't parse child pid %s : %s%n",
line, e.getMessage());
e.printStackTrace(log);
}
}
}
} catch (IOException e) {
e.printStackTrace(log);
}
return result;
}
public ProcessBuilder prepareProcess(PrintWriter log, String app,
String... args) {
File appBin = findApp(app);
if (appBin == null) {
log.printf("ERROR: can't find %s in %s.%n",
app, Arrays.toString(paths));
return null;
}
List<String> command = new ArrayList<>(args.length + 1);
command.add(appBin.toString());
Collections.addAll(command, args);
return new ProcessBuilder()
.command(command)
.directory(workDir.toFile());
}
public File findApp(String app) {
String name = app + executableSuffix;
for (Path pathElem : paths) {
File result = pathElem.resolve(name).toFile();
if (result.exists()) {
return result;
}
}
return null;
}
private void addJdks(Path[] jdkPaths) {
if (jdkPaths != null && jdkPaths.length != 0) {
Path[] result = new Path[jdkPaths.length + paths.length];
for (int i = 0; i < jdkPaths.length; ++i) {
result[i] = jdkPaths[i].resolve("bin");
}
System.arraycopy(paths, 0, result, jdkPaths.length, paths.length);
paths = result;
}
}
private ExitCode run(PrintWriter log, Writer out, ProcessBuilder pb,
ActionParameters params) {
char[] lineChars = new char[40];
Arrays.fill(lineChars, '-');
String line = new String(lineChars);
Stopwatch stopwatch = new Stopwatch();
stopwatch.start();
log.printf("%s%n[%tF %<tT] %s timeout=%s%n%1$s%n", line, new Date(), pb.command(), params.timeout);
Process process;
KillerTask killer;
ExitCode result = ExitCode.NEVER_STARTED;
try {
process = pb.start();
killer = new KillerTask(process);
killer.schedule(params.timeout);
Utils.copyStream(new InputStreamReader(process.getInputStream()),
out);
try {
result = new ExitCode(process.waitFor());
} catch (InterruptedException e) {
log.println("WARNING: interrupted when waiting for the tool:%n");
e.printStackTrace(log);
} finally {
killer.cancel();
}
if (killer.hasTimedOut()) {
log.printf(
"WARNING: tool timed out: killed process after %d ms%n",
params.timeout);
result = ExitCode.TIMED_OUT;
}
} catch (IOException e) {
log.printf("WARNING: caught IOException while running tool%n");
e.printStackTrace(log);
result = ExitCode.LAUNCH_ERROR;
}
stopwatch.stop();
log.printf("%s%n[%tF %<tT] exit code: %d time: %d ms%n%1$s%n",
line, new Date(), result.value,
TimeUnit.NANOSECONDS.toMillis(stopwatch.getElapsedTimeNs()));
return result;
}
public void runPatternAction(SimpleAction action, HtmlSection section) {
if (action != null) {
HtmlSection subSection = action.getSection(section);
PrintWriter log = subSection.getWriter();
ProcessBuilder pb = action.prepareProcess(log, this);
exec(subSection, pb, action.getParameters());
}
}
public void runPatternAction(PatternAction action, HtmlSection section,
String value) {
if (action != null) {
ProcessBuilder pb = action.prepareProcess(section, this, value);
HtmlSection subSection = action.getSection(section);
exec(subSection, pb, action.getParameters());
}
}
public boolean isJava(long pid, PrintWriter log) {
ProcessBuilder pb = prepareProcess(log, "jps", "-q");
if (pb == null) {
return false;
}
pb.redirectErrorStream(true);
boolean result = false;
String pidStr = "" + pid;
try {
Process process = pb.start();
try (BufferedReader reader = new BufferedReader(
new InputStreamReader(process.getInputStream()))) {
String line;
while ((line = reader.readLine()) != null){
if (pidStr.equals(line)) {
result = true;
}
}
}
process.waitFor();
} catch (IOException e) {
log.printf("WARNING: can't run jps : %s%n", e.getMessage());
e.printStackTrace(log);
} catch (InterruptedException e) {
log.printf("WARNING: interrupted%n");
e.printStackTrace(log);
}
return result;
}
private static class KillerTask extends TimerTask {
private static final Timer WATCHDOG = new Timer("WATCHDOG", true);
private final Process process;
private boolean timedOut;
public KillerTask(Process process) {
this.process = process;
}
public void run() {
try {
process.exitValue();
} catch (IllegalThreadStateException e) {
process.destroyForcibly();
timedOut = true;
}
}
public boolean hasTimedOut() {
return timedOut;
}
public void schedule(long timeout) {
if (timeout > 0) {
WATCHDOG.schedule(this, timeout);
}
}
}
private void exec(HtmlSection section, ProcessBuilder process,
ActionParameters params) {
if (process == null) {
return;
}
PrintWriter sectionWriter = section.getWriter();
if (params.repeat > 1) {
for (int i = 0, n = params.repeat; i < n; ++i) {
HtmlSection iteration = section.createChildren(
String.format("iteration_%d", i));
PrintWriter writer = iteration.getWriter();
ExitCode exitCode = run(writer, writer, process, params);
if (params.stopOnError && !ExitCode.OK.equals(exitCode)) {
sectionWriter.printf(
"ERROR: non zero exit code[%d] -- break.",
exitCode.value);
break;
}
if (i < n - 1) {
try {
Thread.sleep(params.pause);
} catch (InterruptedException e) {
sectionWriter.printf(
"WARNING: interrupted while sleeping between invocations");
e.printStackTrace(sectionWriter);
}
}
}
} else {
run(section.getWriter(), section.getWriter(), process, params);
}
}
private static class ExitCode {
public static final ExitCode OK = new ExitCode(0);
public static final ExitCode LAUNCH_ERROR = new ExitCode(-1);
public static final ExitCode TIMED_OUT = new ExitCode(-2);
public static final ExitCode NEVER_STARTED = new ExitCode(-3);
public final int value;
private ExitCode(int value) {
this.value = value;
}
@Override
public boolean equals(Object o) {
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
ExitCode exitCode = (ExitCode) o;
return value == exitCode.value;
}
@Override
public int hashCode() {
return value;
}
}
}
package java.awt.event;
import java.util.EventListener;
public interface ActionListener extends EventListener {
public void actionPerformed(ActionEvent e);
}
package com.sun.java.swing.action;
import java.util.HashMap;
import javax.swing.Action;
import javax.swing.ImageIcon;
public abstract class ActionManager
{
protected ActionManager()
{
actions = new HashMap<>();
addActions();
}
public static ActionManager getInstance()
{
return manager;
}
protected static void setInstance(ActionManager m)
{
manager = m;
}
protected abstract void addActions();
protected void addAction(String cmdname, Action action)
{
actions.put(cmdname, action);
}
public Action getAction(String key)
{
return (Action)actions.get(key);
}
public DelegateAction getDelegateAction(String name)
{
Action a = getAction(name);
if(a instanceof DelegateAction)
return (DelegateAction)a;
else
return null;
}
public StateChangeAction getStateChangeAction(String name)
{
Action a = getAction(name);
if(a instanceof StateChangeAction)
return (StateChangeAction)a;
else
return null;
}
public static ImageIcon getIcon(String name)
{
return utilities.getIcon(name);
}
public void setActionEnabled(String name, boolean enabled)
{
Action action = getAction(name);
if(action != null)
action.setEnabled(enabled);
}
private HashMap<String, Action> actions;
private static ActionUtilities utilities = new ActionUtilities();
private static ActionManager manager;
}
package javax.swing;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serial;
import java.io.Serializable;
import java.util.HashMap;
@SuppressWarnings("serial")
public class ActionMap implements Serializable {
private transient ArrayTable     arrayTable;
private ActionMap                               parent;
public ActionMap() {
}
public void setParent(ActionMap map) {
this.parent = map;
}
public ActionMap getParent() {
return parent;
}
public void put(Object key, Action action) {
if (key == null) {
return;
}
if (action == null) {
remove(key);
}
else {
if (arrayTable == null) {
arrayTable = new ArrayTable();
}
arrayTable.put(key, action);
}
}
public Action get(Object key) {
Action value = (arrayTable == null) ? null :
(Action)arrayTable.get(key);
if (value == null) {
ActionMap    parent = getParent();
if (parent != null) {
return parent.get(key);
}
}
return value;
}
public void remove(Object key) {
if (arrayTable != null) {
arrayTable.remove(key);
}
}
public void clear() {
if (arrayTable != null) {
arrayTable.clear();
}
}
public Object[] keys() {
if (arrayTable == null) {
return null;
}
return arrayTable.getKeys(null);
}
public int size() {
if (arrayTable == null) {
return 0;
}
return arrayTable.size();
}
public Object[] allKeys() {
int           count = size();
ActionMap     parent = getParent();
if (count == 0) {
if (parent != null) {
return parent.allKeys();
}
return keys();
}
if (parent == null) {
return keys();
}
Object[]    keys = keys();
Object[]    pKeys =  parent.allKeys();
if (pKeys == null) {
return keys;
}
if (keys == null) {
return pKeys;
}
HashMap<Object, Object> keyMap = new HashMap<Object, Object>();
int            counter;
for (counter = keys.length - 1; counter >= 0; counter--) {
keyMap.put(keys[counter], keys[counter]);
}
for (counter = pKeys.length - 1; counter >= 0; counter--) {
keyMap.put(pKeys[counter], pKeys[counter]);
}
return keyMap.keySet().toArray();
}
@Serial
private void writeObject(ObjectOutputStream s) throws IOException {
s.defaultWriteObject();
ArrayTable.writeArrayTable(s, arrayTable);
}
@Serial
private void readObject(ObjectInputStream s) throws ClassNotFoundException,
IOException {
s.defaultReadObject();
for (int counter = s.readInt() - 1; counter >= 0; counter--) {
put(s.readObject(), (Action)s.readObject());
}
}
}
package javax.swing.plaf;
import javax.swing.ActionMap;
@SuppressWarnings("serial") public class ActionMapUIResource extends ActionMap implements UIResource {
public ActionMapUIResource() {
}
}
package jdk.test.failurehandler.action;
import jdk.test.failurehandler.value.DefaultValue;
import jdk.test.failurehandler.value.Value;
public class ActionParameters {
@Value (name = "repeat")
@DefaultValue (value = "1")
public int repeat = 1;
@Value (name = "pause")
@DefaultValue (value = "500")
public long pause = 500;
@Value (name = "stopOnError")
@DefaultValue (value = "false")
public boolean stopOnError = false;
@Value (name = "timeout")
@DefaultValue (value = "" + 20_000L)
public long timeout = -1L;
public ActionParameters() { }
}
package javax.swing;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serial;
import java.io.Serializable;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
@SuppressWarnings("serial") abstract class ActionPropertyChangeListener<T extends JComponent>
implements PropertyChangeListener, Serializable {
private static ReferenceQueue<JComponent> queue;
private transient OwnedWeakReference<T> target;
private Action action;
private static ReferenceQueue<JComponent> getQueue() {
synchronized(ActionPropertyChangeListener.class) {
if (queue == null) {
queue = new ReferenceQueue<JComponent>();
}
}
return queue;
}
public ActionPropertyChangeListener(T c, Action a) {
super();
setTarget(c);
this.action = a;
}
public final void propertyChange(PropertyChangeEvent e) {
T target = getTarget();
if (target == null) {
getAction().removePropertyChangeListener(this);
} else {
actionPropertyChanged(target, getAction(), e);
}
}
protected abstract void actionPropertyChanged(T target, Action action,
PropertyChangeEvent e);
private void setTarget(T c) {
ReferenceQueue<JComponent> queue = getQueue();
OwnedWeakReference<?> r;
while ((r = (OwnedWeakReference)queue.poll()) != null) {
ActionPropertyChangeListener<?> oldPCL = r.getOwner();
Action oldAction = oldPCL.getAction();
if (oldAction!=null) {
oldAction.removePropertyChangeListener(oldPCL);
}
}
this.target = new OwnedWeakReference<T>(c, queue, this);
}
public T getTarget() {
if (target == null) {
return null;
}
return this.target.get();
}
public Action getAction() {
return action;
}
@Serial
private void writeObject(ObjectOutputStream s) throws IOException {
s.defaultWriteObject();
s.writeObject(getTarget());
}
@Serial
@SuppressWarnings("unchecked")
private void readObject(ObjectInputStream s)
throws IOException, ClassNotFoundException {
s.defaultReadObject();
T target = (T)s.readObject();
if (target != null) {
setTarget(target);
}
}
private static class OwnedWeakReference<U extends JComponent> extends
WeakReference<U> {
private ActionPropertyChangeListener<?> owner;
OwnedWeakReference(U target, ReferenceQueue<? super U> queue,
ActionPropertyChangeListener<?> owner) {
super(target, queue);
this.owner = owner;
}
public ActionPropertyChangeListener<?> getOwner() {
return owner;
}
}
}
package jdk.test.failurehandler.action;
import jdk.test.failurehandler.CoreInfoGatherer;
import jdk.test.failurehandler.ProcessInfoGatherer;
import jdk.test.failurehandler.EnvironmentInfoGatherer;
import jdk.test.failurehandler.HtmlSection;
import jdk.test.failurehandler.Utils;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.zip.GZIPInputStream;
public class ActionSet implements ProcessInfoGatherer, EnvironmentInfoGatherer, CoreInfoGatherer {
private static final String ENVIRONMENT_PROPERTY = "environment";
private static final String ON_PID_PROPERTY = "onTimeout";
private static final String CORES_PROPERTY = "cores";
private final ActionHelper helper;
public String getName() {
return name;
}
private final String name;
private final List<SimpleAction> environmentActions;
private final List<PatternAction> processActions;
private final List<PatternAction> coreActions;
public ActionSet(ActionHelper helper, PrintWriter log, String name) {
this.helper = helper;
this.name = name;
Properties p = Utils.getProperties(name);
environmentActions = getSimpleActions(log, p, ENVIRONMENT_PROPERTY);
processActions = getPatternActions(log, p, ON_PID_PROPERTY);
coreActions = getPatternActions(log, p, CORES_PROPERTY);
}
private List<SimpleAction> getSimpleActions(PrintWriter log, Properties p,
String key) {
String[] tools = getTools(log, p, key);
List<SimpleAction> result = new ArrayList<>(tools.length);
for (String tool : tools) {
try {
SimpleAction action = new SimpleAction(
Utils.prependPrefix(name, tool), tool, p);
result.add(action);
} catch (Exception e) {
log.printf("ERROR: %s cannot be created : %s %n",
tool, e.getMessage());
e.printStackTrace(log);
}
}
return result;
}
private List<PatternAction> getPatternActions(PrintWriter log,
Properties p, String key) {
String[] tools = getTools(log, p, key);
List<PatternAction> result = new ArrayList<>(tools.length);
for (String tool : tools) {
try {
PatternAction action = new PatternAction(
Utils.prependPrefix(name, tool), tool, p);
result.add(action);
} catch (Exception e) {
log.printf("ERROR: %s cannot be created : %s %n",
tool, e.getMessage());
e.printStackTrace(log);
}
}
return result;
}
private String[] getTools(PrintWriter writer, Properties p, String key) {
String value = p.getProperty(key);
if (value == null || value.isEmpty()) {
writer.printf("ERROR: '%s' property is empty%n", key);
return new String[]{};
}
return value.split(" ");
}
@Override
public void gatherProcessInfo(HtmlSection section, long pid) {
String pidStr = "" + pid;
for (PatternAction action : processActions) {
if (action.isJavaOnly()) {
if (helper.isJava(pid, section.getWriter())) {
helper.runPatternAction(action, section, pidStr);
}
} else {
helper.runPatternAction(action, section, pidStr);
}
}
}
@Override
public void gatherEnvironmentInfo(HtmlSection section) {
for (SimpleAction action : environmentActions) {
helper.runPatternAction(action, section);
}
}
@Override
public void gatherCoreInfo(HtmlSection section, Path core) {
for (PatternAction action : coreActions) {
helper.runPatternAction(action, section, core.toString());
}
}
}
package com.sun.java.swing.action;
import javax.swing.ImageIcon;
class ActionUtilities
{
ActionUtilities()
{
}
public ImageIcon getIcon(String name)
{
String imagePath = "/toolbarButtonGraphics/" + name;
java.net.URL url = getClass().getResource(imagePath);
if(url != null)
return new ImageIcon(url);
else
return null;
}
public static final String IMAGE_DIR = "/toolbarButtonGraphics/";
}
package java.awt;
public interface ActiveEvent {
public void dispatch();
}
package jdk.jfr.events;
import jdk.jfr.Category;
import jdk.jfr.Label;
import jdk.jfr.DataAmount;
import jdk.jfr.Name;
import jdk.jfr.StackTrace;
import jdk.jfr.Timespan;
import jdk.jfr.Timestamp;
import jdk.jfr.internal.Type;
@Name(Type.EVENT_NAME_PREFIX + "ActiveRecording")
@Label("Flight Recording")
@Category("Flight Recorder")
@StackTrace(false)
public final class ActiveRecordingEvent extends AbstractJDKEvent {
@Label("Id")
public long id;
@Label("Name")
public String name;
@Label("Destination")
public String destination;
@Label("Max Age")
@Timespan(Timespan.MILLISECONDS)
public long maxAge;
@Label("Flush Interval")
@Timespan(Timespan.MILLISECONDS)
public long flushInterval;
@Label("Max Size")
@DataAmount
public long maxSize;
@Label("Start Time")
@Timestamp(Timestamp.MILLISECONDS_SINCE_EPOCH)
public long recordingStart;
@Label("Recording Duration")
@Timespan(Timespan.MILLISECONDS)
public long recordingDuration;
public static boolean enabled() {
return false;     }
public static void commit(long timestamp, long duration, long id, String name,
String destination, long maxAge, long flushInterval,
long maxSize, long recordingStart, long recordingDuration) {
}
}
package jdk.jfr.events;
import jdk.jfr.Category;
import jdk.jfr.Label;
import jdk.jfr.Name;
import jdk.jfr.StackTrace;
import jdk.jfr.internal.Type;
@Name(Type.EVENT_NAME_PREFIX + "ActiveSetting")
@Label("Recording Setting")
@Category("Flight Recorder")
@StackTrace(false)
public final class ActiveSettingEvent extends AbstractJDKEvent {
@Label("Event Id")
public long id;
@Label("Setting Name")
public String name;
@Label("Setting Value")
public String value;
public static void commit(long startTime, long duration, long id, String name, String value) {
}
public static boolean enabled() {
return false;     }
}
package sun.security.provider.certpath;
import java.io.IOException;
import java.math.BigInteger;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.security.cert.X509CertSelector;
import java.security.cert.CertificateException;
import java.util.Arrays;
import java.util.Date;
import sun.security.util.Debug;
import sun.security.util.DerInputStream;
import sun.security.util.KnownOIDs;
import sun.security.x509.SerialNumber;
import sun.security.x509.AuthorityKeyIdentifierExtension;
class AdaptableX509CertSelector extends X509CertSelector {
private static final Debug debug = Debug.getInstance("certpath");
private Date startDate;
private Date endDate;
private byte[] ski;
private BigInteger serial;
void setValidityPeriod(Date startDate, Date endDate) {
this.startDate = startDate;
this.endDate = endDate;
}
@Override
public void setSubjectKeyIdentifier(byte[] subjectKeyID) {
throw new IllegalArgumentException();
}
@Override
public void setSerialNumber(BigInteger serial) {
throw new IllegalArgumentException();
}
void setSkiAndSerialNumber(AuthorityKeyIdentifierExtension ext)
throws IOException {
ski = null;
serial = null;
if (ext != null) {
ski = ext.getEncodedKeyIdentifier();
SerialNumber asn = (SerialNumber)ext.get(
AuthorityKeyIdentifierExtension.SERIAL_NUMBER);
if (asn != null) {
serial = asn.getNumber();
}
}
}
@Override
public boolean match(Certificate cert) {
X509Certificate xcert = (X509Certificate)cert;
if (!matchSubjectKeyID(xcert)) {
return false;
}
int version = xcert.getVersion();
if (serial != null && version > 2) {
if (!serial.equals(xcert.getSerialNumber())) {
return false;
}
}
if (version < 3) {
if (startDate != null) {
try {
xcert.checkValidity(startDate);
} catch (CertificateException ce) {
return false;
}
}
if (endDate != null) {
try {
xcert.checkValidity(endDate);
} catch (CertificateException ce) {
return false;
}
}
}
if (!super.match(cert)) {
return false;
}
return true;
}
private boolean matchSubjectKeyID(X509Certificate xcert) {
if (ski == null) {
return true;
}
try {
byte[] extVal = xcert.getExtensionValue(
KnownOIDs.SubjectKeyID.value());
if (extVal == null) {
if (debug != null && Debug.isVerbose()) {
debug.println("AdaptableX509CertSelector.match: "
+ "no subject key ID extension. Subject: "
+ xcert.getSubjectX500Principal());
}
return true;
}
DerInputStream in = new DerInputStream(extVal);
byte[] certSubjectKeyID = in.getOctetString();
if (certSubjectKeyID == null ||
!Arrays.equals(ski, certSubjectKeyID)) {
if (debug != null && Debug.isVerbose()) {
debug.println("AdaptableX509CertSelector.match: "
+ "subject key IDs don't match. "
+ "Expected: " + Arrays.toString(ski) + " "
+ "Cert's: " + Arrays.toString(certSubjectKeyID));
}
return false;
}
} catch (IOException ex) {
if (debug != null && Debug.isVerbose()) {
debug.println("AdaptableX509CertSelector.match: "
+ "exception in subject key ID check");
}
return false;
}
return true;
}
@Override
public Object clone() {
AdaptableX509CertSelector copy =
(AdaptableX509CertSelector)super.clone();
if (startDate != null) {
copy.startDate = (Date)startDate.clone();
}
if (endDate != null) {
copy.endDate = (Date)endDate.clone();
}
if (ski != null) {
copy.ski = ski.clone();
}
return copy;
}
}
package sun.jvm.hotspot.code;
import java.util.*;
import sun.jvm.hotspot.debugger.*;
import sun.jvm.hotspot.runtime.*;
import sun.jvm.hotspot.types.*;
import sun.jvm.hotspot.utilities.Observable;
import sun.jvm.hotspot.utilities.Observer;
public class AdapterBlob extends RuntimeBlob {
static {
VM.registerVMInitializedObserver(new Observer() {
public void update(Observable o, Object data) {
initialize(VM.getVM().getTypeDataBase());
}
});
}
private static void initialize(TypeDataBase db) {
}
public AdapterBlob(Address addr) {
super(addr);
}
public boolean isAdapterBlob() {
return true;
}
public String getName() {
return "AdapterBlob: " + super.getName();
}
}
package com.sun.org.apache.xalan.internal.xsltc.dom;
import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.StripFilter;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.BasisLibrary;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.dtm.DTMAxisTraverser;
import com.sun.org.apache.xml.internal.dtm.DTMWSFilter;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
import com.sun.org.apache.xml.internal.utils.XMLString;
import java.util.Map;
import javax.xml.transform.SourceLocator;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.AttributesImpl;
public class AdaptiveResultTreeImpl extends SimpleResultTreeImpl
{
private static int _documentURIIndex = 0;
private static final String EMPTY_STRING = "".intern();
private SAXImpl _dom;
private DTMWSFilter _wsfilter;
private int _initSize;
private boolean _buildIdIndex;
private final AttributesImpl _attributes = new AttributesImpl();
private String _openElementName;
public AdaptiveResultTreeImpl(XSLTCDTMManager dtmManager, int documentID,
DTMWSFilter wsfilter, int initSize,
boolean buildIdIndex)
{
super(dtmManager, documentID);
_wsfilter = wsfilter;
_initSize = initSize;
_buildIdIndex = buildIdIndex;
}
public DOM getNestedDOM()
{
return _dom;
}
public int getDocument()
{
if (_dom != null) {
return _dom.getDocument();
}
else {
return super.getDocument();
}
}
public String getStringValue()
{
if (_dom != null) {
return _dom.getStringValue();
}
else {
return super.getStringValue();
}
}
public DTMAxisIterator getIterator()
{
if (_dom != null) {
return _dom.getIterator();
}
else {
return super.getIterator();
}
}
public DTMAxisIterator getChildren(final int node)
{
if (_dom != null) {
return _dom.getChildren(node);
}
else {
return super.getChildren(node);
}
}
public DTMAxisIterator getTypedChildren(final int type)
{
if (_dom != null) {
return _dom.getTypedChildren(type);
}
else {
return super.getTypedChildren(type);
}
}
public DTMAxisIterator getAxisIterator(final int axis)
{
if (_dom != null) {
return _dom.getAxisIterator(axis);
}
else {
return super.getAxisIterator(axis);
}
}
public DTMAxisIterator getTypedAxisIterator(final int axis, final int type)
{
if (_dom != null) {
return _dom.getTypedAxisIterator(axis, type);
}
else {
return super.getTypedAxisIterator(axis, type);
}
}
public DTMAxisIterator getNthDescendant(int node, int n, boolean includeself)
{
if (_dom != null) {
return _dom.getNthDescendant(node, n, includeself);
}
else {
return super.getNthDescendant(node, n, includeself);
}
}
public DTMAxisIterator getNamespaceAxisIterator(final int axis, final int ns)
{
if (_dom != null) {
return _dom.getNamespaceAxisIterator(axis, ns);
}
else {
return super.getNamespaceAxisIterator(axis, ns);
}
}
public DTMAxisIterator getNodeValueIterator(DTMAxisIterator iter, int returnType,
String value, boolean op)
{
if (_dom != null) {
return _dom.getNodeValueIterator(iter, returnType, value, op);
}
else {
return super.getNodeValueIterator(iter, returnType, value, op);
}
}
public DTMAxisIterator orderNodes(DTMAxisIterator source, int node)
{
if (_dom != null) {
return _dom.orderNodes(source, node);
}
else {
return super.orderNodes(source, node);
}
}
public String getNodeName(final int node)
{
if (_dom != null) {
return _dom.getNodeName(node);
}
else {
return super.getNodeName(node);
}
}
public String getNodeNameX(final int node)
{
if (_dom != null) {
return _dom.getNodeNameX(node);
}
else {
return super.getNodeNameX(node);
}
}
public String getNamespaceName(final int node)
{
if (_dom != null) {
return _dom.getNamespaceName(node);
}
else {
return super.getNamespaceName(node);
}
}
public int getExpandedTypeID(final int nodeHandle)
{
if (_dom != null) {
return _dom.getExpandedTypeID(nodeHandle);
}
else {
return super.getExpandedTypeID(nodeHandle);
}
}
public int getNamespaceType(final int node)
{
if (_dom != null) {
return _dom.getNamespaceType(node);
}
else {
return super.getNamespaceType(node);
}
}
public int getParent(final int nodeHandle)
{
if (_dom != null) {
return _dom.getParent(nodeHandle);
}
else {
return super.getParent(nodeHandle);
}
}
public int getAttributeNode(final int gType, final int element)
{
if (_dom != null) {
return _dom.getAttributeNode(gType, element);
}
else {
return super.getAttributeNode(gType, element);
}
}
public String getStringValueX(final int nodeHandle)
{
if (_dom != null) {
return _dom.getStringValueX(nodeHandle);
}
else {
return super.getStringValueX(nodeHandle);
}
}
public void copy(final int node, SerializationHandler handler)
throws TransletException
{
if (_dom != null) {
_dom.copy(node, handler);
}
else {
super.copy(node, handler);
}
}
public void copy(DTMAxisIterator nodes, SerializationHandler handler)
throws TransletException
{
if (_dom != null) {
_dom.copy(nodes, handler);
}
else {
super.copy(nodes, handler);
}
}
public String shallowCopy(final int node, SerializationHandler handler)
throws TransletException
{
if (_dom != null) {
return _dom.shallowCopy(node, handler);
}
else {
return super.shallowCopy(node, handler);
}
}
public boolean lessThan(final int node1, final int node2)
{
if (_dom != null) {
return _dom.lessThan(node1, node2);
}
else {
return super.lessThan(node1, node2);
}
}
public void characters(final int node, SerializationHandler handler)
throws TransletException
{
if (_dom != null) {
_dom.characters(node, handler);
}
else {
super.characters(node, handler);
}
}
public Node makeNode(int index)
{
if (_dom != null) {
return _dom.makeNode(index);
}
else {
return super.makeNode(index);
}
}
public Node makeNode(DTMAxisIterator iter)
{
if (_dom != null) {
return _dom.makeNode(iter);
}
else {
return super.makeNode(iter);
}
}
public NodeList makeNodeList(int index)
{
if (_dom != null) {
return _dom.makeNodeList(index);
}
else {
return super.makeNodeList(index);
}
}
public NodeList makeNodeList(DTMAxisIterator iter)
{
if (_dom != null) {
return _dom.makeNodeList(iter);
}
else {
return super.makeNodeList(iter);
}
}
public String getLanguage(int node)
{
if (_dom != null) {
return _dom.getLanguage(node);
}
else {
return super.getLanguage(node);
}
}
public int getSize()
{
if (_dom != null) {
return _dom.getSize();
}
else {
return super.getSize();
}
}
public String getDocumentURI(int node)
{
if (_dom != null) {
return _dom.getDocumentURI(node);
}
else {
return "adaptive_rtf" + _documentURIIndex++;
}
}
public void setFilter(StripFilter filter)
{
if (_dom != null) {
_dom.setFilter(filter);
}
else {
super.setFilter(filter);
}
}
public void setupMapping(String[] names, String[] uris, int[] types, String[] namespaces)
{
if (_dom != null) {
_dom.setupMapping(names, uris, types, namespaces);
}
else {
super.setupMapping(names, uris, types, namespaces);
}
}
public boolean isElement(final int node)
{
if (_dom != null) {
return _dom.isElement(node);
}
else {
return super.isElement(node);
}
}
public boolean isAttribute(final int node)
{
if (_dom != null) {
return _dom.isAttribute(node);
}
else {
return super.isAttribute(node);
}
}
public String lookupNamespace(int node, String prefix)
throws TransletException
{
if (_dom != null) {
return _dom.lookupNamespace(node, prefix);
}
else {
return super.lookupNamespace(node, prefix);
}
}
public final int getNodeIdent(final int nodehandle)
{
if (_dom != null) {
return _dom.getNodeIdent(nodehandle);
}
else {
return super.getNodeIdent(nodehandle);
}
}
public final int getNodeHandle(final int nodeId)
{
if (_dom != null) {
return _dom.getNodeHandle(nodeId);
}
else {
return super.getNodeHandle(nodeId);
}
}
public DOM getResultTreeFrag(int initialSize, int rtfType)
{
if (_dom != null) {
return _dom.getResultTreeFrag(initialSize, rtfType);
}
else {
return super.getResultTreeFrag(initialSize, rtfType);
}
}
public SerializationHandler getOutputDomBuilder()
{
return this;
}
public int getNSType(int node)
{
if (_dom != null) {
return _dom.getNSType(node);
}
else {
return super.getNSType(node);
}
}
public String getUnparsedEntityURI(String name)
{
if (_dom != null) {
return _dom.getUnparsedEntityURI(name);
}
else {
return super.getUnparsedEntityURI(name);
}
}
public Map<String, Integer> getElementsWithIDs()
{
if (_dom != null) {
return _dom.getElementsWithIDs();
}
else {
return super.getElementsWithIDs();
}
}
private void maybeEmitStartElement() throws SAXException
{
if (_openElementName != null) {
int index;
if ((index =_openElementName.indexOf(':')) < 0)
_dom.startElement(null, _openElementName, _openElementName, _attributes);
else {
String uri =_dom.getNamespaceURI(_openElementName.substring(0,index));
_dom.startElement(uri, _openElementName.substring(index+1), _openElementName, _attributes);
}
_openElementName = null;
}
}
private void prepareNewDOM() throws SAXException
{
_dom = (SAXImpl)_dtmManager.getDTM(null, true, _wsfilter,
true, false, false,
_initSize, _buildIdIndex);
_dom.startDocument();
for (int i = 0; i < _size; i++) {
String str = _textArray[i];
_dom.characters(str.toCharArray(), 0, str.length());
}
_size = 0;
}
public void startDocument() throws SAXException
{
}
public void endDocument() throws SAXException
{
if (_dom != null) {
_dom.endDocument();
}
else {
super.endDocument();
}
}
public void characters(String str) throws SAXException
{
if (_dom != null) {
characters(str.toCharArray(), 0, str.length());
}
else {
super.characters(str);
}
}
public void characters(char[] ch, int offset, int length)
throws SAXException
{
if (_dom != null) {
maybeEmitStartElement();
_dom.characters(ch, offset, length);
}
else {
super.characters(ch, offset, length);
}
}
public boolean setEscaping(boolean escape) throws SAXException
{
if (_dom != null) {
return _dom.setEscaping(escape);
}
else {
return super.setEscaping(escape);
}
}
public void startElement(String elementName) throws SAXException
{
if (_dom == null) {
prepareNewDOM();
}
maybeEmitStartElement();
_openElementName = elementName;
_attributes.clear();
}
public void startElement(String uri, String localName, String qName)
throws SAXException
{
startElement(qName);
}
public void startElement(String uri, String localName, String qName, Attributes attributes)
throws SAXException
{
startElement(qName);
}
public void endElement(String elementName) throws SAXException
{
maybeEmitStartElement();
_dom.endElement(null, null, elementName);
}
public void endElement(String uri, String localName, String qName)
throws SAXException
{
endElement(qName);
}
public void addAttribute(String qName, String value)
{
int colonpos = qName.indexOf(':');
String uri = EMPTY_STRING;
String localName = qName;
if (colonpos >0)
{
String prefix = qName.substring(0, colonpos);
localName = qName.substring(colonpos+1);
uri = _dom.getNamespaceURI(prefix);
}
addAttribute(uri, localName, qName, "CDATA", value);
}
public void addUniqueAttribute(String qName, String value, int flags)
throws SAXException
{
addAttribute(qName, value);
}
public void addAttribute(String uri, String localName, String qname,
String type, String value)
{
if (_openElementName != null) {
_attributes.addAttribute(uri, localName, qname, type, value);
}
else {
BasisLibrary.runTimeError(BasisLibrary.STRAY_ATTRIBUTE_ERR, qname);
}
}
public void namespaceAfterStartElement(String prefix, String uri)
throws SAXException
{
if (_dom == null) {
prepareNewDOM();
}
_dom.startPrefixMapping(prefix, uri);
}
public void comment(String comment) throws SAXException
{
if (_dom == null) {
prepareNewDOM();
}
maybeEmitStartElement();
char[] chars = comment.toCharArray();
_dom.comment(chars, 0, chars.length);
}
public void comment(char[] chars, int offset, int length)
throws SAXException
{
if (_dom == null) {
prepareNewDOM();
}
maybeEmitStartElement();
_dom.comment(chars, offset, length);
}
public void processingInstruction(String target, String data)
throws SAXException
{
if (_dom == null) {
prepareNewDOM();
}
maybeEmitStartElement();
_dom.processingInstruction(target, data);
}
public void setFeature(String featureId, boolean state)
{
if (_dom != null) {
_dom.setFeature(featureId, state);
}
}
public void setProperty(String property, Object value)
{
if (_dom != null) {
_dom.setProperty(property, value);
}
}
public DTMAxisTraverser getAxisTraverser(final int axis)
{
if (_dom != null) {
return _dom.getAxisTraverser(axis);
}
else {
return super.getAxisTraverser(axis);
}
}
public boolean hasChildNodes(int nodeHandle)
{
if (_dom != null) {
return _dom.hasChildNodes(nodeHandle);
}
else {
return super.hasChildNodes(nodeHandle);
}
}
public int getFirstChild(int nodeHandle)
{
if (_dom != null) {
return _dom.getFirstChild(nodeHandle);
}
else {
return super.getFirstChild(nodeHandle);
}
}
public int getLastChild(int nodeHandle)
{
if (_dom != null) {
return _dom.getLastChild(nodeHandle);
}
else {
return super.getLastChild(nodeHandle);
}
}
public int getAttributeNode(int elementHandle, String namespaceURI, String name)
{
if (_dom != null) {
return _dom.getAttributeNode(elementHandle, namespaceURI, name);
}
else {
return super.getAttributeNode(elementHandle, namespaceURI, name);
}
}
public int getFirstAttribute(int nodeHandle)
{
if (_dom != null) {
return _dom.getFirstAttribute(nodeHandle);
}
else {
return super.getFirstAttribute(nodeHandle);
}
}
public int getFirstNamespaceNode(int nodeHandle, boolean inScope)
{
if (_dom != null) {
return _dom.getFirstNamespaceNode(nodeHandle, inScope);
}
else {
return super.getFirstNamespaceNode(nodeHandle, inScope);
}
}
public int getNextSibling(int nodeHandle)
{
if (_dom != null) {
return _dom.getNextSibling(nodeHandle);
}
else {
return super.getNextSibling(nodeHandle);
}
}
public int getPreviousSibling(int nodeHandle)
{
if (_dom != null) {
return _dom.getPreviousSibling(nodeHandle);
}
else {
return super.getPreviousSibling(nodeHandle);
}
}
public int getNextAttribute(int nodeHandle)
{
if (_dom != null) {
return _dom.getNextAttribute(nodeHandle);
}
else {
return super.getNextAttribute(nodeHandle);
}
}
public int getNextNamespaceNode(int baseHandle, int namespaceHandle,
boolean inScope)
{
if (_dom != null) {
return _dom.getNextNamespaceNode(baseHandle, namespaceHandle, inScope);
}
else {
return super.getNextNamespaceNode(baseHandle, namespaceHandle, inScope);
}
}
public int getOwnerDocument(int nodeHandle)
{
if (_dom != null) {
return _dom.getOwnerDocument(nodeHandle);
}
else {
return super.getOwnerDocument(nodeHandle);
}
}
public int getDocumentRoot(int nodeHandle)
{
if (_dom != null) {
return _dom.getDocumentRoot(nodeHandle);
}
else {
return super.getDocumentRoot(nodeHandle);
}
}
public XMLString getStringValue(int nodeHandle)
{
if (_dom != null) {
return _dom.getStringValue(nodeHandle);
}
else {
return super.getStringValue(nodeHandle);
}
}
public int getStringValueChunkCount(int nodeHandle)
{
if (_dom != null) {
return _dom.getStringValueChunkCount(nodeHandle);
}
else {
return super.getStringValueChunkCount(nodeHandle);
}
}
public char[] getStringValueChunk(int nodeHandle, int chunkIndex,
int[] startAndLen)
{
if (_dom != null) {
return _dom.getStringValueChunk(nodeHandle, chunkIndex, startAndLen);
}
else {
return super.getStringValueChunk(nodeHandle, chunkIndex, startAndLen);
}
}
public int getExpandedTypeID(String namespace, String localName, int type)
{
if (_dom != null) {
return _dom.getExpandedTypeID(namespace, localName, type);
}
else {
return super.getExpandedTypeID(namespace, localName, type);
}
}
public String getLocalNameFromExpandedNameID(int ExpandedNameID)
{
if (_dom != null) {
return _dom.getLocalNameFromExpandedNameID(ExpandedNameID);
}
else {
return super.getLocalNameFromExpandedNameID(ExpandedNameID);
}
}
public String getNamespaceFromExpandedNameID(int ExpandedNameID)
{
if (_dom != null) {
return _dom.getNamespaceFromExpandedNameID(ExpandedNameID);
}
else {
return super.getNamespaceFromExpandedNameID(ExpandedNameID);
}
}
public String getLocalName(int nodeHandle)
{
if (_dom != null) {
return _dom.getLocalName(nodeHandle);
}
else {
return super.getLocalName(nodeHandle);
}
}
public String getPrefix(int nodeHandle)
{
if (_dom != null) {
return _dom.getPrefix(nodeHandle);
}
else {
return super.getPrefix(nodeHandle);
}
}
public String getNamespaceURI(int nodeHandle)
{
if (_dom != null) {
return _dom.getNamespaceURI(nodeHandle);
}
else {
return super.getNamespaceURI(nodeHandle);
}
}
public String getNodeValue(int nodeHandle)
{
if (_dom != null) {
return _dom.getNodeValue(nodeHandle);
}
else {
return super.getNodeValue(nodeHandle);
}
}
public short getNodeType(int nodeHandle)
{
if (_dom != null) {
return _dom.getNodeType(nodeHandle);
}
else {
return super.getNodeType(nodeHandle);
}
}
public short getLevel(int nodeHandle)
{
if (_dom != null) {
return _dom.getLevel(nodeHandle);
}
else {
return super.getLevel(nodeHandle);
}
}
public boolean isSupported(String feature, String version)
{
if (_dom != null) {
return _dom.isSupported(feature, version);
}
else {
return super.isSupported(feature, version);
}
}
public String getDocumentBaseURI()
{
if (_dom != null) {
return _dom.getDocumentBaseURI();
}
else {
return super.getDocumentBaseURI();
}
}
public void setDocumentBaseURI(String baseURI)
{
if (_dom != null) {
_dom.setDocumentBaseURI(baseURI);
}
else {
super.setDocumentBaseURI(baseURI);
}
}
public String getDocumentSystemIdentifier(int nodeHandle)
{
if (_dom != null) {
return _dom.getDocumentSystemIdentifier(nodeHandle);
}
else {
return super.getDocumentSystemIdentifier(nodeHandle);
}
}
public String getDocumentEncoding(int nodeHandle)
{
if (_dom != null) {
return _dom.getDocumentEncoding(nodeHandle);
}
else {
return super.getDocumentEncoding(nodeHandle);
}
}
public String getDocumentStandalone(int nodeHandle)
{
if (_dom != null) {
return _dom.getDocumentStandalone(nodeHandle);
}
else {
return super.getDocumentStandalone(nodeHandle);
}
}
public String getDocumentVersion(int documentHandle)
{
if (_dom != null) {
return _dom.getDocumentVersion(documentHandle);
}
else {
return super.getDocumentVersion(documentHandle);
}
}
public boolean getDocumentAllDeclarationsProcessed()
{
if (_dom != null) {
return _dom.getDocumentAllDeclarationsProcessed();
}
else {
return super.getDocumentAllDeclarationsProcessed();
}
}
public String getDocumentTypeDeclarationSystemIdentifier()
{
if (_dom != null) {
return _dom.getDocumentTypeDeclarationSystemIdentifier();
}
else {
return super.getDocumentTypeDeclarationSystemIdentifier();
}
}
public String getDocumentTypeDeclarationPublicIdentifier()
{
if (_dom != null) {
return _dom.getDocumentTypeDeclarationPublicIdentifier();
}
else {
return super.getDocumentTypeDeclarationPublicIdentifier();
}
}
public int getElementById(String elementId)
{
if (_dom != null) {
return _dom.getElementById(elementId);
}
else {
return super.getElementById(elementId);
}
}
public boolean supportsPreStripping()
{
if (_dom != null) {
return _dom.supportsPreStripping();
}
else {
return super.supportsPreStripping();
}
}
public boolean isNodeAfter(int firstNodeHandle, int secondNodeHandle)
{
if (_dom != null) {
return _dom.isNodeAfter(firstNodeHandle, secondNodeHandle);
}
else {
return super.isNodeAfter(firstNodeHandle, secondNodeHandle);
}
}
public boolean isCharacterElementContentWhitespace(int nodeHandle)
{
if (_dom != null) {
return _dom.isCharacterElementContentWhitespace(nodeHandle);
}
else {
return super.isCharacterElementContentWhitespace(nodeHandle);
}
}
public boolean isDocumentAllDeclarationsProcessed(int documentHandle)
{
if (_dom != null) {
return _dom.isDocumentAllDeclarationsProcessed(documentHandle);
}
else {
return super.isDocumentAllDeclarationsProcessed(documentHandle);
}
}
public boolean isAttributeSpecified(int attributeHandle)
{
if (_dom != null) {
return _dom.isAttributeSpecified(attributeHandle);
}
else {
return super.isAttributeSpecified(attributeHandle);
}
}
public void dispatchCharactersEvents(int nodeHandle, org.xml.sax.ContentHandler ch,
boolean normalize)
throws org.xml.sax.SAXException
{
if (_dom != null) {
_dom.dispatchCharactersEvents(nodeHandle,  ch, normalize);
}
else {
super.dispatchCharactersEvents(nodeHandle, ch, normalize);
}
}
public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch)
throws org.xml.sax.SAXException
{
if (_dom != null) {
_dom.dispatchToEvents(nodeHandle,  ch);
}
else {
super.dispatchToEvents(nodeHandle, ch);
}
}
public org.w3c.dom.Node getNode(int nodeHandle)
{
if (_dom != null) {
return _dom.getNode(nodeHandle);
}
else {
return super.getNode(nodeHandle);
}
}
public boolean needsTwoThreads()
{
if (_dom != null) {
return _dom.needsTwoThreads();
}
else {
return super.needsTwoThreads();
}
}
public org.xml.sax.ContentHandler getContentHandler()
{
if (_dom != null) {
return _dom.getContentHandler();
}
else {
return super.getContentHandler();
}
}
public org.xml.sax.ext.LexicalHandler getLexicalHandler()
{
if (_dom != null) {
return _dom.getLexicalHandler();
}
else {
return super.getLexicalHandler();
}
}
public org.xml.sax.EntityResolver getEntityResolver()
{
if (_dom != null) {
return _dom.getEntityResolver();
}
else {
return super.getEntityResolver();
}
}
public org.xml.sax.DTDHandler getDTDHandler()
{
if (_dom != null) {
return _dom.getDTDHandler();
}
else {
return super.getDTDHandler();
}
}
public org.xml.sax.ErrorHandler getErrorHandler()
{
if (_dom != null) {
return _dom.getErrorHandler();
}
else {
return super.getErrorHandler();
}
}
public org.xml.sax.ext.DeclHandler getDeclHandler()
{
if (_dom != null) {
return _dom.getDeclHandler();
}
else {
return super.getDeclHandler();
}
}
public void appendChild(int newChild, boolean clone, boolean cloneDepth)
{
if (_dom != null) {
_dom.appendChild(newChild, clone, cloneDepth);
}
else {
super.appendChild(newChild, clone, cloneDepth);
}
}
public void appendTextChild(String str)
{
if (_dom != null) {
_dom.appendTextChild(str);
}
else {
super.appendTextChild(str);
}
}
public SourceLocator getSourceLocatorFor(int node)
{
if (_dom != null) {
return _dom.getSourceLocatorFor(node);
}
else {
return super.getSourceLocatorFor(node);
}
}
public void documentRegistration()
{
if (_dom != null) {
_dom.documentRegistration();
}
else {
super.documentRegistration();
}
}
public void documentRelease()
{
if (_dom != null) {
_dom.documentRelease();
}
else {
super.documentRelease();
}
}
public void release() {
if (_dom != null) {
_dom.release();
_dom = null;
}
super.release();
}
}
package compiler.compilercontrol.jcmd;
import compiler.compilercontrol.share.AbstractTestBase;
import compiler.compilercontrol.share.method.MethodDescriptor;
import compiler.compilercontrol.share.scenario.Command;
import compiler.compilercontrol.share.scenario.CompileCommand;
import compiler.compilercontrol.share.scenario.JcmdCommand;
import compiler.compilercontrol.share.scenario.Scenario;
import jdk.test.lib.Utils;
import java.lang.reflect.Executable;
public class AddAndRemoveTest extends AbstractTestBase {
private static final int AMOUNT = Integer.getInteger(
"compiler.compilercontrol.jcmd.AddAndRemoveTest.amount", 10);
public static void main(String[] args) {
new AddAndRemoveTest().test();
}
@Override
public void test() {
Scenario.Builder builder = Scenario.getBuilder();
for (int i = 0; i < AMOUNT; i++) {
Executable exec = Utils.getRandomElement(METHODS).first;
MethodDescriptor md = getValidMethodDescriptor(exec);
CompileCommand compileCommand = new JcmdCommand(Command.COMPILEONLY,
md, null, Scenario.Type.JCMD, Scenario.JcmdType.ADD);
builder.add(compileCommand);
}
for (int i = 0; i < AMOUNT / 2; i++) {
builder.add(new JcmdCommand(Command.NONEXISTENT, null, null,
Scenario.Type.JCMD, Scenario.JcmdType.REMOVE));
}
Scenario scenario = builder.build();
scenario.execute();
}
}
package compiler.compilercontrol.jcmd;
import compiler.compilercontrol.share.SingleCommand;
import compiler.compilercontrol.share.scenario.Command;
import compiler.compilercontrol.share.scenario.Scenario;
public class AddCompileOnlyTest {
public static void main(String[] args) {
new SingleCommand(Command.COMPILEONLY, Scenario.Type.JCMD)
.test();
}
}
package compiler.intrinsics.mathexact;
public class AddExactICondTest {
public static int result = 0;
public static void main(String[] args) {
for (int i = 0; i < 50000; ++i) {
runTest();
}
}
public static void runTest() {
int i = 7;
while (java.lang.Math.addExact(i, result) < 89361) {
if ((java.lang.Math.addExact(i, i) & 1) == 1) {
i += 3;
} else if ((i & 5) == 4) {
i += 7;
} else if ((i & 0xf) == 6) {
i += 2;
} else {
i += 1;
}
result += 2;
}
}
}
package compiler.intrinsics.mathexact;
public class AddExactIConstantTest {
public static void main(String[] args) {
Verify.ConstantTest.verify(new Verify.AddExactI());
}
}
package compiler.intrinsics.mathexact;
public class AddExactILoadTest {
public static void main(String[] args) {
Verify.LoadTest.init();
Verify.LoadTest.verify(new Verify.AddExactI());
}
}
package compiler.intrinsics.mathexact;
public class AddExactILoopDependentTest {
public static void main(String[] args) {
Verify.LoopDependentTest.verify(new Verify.AddExactI());
}
}
package compiler.intrinsics.mathexact;
public class AddExactINonConstantTest {
public static void main(String[] args) {
Verify.NonConstantTest.verify(new Verify.AddExactI());
}
}
package compiler.intrinsics.mathexact.sanity;
public class AddExactIntTest {
public static void main(String[] args) throws Exception {
new IntrinsicBase.IntTest(MathIntrinsic.IntIntrinsic.Add).test();
}
}
package compiler.intrinsics.mathexact;
import jdk.test.lib.Utils;
import java.util.Random;
public class AddExactIRepeatTest {
public static void main(String[] args) {
runTest(new Verify.AddExactI());
}
public static int nonExact(int x, int y, Verify.BinaryMethod method) {
int result = method.unchecked(x, y);
result += method.unchecked(x, y);
result += method.unchecked(x, y);
result += method.unchecked(x, y);
return result;
}
public static void runTest(Verify.BinaryMethod method) {
Random rnd = Utils.getRandomInstance();
for (int i = 0; i < 50000; ++i) {
int x = Integer.MAX_VALUE - 10;
int y = Integer.MAX_VALUE - 10 + rnd.nextInt(5);
int c = rnd.nextInt() / 2;
int d = rnd.nextInt() / 2;
int a = catchingExact(x, y, method);
if (a != 36) {
throw new RuntimeException("a != 36 : " + a);
}
int b = nonExact(c, d, method);
int n = exact(c, d, method);
if (n != b) {
throw new RuntimeException("n != b : " + n + " != " + b);
}
}
}
public static int exact(int x, int y, Verify.BinaryMethod method) {
int result = 0;
result += method.checkMethod(x, y);
result += method.checkMethod(x, y);
result += method.checkMethod(x, y);
result += method.checkMethod(x, y);
return result;
}
public static int catchingExact(int x, int y, Verify.BinaryMethod method) {
int result = 0;
try {
result += 5;
result = method.checkMethod(x, y);
} catch (ArithmeticException e) {
result += 1;
}
try {
result += 6;
result += method.checkMethod(x, y);
} catch (ArithmeticException e) {
result += 2;
}
try {
result += 7;
result += method.checkMethod(x, y);
} catch (ArithmeticException e) {
result += 3;
}
try {
result += 8;
result += method.checkMethod(x, y);
} catch (ArithmeticException e) {
result += 4;
}
return result;
}
}
package compiler.intrinsics.mathexact;
public class AddExactLConstantTest {
public static void main(String[] args) {
Verify.ConstantLongTest.verify(new Verify.AddExactL());
}
}
package compiler.intrinsics.mathexact;
public class AddExactLNonConstantTest {
public static void main(String[] args) {
Verify.NonConstantLongTest.verify(new Verify.AddExactL());
}
}
package compiler.intrinsics.mathexact.sanity;
public class AddExactLongTest {
public static void main(String[] args) throws Exception {
new IntrinsicBase.LongTest(MathIntrinsic.LongIntrinsic.Add).test();
}
}
package compiler.compilercontrol.jcmd;
import compiler.compilercontrol.share.SingleCommand;
import compiler.compilercontrol.share.scenario.Command;
import compiler.compilercontrol.share.scenario.Scenario;
public class AddExcludeTest {
public static void main(String[] args) {
new SingleCommand(Command.EXCLUDE, Scenario.Type.JCMD)
.test();
}
}
package compiler.c2.irTests;
import jdk.test.lib.Asserts;
import compiler.lib.ir_framework.*;
public class AddINodeIdealizationTests {
public static void main(String[] args) {
TestFramework.run();
}
@Run(test = {"additions", "xMinusX", "test1",
"test2", "test3", "test4",
"test5", "test6", "test7",
"test8", "test9", "test10",
"test11", "test12", "test13",
"test14", "test15", "test16",
"test17", "test18", "test19",
"test20", "test21", "test22",
"test23"})
public void runMethod() {
int a = RunInfo.getRandom().nextInt();
int b = RunInfo.getRandom().nextInt();
int c = RunInfo.getRandom().nextInt();
int d = RunInfo.getRandom().nextInt();
int min = Integer.MIN_VALUE;
int max = Integer.MAX_VALUE;
assertResult(0, 0, 0, 0);
assertResult(a, b, c, d);
assertResult(min, min, min, min);
assertResult(max, max, max, max);
}
@DontCompile
public void assertResult(int a, int b, int c, int d) {
Asserts.assertEQ(((a+a) + (a+a))  , additions(a));
Asserts.assertEQ(0                , xMinusX(a));
Asserts.assertEQ(a + 1 + 2        , test1(a));
Asserts.assertEQ((a + 2021) + b   , test2(a, b));
Asserts.assertEQ(a + (b + 2021)   , test3(a, b));
Asserts.assertEQ((1 - a) + 2      , test4(a));
Asserts.assertEQ((a - b) + (c - d), test5(a, b, c, d));
Asserts.assertEQ((a - b) + (b + c), test6(a, b, c));
Asserts.assertEQ((a - b) + (c + b), test7(a, b, c));
Asserts.assertEQ((a - b) + (b - c), test8(a, b, c));
Asserts.assertEQ((a - b) + (c - a), test9(a, b, c));
Asserts.assertEQ(a + (0 - b)      , test10(a, b));
Asserts.assertEQ((0 - b) + a      , test11(a, b));
Asserts.assertEQ((a - b) + b      , test12(a, b));
Asserts.assertEQ(b + (a - b)      , test13(a, b));
Asserts.assertEQ(a + 0            , test14(a));
Asserts.assertEQ(0 + a            , test15(a));
Asserts.assertEQ(a*b + a*c        , test16(a, b, c));
Asserts.assertEQ(a*b + b*c        , test17(a, b, c));
Asserts.assertEQ(a*c + b*c        , test18(a, b, c));
Asserts.assertEQ(a*b + c*a        , test19(a, b, c));
Asserts.assertEQ((a - b) + 210    , test20(a, b));
Asserts.assertEQ((a - b) + 190    , test21(a, b));
Asserts.assertEQ((a - b) + 210    , test22(a, b));
Asserts.assertEQ((a - b) + 190    , test23(a, b));
}
@Test
@IR(counts = {IRNode.ADD, "2"})
public int additions(int x) {
return (x + x) + (x + x);
}
@Test
@IR(failOn = {IRNode.ADD, IRNode.SUB})
public int xMinusX(int x) {
return (x - x) + (x - x);
}
@Test
@IR(counts = {IRNode.ADD, "1"})
public int test1(int x) {
return (x + 1) + 2;
}
@Test
@IR(counts = {IRNode.ADD, "2"})
public int test2(int x, int y) {
return (x + 2021) + y;
}
@Test
@IR(counts = {IRNode.ADD, "2"})
public int test3(int x, int y) {
return x + (y + 2021);
}
@Test
@IR(failOn = {IRNode.ADD})
@IR(counts = {IRNode.SUB, "1"})
public int test4(int x) {
return (1 - x) + 2;
}
@Test
@IR(counts = {IRNode.SUB, "1",
IRNode.ADD, "2",
})
public int test5(int a, int b, int c, int d) {
return (a - b) + (c - d);
}
@Test
@IR(failOn = {IRNode.SUB})
@IR(counts = {IRNode.ADD, "1"})
public int test6(int a, int b, int c) {
return (a - b) + (b + c);
}
@Test
@IR(failOn = {IRNode.SUB})
@IR(counts = {IRNode.ADD, "1"})
public int test7(int a, int b, int c) {
return (a - b) + (c + b);
}
@Test
@IR(failOn = {IRNode.ADD})
@IR(counts = {IRNode.SUB, "1"})
public int test8(int a, int b, int c) {
return (a - b) + (b - c);
}
@Test
@IR(failOn = {IRNode.ADD})
@IR(counts = {IRNode.SUB, "1"})
public int test9(int a, int b, int c) {
return (a - b) + (c - a);
}
@Test
@IR(failOn = {IRNode.ADD})
@IR(counts = {IRNode.SUB, "1"})
public int test10(int x, int y) {
return x + (0 - y);
}
@Test
@IR(failOn = {IRNode.ADD})
@IR(counts = {IRNode.SUB, "1"})
public int test11(int x, int y) {
return (0 - y) + x;
}
@Test
@IR(failOn = {IRNode.ADD, IRNode.SUB})
public int test12(int x, int y) {
return (x - y) + y;
}
@Test
@IR(failOn = {IRNode.ADD, IRNode.SUB})
public int test13(int x, int y) {
return y + (x - y);
}
@Test
@IR(failOn = {IRNode.ADD})
public int test14(int x) {
return x + 0;
}
@Test
@IR(failOn = {IRNode.ADD})
public int test15(int x) {
return 0 + x;
}
@Test
@IR(counts = {IRNode.MUL, "1",
IRNode.ADD, "1"
})
public int test16(int a, int b, int c) {
return a*b + a*c;
}
@Test
@IR(counts = {IRNode.MUL, "1",
IRNode.ADD, "1"
})
public int test17(int a, int b, int c) {
return a*b + b*c;
}
@Test
@IR(counts = {IRNode.MUL, "1",
IRNode.ADD, "1"
})
public int test18(int a, int b, int c) {
return a*c + b*c;
}
@Test
@IR(counts = {IRNode.MUL, "1",
IRNode.ADD, "1"
})
public int test19(int a, int b, int c) {
return a*b + c*a;
}
@Test
@IR(counts = {IRNode.SUB_I, "1",
IRNode.ADD_I, "1",
IRNode.CON_I, "1"})
public int test20(int x, int y) {
return x + (10 - y) + 200;     }
@Test
@IR(counts = {IRNode.SUB_I, "1",
IRNode.ADD_I, "1",
IRNode.CON_I, "1"})
public int test21(int x, int y) {
return x + (-10 - y) + 200;     }
@Test
@IR(counts = {IRNode.SUB_I, "1",
IRNode.ADD_I, "1",
IRNode.CON_I, "1"})
public int test22(int x, int y) {
return (10 - y) + x + 200;     }
@Test
@IR(counts = {IRNode.SUB_I, "1",
IRNode.ADD_I, "1",
IRNode.CON_I, "1"})
public int test23(int x, int y) {
return x + (-10 - y) + 200;     }
}
package jdk.jpackage.internal;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.Optional;
import jdk.jpackage.internal.Arguments.CLIOptions;
import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_DATA;
import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;
import static jdk.jpackage.internal.StandardBundlerParam.MENU_HINT;
import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;
class AddLauncherArguments {
private final String name;
private final String filename;
private Map<String, String> allArgs;
private Map<String, ? super Object> bundleParams;
AddLauncherArguments(String name, String filename) {
this.name = name;
this.filename = filename;
}
private void initLauncherMap() {
if (bundleParams != null) {
return;
}
allArgs = Arguments.getPropertiesFromFile(filename);
allArgs.put(CLIOptions.NAME.getId(), name);
bundleParams = new HashMap<>();
String mainJar = getOptionValue(CLIOptions.MAIN_JAR);
String mainClass = getOptionValue(CLIOptions.APPCLASS);
String module = getOptionValue(CLIOptions.MODULE);
if (module != null && mainClass != null) {
Arguments.putUnlessNull(bundleParams, CLIOptions.MODULE.getId(),
module + "/" + mainClass);
} else if (module != null) {
Arguments.putUnlessNull(bundleParams, CLIOptions.MODULE.getId(),
module);
} else {
Arguments.putUnlessNull(bundleParams, CLIOptions.MAIN_JAR.getId(),
mainJar);
Arguments.putUnlessNull(bundleParams, CLIOptions.APPCLASS.getId(),
mainClass);
}
Arguments.putUnlessNull(bundleParams, CLIOptions.NAME.getId(),
getOptionValue(CLIOptions.NAME));
Arguments.putUnlessNull(bundleParams, CLIOptions.VERSION.getId(),
getOptionValue(CLIOptions.VERSION));
Arguments.putUnlessNull(bundleParams, CLIOptions.DESCRIPTION.getId(),
getOptionValue(CLIOptions.DESCRIPTION));
Arguments.putUnlessNull(bundleParams, CLIOptions.RELEASE.getId(),
getOptionValue(CLIOptions.RELEASE));
Arguments.putUnlessNull(bundleParams, CLIOptions.ICON.getId(),
Optional.ofNullable(getOptionValue(CLIOptions.ICON)).map(
Path::of).orElse(null));
Arguments.putUnlessNull(bundleParams,
CLIOptions.LAUNCHER_AS_SERVICE.getId(), getOptionValue(
CLIOptions.LAUNCHER_AS_SERVICE));
if (Platform.isWindows())  {
Arguments.putUnlessNull(bundleParams,
CLIOptions.WIN_CONSOLE_HINT.getId(),
getOptionValue(CLIOptions.WIN_CONSOLE_HINT));
Arguments.putUnlessNull(bundleParams, SHORTCUT_HINT.getID(),
getOptionValue(CLIOptions.WIN_SHORTCUT_HINT));
Arguments.putUnlessNull(bundleParams, MENU_HINT.getID(),
getOptionValue(CLIOptions.WIN_MENU_HINT));
}
if (Platform.isLinux())  {
Arguments.putUnlessNull(bundleParams, CLIOptions.LINUX_CATEGORY.getId(),
getOptionValue(CLIOptions.LINUX_CATEGORY));
Arguments.putUnlessNull(bundleParams, SHORTCUT_HINT.getID(),
getOptionValue(CLIOptions.LINUX_SHORTCUT_HINT));
}
if (allArgs.containsKey(CLIOptions.ARGUMENTS.getId())) {
String argumentStr = getOptionValue(CLIOptions.ARGUMENTS);
bundleParams.put(CLIOptions.ARGUMENTS.getId(),
Arguments.getArgumentList(argumentStr));
}
if (allArgs.containsKey(CLIOptions.JAVA_OPTIONS.getId())) {
String jvmargsStr = getOptionValue(CLIOptions.JAVA_OPTIONS);
bundleParams.put(CLIOptions.JAVA_OPTIONS.getId(),
Arguments.getArgumentList(jvmargsStr));
}
}
private String getOptionValue(CLIOptions option) {
if (option == null || allArgs == null) {
return null;
}
String id = option.getId();
if (allArgs.containsKey(id)) {
return allArgs.get(id);
}
return null;
}
Map<String, ? super Object> getLauncherMap() {
initLauncherMap();
return bundleParams;
}
static Map<String, ? super Object> merge(
Map<String, ? super Object> original,
Map<String, ? super Object> additional, String... exclude) {
Map<String, ? super Object> tmp = new HashMap<>(original);
List.of(exclude).forEach(tmp::remove);
tmp.remove(LAUNCHER_DATA.getID());
tmp.remove(APP_NAME.getID());
if (additional.containsKey(CLIOptions.MODULE.getId())) {
tmp.remove(CLIOptions.MAIN_JAR.getId());
tmp.remove(CLIOptions.APPCLASS.getId());
} else if (additional.containsKey(CLIOptions.MAIN_JAR.getId())) {
tmp.remove(CLIOptions.MODULE.getId());
}
if (additional.containsKey(CLIOptions.ARGUMENTS.getId())) {
tmp.remove(CLIOptions.ARGUMENTS.getId());
}
if (additional.containsKey(CLIOptions.JAVA_OPTIONS.getId())) {
tmp.remove(CLIOptions.JAVA_OPTIONS.getId());
}
tmp.putAll(additional);
return tmp;
}
}
package compiler.c2.irTests;
import jdk.test.lib.Asserts;
import compiler.lib.ir_framework.*;
public class AddLNodeIdealizationTests {
public static void main(String[] args) {
TestFramework.run();
}
@Run(test = {"additions", "xMinusX", "test1",
"test2", "test3", "test4",
"test5", "test6", "test7",
"test8", "test9", "test10",
"test11", "test12", "test13",
"test14", "test15", "test16",
"test17", "test18", "test19",
"test20","test21", "test22"})
public void runMethod() {
long a = RunInfo.getRandom().nextLong();
long b = RunInfo.getRandom().nextLong();
long c = RunInfo.getRandom().nextLong();
long d = RunInfo.getRandom().nextLong();
long min = Long.MIN_VALUE;
long max = Long.MAX_VALUE;
assertResult(0, 0, 0, 0);
assertResult(a, b, c, d);
assertResult(min, min, min, min);
assertResult(max, max, max, max);
}
@DontCompile
public void assertResult(long a, long b, long c, long d) {
Asserts.assertEQ(((a+a) + (a+a))             , additions(a));
Asserts.assertEQ(0L                          , xMinusX(a));
Asserts.assertEQ(a + 1 + 2                   , test1(a));
Asserts.assertEQ((a + 2021) + b              , test2(a, b));
Asserts.assertEQ(a + (b + 2021)              , test3(a, b));
Asserts.assertEQ((1 - a) + 2                 , test4(a));
Asserts.assertEQ((a - b) + (c - d)           , test5(a, b, c, d));
Asserts.assertEQ((a - b) + (b + c)           , test6(a, b, c));
Asserts.assertEQ((a - b) + (c + b)           , test7(a, b, c));
Asserts.assertEQ((a - b) + (c - a)           , test8(a, b, c));
Asserts.assertEQ(a + (0 - b)                 , test9(a, b));
Asserts.assertEQ((0 - b) + a                 , test10(a, b));
Asserts.assertEQ((a - b) + b                 , test11(a, b));
Asserts.assertEQ(b + (a - b)                 , test12(a, b));
Asserts.assertEQ(a + 0                       , test13(a));
Asserts.assertEQ(0 + a                       , test14(a));
Asserts.assertEQ(a*b + a*c                   , test15(a, b, c));
Asserts.assertEQ(a*b + b*c                   , test16(a, b, c));
Asserts.assertEQ(a*c + b*c                   , test17(a, b, c));
Asserts.assertEQ(a*b + c*a                   , test18(a, b, c));
Asserts.assertEQ((a - b) + 123_456_789_123L  , test19(a, b));
Asserts.assertEQ((a - b) + -123_456_788_877L , test20(a, b));
Asserts.assertEQ((a - b) + 123_456_789_123L  , test21(a, b));
Asserts.assertEQ((a - b) + -123_456_788_877L , test22(a, b));
}
@Test
@IR(counts = {IRNode.ADD, "2"})
public long additions(long x) {
return (x + x) + (x + x);
}
@Test
@IR(failOn = {IRNode.ADD, IRNode.SUB})
public long xMinusX(long x) {
return (x - x) + (x - x);
}
@Test
@IR(counts = {IRNode.ADD, "1"})
public long test1(long x) {
return (x + 1) + 2;
}
@Test
@IR(counts = {IRNode.ADD, "2"})
public long test2(long x, long y) {
return (x + 2021) + y;
}
@Test
@IR(counts = {IRNode.ADD, "2"})
public long test3(long x, long y) {
return x + (y + 2021);
}
@Test
@IR(failOn = {IRNode.ADD})
@IR(counts = {IRNode.SUB, "1"})
public long test4(long x) {
return (1 - x) + 2;
}
@Test
@IR(counts = {IRNode.SUB, "1",
IRNode.ADD, "2",
})
public long test5(long a, long b, long c, long d) {
return (a - b) + (c - d);
}
@Test
@IR(failOn = {IRNode.SUB})
@IR(counts = {IRNode.ADD, "1"})
public long test6(long a, long b, long c) {
return (a - b) + (b + c);
}
@Test
@IR(failOn = {IRNode.SUB})
@IR(counts = {IRNode.ADD, "1"})
public long test7(long a, long b, long c) {
return (a - b) + (c + b);
}
@Test
@IR(failOn = {IRNode.ADD})
@IR(counts = {IRNode.SUB, "1"})
public long test8(long a, long b, long c) {
return (a - b) + (c - a);
}
@Test
@IR(failOn = {IRNode.ADD})
@IR(counts = {IRNode.SUB, "1"})
public long test9(long x, long y) {
return x + (0 - y);
}
@Test
@IR(failOn = {IRNode.ADD})
@IR(counts = {IRNode.SUB, "1"})
public long test10(long x, long y) {
return (0 - y) + x;
}
@Test
@IR(failOn = {IRNode.ADD, IRNode.SUB})
public long test11(long x, long y) {
return (x - y) + y;
}
@Test
@IR(failOn = {IRNode.ADD, IRNode.SUB})
public long test12(long x, long y) {
return y + (x - y);
}
@Test
@IR(failOn = {IRNode.ADD})
public long test13(long x) {
return x + 0;
}
@Test
@IR(failOn = {IRNode.ADD})
public long test14(long x) {
return 0 + x;
}
@Test
@IR(counts = {IRNode.MUL, "1",
IRNode.ADD, "1"
})
public long test15(long a, long b, long c) {
return a*b + a*c;
}
@Test
@IR(counts = {IRNode.MUL, "1",
IRNode.ADD, "1"
})
public long test16(long a, long b, long c) {
return a*b + b*c;
}
@Test
@IR(counts = {IRNode.MUL, "1",
IRNode.ADD, "1"
})
public long test17(long a, long b, long c) {
return a*c + b*c;
}
@Test
@IR(counts = {IRNode.MUL, "1",
IRNode.ADD, "1"
})
public long test18(long a, long b, long c) {
return a*b + c*a;
}
@Test
@IR(counts = {IRNode.SUB_L, "1",
IRNode.ADD_L, "1",
IRNode.CON_L, "1"})
public long test19(long x, long y) {
return x + (123_456_789_000L - y) + 123;
}
@Test
@IR(counts = {IRNode.SUB_L, "1",
IRNode.ADD_L, "1",
IRNode.CON_L, "1"})
public long test20(long x, long y) {
return x + (-123_456_789_000L - y) + 123;
}
@Test
@IR(counts = {IRNode.SUB_L, "1",
IRNode.ADD_L, "1",
IRNode.CON_L, "1"})
public long test21(long x, long y) {
return x + (123_456_789_000L - y) + 123;
}
@Test
@IR(counts = {IRNode.SUB_L, "1",
IRNode.ADD_L, "1",
IRNode.CON_L, "1"})
public long test22(long x, long y) {
return x + (-123_456_789_000L - y) + 123;
}
}
package compiler.compilercontrol.jcmd;
import compiler.compilercontrol.share.SingleCommand;
import compiler.compilercontrol.share.scenario.Command;
import compiler.compilercontrol.share.scenario.Scenario;
public class AddLogTest {
public static void main(String[] args) {
new SingleCommand(Command.LOG, Scenario.Type.JCMD)
.test();
}
}
package jdk.tools.jlink.internal.plugins;
public final class AddOptionsPlugin extends AddResourcePlugin {
public AddOptionsPlugin() {
super("add-options", "/java.base/jdk/internal/vm/options");
}
}
package build.tools.jigsaw;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.module.ModuleFinder;
import java.lang.module.ModuleReference;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Optional;
import java.util.Set;
import jdk.internal.module.ModuleInfoExtender;
public class AddPackagesAttribute {
public static void main(String[] args) throws IOException {
if (args.length != 1) {
System.err.println("Usage AddPackagesAttribute exploded-java-home");
System.exit(-1);
}
String home = args[0];
Path dir = Paths.get(home, "modules");
ModuleFinder finder = ModuleFinder.of(dir);
try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {
for (Path entry : stream) {
Path mi = entry.resolve("module-info.class");
if (Files.isRegularFile(mi)) {
String mn = entry.getFileName().toString();
Optional<ModuleReference> omref = finder.find(mn);
if (omref.isPresent()) {
Set<String> packages = omref.get().descriptor().packages();
addPackagesAttribute(mi, packages);
}
}
}
}
}
static void addPackagesAttribute(Path mi, Set<String> packages) throws IOException {
byte[] bytes;
try (InputStream in = Files.newInputStream(mi)) {
ModuleInfoExtender extender = ModuleInfoExtender.newExtender(in);
extender.packages(packages);
ByteArrayOutputStream baos = new ByteArrayOutputStream();
extender.write(baos);
bytes = baos.toByteArray();
}
byte[] currentBytes = Files.readAllBytes(mi);
if (!Arrays.equals(bytes, currentBytes)) {
Files.write(mi, bytes);
}
}
}
package compiler.compilercontrol.jcmd;
import compiler.compilercontrol.share.SingleCommand;
import compiler.compilercontrol.share.scenario.Command;
import compiler.compilercontrol.share.scenario.Scenario;
public class AddPrintAssemblyTest {
public static void main(String[] args) {
new SingleCommand(Command.PRINT, Scenario.Type.JCMD)
.test();
}
}
package jdk.tools.jlink.internal.plugins;
import java.nio.charset.StandardCharsets;
import java.util.Map;
import java.util.function.Function;
import jdk.tools.jlink.plugin.ResourcePool;
import jdk.tools.jlink.plugin.ResourcePoolBuilder;
import jdk.tools.jlink.plugin.ResourcePoolEntry;
abstract class AddResourcePlugin extends AbstractPlugin {
private final String path;
private String value;
protected AddResourcePlugin(String name, String p) {
super(name);
path = p;
}
@Override
public Category getType() {
return Category.ADDER;
}
@Override
public boolean hasArguments() {
return true;
}
@Override
public boolean hasRawArgument() {
return true;
}
@Override
public void configure(Map<String, String> config) {
var v = config.get(getName());
if (v == null)
throw new AssertionError();
value = v;
}
@Override
public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {
in.transformAndCopy(Function.identity(), out);
out.add(ResourcePoolEntry.create(path,
value.getBytes(StandardCharsets.UTF_8)));
return out.build();
}
}
package sun.jvm.hotspot.debugger;
public interface Address {
public boolean equals(Object arg);
public int hashCode();
public long       getCIntegerAt      (long offset, long numBytes, boolean isUnsigned)
throws UnmappedAddressException, UnalignedAddressException;
public Address    getAddressAt       (long offset) throws UnmappedAddressException, UnalignedAddressException;
public Address    getCompOopAddressAt (long offset) throws UnmappedAddressException, UnalignedAddressException;
public Address    getCompKlassAddressAt (long offset) throws UnmappedAddressException, UnalignedAddressException;
public boolean    getJBooleanAt      (long offset) throws UnmappedAddressException, UnalignedAddressException;
public byte       getJByteAt         (long offset) throws UnmappedAddressException, UnalignedAddressException;
public char       getJCharAt         (long offset) throws UnmappedAddressException, UnalignedAddressException;
public double     getJDoubleAt       (long offset) throws UnmappedAddressException, UnalignedAddressException;
public float      getJFloatAt        (long offset) throws UnmappedAddressException, UnalignedAddressException;
public int        getJIntAt          (long offset) throws UnmappedAddressException, UnalignedAddressException;
public long       getJLongAt         (long offset) throws UnmappedAddressException, UnalignedAddressException;
public short      getJShortAt        (long offset) throws UnmappedAddressException, UnalignedAddressException;
public OopHandle  getOopHandleAt     (long offset)
throws UnmappedAddressException, UnalignedAddressException, NotInHeapException;
public OopHandle  getCompOopHandleAt (long offset)
throws UnmappedAddressException, UnalignedAddressException, NotInHeapException;
public void setCIntegerAt(long offset, long numBytes, long value);
public void setAddressAt(long offset, Address value);
public void       setJBooleanAt      (long offset, boolean value)
throws UnmappedAddressException, UnalignedAddressException;
public void       setJByteAt         (long offset, byte value)
throws UnmappedAddressException, UnalignedAddressException;
public void       setJCharAt         (long offset, char value)
throws UnmappedAddressException, UnalignedAddressException;
public void       setJDoubleAt       (long offset, double value)
throws UnmappedAddressException, UnalignedAddressException;
public void       setJFloatAt        (long offset, float value)
throws UnmappedAddressException, UnalignedAddressException;
public void       setJIntAt          (long offset, int value)
throws UnmappedAddressException, UnalignedAddressException;
public void       setJLongAt         (long offset, long value)
throws UnmappedAddressException, UnalignedAddressException;
public void       setJShortAt        (long offset, short value)
throws UnmappedAddressException, UnalignedAddressException;
public void       setOopHandleAt     (long offset, OopHandle value)
throws UnmappedAddressException, UnalignedAddressException;
public Address    addOffsetTo        (long offset) throws UnsupportedOperationException;
public OopHandle  addOffsetToAsOopHandle(long offset) throws UnsupportedOperationException;
public long       minus(Address arg);
public boolean    lessThan          (Address arg);
public boolean    lessThanOrEqual   (Address arg);
public boolean    greaterThan       (Address arg);
public boolean    greaterThanOrEqual(Address arg);
public Address    andWithMask(long mask) throws UnsupportedOperationException;
public Address    orWithMask(long mask) throws UnsupportedOperationException;
public Address    xorWithMask(long mask) throws UnsupportedOperationException;
public long asLongValue();
}
package java.lang.foreign;
import jdk.internal.javac.PreviewFeature;
@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)
public sealed interface Addressable permits MemorySegment, MemoryAddress, VaList {
MemoryAddress address();
}
package sun.jvm.hotspot.debugger.posix;
import java.io.*;
import sun.jvm.hotspot.debugger.*;
import sun.jvm.hotspot.debugger.posix.elf.*;
class AddressDataSource implements DataSource {
AddressDataSource(Address addr) {
this.addr = addr;
offset = 0;
}
public byte readByte() throws IOException {
try {
byte res = (byte) addr.getCIntegerAt(offset, 1, false);
++offset;
return res;
} catch (UnmappedAddressException e) {
throw (IOException) new IOException("Unmapped address at 0x"
+ Long.toHexString(e.getAddress())).initCause(e);
} catch (DebuggerException e) {
throw (IOException) new IOException().initCause(e);
}
}
public short readShort() throws IOException {
int b1 = readByte() & 0xFF;
int b2 = readByte() & 0xFF;
return (short) ((b1 << 8) | b2);
}
public int readInt() throws IOException {
int b1 = ((int) readByte()) & 0xFF;
int b2 = ((int) readByte()) & 0xFF;
int b3 = ((int) readByte()) & 0xFF;
int b4 = ((int) readByte()) & 0xFF;
return ((b1 << 24) | (b2 << 16) | (b3 << 8) | b4);
}
public long readLong() throws IOException {
long b1 = ((long) readByte()) & 0xFFL;
long b2 = ((long) readByte()) & 0xFFL;
long b3 = ((long) readByte()) & 0xFFL;
long b4 = ((long) readByte()) & 0xFFL;
long b5 = ((long) readByte()) & 0xFFL;
long b6 = ((long) readByte()) & 0xFFL;
long b7 = ((long) readByte()) & 0xFFL;
long b8 = ((long) readByte()) & 0xFFL;
return (((((b1 << 24) | (b2 << 16) | (b3 << 8) | b4)) << 32) |
((((b5 << 24) | (b6 << 16) | (b7 << 8) | b8))));
}
public int read(byte[] b) throws IOException {
for (int i = 0; i < b.length; i++) {
b[i] = readByte();
}
return b.length;
}
public void seek(long pos) throws IOException {
offset = pos;
}
public long getFilePointer() throws IOException {
return offset;
}
public void close() throws IOException {
}
private Address addr;
private long offset;
}
package sun.jvm.hotspot.debugger;
public class AddressException extends RuntimeException {
private long addr;
public AddressException(long addr) {
this.addr = addr;
}
public AddressException(String detail, long addr) {
super(detail);
this.addr = addr;
}
public long getAddress() {
return addr;
}
public String getMessage() {
return Long.toHexString(addr);
}
}
package sun.jvm.hotspot.types;
import sun.jvm.hotspot.debugger.*;
public interface AddressField extends Field {
public Address getValue(Address addr)     throws UnmappedAddressException, UnalignedAddressException, WrongTypeException;
public Address getValue()                 throws UnmappedAddressException, UnalignedAddressException, WrongTypeException;
}
package sun.jvm.hotspot.utilities;
import sun.jvm.hotspot.debugger.*;
public class AddressOps {
public static boolean lessThan(Address a1, Address a2) {
if (a2 == null) {
return false;
} else if (a1 == null) {
return true;
} else {
return a1.lessThan(a2);
}
}
public static boolean lessThanOrEqual(Address a1, Address a2) {
if (a2 == null) {
return (a1 == null);
} else if (a1 == null) {
return true;
} else {
return a1.lessThanOrEqual(a2);
}
}
public static boolean greaterThan(Address a1, Address a2) {
if (a1 == null) {
return false;
} else if (a2 == null) {
return true;
} else {
return a1.greaterThan(a2);
}
}
public static boolean greaterThanOrEqual(Address a1, Address a2) {
if (a1 == null) {
return (a2 == null);
} else if (a2 == null) {
return true;
} else {
return a1.greaterThanOrEqual(a2);
}
}
public static boolean equal(Address a1, Address a2) {
if ((a1 == null) && (a2 == null)) {
return true;
}
if ((a1 == null) || (a2 == null)) {
return false;
}
return (a1.equals(a2));
}
public static boolean lt(Address a1, Address a2) {
return lessThan(a1, a2);
}
public static boolean lte(Address a1, Address a2) {
return lessThanOrEqual(a1, a2);
}
public static boolean gt(Address a1, Address a2) {
return greaterThan(a1, a2);
}
public static boolean gte(Address a1, Address a2) {
return greaterThanOrEqual(a1, a2);
}
public static Address max(Address a1, Address a2) {
return (gt(a1, a2) ? a1 : a2);
}
public static Address min(Address a1, Address a2) {
return (lt(a1, a2) ? a1 : a2);
}
}
package sun.jvm.hotspot.runtime;
import sun.jvm.hotspot.debugger.*;
public interface AddressVisitor {
public void visitAddress(Address addr);
public void visitCompOopAddress(Address addr);
}
package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public final class AddStyle implements Action {
private final Style style;
private final Pattern pattern;
private final StyledText text;
public AddStyle(Style style, Pattern pattern, StyledText text) {
this.style = style;
this.pattern = pattern;
this.text = text;
}
@Override
public void perform() {
var singleStyle = Set.of(style);
Matcher matcher = pattern.matcher(text.asCharSequence());
while (matcher.find()) {
int start = matcher.start();
int end = matcher.end();
text.subText(start, end).addStyle(singleStyle);
}
}
}
package sun.security.provider.certpath;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
public class AdjacencyList {
private ArrayList<BuildStep> mStepList;
private List<List<Vertex>> mOrigList;
public AdjacencyList(List<List<Vertex>> list) {
mStepList = new ArrayList<BuildStep>();
mOrigList = list;
buildList(list, 0, null);
}
public Iterator<BuildStep> iterator() {
return Collections.unmodifiableList(mStepList).iterator();
}
private boolean buildList(List<List<Vertex>> theList, int index,
BuildStep follow) {
List<Vertex> l = theList.get(index);
boolean allNegOne = true;
boolean allXcps = true;
for (Vertex v : l) {
if (v.getIndex() != -1) {
if (theList.get(v.getIndex()).size() != 0)
allNegOne = false;
} else {
if (v.getThrowable() == null)
allXcps = false;
}
mStepList.add(new BuildStep(v, BuildStep.POSSIBLE));
}
if (allNegOne) {
if (allXcps) {
if (follow == null)
mStepList.add(new BuildStep(null, BuildStep.FAIL));
else
mStepList.add(new BuildStep(follow.getVertex(),
BuildStep.BACK));
return false;
} else {
List<Vertex> possibles = new ArrayList<>();
for (Vertex v : l) {
if (v.getThrowable() == null)
possibles.add(v);
}
if (possibles.size() == 1) {
mStepList.add(new BuildStep(possibles.get(0),
BuildStep.SUCCEED));
} else {
mStepList.add(new BuildStep(possibles.get(0),
BuildStep.SUCCEED));
}
return true;
}
} else {
boolean success = false;
for (Vertex v : l) {
if (v.getIndex() != -1) {
if (theList.get(v.getIndex()).size() != 0) {
BuildStep bs = new BuildStep(v, BuildStep.FOLLOW);
mStepList.add(bs);
success = buildList(theList, v.getIndex(), bs);
}
}
}
if (success) {
return true;
} else {
if (follow == null)
mStepList.add(new BuildStep(null, BuildStep.FAIL));
else
mStepList.add(new BuildStep(follow.getVertex(),
BuildStep.BACK));
return false;
}
}
}
@Override
public String toString() {
StringBuilder sb = new StringBuilder("[\n");
int i = 0;
for (List<Vertex> l : mOrigList) {
sb.append("LinkedList[").append(i++).append("]:\n");
for (Vertex step : l) {
sb.append(step.toString()).append("\n");
}
}
sb.append("]\n");
return sb.toString();
}
}
package java.awt;
import java.awt.event.*;
import java.lang.annotation.Native;
public interface Adjustable {
@Native public static final int HORIZONTAL = 0;
@Native public static final int VERTICAL = 1;
@Native public static final int NO_ORIENTATION = 2;
int getOrientation();
void setMinimum(int min);
int getMinimum();
void setMaximum(int max);
int getMaximum();
void setUnitIncrement(int u);
int getUnitIncrement();
void setBlockIncrement(int b);
int getBlockIncrement();
void setVisibleAmount(int v);
int getVisibleAmount();
void setValue(int v);
int getValue();
void addAdjustmentListener(AdjustmentListener l);
void removeAdjustmentListener(AdjustmentListener l);
}
package java.awt.event;
import java.awt.AWTEvent;
import java.awt.Adjustable;
import java.io.Serial;
import java.lang.annotation.Native;
public class AdjustmentEvent extends AWTEvent {
public static final int ADJUSTMENT_FIRST    = 601;
public static final int ADJUSTMENT_LAST     = 601;
public static final int ADJUSTMENT_VALUE_CHANGED = ADJUSTMENT_FIRST;
@Native public static final int UNIT_INCREMENT      = 1;
@Native public static final int UNIT_DECREMENT      = 2;
@Native public static final int BLOCK_DECREMENT     = 3;
@Native public static final int BLOCK_INCREMENT     = 4;
@Native public static final int TRACK               = 5;
@SuppressWarnings("serial")     Adjustable adjustable;
int value;
int adjustmentType;
boolean isAdjusting;
@Serial
private static final long serialVersionUID = 5700290645205279921L;
public AdjustmentEvent(Adjustable source, int id, int type, int value) {
this(source, id, type, value, false);
}
public AdjustmentEvent(Adjustable source, int id, int type, int value, boolean isAdjusting) {
super(source, id);
adjustable = source;
this.adjustmentType = type;
this.value = value;
this.isAdjusting = isAdjusting;
}
public Adjustable getAdjustable() {
return adjustable;
}
public int getValue() {
return value;
}
public int getAdjustmentType() {
return adjustmentType;
}
public boolean getValueIsAdjusting() {
return isAdjusting;
}
public String paramString() {
String typeStr;
switch(id) {
case ADJUSTMENT_VALUE_CHANGED:
typeStr = "ADJUSTMENT_VALUE_CHANGED";
break;
default:
typeStr = "unknown type";
}
String adjTypeStr;
switch(adjustmentType) {
case UNIT_INCREMENT:
adjTypeStr = "UNIT_INCREMENT";
break;
case UNIT_DECREMENT:
adjTypeStr = "UNIT_DECREMENT";
break;
case BLOCK_INCREMENT:
adjTypeStr = "BLOCK_INCREMENT";
break;
case BLOCK_DECREMENT:
adjTypeStr = "BLOCK_DECREMENT";
break;
case TRACK:
adjTypeStr = "TRACK";
break;
default:
adjTypeStr = "unknown type";
}
return typeStr
+ ",adjType="+adjTypeStr
+ ",value="+value
+ ",isAdjusting="+isAdjusting;
}
}
package java.awt.event;
import java.util.EventListener;
public interface AdjustmentListener extends EventListener {
public void adjustmentValueChanged(AdjustmentEvent e);
}
package java.util.zip;
import java.lang.ref.Reference;
import java.nio.ByteBuffer;
import sun.nio.ch.DirectBuffer;
import jdk.internal.util.Preconditions;
import jdk.internal.vm.annotation.IntrinsicCandidate;
public class Adler32 implements Checksum {
private int adler = 1;
public Adler32() {
}
@Override
public void update(int b) {
adler = update(adler, b);
}
@Override
public void update(byte[] b, int off, int len) {
if (b == null) {
throw new NullPointerException();
}
Preconditions.checkFromIndexSize(len, off, b.length, Preconditions.AIOOBE_FORMATTER);
adler = updateBytes(adler, b, off, len);
}
@Override
public void update(ByteBuffer buffer) {
int pos = buffer.position();
int limit = buffer.limit();
assert (pos <= limit);
int rem = limit - pos;
if (rem <= 0)
return;
if (buffer.isDirect()) {
try {
adler = updateByteBuffer(adler, ((DirectBuffer)buffer).address(), pos, rem);
} finally {
Reference.reachabilityFence(buffer);
}
} else if (buffer.hasArray()) {
adler = updateBytes(adler, buffer.array(), pos + buffer.arrayOffset(), rem);
} else {
byte[] b = new byte[Math.min(buffer.remaining(), 4096)];
while (buffer.hasRemaining()) {
int length = Math.min(buffer.remaining(), b.length);
buffer.get(b, 0, length);
update(b, 0, length);
}
}
buffer.position(limit);
}
@Override
public void reset() {
adler = 1;
}
@Override
public long getValue() {
return (long)adler & 0xffffffffL;
}
private static native int update(int adler, int b);
@IntrinsicCandidate
private static native int updateBytes(int adler, byte[] b, int off,
int len);
@IntrinsicCandidate
private static native int updateByteBuffer(int adler, long addr,
int off, int len);
static {
ZipUtils.loadLibrary();
}
}
package com.sun.imageio.plugins.jpeg;
import javax.imageio.IIOException;
import javax.imageio.metadata.IIOInvalidTreeException;
import javax.imageio.metadata.IIOMetadataNode;
import javax.imageio.stream.ImageOutputStream;
import java.io.IOException;
import org.w3c.dom.Node;
import org.w3c.dom.NamedNodeMap;
class AdobeMarkerSegment extends MarkerSegment {
int version;
int flags0;
int flags1;
int transform;
private static final int ID_SIZE = 5;
AdobeMarkerSegment(int transform) {
super(JPEG.APP14);
version = 101;
flags0 = 0;
flags1 = 0;
this.transform = transform;
}
AdobeMarkerSegment(JPEGBuffer buffer) throws IOException {
super(buffer);
buffer.bufPtr += ID_SIZE;         version = (buffer.buf[buffer.bufPtr++] & 0xff) << 8;
version |= buffer.buf[buffer.bufPtr++] & 0xff;
flags0 = (buffer.buf[buffer.bufPtr++] & 0xff) << 8;
flags0 |= buffer.buf[buffer.bufPtr++] & 0xff;
flags1 = (buffer.buf[buffer.bufPtr++] & 0xff) << 8;
flags1 |= buffer.buf[buffer.bufPtr++] & 0xff;
transform = buffer.buf[buffer.bufPtr++] & 0xff;
buffer.bufAvail -= length;
}
AdobeMarkerSegment(Node node) throws IIOInvalidTreeException {
this(0);         updateFromNativeNode(node, true);
}
IIOMetadataNode getNativeNode() {
IIOMetadataNode node = new IIOMetadataNode("app14Adobe");
node.setAttribute("version", Integer.toString(version));
node.setAttribute("flags0", Integer.toString(flags0));
node.setAttribute("flags1", Integer.toString(flags1));
node.setAttribute("transform", Integer.toString(transform));
return node;
}
void updateFromNativeNode(Node node, boolean fromScratch)
throws IIOInvalidTreeException {
NamedNodeMap attrs = node.getAttributes();
transform = getAttributeValue(node, attrs, "transform", 0, 2, true);
int count = attrs.getLength();
if (count > 4) {
throw new IIOInvalidTreeException
("Adobe APP14 node cannot have > 4 attributes", node);
}
if (count > 1) {
int value = getAttributeValue(node, attrs, "version",
100, 255, false);
version = (value != -1) ? value : version;
value = getAttributeValue(node, attrs, "flags0", 0, 65535, false);
flags0 = (value != -1) ? value : flags0;
value = getAttributeValue(node, attrs, "flags1", 0, 65535, false);
flags1 = (value != -1) ? value : flags1;
}
}
void write(ImageOutputStream ios) throws IOException {
length = 14;
writeTag(ios);
byte [] id = {0x41, 0x64, 0x6F, 0x62, 0x65};
ios.write(id);
write2bytes(ios, version);
write2bytes(ios, flags0);
write2bytes(ios, flags1);
ios.write(transform);
}
static void writeAdobeSegment(ImageOutputStream ios, int transform)
throws IOException {
(new AdobeMarkerSegment(transform)).write(ios);
}
void print () {
printTag("Adobe APP14");
System.out.print("Version: ");
System.out.println(version);
System.out.print("Flags0: 0x");
System.out.println(Integer.toHexString(flags0));
System.out.print("Flags1: 0x");
System.out.println(Integer.toHexString(flags1));
System.out.print("Transform: ");
System.out.println(transform);
}
}
package jdk.internal.org.objectweb.asm.commons;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import jdk.internal.org.objectweb.asm.ConstantDynamic;
import jdk.internal.org.objectweb.asm.Handle;
import jdk.internal.org.objectweb.asm.Label;
import jdk.internal.org.objectweb.asm.MethodVisitor;
import jdk.internal.org.objectweb.asm.Opcodes;
import jdk.internal.org.objectweb.asm.Type;
public abstract class AdviceAdapter extends GeneratorAdapter implements Opcodes {
private static final Object UNINITIALIZED_THIS = new Object();
private static final Object OTHER = new Object();
private static final String INVALID_OPCODE = "Invalid opcode ";
protected int methodAccess;
protected String methodDesc;
private final boolean isConstructor;
private boolean superClassConstructorCalled;
private List<Object> stackFrame;
private Map<Label, List<Object>> forwardJumpStackFrames;
protected AdviceAdapter(
final int api,
final MethodVisitor methodVisitor,
final int access,
final String name,
final String descriptor) {
super(api, methodVisitor, access, name, descriptor);
methodAccess = access;
methodDesc = descriptor;
isConstructor = "<init>".equals(name);
}
@Override
public void visitCode() {
super.visitCode();
if (isConstructor) {
stackFrame = new ArrayList<>();
forwardJumpStackFrames = new HashMap<>();
} else {
onMethodEnter();
}
}
@Override
public void visitLabel(final Label label) {
super.visitLabel(label);
if (isConstructor && forwardJumpStackFrames != null) {
List<Object> labelStackFrame = forwardJumpStackFrames.get(label);
if (labelStackFrame != null) {
stackFrame = labelStackFrame;
superClassConstructorCalled = false;
forwardJumpStackFrames.remove(label);
}
}
}
@Override
public void visitInsn(final int opcode) {
if (isConstructor && !superClassConstructorCalled) {
int stackSize;
switch (opcode) {
case IRETURN:
case FRETURN:
case ARETURN:
case LRETURN:
case DRETURN:
throw new IllegalArgumentException("Invalid return in constructor");
case RETURN:                     onMethodExit(opcode);
endConstructorBasicBlockWithoutSuccessor();
break;
case ATHROW:                     popValue();
onMethodExit(opcode);
endConstructorBasicBlockWithoutSuccessor();
break;
case NOP:
case LALOAD:                 case DALOAD:                 case LNEG:
case DNEG:
case FNEG:
case INEG:
case L2D:
case D2L:
case F2I:
case I2B:
case I2C:
case I2S:
case I2F:
case ARRAYLENGTH:
break;
case ACONST_NULL:
case ICONST_M1:
case ICONST_0:
case ICONST_1:
case ICONST_2:
case ICONST_3:
case ICONST_4:
case ICONST_5:
case FCONST_0:
case FCONST_1:
case FCONST_2:
case F2L:                 case F2D:
case I2L:
case I2D:
pushValue(OTHER);
break;
case LCONST_0:
case LCONST_1:
case DCONST_0:
case DCONST_1:
pushValue(OTHER);
pushValue(OTHER);
break;
case IALOAD:                 case FALOAD:                 case AALOAD:                 case BALOAD:                 case CALOAD:                 case SALOAD:                 case POP:
case IADD:
case FADD:
case ISUB:
case LSHL:                 case LSHR:                 case LUSHR:                 case L2I:                 case L2F:                 case D2I:                 case D2F:                 case FSUB:
case FMUL:
case FDIV:
case FREM:
case FCMPL:                 case FCMPG:                 case IMUL:
case IDIV:
case IREM:
case ISHL:
case ISHR:
case IUSHR:
case IAND:
case IOR:
case IXOR:
case MONITORENTER:
case MONITOREXIT:
popValue();
break;
case POP2:
case LSUB:
case LMUL:
case LDIV:
case LREM:
case LADD:
case LAND:
case LOR:
case LXOR:
case DADD:
case DMUL:
case DSUB:
case DDIV:
case DREM:
popValue();
popValue();
break;
case IASTORE:
case FASTORE:
case AASTORE:
case BASTORE:
case CASTORE:
case SASTORE:
case LCMP:                 case DCMPL:
case DCMPG:
popValue();
popValue();
popValue();
break;
case LASTORE:
case DASTORE:
popValue();
popValue();
popValue();
popValue();
break;
case DUP:
pushValue(peekValue());
break;
case DUP_X1:
stackSize = stackFrame.size();
stackFrame.add(stackSize - 2, stackFrame.get(stackSize - 1));
break;
case DUP_X2:
stackSize = stackFrame.size();
stackFrame.add(stackSize - 3, stackFrame.get(stackSize - 1));
break;
case DUP2:
stackSize = stackFrame.size();
stackFrame.add(stackSize - 2, stackFrame.get(stackSize - 1));
stackFrame.add(stackSize - 2, stackFrame.get(stackSize - 1));
break;
case DUP2_X1:
stackSize = stackFrame.size();
stackFrame.add(stackSize - 3, stackFrame.get(stackSize - 1));
stackFrame.add(stackSize - 3, stackFrame.get(stackSize - 1));
break;
case DUP2_X2:
stackSize = stackFrame.size();
stackFrame.add(stackSize - 4, stackFrame.get(stackSize - 1));
stackFrame.add(stackSize - 4, stackFrame.get(stackSize - 1));
break;
case SWAP:
stackSize = stackFrame.size();
stackFrame.add(stackSize - 2, stackFrame.get(stackSize - 1));
stackFrame.remove(stackSize);
break;
default:
throw new IllegalArgumentException(INVALID_OPCODE + opcode);
}
} else {
switch (opcode) {
case RETURN:
case IRETURN:
case FRETURN:
case ARETURN:
case LRETURN:
case DRETURN:
case ATHROW:
onMethodExit(opcode);
break;
default:
break;
}
}
super.visitInsn(opcode);
}
@Override
public void visitVarInsn(final int opcode, final int varIndex) {
super.visitVarInsn(opcode, varIndex);
if (isConstructor && !superClassConstructorCalled) {
switch (opcode) {
case ILOAD:
case FLOAD:
pushValue(OTHER);
break;
case LLOAD:
case DLOAD:
pushValue(OTHER);
pushValue(OTHER);
break;
case ALOAD:
pushValue(varIndex == 0 ? UNINITIALIZED_THIS : OTHER);
break;
case ASTORE:
case ISTORE:
case FSTORE:
popValue();
break;
case LSTORE:
case DSTORE:
popValue();
popValue();
break;
case RET:
endConstructorBasicBlockWithoutSuccessor();
break;
default:
throw new IllegalArgumentException(INVALID_OPCODE + opcode);
}
}
}
@Override
public void visitFieldInsn(
final int opcode, final String owner, final String name, final String descriptor) {
super.visitFieldInsn(opcode, owner, name, descriptor);
if (isConstructor && !superClassConstructorCalled) {
char firstDescriptorChar = descriptor.charAt(0);
boolean longOrDouble = firstDescriptorChar == 'J' || firstDescriptorChar == 'D';
switch (opcode) {
case GETSTATIC:
pushValue(OTHER);
if (longOrDouble) {
pushValue(OTHER);
}
break;
case PUTSTATIC:
popValue();
if (longOrDouble) {
popValue();
}
break;
case PUTFIELD:
popValue();
popValue();
if (longOrDouble) {
popValue();
}
break;
case GETFIELD:
if (longOrDouble) {
pushValue(OTHER);
}
break;
default:
throw new IllegalArgumentException(INVALID_OPCODE + opcode);
}
}
}
@Override
public void visitIntInsn(final int opcode, final int operand) {
super.visitIntInsn(opcode, operand);
if (isConstructor && !superClassConstructorCalled && opcode != NEWARRAY) {
pushValue(OTHER);
}
}
@Override
public void visitLdcInsn(final Object value) {
super.visitLdcInsn(value);
if (isConstructor && !superClassConstructorCalled) {
pushValue(OTHER);
if (value instanceof Double
|| value instanceof Long
|| (value instanceof ConstantDynamic && ((ConstantDynamic) value).getSize() == 2)) {
pushValue(OTHER);
}
}
}
@Override
public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
super.visitMultiANewArrayInsn(descriptor, numDimensions);
if (isConstructor && !superClassConstructorCalled) {
for (int i = 0; i < numDimensions; i++) {
popValue();
}
pushValue(OTHER);
}
}
@Override
public void visitTypeInsn(final int opcode, final String type) {
super.visitTypeInsn(opcode, type);
if (isConstructor && !superClassConstructorCalled && opcode == NEW) {
pushValue(OTHER);
}
}
@Override
public void visitMethodInsn(
final int opcodeAndSource,
final String owner,
final String name,
final String descriptor,
final boolean isInterface) {
if (api < Opcodes.ASM5 && (opcodeAndSource & Opcodes.SOURCE_DEPRECATED) == 0) {
super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
return;
}
super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
int opcode = opcodeAndSource & ~Opcodes.SOURCE_MASK;
doVisitMethodInsn(opcode, name, descriptor);
}
private void doVisitMethodInsn(final int opcode, final String name, final String descriptor) {
if (isConstructor && !superClassConstructorCalled) {
for (Type argumentType : Type.getArgumentTypes(descriptor)) {
popValue();
if (argumentType.getSize() == 2) {
popValue();
}
}
switch (opcode) {
case INVOKEINTERFACE:
case INVOKEVIRTUAL:
popValue();
break;
case INVOKESPECIAL:
Object value = popValue();
if (value == UNINITIALIZED_THIS
&& !superClassConstructorCalled
&& name.equals("<init>")) {
superClassConstructorCalled = true;
onMethodEnter();
}
break;
default:
break;
}
Type returnType = Type.getReturnType(descriptor);
if (returnType != Type.VOID_TYPE) {
pushValue(OTHER);
if (returnType.getSize() == 2) {
pushValue(OTHER);
}
}
}
}
@Override
public void visitInvokeDynamicInsn(
final String name,
final String descriptor,
final Handle bootstrapMethodHandle,
final Object... bootstrapMethodArguments) {
super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
doVisitMethodInsn(Opcodes.INVOKEDYNAMIC, name, descriptor);
}
@Override
public void visitJumpInsn(final int opcode, final Label label) {
super.visitJumpInsn(opcode, label);
if (isConstructor && !superClassConstructorCalled) {
switch (opcode) {
case IFEQ:
case IFNE:
case IFLT:
case IFGE:
case IFGT:
case IFLE:
case IFNULL:
case IFNONNULL:
popValue();
break;
case IF_ICMPEQ:
case IF_ICMPNE:
case IF_ICMPLT:
case IF_ICMPGE:
case IF_ICMPGT:
case IF_ICMPLE:
case IF_ACMPEQ:
case IF_ACMPNE:
popValue();
popValue();
break;
case JSR:
pushValue(OTHER);
break;
case GOTO:
endConstructorBasicBlockWithoutSuccessor();
break;
default:
break;
}
addForwardJump(label);
}
}
@Override
public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
super.visitLookupSwitchInsn(dflt, keys, labels);
if (isConstructor && !superClassConstructorCalled) {
popValue();
addForwardJumps(dflt, labels);
endConstructorBasicBlockWithoutSuccessor();
}
}
@Override
public void visitTableSwitchInsn(
final int min, final int max, final Label dflt, final Label... labels) {
super.visitTableSwitchInsn(min, max, dflt, labels);
if (isConstructor && !superClassConstructorCalled) {
popValue();
addForwardJumps(dflt, labels);
endConstructorBasicBlockWithoutSuccessor();
}
}
@Override
public void visitTryCatchBlock(
final Label start, final Label end, final Label handler, final String type) {
super.visitTryCatchBlock(start, end, handler, type);
if (isConstructor && !forwardJumpStackFrames.containsKey(handler)) {
List<Object> handlerStackFrame = new ArrayList<>();
handlerStackFrame.add(OTHER);
forwardJumpStackFrames.put(handler, handlerStackFrame);
}
}
private void addForwardJumps(final Label dflt, final Label[] labels) {
addForwardJump(dflt);
for (Label label : labels) {
addForwardJump(label);
}
}
private void addForwardJump(final Label label) {
if (forwardJumpStackFrames.containsKey(label)) {
return;
}
forwardJumpStackFrames.put(label, new ArrayList<>(stackFrame));
}
private void endConstructorBasicBlockWithoutSuccessor() {
superClassConstructorCalled = true;
}
private Object popValue() {
return stackFrame.remove(stackFrame.size() - 1);
}
private Object peekValue() {
return stackFrame.get(stackFrame.size() - 1);
}
private void pushValue(final Object value) {
stackFrame.add(value);
}
protected void onMethodEnter() {}
protected void onMethodExit(final int opcode) {}
}
package javax.crypto;
public class AEADBadTagException extends BadPaddingException {
@java.io.Serial
private static final long serialVersionUID = -488059093241685509L;
public AEADBadTagException() {
super();
}
public AEADBadTagException(String msg) {
super(msg);
}
}
package sun.security.krb5.internal.crypto;
import sun.security.krb5.internal.crypto.dk.AesDkCrypto;
import sun.security.krb5.KrbCryptoException;
import java.security.GeneralSecurityException;
public class Aes128 {
private static final AesDkCrypto CRYPTO = new AesDkCrypto(128);
private Aes128() {
}
public static byte[] stringToKey(char[] password, String salt, byte[] params)
throws GeneralSecurityException {
return CRYPTO.stringToKey(password, salt, params);
}
public static int getChecksumLength() {
return CRYPTO.getChecksumLength();
}
public static byte[] calculateChecksum(byte[] baseKey, int usage,
byte[] input, int start, int len) throws GeneralSecurityException {
return CRYPTO.calculateChecksum(baseKey, usage, input, start, len);
}
public static byte[] encrypt(byte[] baseKey, int usage,
byte[] ivec, byte[] plaintext, int start, int len)
throws GeneralSecurityException, KrbCryptoException {
return CRYPTO.encrypt(baseKey, usage, ivec, null ,
plaintext, start, len);
}
public static byte[] encryptRaw(byte[] baseKey, int usage,
byte[] ivec, byte[] plaintext, int start, int len)
throws GeneralSecurityException, KrbCryptoException {
return CRYPTO.encryptRaw(baseKey, usage, ivec, plaintext, start, len);
}
public static byte[] decrypt(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len)
throws GeneralSecurityException {
return CRYPTO.decrypt(baseKey, usage, ivec, ciphertext, start, len);
}
public static byte[] decryptRaw(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len)
throws GeneralSecurityException {
return CRYPTO.decryptRaw(baseKey, usage, ivec, ciphertext, start, len);
}
};
package sun.security.krb5.internal.crypto;
import sun.security.krb5.KrbCryptoException;
import sun.security.krb5.internal.*;
import java.security.GeneralSecurityException;
import sun.security.krb5.EncryptedData;
import sun.security.krb5.Checksum;
public final class Aes128CtsHmacSha1EType extends EType {
public int eType() {
return EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96;
}
public int minimumPadSize() {
return 0;
}
public int confounderSize() {
return blockSize();
}
public int checksumType() {
return Checksum.CKSUMTYPE_HMAC_SHA1_96_AES128;
}
public int checksumSize() {
return Aes128.getChecksumLength();
}
public int blockSize() {
return 16;
}
public int keyType() {
return Krb5.KEYTYPE_AES;
}
public int keySize() {
return 16;     }
public byte[] encrypt(byte[] data, byte[] key, int usage)
throws KrbCryptoException {
byte[] ivec = new byte[blockSize()];
return encrypt(data, key, ivec, usage);
}
public byte[] encrypt(byte[] data, byte[] key, byte[] ivec, int usage)
throws KrbCryptoException {
try {
return Aes128.encrypt(key, usage, ivec, data, 0, data.length);
} catch (GeneralSecurityException e) {
KrbCryptoException ke = new KrbCryptoException(e.getMessage());
ke.initCause(e);
throw ke;
}
}
public byte[] decrypt(byte[] cipher, byte[] key, int usage)
throws KrbApErrException, KrbCryptoException {
byte[] ivec = new byte[blockSize()];
return decrypt(cipher, key, ivec, usage);
}
public byte[] decrypt(byte[] cipher, byte[] key, byte[] ivec, int usage)
throws KrbApErrException, KrbCryptoException {
try {
return Aes128.decrypt(key, usage, ivec, cipher, 0, cipher.length);
} catch (GeneralSecurityException e) {
KrbCryptoException ke = new KrbCryptoException(e.getMessage());
ke.initCause(e);
throw ke;
}
}
public byte[] decryptedData(byte[] data) {
return data;
}
}
package sun.security.krb5.internal.crypto;
import sun.security.krb5.KrbCryptoException;
import sun.security.krb5.internal.*;
import java.security.GeneralSecurityException;
import sun.security.krb5.EncryptedData;
import sun.security.krb5.Checksum;
public final class Aes128CtsHmacSha2EType extends EType {
public int eType() {
return EncryptedData.ETYPE_AES128_CTS_HMAC_SHA256_128;
}
public int minimumPadSize() {
return 0;
}
public int confounderSize() {
return blockSize();
}
public int checksumType() {
return Checksum.CKSUMTYPE_HMAC_SHA256_128_AES128;
}
public int checksumSize() {
return Aes128Sha2.getChecksumLength();
}
public int blockSize() {
return 16;
}
public int keyType() {
return Krb5.KEYTYPE_AES;
}
public int keySize() {
return 16;     }
public byte[] encrypt(byte[] data, byte[] key, int usage)
throws KrbCryptoException {
byte[] ivec = new byte[blockSize()];
return encrypt(data, key, ivec, usage);
}
public byte[] encrypt(byte[] data, byte[] key, byte[] ivec, int usage)
throws KrbCryptoException {
try {
return Aes128Sha2.encrypt(key, usage, ivec, data, 0, data.length);
} catch (GeneralSecurityException e) {
KrbCryptoException ke = new KrbCryptoException(e.getMessage());
ke.initCause(e);
throw ke;
}
}
public byte[] decrypt(byte[] cipher, byte[] key, int usage)
throws KrbApErrException, KrbCryptoException {
byte[] ivec = new byte[blockSize()];
return decrypt(cipher, key, ivec, usage);
}
public byte[] decrypt(byte[] cipher, byte[] key, byte[] ivec, int usage)
throws KrbApErrException, KrbCryptoException {
try {
return Aes128Sha2.decrypt(key, usage, ivec, cipher, 0, cipher.length);
} catch (GeneralSecurityException e) {
KrbCryptoException ke = new KrbCryptoException(e.getMessage());
ke.initCause(e);
throw ke;
}
}
public byte[] decryptedData(byte[] data) {
return data;
}
}
package sun.security.krb5.internal.crypto;
import sun.security.krb5.internal.crypto.dk.AesSha2DkCrypto;
import sun.security.krb5.KrbCryptoException;
import java.security.GeneralSecurityException;
public class Aes128Sha2 {
private static final AesSha2DkCrypto CRYPTO = new AesSha2DkCrypto(128);
private Aes128Sha2() {
}
public static byte[] stringToKey(char[] password, String salt, byte[] params)
throws GeneralSecurityException {
return CRYPTO.stringToKey(password, salt, params);
}
public static int getChecksumLength() {
return CRYPTO.getChecksumLength();
}
public static byte[] calculateChecksum(byte[] baseKey, int usage,
byte[] input, int start, int len) throws GeneralSecurityException {
return CRYPTO.calculateChecksum(baseKey, usage, input, start, len);
}
public static byte[] encrypt(byte[] baseKey, int usage,
byte[] ivec, byte[] plaintext, int start, int len)
throws GeneralSecurityException, KrbCryptoException {
return CRYPTO.encrypt(baseKey, usage, ivec, null ,
plaintext, start, len);
}
public static byte[] encryptRaw(byte[] baseKey, int usage,
byte[] ivec, byte[] plaintext, int start, int len)
throws GeneralSecurityException, KrbCryptoException {
return CRYPTO.encryptRaw(baseKey, usage, ivec, plaintext, start, len);
}
public static byte[] decrypt(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len)
throws GeneralSecurityException {
return CRYPTO.decrypt(baseKey, usage, ivec, ciphertext, start, len);
}
public static byte[] decryptRaw(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len)
throws GeneralSecurityException {
return CRYPTO.decryptRaw(baseKey, usage, ivec, ciphertext, start, len);
}
};
package sun.security.krb5.internal.crypto;
import sun.security.krb5.internal.crypto.dk.AesDkCrypto;
import sun.security.krb5.KrbCryptoException;
import java.security.GeneralSecurityException;
public class Aes256 {
private static final AesDkCrypto CRYPTO = new AesDkCrypto(256);
private Aes256() {
}
public static byte[] stringToKey(char[] password, String salt, byte[] params)
throws GeneralSecurityException {
return CRYPTO.stringToKey(password, salt, params);
}
public static int getChecksumLength() {
return CRYPTO.getChecksumLength();
}
public static byte[] calculateChecksum(byte[] baseKey, int usage,
byte[] input, int start, int len) throws GeneralSecurityException {
return CRYPTO.calculateChecksum(baseKey, usage, input, start, len);
}
public static byte[] encrypt(byte[] baseKey, int usage,
byte[] ivec, byte[] plaintext, int start, int len)
throws GeneralSecurityException, KrbCryptoException {
return CRYPTO.encrypt(baseKey, usage, ivec, null ,
plaintext, start, len);
}
public static byte[] encryptRaw(byte[] baseKey, int usage,
byte[] ivec, byte[] plaintext, int start, int len)
throws GeneralSecurityException, KrbCryptoException {
return CRYPTO.encryptRaw(baseKey, usage, ivec, plaintext, start, len);
}
public static byte[] decrypt(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len)
throws GeneralSecurityException {
return CRYPTO.decrypt(baseKey, usage, ivec, ciphertext, start, len);
}
public static byte[] decryptRaw(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len)
throws GeneralSecurityException {
return CRYPTO.decryptRaw(baseKey, usage, ivec, ciphertext, start, len);
}
};
package sun.security.krb5.internal.crypto;
import sun.security.krb5.KrbCryptoException;
import sun.security.krb5.internal.*;
import java.security.GeneralSecurityException;
import sun.security.krb5.EncryptedData;
import sun.security.krb5.Checksum;
public final class Aes256CtsHmacSha1EType extends EType {
public int eType() {
return EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96;
}
public int minimumPadSize() {
return 0;
}
public int confounderSize() {
return blockSize();
}
public int checksumType() {
return Checksum.CKSUMTYPE_HMAC_SHA1_96_AES256;
}
public int checksumSize() {
return Aes256.getChecksumLength();
}
public int blockSize() {
return 16;
}
public int keyType() {
return Krb5.KEYTYPE_AES;
}
public int keySize() {
return 32;     }
public byte[] encrypt(byte[] data, byte[] key, int usage)
throws KrbCryptoException {
byte[] ivec = new byte[blockSize()];
return encrypt(data, key, ivec, usage);
}
public byte[] encrypt(byte[] data, byte[] key, byte[] ivec, int usage)
throws KrbCryptoException {
try {
return Aes256.encrypt(key, usage, ivec, data, 0, data.length);
} catch (GeneralSecurityException e) {
KrbCryptoException ke = new KrbCryptoException(e.getMessage());
ke.initCause(e);
throw ke;
}
}
public byte[] decrypt(byte[] cipher, byte[] key, int usage)
throws KrbApErrException, KrbCryptoException {
byte[] ivec = new byte[blockSize()];
return decrypt(cipher, key, ivec, usage);
}
public byte[] decrypt(byte[] cipher, byte[] key, byte[] ivec, int usage)
throws KrbApErrException, KrbCryptoException {
try {
return Aes256.decrypt(key, usage, ivec, cipher, 0, cipher.length);
} catch (GeneralSecurityException e) {
KrbCryptoException ke = new KrbCryptoException(e.getMessage());
ke.initCause(e);
throw ke;
}
}
public byte[] decryptedData(byte[] data) {
return data;
}
}
package sun.security.krb5.internal.crypto;
import sun.security.krb5.KrbCryptoException;
import sun.security.krb5.internal.*;
import java.security.GeneralSecurityException;
import sun.security.krb5.EncryptedData;
import sun.security.krb5.Checksum;
public final class Aes256CtsHmacSha2EType extends EType {
public int eType() {
return EncryptedData.ETYPE_AES256_CTS_HMAC_SHA384_192;
}
public int minimumPadSize() {
return 0;
}
public int confounderSize() {
return blockSize();
}
public int checksumType() {
return Checksum.CKSUMTYPE_HMAC_SHA384_192_AES256;
}
public int checksumSize() {
return Aes256Sha2.getChecksumLength();
}
public int blockSize() {
return 16;
}
public int keyType() {
return Krb5.KEYTYPE_AES;
}
public int keySize() {
return 32;     }
public byte[] encrypt(byte[] data, byte[] key, int usage)
throws KrbCryptoException {
byte[] ivec = new byte[blockSize()];
return encrypt(data, key, ivec, usage);
}
public byte[] encrypt(byte[] data, byte[] key, byte[] ivec, int usage)
throws KrbCryptoException {
try {
return Aes256Sha2.encrypt(key, usage, ivec, data, 0, data.length);
} catch (GeneralSecurityException e) {
KrbCryptoException ke = new KrbCryptoException(e.getMessage());
ke.initCause(e);
throw ke;
}
}
public byte[] decrypt(byte[] cipher, byte[] key, int usage)
throws KrbApErrException, KrbCryptoException {
byte[] ivec = new byte[blockSize()];
return decrypt(cipher, key, ivec, usage);
}
public byte[] decrypt(byte[] cipher, byte[] key, byte[] ivec, int usage)
throws KrbApErrException, KrbCryptoException {
try {
return Aes256Sha2.decrypt(key, usage, ivec, cipher, 0, cipher.length);
} catch (GeneralSecurityException e) {
KrbCryptoException ke = new KrbCryptoException(e.getMessage());
ke.initCause(e);
throw ke;
}
}
public byte[] decryptedData(byte[] data) {
return data;
}
}
package sun.security.krb5.internal.crypto;
import sun.security.krb5.internal.crypto.dk.AesSha2DkCrypto;
import sun.security.krb5.KrbCryptoException;
import java.security.GeneralSecurityException;
public class Aes256Sha2 {
private static final AesSha2DkCrypto CRYPTO = new AesSha2DkCrypto(256);
private Aes256Sha2() {
}
public static byte[] stringToKey(char[] password, String salt, byte[] params)
throws GeneralSecurityException {
return CRYPTO.stringToKey(password, salt, params);
}
public static int getChecksumLength() {
return CRYPTO.getChecksumLength();
}
public static byte[] calculateChecksum(byte[] baseKey, int usage,
byte[] input, int start, int len) throws GeneralSecurityException {
return CRYPTO.calculateChecksum(baseKey, usage, input, start, len);
}
public static byte[] encrypt(byte[] baseKey, int usage,
byte[] ivec, byte[] plaintext, int start, int len)
throws GeneralSecurityException, KrbCryptoException {
return CRYPTO.encrypt(baseKey, usage, ivec, null ,
plaintext, start, len);
}
public static byte[] encryptRaw(byte[] baseKey, int usage,
byte[] ivec, byte[] plaintext, int start, int len)
throws GeneralSecurityException, KrbCryptoException {
return CRYPTO.encryptRaw(baseKey, usage, ivec, plaintext, start, len);
}
public static byte[] decrypt(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len)
throws GeneralSecurityException {
return CRYPTO.decrypt(baseKey, usage, ivec, ciphertext, start, len);
}
public static byte[] decryptRaw(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len)
throws GeneralSecurityException {
return CRYPTO.decryptRaw(baseKey, usage, ivec, ciphertext, start, len);
}
};
package com.sun.crypto.provider;
import javax.crypto.BadPaddingException;
import javax.crypto.CipherSpi;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.ShortBufferException;
import java.nio.ByteBuffer;
import java.security.AlgorithmParameters;
import java.security.GeneralSecurityException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.ProviderException;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Arrays;
abstract class AESCipher extends CipherSpi {
public static final class General extends AESCipher {
public General() {
super(-1);
}
}
abstract static class OidImpl extends AESCipher {
protected OidImpl(int keySize, String mode, String padding) {
super(keySize);
try {
engineSetMode(mode);
engineSetPadding(padding);
} catch (GeneralSecurityException gse) {
throw new ProviderException("Internal Error", gse);
}
}
}
public static final class AES128_ECB_NoPadding extends OidImpl {
public AES128_ECB_NoPadding() {
super(16, "ECB", "NOPADDING");
}
}
public static final class AES192_ECB_NoPadding extends OidImpl {
public AES192_ECB_NoPadding() {
super(24, "ECB", "NOPADDING");
}
}
public static final class AES256_ECB_NoPadding extends OidImpl {
public AES256_ECB_NoPadding() {
super(32, "ECB", "NOPADDING");
}
}
public static final class AES128_CBC_NoPadding extends OidImpl {
public AES128_CBC_NoPadding() {
super(16, "CBC", "NOPADDING");
}
}
public static final class AES192_CBC_NoPadding extends OidImpl {
public AES192_CBC_NoPadding() {
super(24, "CBC", "NOPADDING");
}
}
public static final class AES256_CBC_NoPadding extends OidImpl {
public AES256_CBC_NoPadding() {
super(32, "CBC", "NOPADDING");
}
}
public static final class AES128_OFB_NoPadding extends OidImpl {
public AES128_OFB_NoPadding() {
super(16, "OFB", "NOPADDING");
}
}
public static final class AES192_OFB_NoPadding extends OidImpl {
public AES192_OFB_NoPadding() {
super(24, "OFB", "NOPADDING");
}
}
public static final class AES256_OFB_NoPadding extends OidImpl {
public AES256_OFB_NoPadding() {
super(32, "OFB", "NOPADDING");
}
}
public static final class AES128_CFB_NoPadding extends OidImpl {
public AES128_CFB_NoPadding() {
super(16, "CFB", "NOPADDING");
}
}
public static final class AES192_CFB_NoPadding extends OidImpl {
public AES192_CFB_NoPadding() {
super(24, "CFB", "NOPADDING");
}
}
public static final class AES256_CFB_NoPadding extends OidImpl {
public AES256_CFB_NoPadding() {
super(32, "CFB", "NOPADDING");
}
}
static final void checkKeySize(Key key, int fixedKeySize)
throws InvalidKeyException {
if (fixedKeySize != -1) {
if (key == null) {
throw new InvalidKeyException("The key must not be null");
}
byte[] value = key.getEncoded();
if (value == null) {
throw new InvalidKeyException("Key encoding must not be null");
} else {
Arrays.fill(value, (byte)0);
if (value.length != fixedKeySize) {
throw new InvalidKeyException("The key must be " +
fixedKeySize + " bytes");
}
}
}
}
private CipherCore core = null;
private final int fixedKeySize;
protected AESCipher(int keySize) {
core = new CipherCore(new AESCrypt(), AESConstants.AES_BLOCK_SIZE);
fixedKeySize = keySize;
}
protected void engineSetMode(String mode)
throws NoSuchAlgorithmException {
core.setMode(mode);
}
protected void engineSetPadding(String paddingScheme)
throws NoSuchPaddingException {
core.setPadding(paddingScheme);
}
protected int engineGetBlockSize() {
return AESConstants.AES_BLOCK_SIZE;
}
protected int engineGetOutputSize(int inputLen) {
return core.getOutputSize(inputLen);
}
protected byte[] engineGetIV() {
return core.getIV();
}
protected AlgorithmParameters engineGetParameters() {
return core.getParameters("AES");
}
protected void engineInit(int opmode, Key key, SecureRandom random)
throws InvalidKeyException {
checkKeySize(key, fixedKeySize);
core.init(opmode, key, random);
}
protected void engineInit(int opmode, Key key,
AlgorithmParameterSpec params,
SecureRandom random)
throws InvalidKeyException, InvalidAlgorithmParameterException {
checkKeySize(key, fixedKeySize);
core.init(opmode, key, params, random);
}
protected void engineInit(int opmode, Key key,
AlgorithmParameters params,
SecureRandom random)
throws InvalidKeyException, InvalidAlgorithmParameterException {
checkKeySize(key, fixedKeySize);
core.init(opmode, key, params, random);
}
protected byte[] engineUpdate(byte[] input, int inputOffset,
int inputLen) {
return core.update(input, inputOffset, inputLen);
}
protected int engineUpdate(byte[] input, int inputOffset, int inputLen,
byte[] output, int outputOffset)
throws ShortBufferException {
return core.update(input, inputOffset, inputLen, output,
outputOffset);
}
protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen)
throws IllegalBlockSizeException, BadPaddingException {
byte[] out = core.doFinal(input, inputOffset, inputLen);
return out;
}
protected int engineDoFinal(byte[] input, int inputOffset, int inputLen,
byte[] output, int outputOffset)
throws IllegalBlockSizeException, ShortBufferException,
BadPaddingException {
int outLen = core.doFinal(input, inputOffset, inputLen, output,
outputOffset);
return outLen;
}
protected int engineGetKeySize(Key key) throws InvalidKeyException {
byte[] encoded = key.getEncoded();
Arrays.fill(encoded, (byte)0);
if (!AESCrypt.isKeySizeValid(encoded.length)) {
throw new InvalidKeyException("Invalid AES key length: " +
encoded.length + " bytes");
}
return Math.multiplyExact(encoded.length, 8);
}
protected byte[] engineWrap(Key key)
throws IllegalBlockSizeException, InvalidKeyException {
return core.wrap(key);
}
protected Key engineUnwrap(byte[] wrappedKey,
String wrappedKeyAlgorithm,
int wrappedKeyType)
throws InvalidKeyException, NoSuchAlgorithmException {
return core.unwrap(wrappedKey, wrappedKeyAlgorithm,
wrappedKeyType);
}
@Override
protected int engineDoFinal(ByteBuffer input, ByteBuffer output)
throws ShortBufferException, IllegalBlockSizeException,
BadPaddingException {
return super.engineDoFinal(input, output);
}
}
package com.sun.crypto.provider;
interface AESConstants {
int AES_BLOCK_SIZE = 16;
int[] AES_KEYSIZES = { 16, 24, 32 };
}
package com.sun.crypto.provider;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.util.Arrays;
import jdk.internal.vm.annotation.IntrinsicCandidate;
final class AESCrypt extends SymmetricCipher implements AESConstants
{
private boolean ROUNDS_12 = false;
private boolean ROUNDS_14 = false;
private int[][] sessionK = null;
private int[] K = null;
private byte[] lastKey = null;
private int limit = 0;
AESCrypt() {
}
int getBlockSize() {
return AES_BLOCK_SIZE;
}
void init(boolean decrypting, String algorithm, byte[] key)
throws InvalidKeyException {
if (!algorithm.equalsIgnoreCase("AES")
&& !algorithm.equalsIgnoreCase("Rijndael")) {
throw new InvalidKeyException
("Wrong algorithm: AES or Rijndael required");
}
if (!isKeySizeValid(key.length)) {
throw new InvalidKeyException("Invalid AES key length: " +
key.length + " bytes");
}
if (!MessageDigest.isEqual(key, lastKey)) {
makeSessionKey(key);
if (lastKey != null) {
Arrays.fill(lastKey, (byte)0);
}
lastKey = key.clone();          }
this.K = sessionK[(decrypting? 1:0)];
}
private static final int[] expandToSubKey(int[][] kr, boolean decrypting) {
int total = kr.length;
int[] expK = new int[total*4];
if (decrypting) {
for(int j=0; j<4; j++) {
expK[j] = kr[total-1][j];
}
for(int i=1; i<total; i++) {
for(int j=0; j<4; j++) {
expK[i*4 + j] = kr[i-1][j];
}
}
} else {
for(int i=0; i<total; i++) {
for(int j=0; j<4; j++) {
expK[i*4 + j] = kr[i][j];
}
}
}
return expK;
}
private static int[]
alog = new int[256],
log  = new int[256];
private static final byte[]
S  = new byte[256],
Si = new byte[256];
private static final int[]
T1 = new int[256],
T2 = new int[256],
T3 = new int[256],
T4 = new int[256],
T5 = new int[256],
T6 = new int[256],
T7 = new int[256],
T8 = new int[256];
private static final int[]
U1 = new int[256],
U2 = new int[256],
U3 = new int[256],
U4 = new int[256];
private static final byte[] rcon = new byte[30];
static
{
int ROOT = 0x11B;
int i, j = 0;
alog[0] = 1;
for (i = 1; i < 256; i++)
{
j = (alog[i-1] << 1) ^ alog[i-1];
if ((j & 0x100) != 0) {
j ^= ROOT;
}
alog[i] = j;
}
for (i = 1; i < 255; i++) {
log[alog[i]] = i;
}
byte[][] A = new byte[][]
{
{1, 1, 1, 1, 1, 0, 0, 0},
{0, 1, 1, 1, 1, 1, 0, 0},
{0, 0, 1, 1, 1, 1, 1, 0},
{0, 0, 0, 1, 1, 1, 1, 1},
{1, 0, 0, 0, 1, 1, 1, 1},
{1, 1, 0, 0, 0, 1, 1, 1},
{1, 1, 1, 0, 0, 0, 1, 1},
{1, 1, 1, 1, 0, 0, 0, 1}
};
byte[] B = new byte[] { 0, 1, 1, 0, 0, 0, 1, 1};
int t;
byte[][] box = new byte[256][8];
box[1][7] = 1;
for (i = 2; i < 256; i++) {
j = alog[255 - log[i]];
for (t = 0; t < 8; t++) {
box[i][t] = (byte)((j >>> (7 - t)) & 0x01);
}
}
byte[][] cox = new byte[256][8];
for (i = 0; i < 256; i++) {
for (t = 0; t < 8; t++) {
cox[i][t] = B[t];
for (j = 0; j < 8; j++) {
cox[i][t] ^= (byte)(A[t][j] * box[i][j]);
}
}
}
for (i = 0; i < 256; i++) {
S[i] = (byte)(cox[i][0] << 7);
for (t = 1; t < 8; t++) {
S[i] ^= (byte)(cox[i][t] << (7-t));
}
Si[S[i] & 0xFF] = (byte) i;
}
byte[][] G = new byte[][] {
{2, 1, 1, 3},
{3, 2, 1, 1},
{1, 3, 2, 1},
{1, 1, 3, 2}
};
byte[][] AA = new byte[4][8];
for (i = 0; i < 4; i++) {
for (j = 0; j < 4; j++) AA[i][j] = G[i][j];
AA[i][i+4] = 1;
}
byte pivot, tmp;
byte[][] iG = new byte[4][4];
for (i = 0; i < 4; i++) {
pivot = AA[i][i];
if (pivot == 0) {
t = i + 1;
while ((AA[t][i] == 0) && (t < 4)) {
t++;
}
if (t == 4) {
throw new RuntimeException("G matrix is not invertible");
}
else {
for (j = 0; j < 8; j++) {
tmp = AA[i][j];
AA[i][j] = AA[t][j];
AA[t][j] = tmp;
}
pivot = AA[i][i];
}
}
for (j = 0; j < 8; j++) {
if (AA[i][j] != 0) {
AA[i][j] = (byte)
alog[(255 + log[AA[i][j] & 0xFF] - log[pivot & 0xFF])
% 255];
}
}
for (t = 0; t < 4; t++) {
if (i != t) {
for (j = i+1; j < 8; j++) {
AA[t][j] ^= (byte)(mul(AA[i][j], AA[t][i]));
}
AA[t][i] = 0;
}
}
}
for (i = 0; i < 4; i++) {
for (j = 0; j < 4; j++) {
iG[i][j] = AA[i][j + 4];
}
}
int s;
for (t = 0; t < 256; t++) {
s = S[t];
T1[t] = mul4(s, G[0]);
T2[t] = mul4(s, G[1]);
T3[t] = mul4(s, G[2]);
T4[t] = mul4(s, G[3]);
s = Si[t];
T5[t] = mul4(s, iG[0]);
T6[t] = mul4(s, iG[1]);
T7[t] = mul4(s, iG[2]);
T8[t] = mul4(s, iG[3]);
U1[t] = mul4(t, iG[0]);
U2[t] = mul4(t, iG[1]);
U3[t] = mul4(t, iG[2]);
U4[t] = mul4(t, iG[3]);
}
rcon[0] = 1;
int r = 1;
for (t = 1; t < 30; t++) {
r = mul(2, r);
rcon[t] = (byte) r;
}
log = null;
alog = null;
}
private static final int mul (int a, int b) {
return (a != 0 && b != 0) ?
alog[(log[a & 0xFF] + log[b & 0xFF]) % 255] :
0;
}
private static final int mul4 (int a, byte[] b) {
if (a == 0) return 0;
a = log[a & 0xFF];
int a0 = (b[0] != 0) ? alog[(a + log[b[0] & 0xFF]) % 255] & 0xFF : 0;
int a1 = (b[1] != 0) ? alog[(a + log[b[1] & 0xFF]) % 255] & 0xFF : 0;
int a2 = (b[2] != 0) ? alog[(a + log[b[2] & 0xFF]) % 255] & 0xFF : 0;
int a3 = (b[3] != 0) ? alog[(a + log[b[3] & 0xFF]) % 255] & 0xFF : 0;
return a0 << 24 | a1 << 16 | a2 << 8 | a3;
}
static final boolean isKeySizeValid(int len) {
for (int i = 0; i < AES_KEYSIZES.length; i++) {
if (len == AES_KEYSIZES[i]) {
return true;
}
}
return false;
}
void encryptBlock(byte[] in, int inOffset,
byte[] out, int outOffset) {
implEncryptBlock(in, inOffset, out, outOffset);
}
@IntrinsicCandidate
private void implEncryptBlock(byte[] in, int inOffset,
byte[] out, int outOffset)
{
int keyOffset = 0;
int t0   = ((in[inOffset++]       ) << 24 |
(in[inOffset++] & 0xFF) << 16 |
(in[inOffset++] & 0xFF) <<  8 |
(in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];
int t1   = ((in[inOffset++]       ) << 24 |
(in[inOffset++] & 0xFF) << 16 |
(in[inOffset++] & 0xFF) <<  8 |
(in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];
int t2   = ((in[inOffset++]       ) << 24 |
(in[inOffset++] & 0xFF) << 16 |
(in[inOffset++] & 0xFF) <<  8 |
(in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];
int t3   = ((in[inOffset++]       ) << 24 |
(in[inOffset++] & 0xFF) << 16 |
(in[inOffset++] & 0xFF) <<  8 |
(in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];
while( keyOffset < limit )
{
int a0, a1, a2;
a0 = T1[(t0 >>> 24)       ] ^
T2[(t1 >>> 16) & 0xFF] ^
T3[(t2 >>>  8) & 0xFF] ^
T4[(t3       ) & 0xFF] ^ K[keyOffset++];
a1 = T1[(t1 >>> 24)       ] ^
T2[(t2 >>> 16) & 0xFF] ^
T3[(t3 >>>  8) & 0xFF] ^
T4[(t0       ) & 0xFF] ^ K[keyOffset++];
a2 = T1[(t2 >>> 24)       ] ^
T2[(t3 >>> 16) & 0xFF] ^
T3[(t0 >>>  8) & 0xFF] ^
T4[(t1       ) & 0xFF] ^ K[keyOffset++];
t3 = T1[(t3 >>> 24)       ] ^
T2[(t0 >>> 16) & 0xFF] ^
T3[(t1 >>>  8) & 0xFF] ^
T4[(t2       ) & 0xFF] ^ K[keyOffset++];
t0 = a0; t1 = a1; t2 = a2;
}
int tt = K[keyOffset++];
out[outOffset++] = (byte)(S[(t0 >>> 24)       ] ^ (tt >>> 24));
out[outOffset++] = (byte)(S[(t1 >>> 16) & 0xFF] ^ (tt >>> 16));
out[outOffset++] = (byte)(S[(t2 >>>  8) & 0xFF] ^ (tt >>>  8));
out[outOffset++] = (byte)(S[(t3       ) & 0xFF] ^ (tt       ));
tt = K[keyOffset++];
out[outOffset++] = (byte)(S[(t1 >>> 24)       ] ^ (tt >>> 24));
out[outOffset++] = (byte)(S[(t2 >>> 16) & 0xFF] ^ (tt >>> 16));
out[outOffset++] = (byte)(S[(t3 >>>  8) & 0xFF] ^ (tt >>>  8));
out[outOffset++] = (byte)(S[(t0       ) & 0xFF] ^ (tt       ));
tt = K[keyOffset++];
out[outOffset++] = (byte)(S[(t2 >>> 24)       ] ^ (tt >>> 24));
out[outOffset++] = (byte)(S[(t3 >>> 16) & 0xFF] ^ (tt >>> 16));
out[outOffset++] = (byte)(S[(t0 >>>  8) & 0xFF] ^ (tt >>>  8));
out[outOffset++] = (byte)(S[(t1       ) & 0xFF] ^ (tt       ));
tt = K[keyOffset++];
out[outOffset++] = (byte)(S[(t3 >>> 24)       ] ^ (tt >>> 24));
out[outOffset++] = (byte)(S[(t0 >>> 16) & 0xFF] ^ (tt >>> 16));
out[outOffset++] = (byte)(S[(t1 >>>  8) & 0xFF] ^ (tt >>>  8));
out[outOffset  ] = (byte)(S[(t2       ) & 0xFF] ^ (tt       ));
}
void decryptBlock(byte[] in, int inOffset,
byte[] out, int outOffset) {
implDecryptBlock(in, inOffset, out, outOffset);
}
@IntrinsicCandidate
private void implDecryptBlock(byte[] in, int inOffset,
byte[] out, int outOffset)
{
int keyOffset = 4;
int t0 = ((in[inOffset++]       ) << 24 |
(in[inOffset++] & 0xFF) << 16 |
(in[inOffset++] & 0xFF) <<  8 |
(in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];
int t1 = ((in[inOffset++]       ) << 24 |
(in[inOffset++] & 0xFF) << 16 |
(in[inOffset++] & 0xFF) <<  8 |
(in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];
int t2 = ((in[inOffset++]       ) << 24 |
(in[inOffset++] & 0xFF) << 16 |
(in[inOffset++] & 0xFF) <<  8 |
(in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];
int t3 = ((in[inOffset++]       ) << 24 |
(in[inOffset++] & 0xFF) << 16 |
(in[inOffset++] & 0xFF) <<  8 |
(in[inOffset  ] & 0xFF)        ) ^ K[keyOffset++];
int a0, a1, a2;
if(ROUNDS_12)
{
a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^
T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];
a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^
T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];
a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^
T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];
t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^
T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];
t0 = T5[(a0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^
T7[(a2>>> 8)&0xFF] ^ T8[(a1     )&0xFF] ^ K[keyOffset++];
t1 = T5[(a1>>>24)     ] ^ T6[(a0>>>16)&0xFF] ^
T7[(t3>>> 8)&0xFF] ^ T8[(a2     )&0xFF] ^ K[keyOffset++];
t2 = T5[(a2>>>24)     ] ^ T6[(a1>>>16)&0xFF] ^
T7[(a0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];
t3 = T5[(t3>>>24)     ] ^ T6[(a2>>>16)&0xFF] ^
T7[(a1>>> 8)&0xFF] ^ T8[(a0     )&0xFF] ^ K[keyOffset++];
if(ROUNDS_14)
{
a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^
T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];
a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^
T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];
a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^
T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];
t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^
T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];
t0 = T5[(a0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^
T7[(a2>>> 8)&0xFF] ^ T8[(a1     )&0xFF] ^ K[keyOffset++];
t1 = T5[(a1>>>24)     ] ^ T6[(a0>>>16)&0xFF] ^
T7[(t3>>> 8)&0xFF] ^ T8[(a2     )&0xFF] ^ K[keyOffset++];
t2 = T5[(a2>>>24)     ] ^ T6[(a1>>>16)&0xFF] ^
T7[(a0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];
t3 = T5[(t3>>>24)     ] ^ T6[(a2>>>16)&0xFF] ^
T7[(a1>>> 8)&0xFF] ^ T8[(a0     )&0xFF] ^ K[keyOffset++];
}
}
a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^
T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];
a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^
T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];
a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^
T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];
t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^
T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];
t0 = T5[(a0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^
T7[(a2>>> 8)&0xFF] ^ T8[(a1     )&0xFF] ^ K[keyOffset++];
t1 = T5[(a1>>>24)     ] ^ T6[(a0>>>16)&0xFF] ^
T7[(t3>>> 8)&0xFF] ^ T8[(a2     )&0xFF] ^ K[keyOffset++];
t2 = T5[(a2>>>24)     ] ^ T6[(a1>>>16)&0xFF] ^
T7[(a0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];
t3 = T5[(t3>>>24)     ] ^ T6[(a2>>>16)&0xFF] ^
T7[(a1>>> 8)&0xFF] ^ T8[(a0     )&0xFF] ^ K[keyOffset++];
a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^
T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];
a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^
T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];
a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^
T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];
t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^
T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];
t0 = T5[(a0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^
T7[(a2>>> 8)&0xFF] ^ T8[(a1     )&0xFF] ^ K[keyOffset++];
t1 = T5[(a1>>>24)     ] ^ T6[(a0>>>16)&0xFF] ^
T7[(t3>>> 8)&0xFF] ^ T8[(a2     )&0xFF] ^ K[keyOffset++];
t2 = T5[(a2>>>24)     ] ^ T6[(a1>>>16)&0xFF] ^
T7[(a0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];
t3 = T5[(t3>>>24)     ] ^ T6[(a2>>>16)&0xFF] ^
T7[(a1>>> 8)&0xFF] ^ T8[(a0     )&0xFF] ^ K[keyOffset++];
a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^
T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];
a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^
T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];
a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^
T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];
t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^
T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];
t0 = T5[(a0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^
T7[(a2>>> 8)&0xFF] ^ T8[(a1     )&0xFF] ^ K[keyOffset++];
t1 = T5[(a1>>>24)     ] ^ T6[(a0>>>16)&0xFF] ^
T7[(t3>>> 8)&0xFF] ^ T8[(a2     )&0xFF] ^ K[keyOffset++];
t2 = T5[(a2>>>24)     ] ^ T6[(a1>>>16)&0xFF] ^
T7[(a0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];
t3 = T5[(t3>>>24)     ] ^ T6[(a2>>>16)&0xFF] ^
T7[(a1>>> 8)&0xFF] ^ T8[(a0     )&0xFF] ^ K[keyOffset++];
a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^
T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];
a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^
T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];
a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^
T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];
t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^
T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];
t0 = T5[(a0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^
T7[(a2>>> 8)&0xFF] ^ T8[(a1     )&0xFF] ^ K[keyOffset++];
t1 = T5[(a1>>>24)     ] ^ T6[(a0>>>16)&0xFF] ^
T7[(t3>>> 8)&0xFF] ^ T8[(a2     )&0xFF] ^ K[keyOffset++];
t2 = T5[(a2>>>24)     ] ^ T6[(a1>>>16)&0xFF] ^
T7[(a0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];
t3 = T5[(t3>>>24)     ] ^ T6[(a2>>>16)&0xFF] ^
T7[(a1>>> 8)&0xFF] ^ T8[(a0     )&0xFF] ^ K[keyOffset++];
a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^
T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];
a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^
T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];
a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^
T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];
t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^
T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];
t1 = K[0];
out[outOffset++] = (byte)(Si[(a0 >>> 24)       ] ^ (t1 >>> 24));
out[outOffset++] = (byte)(Si[(t3 >>> 16) & 0xFF] ^ (t1 >>> 16));
out[outOffset++] = (byte)(Si[(a2 >>>  8) & 0xFF] ^ (t1 >>>  8));
out[outOffset++] = (byte)(Si[(a1       ) & 0xFF] ^ (t1       ));
t1 = K[1];
out[outOffset++] = (byte)(Si[(a1 >>> 24)       ] ^ (t1 >>> 24));
out[outOffset++] = (byte)(Si[(a0 >>> 16) & 0xFF] ^ (t1 >>> 16));
out[outOffset++] = (byte)(Si[(t3 >>>  8) & 0xFF] ^ (t1 >>>  8));
out[outOffset++] = (byte)(Si[(a2       ) & 0xFF] ^ (t1       ));
t1 = K[2];
out[outOffset++] = (byte)(Si[(a2 >>> 24)       ] ^ (t1 >>> 24));
out[outOffset++] = (byte)(Si[(a1 >>> 16) & 0xFF] ^ (t1 >>> 16));
out[outOffset++] = (byte)(Si[(a0 >>>  8) & 0xFF] ^ (t1 >>>  8));
out[outOffset++] = (byte)(Si[(t3       ) & 0xFF] ^ (t1       ));
t1 = K[3];
out[outOffset++] = (byte)(Si[(t3 >>> 24)       ] ^ (t1 >>> 24));
out[outOffset++] = (byte)(Si[(a2 >>> 16) & 0xFF] ^ (t1 >>> 16));
out[outOffset++] = (byte)(Si[(a1 >>>  8) & 0xFF] ^ (t1 >>>  8));
out[outOffset  ] = (byte)(Si[(a0       ) & 0xFF] ^ (t1       ));
}
private void makeSessionKey(byte[] k) throws InvalidKeyException {
if (k == null) {
throw new InvalidKeyException("Empty key");
}
if (!isKeySizeValid(k.length)) {
throw new InvalidKeyException("Invalid AES key length: " +
k.length + " bytes");
}
int ROUNDS          = getRounds(k.length);
int ROUND_KEY_COUNT = (ROUNDS + 1) * 4;
int BC = 4;
int[][] Ke = new int[ROUNDS + 1][4];         int[][] Kd = new int[ROUNDS + 1][4];
int KC = k.length/4;
int[] tk = new int[KC];
int i, j;
for (i = 0, j = 0; i < KC; i++, j+=4) {
tk[i] = (k[j]       ) << 24 |
(k[j+1] & 0xFF) << 16 |
(k[j+2] & 0xFF) <<  8 |
(k[j+3] & 0xFF);
}
int t = 0;
for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++, t++) {
Ke[t / 4][t % 4] = tk[j];
Kd[ROUNDS - (t / 4)][t % 4] = tk[j];
}
int tt, rconpointer = 0;
while (t < ROUND_KEY_COUNT) {
tt = tk[KC - 1];
tk[0] ^= (S[(tt >>> 16) & 0xFF]       ) << 24 ^
(S[(tt >>>  8) & 0xFF] & 0xFF) << 16 ^
(S[(tt       ) & 0xFF] & 0xFF) <<  8 ^
(S[(tt >>> 24)       ] & 0xFF)       ^
(rcon[rconpointer++]         ) << 24;
if (KC != 8)
for (i = 1, j = 0; i < KC; i++, j++) tk[i] ^= tk[j];
else {
for (i = 1, j = 0; i < KC / 2; i++, j++) tk[i] ^= tk[j];
tt = tk[KC / 2 - 1];
tk[KC / 2] ^= (S[(tt       ) & 0xFF] & 0xFF)       ^
(S[(tt >>>  8) & 0xFF] & 0xFF) <<  8 ^
(S[(tt >>> 16) & 0xFF] & 0xFF) << 16 ^
(S[(tt >>> 24)       ]       ) << 24;
for (j = KC / 2, i = j + 1; i < KC; i++, j++) tk[i] ^= tk[j];
}
for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++, t++) {
Ke[t / 4][t % 4] = tk[j];
Kd[ROUNDS - (t / 4)][t % 4] = tk[j];
}
}
for (int r = 1; r < ROUNDS; r++) {
for (j = 0; j < BC; j++) {
tt = Kd[r][j];
Kd[r][j] = U1[(tt >>> 24) & 0xFF] ^
U2[(tt >>> 16) & 0xFF] ^
U3[(tt >>>  8) & 0xFF] ^
U4[ tt         & 0xFF];
}
}
int[] expandedKe = expandToSubKey(Ke, false);         int[] expandedKd = expandToSubKey(Kd, true);          Arrays.fill(tk, 0);
for (int[] ia: Ke) {
Arrays.fill(ia, 0);
}
for (int[] ia: Kd) {
Arrays.fill(ia, 0);
}
ROUNDS_12 = (ROUNDS>=12);
ROUNDS_14 = (ROUNDS==14);
limit = ROUNDS*4;
if (sessionK != null) {
Arrays.fill(sessionK[0], 0);
Arrays.fill(sessionK[1], 0);
}
sessionK = new int[][] { expandedKe, expandedKd };
}
private static int getRounds(int keySize) {
return (keySize >> 2) + 6;
}
}
package sun.security.krb5.internal.crypto.dk;
import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.SecretKeyFactory;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.DESedeKeySpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import java.security.spec.KeySpec;
import java.security.GeneralSecurityException;
import sun.security.krb5.KrbCryptoException;
import sun.security.krb5.Confounder;
import sun.security.krb5.internal.crypto.KeyUsage;
import java.util.Arrays;
import static java.nio.charset.StandardCharsets.UTF_8;
public class AesDkCrypto extends DkCrypto {
private static final boolean debug = false;
private static final int BLOCK_SIZE = 16;
private static final int DEFAULT_ITERATION_COUNT = 4096;
private static final byte[] ZERO_IV = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0 };
private static final int hashSize = 96/8;
private final int keyLength;
public AesDkCrypto(int length) {
keyLength = length;
}
protected int getKeySeedLength() {
return keyLength;       }
public byte[] stringToKey(char[] password, String salt, byte[] s2kparams)
throws GeneralSecurityException {
byte[] saltUtf8 = null;
try {
saltUtf8 = salt.getBytes(UTF_8);
return stringToKey(password, saltUtf8, s2kparams);
} catch (Exception e) {
return null;
} finally {
if (saltUtf8 != null) {
Arrays.fill(saltUtf8, (byte)0);
}
}
}
private byte[] stringToKey(char[] secret, byte[] salt, byte[] params)
throws GeneralSecurityException {
int iter_count = DEFAULT_ITERATION_COUNT;
if (params != null) {
if (params.length != 4) {
throw new RuntimeException("Invalid parameter to stringToKey");
}
iter_count = readBigEndian(params, 0, 4);
}
byte[] tmpKey = randomToKey(PBKDF2(secret, salt, iter_count,
getKeySeedLength()));
byte[] result = dk(tmpKey, KERBEROS_CONSTANT);
return result;
}
protected byte[] randomToKey(byte[] in) {
return in;
}
protected Cipher getCipher(byte[] key, byte[] ivec, int mode)
throws GeneralSecurityException {
if (ivec == null) {
ivec = ZERO_IV;
}
SecretKeySpec secretKey = new SecretKeySpec(key, "AES");
Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
IvParameterSpec encIv = new IvParameterSpec(ivec, 0, ivec.length);
cipher.init(mode, secretKey, encIv);
return cipher;
}
public int getChecksumLength() {
return hashSize;      }
protected byte[] getHmac(byte[] key, byte[] msg)
throws GeneralSecurityException {
SecretKey keyKi = new SecretKeySpec(key, "HMAC");
Mac m = Mac.getInstance("HmacSHA1");
m.init(keyKi);
byte[] hash = m.doFinal(msg);
byte[] output = new byte[hashSize];
System.arraycopy(hash, 0, output, 0, hashSize);
return output;
}
public byte[] calculateChecksum(byte[] baseKey, int usage, byte[] input,
int start, int len) throws GeneralSecurityException {
if (!KeyUsage.isValid(usage)) {
throw new GeneralSecurityException("Invalid key usage number: "
+ usage);
}
byte[] constant = new byte[5];
constant[0] = (byte) ((usage>>24)&0xff);
constant[1] = (byte) ((usage>>16)&0xff);
constant[2] = (byte) ((usage>>8)&0xff);
constant[3] = (byte) (usage&0xff);
constant[4] = (byte) 0x99;
byte[] Kc = dk(baseKey, constant);          if (debug) {
System.err.println("usage: " + usage);
traceOutput("input", input, start, Math.min(len, 32));
traceOutput("constant", constant, 0, constant.length);
traceOutput("baseKey", baseKey, 0, baseKey.length);
traceOutput("Kc", Kc, 0, Kc.length);
}
try {
byte[] hmac = getHmac(Kc, input);
if (debug) {
traceOutput("hmac", hmac, 0, hmac.length);
}
if (hmac.length == getChecksumLength()) {
return hmac;
} else if (hmac.length > getChecksumLength()) {
byte[] buf = new byte[getChecksumLength()];
System.arraycopy(hmac, 0, buf, 0, buf.length);
return buf;
} else {
throw new GeneralSecurityException("checksum size too short: " +
hmac.length + "; expecting : " + getChecksumLength());
}
} finally {
Arrays.fill(Kc, 0, Kc.length, (byte)0);
}
}
public byte[] encrypt(byte[] baseKey, int usage,
byte[] ivec, byte[] new_ivec, byte[] plaintext, int start, int len)
throws GeneralSecurityException, KrbCryptoException {
if (!KeyUsage.isValid(usage)) {
throw new GeneralSecurityException("Invalid key usage number: "
+ usage);
}
byte[] output = encryptCTS(baseKey, usage, ivec, new_ivec, plaintext,
start, len, true);
return output;
}
public byte[] encryptRaw(byte[] baseKey, int usage,
byte[] ivec, byte[] plaintext, int start, int len)
throws GeneralSecurityException, KrbCryptoException {
if (!KeyUsage.isValid(usage)) {
throw new GeneralSecurityException("Invalid key usage number: "
+ usage);
}
byte[] output = encryptCTS(baseKey, usage, ivec, null, plaintext,
start, len, false);
return output;
}
public byte[] decrypt(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len) throws GeneralSecurityException {
if (!KeyUsage.isValid(usage)) {
throw new GeneralSecurityException("Invalid key usage number: "
+ usage);
}
byte[] output = decryptCTS(baseKey, usage, ivec, ciphertext,
start, len, true);
return output;
}
public byte[] decryptRaw(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len)
throws GeneralSecurityException {
if (!KeyUsage.isValid(usage)) {
throw new GeneralSecurityException("Invalid key usage number: "
+ usage);
}
byte[] output = decryptCTS(baseKey, usage, ivec, ciphertext,
start, len, false);
return output;
}
private byte[] encryptCTS(byte[] baseKey, int usage, byte[] ivec,
byte[] new_ivec, byte[] plaintext, int start, int len,
boolean confounder_exists)
throws GeneralSecurityException, KrbCryptoException {
byte[] Ke = null;
byte[] Ki = null;
if (debug) {
System.err.println("usage: " + usage);
if (ivec != null) {
traceOutput("old_state.ivec", ivec, 0, ivec.length);
}
traceOutput("plaintext", plaintext, start, Math.min(len, 32));
traceOutput("baseKey", baseKey, 0, baseKey.length);
}
try {
byte[] constant = new byte[5];
constant[0] = (byte) ((usage>>24)&0xff);
constant[1] = (byte) ((usage>>16)&0xff);
constant[2] = (byte) ((usage>>8)&0xff);
constant[3] = (byte) (usage&0xff);
constant[4] = (byte) 0xaa;
Ke = dk(baseKey, constant);
byte[] toBeEncrypted = null;
if (confounder_exists) {
byte[] confounder = Confounder.bytes(BLOCK_SIZE);
toBeEncrypted = new byte[confounder.length + len];
System.arraycopy(confounder, 0, toBeEncrypted,
0, confounder.length);
System.arraycopy(plaintext, start, toBeEncrypted,
confounder.length, len);
} else {
toBeEncrypted = new byte[len];
System.arraycopy(plaintext, start, toBeEncrypted, 0, len);
}
byte[] output = new byte[toBeEncrypted.length + hashSize];
Cipher cipher = Cipher.getInstance("AES/CTS/NoPadding");
SecretKeySpec secretKey = new SecretKeySpec(Ke, "AES");
IvParameterSpec encIv = new IvParameterSpec(ivec, 0, ivec.length);
cipher.init(Cipher.ENCRYPT_MODE, secretKey, encIv);
cipher.doFinal(toBeEncrypted, 0, toBeEncrypted.length, output);
constant[4] = (byte) 0x55;
Ki = dk(baseKey, constant);
if (debug) {
traceOutput("constant", constant, 0, constant.length);
traceOutput("Ki", Ki, 0, Ke.length);
}
byte[] hmac = getHmac(Ki, toBeEncrypted);
System.arraycopy(hmac, 0, output, toBeEncrypted.length,
hmac.length);
return output;
} finally {
if (Ke != null) {
Arrays.fill(Ke, 0, Ke.length, (byte) 0);
}
if (Ki != null) {
Arrays.fill(Ki, 0, Ki.length, (byte) 0);
}
}
}
private byte[] decryptCTS(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len, boolean confounder_exists)
throws GeneralSecurityException {
byte[] Ke = null;
byte[] Ki = null;
try {
byte[] constant = new byte[5];
constant[0] = (byte) ((usage>>24)&0xff);
constant[1] = (byte) ((usage>>16)&0xff);
constant[2] = (byte) ((usage>>8)&0xff);
constant[3] = (byte) (usage&0xff);
constant[4] = (byte) 0xaa;
Ke = dk(baseKey, constant);
if (debug) {
System.err.println("usage: " + usage);
if (ivec != null) {
traceOutput("old_state.ivec", ivec, 0, ivec.length);
}
traceOutput("ciphertext", ciphertext, start, Math.min(len, 32));
traceOutput("constant", constant, 0, constant.length);
traceOutput("baseKey", baseKey, 0, baseKey.length);
traceOutput("Ke", Ke, 0, Ke.length);
}
Cipher cipher = Cipher.getInstance("AES/CTS/NoPadding");
SecretKeySpec secretKey = new SecretKeySpec(Ke, "AES");
IvParameterSpec encIv = new IvParameterSpec(ivec, 0, ivec.length);
cipher.init(Cipher.DECRYPT_MODE, secretKey, encIv);
byte[] plaintext = cipher.doFinal(ciphertext, start, len-hashSize);
if (debug) {
traceOutput("AES PlainText", plaintext, 0,
Math.min(plaintext.length, 32));
}
constant[4] = (byte) 0x55;
Ki = dk(baseKey, constant);              if (debug) {
traceOutput("constant", constant, 0, constant.length);
traceOutput("Ki", Ki, 0, Ke.length);
}
byte[] calculatedHmac = getHmac(Ki, plaintext);
int hmacOffset = start + len - hashSize;
if (debug) {
traceOutput("calculated Hmac", calculatedHmac,
0, calculatedHmac.length);
traceOutput("message Hmac", ciphertext, hmacOffset, hashSize);
}
boolean cksumFailed = false;
if (calculatedHmac.length >= hashSize) {
for (int i = 0; i < hashSize; i++) {
if (calculatedHmac[i] != ciphertext[hmacOffset+i]) {
cksumFailed = true;
if (debug) {
System.err.println("Checksum failed !");
}
break;
}
}
}
if (cksumFailed) {
throw new GeneralSecurityException("Checksum failed");
}
if (confounder_exists) {
byte[] output = new byte[plaintext.length - BLOCK_SIZE];
System.arraycopy(plaintext, BLOCK_SIZE, output,
0, output.length);
return output;
} else {
return plaintext;
}
} finally {
if (Ke != null) {
Arrays.fill(Ke, 0, Ke.length, (byte) 0);
}
if (Ki != null) {
Arrays.fill(Ki, 0, Ki.length, (byte) 0);
}
}
}
private static byte[] PBKDF2(char[] secret, byte[] salt,
int count, int keyLength) throws GeneralSecurityException {
PBEKeySpec keySpec = new PBEKeySpec(secret, salt, count, keyLength);
SecretKeyFactory skf =
SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
SecretKey key = skf.generateSecret(keySpec);
byte[] result = key.getEncoded();
return result;
}
public static final int readBigEndian(byte[] data, int pos, int size) {
int retVal = 0;
int shifter = (size-1)*8;
while (size > 0) {
retVal += (data[pos] & 0xff) << shifter;
shifter -= 8;
pos++;
size--;
}
return retVal;
}
}
package compiler.cpuflags;
import compiler.codegen.aes.TestAESMain;
import java.util.Arrays;
public abstract class AESIntrinsicsBase {
public static final String CIPHER_INTRINSIC = "com\\.sun\\.crypto\\"
+ ".provider\\.CipherBlockChaining::"
+ "(implEncrypt|implDecrypt) \\([0-9]+ bytes\\)\\s+\\(intrinsic[,\\)]";
public static final String AES_INTRINSIC = "com\\.sun\\.crypto\\"
+ ".provider\\.AESCrypt::(implEncryptBlock|implDecryptBlock) \\([0-9]+ "
+ "bytes\\)\\s+\\(intrinsic[,\\)]";
public static final String USE_AES = "UseAES";
public static final String USE_AES_INTRINSICS = "UseAESIntrinsics";
public static final String USE_SSE = "UseSSE";
public static final String[] USE_DIAGNOSTIC_CMD
= {"-XX:+UnlockDiagnosticVMOptions", "-XX:+PrintIntrinsics"};
public static final String[] TEST_AES_CMD
= {"-XX:+IgnoreUnrecognizedVMOptions", "-XX:+PrintFlagsFinal",
"-Xbatch", "-XX:CompileThresholdScaling=0.01", "-DcheckOutput=true", "-Dmode=CBC",
TestAESMain.class.getName(), "100", "1000"};
public static String[] prepareArguments(String... args) {
String[] command = Arrays.copyOf(USE_DIAGNOSTIC_CMD, args.length
+ USE_DIAGNOSTIC_CMD.length + TEST_AES_CMD.length);
System.arraycopy(args, 0, command, USE_DIAGNOSTIC_CMD.length,
args.length);
System.arraycopy(TEST_AES_CMD, 0, command, args.length
+ USE_DIAGNOSTIC_CMD.length, TEST_AES_CMD.length);
return command;
}
}
package com.sun.crypto.provider;
import java.security.SecureRandom;
import java.security.InvalidParameterException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Arrays;
import javax.crypto.KeyGeneratorSpi;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import sun.security.util.SecurityProviderConstants;
public final class AESKeyGenerator extends KeyGeneratorSpi {
private SecureRandom random = null;
private int keySize = SecurityProviderConstants.getDefAESKeySize() >> 3;
public AESKeyGenerator() {
}
protected void engineInit(SecureRandom random) {
this.random = random;
}
protected void engineInit(AlgorithmParameterSpec params,
SecureRandom random)
throws InvalidAlgorithmParameterException {
throw new InvalidAlgorithmParameterException
("AES key generation does not take any parameters");
}
protected void engineInit(int keysize, SecureRandom random) {
if (((keysize % 8) != 0) ||
(!AESCrypt.isKeySizeValid(keysize/8))) {
throw new InvalidParameterException
("Wrong keysize: must be equal to 128, 192 or 256");
}
this.keySize = keysize/8;
this.engineInit(random);
}
protected SecretKey engineGenerateKey() {
SecretKeySpec aesKey = null;
if (this.random == null) {
this.random = SunJCE.getRandom();
}
byte[] keyBytes = new byte[keySize];
this.random.nextBytes(keyBytes);
aesKey = new SecretKeySpec(keyBytes, "AES");
Arrays.fill(keyBytes, (byte)0);
return aesKey;
}
}
package com.sun.crypto.provider;
import java.util.Arrays;
import java.security.*;
import java.security.spec.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import static com.sun.crypto.provider.KWUtil.*;
class AESKeyWrap extends FeedbackCipher {
static final byte[] ICV1 = {         (byte) 0xA6, (byte) 0xA6, (byte) 0xA6, (byte) 0xA6,
(byte) 0xA6, (byte) 0xA6, (byte) 0xA6, (byte) 0xA6
};
AESKeyWrap() {
super(new AESCrypt());
}
@Override
String getFeedback() {
return "KW";
}
@Override
void save() {
throw new UnsupportedOperationException("save not supported");
};
@Override
void restore() {
throw new UnsupportedOperationException("restore not supported");
};
@Override
void init(boolean decrypting, String algorithm, byte[] key, byte[] iv)
throws InvalidKeyException, InvalidAlgorithmParameterException {
if (key == null) {
throw new InvalidKeyException("Invalid null key");
}
if (iv != null && iv.length != SEMI_BLKSIZE) {
throw new InvalidAlgorithmParameterException("Invalid IV");
}
embeddedCipher.init(decrypting, algorithm, key);
this.iv = (iv == null? ICV1 : iv);
}
@Override
void reset() {
throw new UnsupportedOperationException("reset not supported");
};
@Override
int encrypt(byte[] pt, int ptOfs, int ptLen, byte[] ct, int ctOfs) {
throw new UnsupportedOperationException("multi-part not supported");
};
@Override
int decrypt(byte[] ct, int ctOfs, int ctLen, byte[] pt, int ptOfs) {
throw new UnsupportedOperationException("multi-part not supported");
};
@Override
int encryptFinal(byte[] pt, int dummy1, int ptLen, byte[] dummy2,
int dummy3) throws IllegalBlockSizeException {
if (ptLen < MIN_INPUTLEN || (ptLen % SEMI_BLKSIZE) != 0) {
throw new IllegalBlockSizeException("data should" +
" be at least 16 bytes and multiples of 8");
}
return W(iv, pt, ptLen, embeddedCipher);
}
@Override
int decryptFinal(byte[] ct, int dummy1, int ctLen, byte[] dummy2,
int dummy3) throws IllegalBlockSizeException {
if (ctLen < MIN_INPUTLEN || (ctLen % SEMI_BLKSIZE) != 0) {
throw new IllegalBlockSizeException
("data should be at least 24 bytes and multiples of 8");
}
byte[] ivOut = new byte[SEMI_BLKSIZE];
ctLen = W_INV(ct, ctLen, ivOut, embeddedCipher);
if (!MessageDigest.isEqual(ivOut, this.iv)) {
throw new IllegalBlockSizeException("Integrity check failed");
}
return ctLen;
}
}
package com.sun.crypto.provider;
import java.util.Arrays;
import java.util.HexFormat;
import java.security.*;
import java.security.spec.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import static com.sun.crypto.provider.KWUtil.*;
class AESKeyWrapPadded extends FeedbackCipher {
static final byte[] ICV2 = {         (byte) 0xA6, (byte) 0x59, (byte) 0x59, (byte) 0xA6,
};
private static final byte[] PAD_BLK = new byte[SEMI_BLKSIZE - 1];
private static void setIvAndLen(byte[] dest, byte[] iv, int inLen) {
assert(dest.length >= SEMI_BLKSIZE) : "buffer needs at least 8 bytes";
System.arraycopy(iv, 0, dest, 0, iv.length);
dest[4] = (byte) ((inLen >>> 24) & 0xFF);
dest[5] = (byte) ((inLen >>> 16) & 0xFF);
dest[6] = (byte) ((inLen >>> 8) & 0xFF);
dest[7] = (byte) (inLen & 0xFF);
}
private static int validateIV(byte[] ivAndLen, byte[] iv)
throws IllegalBlockSizeException {
int match = 0;
for (int i = 0; i < ICV2.length; i++) {
match |= (ivAndLen[i] ^ iv[i]);
}
if (match != 0) {
throw new IllegalBlockSizeException("Integrity check failed");
}
int outLen = ivAndLen[4];
for (int k = 5; k < SEMI_BLKSIZE; k++) {
if (outLen != 0) {
outLen <<= 8;
}
outLen |= ivAndLen[k] & 0xFF;
}
return outLen;
}
AESKeyWrapPadded() {
super(new AESCrypt());
}
@Override
String getFeedback() {
return "KWP";
}
@Override
void save() {
throw new UnsupportedOperationException("save not supported");
};
@Override
void restore() {
throw new UnsupportedOperationException("restore not supported");
};
@Override
void init(boolean decrypting, String algorithm, byte[] key, byte[] iv)
throws InvalidKeyException, InvalidAlgorithmParameterException {
if (key == null) {
throw new InvalidKeyException("Invalid null key");
}
if (iv != null && !Arrays.equals(iv, ICV2)) {
HexFormat hf = HexFormat.of().withUpperCase();
throw new InvalidAlgorithmParameterException("Invalid IV, got 0x" +
hf.formatHex(iv) + " instead of 0x" + hf.formatHex(ICV2));
}
embeddedCipher.init(decrypting, algorithm, key);
this.iv = ICV2;
}
@Override
void reset() {
throw new UnsupportedOperationException("reset not supported");
};
@Override
int encrypt(byte[] pt, int ptOfs, int ptLen, byte[] ct, int ctOfs) {
throw new UnsupportedOperationException("multi-part not supported");
};
@Override
int decrypt(byte[] ct, int ctOfs, int ctLen, byte[] pt, int ptOfs) {
throw new UnsupportedOperationException("multi-part not supported");
};
@Override
int encryptFinal(byte[] pt, int dummy1, int ptLen, byte[] dummy2,
int dummy3) throws IllegalBlockSizeException {
int actualLen = ptLen - SEMI_BLKSIZE;
if (actualLen < 1) {
throw new IllegalBlockSizeException
("data should have at least 1 byte");
}
if (ptLen % SEMI_BLKSIZE != 0) {
int rem = SEMI_BLKSIZE - (ptLen % SEMI_BLKSIZE);
System.arraycopy(PAD_BLK, 0, pt, ptLen, rem);
ptLen += rem;
}
if (ptLen <= BLKSIZE) {
setIvAndLen(pt, iv, actualLen);
embeddedCipher.encryptBlock(pt, 0, pt, 0);
} else {
byte[] ivAndLen = new byte[SEMI_BLKSIZE];
setIvAndLen(ivAndLen, iv, actualLen);
ptLen = W(ivAndLen, pt, ptLen, embeddedCipher);
}
return ptLen;
}
@Override
int decryptFinal(byte[] ct, int dummy1, int ctLen, byte[] dummy2,
int dummy3) throws IllegalBlockSizeException {
if (ctLen < BLKSIZE || ctLen % SEMI_BLKSIZE != 0) {
throw new IllegalBlockSizeException
("data should be at least 16 bytes and multiples of 8");
}
byte[] ivAndLen = new byte[SEMI_BLKSIZE];
if (ctLen == BLKSIZE) {
embeddedCipher.decryptBlock(ct, 0, ct, 0);
System.arraycopy(ct, 0, ivAndLen, 0, SEMI_BLKSIZE);
System.arraycopy(ct, SEMI_BLKSIZE, ct, 0, SEMI_BLKSIZE);
ctLen -= SEMI_BLKSIZE;
} else {
ctLen = W_INV(ct, ctLen, ivAndLen, embeddedCipher);
}
int outLen = validateIV(ivAndLen, this.iv);
int padLen = ctLen - outLen;
if (padLen < 0 || padLen >= SEMI_BLKSIZE) {
throw new IllegalBlockSizeException("Invalid KWP pad length " +
padLen);
}
for (int k = padLen; k > 0; k--) {
if (ct[ctLen - k] != 0) {
throw new IllegalBlockSizeException("Invalid KWP pad value");
}
}
return outLen;
}
}
package com.sun.crypto.provider;
import java.io.*;
import java.security.AlgorithmParametersSpi;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.InvalidParameterSpecException;
public final class AESParameters extends AlgorithmParametersSpi {
private BlockCipherParamsCore core;
public AESParameters() {
core = new BlockCipherParamsCore(AESConstants.AES_BLOCK_SIZE, 4, 8);
}
protected void engineInit(AlgorithmParameterSpec paramSpec)
throws InvalidParameterSpecException {
core.init(paramSpec);
}
protected void engineInit(byte[] encoded)
throws IOException {
core.init(encoded);
}
protected void engineInit(byte[] encoded, String decodingMethod)
throws IOException {
core.init(encoded, decodingMethod);
}
protected <T extends AlgorithmParameterSpec>
T engineGetParameterSpec(Class<T> paramSpec)
throws InvalidParameterSpecException {
if (AlgorithmParameterSpec.class.isAssignableFrom(paramSpec)) {
return core.getParameterSpec(paramSpec);
} else {
throw new InvalidParameterSpecException
("Inappropriate parameter Specification");
}
}
protected byte[] engineGetEncoded() throws IOException {
return core.getEncoded();
}
protected byte[] engineGetEncoded(String encodingMethod)
throws IOException {
return core.getEncoded();
}
protected String engineToString() {
return core.toString();
}
}
package sun.security.krb5.internal.crypto.dk;
import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.SecretKeyFactory;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import java.security.GeneralSecurityException;
import sun.security.krb5.KrbCryptoException;
import sun.security.krb5.Confounder;
import sun.security.krb5.internal.crypto.KeyUsage;
import java.util.Arrays;
import static java.nio.charset.StandardCharsets.UTF_8;
public class AesSha2DkCrypto extends DkCrypto {
private static final boolean debug = false;
private static final int BLOCK_SIZE = 16;
private static final int DEFAULT_ITERATION_COUNT = 32768;
private static final byte[] ZERO_IV = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0 };
private static final byte[] ETYPE_NAME_128 =
"aes128-cts-hmac-sha256-128".getBytes();
private static final byte[] ETYPE_NAME_256 =
"aes256-cts-hmac-sha384-192".getBytes();
private final int hashSize;
private final int keyLength;
public AesSha2DkCrypto(int length) {
keyLength = length;
hashSize = (length == 128?128:192)/8;
}
protected int getKeySeedLength() {
return keyLength;       }
public byte[] stringToKey(char[] password, String salt, byte[] s2kparams)
throws GeneralSecurityException {
byte[] saltUtf8 = null;
try {
saltUtf8 = salt.getBytes(UTF_8);
return stringToKey(password, saltUtf8, s2kparams);
} catch (Exception e) {
return null;
} finally {
if (saltUtf8 != null) {
Arrays.fill(saltUtf8, (byte)0);
}
}
}
private byte[] stringToKey(char[] secret, byte[] salt, byte[] params)
throws GeneralSecurityException {
int iter_count = DEFAULT_ITERATION_COUNT;
if (params != null) {
if (params.length != 4) {
throw new RuntimeException("Invalid parameter to stringToKey");
}
iter_count = readBigEndian(params, 0, 4);
}
byte[] saltp = new byte[26 + 1 + salt.length];
if (keyLength == 128) {
System.arraycopy(ETYPE_NAME_128, 0, saltp, 0, 26);
} else {
System.arraycopy(ETYPE_NAME_256, 0, saltp, 0, 26);
}
System.arraycopy(salt, 0, saltp, 27, salt.length);
byte[] tmpKey = randomToKey(PBKDF2(secret, saltp, iter_count,
getKeySeedLength()));
byte[] result = dk(tmpKey, KERBEROS_CONSTANT);
return result;
}
protected byte[] randomToKey(byte[] in) {
return in;
}
protected byte[] dr(byte[] key, byte[] constant)
throws GeneralSecurityException {
byte[] result;
byte[] input = new byte[constant.length + 9];
input[3] = 1;
System.arraycopy(constant, 0, input, 4, constant.length);
SecretKeySpec tkey = new SecretKeySpec(key, "HMAC");
Mac mac = Mac.getInstance(
keyLength == 128? "HmacSHA256": "HmacSHA384");
mac.init(tkey);
int k;
if (keyLength == 128) {
k = 128;
} else {
byte last = constant[constant.length-1];
if (last == (byte)0x99 || last == (byte)0x55) {
k = 192;
} else {
k = 256;
}
}
input[input.length - 1] = (byte)(k);
input[input.length - 2] = (byte)(k / 256);
result = mac.doFinal(input);
return Arrays.copyOf(result, k / 8);
}
protected Cipher getCipher(byte[] key, byte[] ivec, int mode)
throws GeneralSecurityException {
if (ivec == null) {
ivec = ZERO_IV;
}
SecretKeySpec secretKey = new SecretKeySpec(key, "AES");
Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
IvParameterSpec encIv = new IvParameterSpec(ivec, 0, ivec.length);
cipher.init(mode, secretKey, encIv);
return cipher;
}
public int getChecksumLength() {
return hashSize;      }
protected byte[] getHmac(byte[] key, byte[] msg)
throws GeneralSecurityException {
SecretKey keyKi = new SecretKeySpec(key, "HMAC");
Mac m = Mac.getInstance(keyLength == 128 ? "HmacSHA256" : "HmacSHA384");
m.init(keyKi);
byte[] hash = m.doFinal(msg);
byte[] output = new byte[hashSize];
System.arraycopy(hash, 0, output, 0, hashSize);
return output;
}
private byte[] deriveKey(byte[] baseKey, int usage, byte type)
throws GeneralSecurityException {
byte[] constant = new byte[5];
constant[0] = (byte) ((usage>>24)&0xff);
constant[1] = (byte) ((usage>>16)&0xff);
constant[2] = (byte) ((usage>>8)&0xff);
constant[3] = (byte) (usage&0xff);
constant[4] = type;
return dk(baseKey, constant);
}
public byte[] calculateChecksum(byte[] baseKey, int usage, byte[] input,
int start, int len) throws GeneralSecurityException {
if (!KeyUsage.isValid(usage)) {
throw new GeneralSecurityException("Invalid key usage number: "
+ usage);
}
byte[] Kc = deriveKey(baseKey, usage, (byte) 0x99);          if (debug) {
System.err.println("usage: " + usage);
traceOutput("input", input, start, Math.min(len, 32));
traceOutput("baseKey", baseKey, 0, baseKey.length);
traceOutput("Kc", Kc, 0, Kc.length);
}
try {
byte[] hmac = getHmac(Kc, input);
if (debug) {
traceOutput("hmac", hmac, 0, hmac.length);
}
if (hmac.length == getChecksumLength()) {
return hmac;
} else if (hmac.length > getChecksumLength()) {
byte[] buf = new byte[getChecksumLength()];
System.arraycopy(hmac, 0, buf, 0, buf.length);
return buf;
} else {
throw new GeneralSecurityException("checksum size too short: " +
hmac.length + "; expecting : " + getChecksumLength());
}
} finally {
Arrays.fill(Kc, 0, Kc.length, (byte)0);
}
}
public byte[] encrypt(byte[] baseKey, int usage,
byte[] ivec, byte[] new_ivec, byte[] plaintext, int start, int len)
throws GeneralSecurityException, KrbCryptoException {
if (!KeyUsage.isValid(usage)) {
throw new GeneralSecurityException("Invalid key usage number: "
+ usage);
}
byte[] output = encryptCTS(baseKey, usage, ivec, new_ivec, plaintext,
start, len, true);
return output;
}
public byte[] encryptRaw(byte[] baseKey, int usage,
byte[] ivec, byte[] plaintext, int start, int len)
throws GeneralSecurityException, KrbCryptoException {
if (!KeyUsage.isValid(usage)) {
throw new GeneralSecurityException("Invalid key usage number: "
+ usage);
}
byte[] output = encryptCTS(baseKey, usage, ivec, null, plaintext,
start, len, false);
return output;
}
public byte[] decrypt(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len) throws GeneralSecurityException {
if (!KeyUsage.isValid(usage)) {
throw new GeneralSecurityException("Invalid key usage number: "
+ usage);
}
byte[] output = decryptCTS(baseKey, usage, ivec, ciphertext,
start, len, true);
return output;
}
public byte[] decryptRaw(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len)
throws GeneralSecurityException {
if (!KeyUsage.isValid(usage)) {
throw new GeneralSecurityException("Invalid key usage number: "
+ usage);
}
byte[] output = decryptCTS(baseKey, usage, ivec, ciphertext,
start, len, false);
return output;
}
private byte[] encryptCTS(byte[] baseKey, int usage, byte[] ivec,
byte[] new_ivec, byte[] plaintext, int start, int len,
boolean confounder_exists)
throws GeneralSecurityException, KrbCryptoException {
byte[] Ke = null;
byte[] Ki = null;
if (debug) {
System.err.println("usage: " + usage);
if (ivec != null) {
traceOutput("old_state.ivec", ivec, 0, ivec.length);
}
traceOutput("plaintext", plaintext, start, Math.min(len, 32));
traceOutput("baseKey", baseKey, 0, baseKey.length);
}
try {
Ke = deriveKey(baseKey, usage, (byte) 0xaa);
byte[] toBeEncrypted = null;
if (confounder_exists) {
byte[] confounder = Confounder.bytes(BLOCK_SIZE);
toBeEncrypted = new byte[confounder.length + len];
System.arraycopy(confounder, 0, toBeEncrypted,
0, confounder.length);
System.arraycopy(plaintext, start, toBeEncrypted,
confounder.length, len);
} else {
toBeEncrypted = new byte[len];
System.arraycopy(plaintext, start, toBeEncrypted, 0, len);
}
byte[] output = new byte[toBeEncrypted.length + hashSize];
Cipher cipher = Cipher.getInstance("AES/CTS/NoPadding");
SecretKeySpec secretKey = new SecretKeySpec(Ke, "AES");
IvParameterSpec encIv = new IvParameterSpec(ivec, 0, ivec.length);
cipher.init(Cipher.ENCRYPT_MODE, secretKey, encIv);
cipher.doFinal(toBeEncrypted, 0, toBeEncrypted.length, output);
Ki = deriveKey(baseKey, usage, (byte) 0x55);
if (debug) {
traceOutput("Ki", Ki, 0, Ke.length);
}
byte[] msg = Arrays.copyOf(ivec, ivec.length + toBeEncrypted.length);
System.arraycopy(output, 0, msg, ivec.length, toBeEncrypted.length);
byte[] hmac = getHmac(Ki, msg);
System.arraycopy(hmac, 0, output, toBeEncrypted.length,
hmac.length);
return output;
} finally {
if (Ke != null) {
Arrays.fill(Ke, 0, Ke.length, (byte) 0);
}
if (Ki != null) {
Arrays.fill(Ki, 0, Ki.length, (byte) 0);
}
}
}
private byte[] decryptCTS(byte[] baseKey, int usage, byte[] ivec,
byte[] ciphertext, int start, int len, boolean confounder_exists)
throws GeneralSecurityException {
byte[] Ke = null;
byte[] Ki = null;
try {
Ke = deriveKey(baseKey, usage, (byte) 0xaa);
if (debug) {
System.err.println("usage: " + usage);
if (ivec != null) {
traceOutput("old_state.ivec", ivec, 0, ivec.length);
}
traceOutput("ciphertext", ciphertext, start, Math.min(len, 32));
traceOutput("baseKey", baseKey, 0, baseKey.length);
traceOutput("Ke", Ke, 0, Ke.length);
}
Cipher cipher = Cipher.getInstance("AES/CTS/NoPadding");
SecretKeySpec secretKey = new SecretKeySpec(Ke, "AES");
IvParameterSpec encIv = new IvParameterSpec(ivec, 0, ivec.length);
cipher.init(Cipher.DECRYPT_MODE, secretKey, encIv);
byte[] plaintext = cipher.doFinal(ciphertext, start, len-hashSize);
if (debug) {
traceOutput("AES PlainText", plaintext, 0,
Math.min(plaintext.length, 32));
}
Ki = deriveKey(baseKey, usage, (byte) 0x55);              if (debug) {
traceOutput("Ki", Ki, 0, Ke.length);
}
byte[] msg = Arrays.copyOf(ivec, ivec.length + len-hashSize);
System.arraycopy(ciphertext, start, msg, ivec.length, len-hashSize);
byte[] calculatedHmac = getHmac(Ki, msg);
int hmacOffset = start + len - hashSize;
if (debug) {
traceOutput("calculated Hmac", calculatedHmac,
0, calculatedHmac.length);
traceOutput("message Hmac", ciphertext, hmacOffset, hashSize);
}
boolean cksumFailed = false;
if (calculatedHmac.length >= hashSize) {
for (int i = 0; i < hashSize; i++) {
if (calculatedHmac[i] != ciphertext[hmacOffset+i]) {
cksumFailed = true;
if (debug) {
System.err.println("Checksum failed !");
}
break;
}
}
}
if (cksumFailed) {
throw new GeneralSecurityException("Checksum failed");
}
if (confounder_exists) {
byte[] output = new byte[plaintext.length - BLOCK_SIZE];
System.arraycopy(plaintext, BLOCK_SIZE, output,
0, output.length);
return output;
} else {
return plaintext;
}
} finally {
if (Ke != null) {
Arrays.fill(Ke, 0, Ke.length, (byte) 0);
}
if (Ki != null) {
Arrays.fill(Ki, 0, Ki.length, (byte) 0);
}
}
}
private static byte[] PBKDF2(char[] secret, byte[] salt,
int count, int keyLength) throws GeneralSecurityException {
PBEKeySpec keySpec = new PBEKeySpec(secret, salt, count, keyLength);
SecretKeyFactory skf =
SecretKeyFactory.getInstance(keyLength == 128 ?
"PBKDF2WithHmacSHA256" : "PBKDF2WithHmacSHA384");
SecretKey key = skf.generateSecret(keySpec);
byte[] result = key.getEncoded();
return result;
}
public static final int readBigEndian(byte[] data, int pos, int size) {
int retVal = 0;
int shifter = (size-1)*8;
while (size > 0) {
retVal += (data[pos] & 0xff) << shifter;
shifter -= 8;
pos++;
size--;
}
return retVal;
}
}
package sun.security.ec.point;
import sun.security.util.math.ImmutableIntegerModuloP;
import java.util.Objects;
public class AffinePoint {
private final ImmutableIntegerModuloP x;
private final ImmutableIntegerModuloP y;
public AffinePoint(ImmutableIntegerModuloP x, ImmutableIntegerModuloP y) {
this.x = x;
this.y = y;
}
public ImmutableIntegerModuloP getX() {
return x;
}
public ImmutableIntegerModuloP getY() {
return y;
}
@Override
public boolean equals(Object obj) {
if (!(obj instanceof AffinePoint)) {
return false;
}
AffinePoint p = (AffinePoint) obj;
boolean xEquals = x.asBigInteger().equals(p.x.asBigInteger());
boolean yEquals = y.asBigInteger().equals(p.y.asBigInteger());
return xEquals && yEquals;
}
@Override
public int hashCode() {
return Objects.hash(x, y);
}
@Override
public String toString() {
return "(" + x.asBigInteger().toString() + "," +
y.asBigInteger().toString() + ")";
}
}
package java.awt.geom;
import java.awt.Shape;
import java.beans.ConstructorProperties;
import java.io.IOException;
import java.io.Serial;
public class AffineTransform implements Cloneable, java.io.Serializable {
private static final int TYPE_UNKNOWN = -1;
public static final int TYPE_IDENTITY = 0;
public static final int TYPE_TRANSLATION = 1;
public static final int TYPE_UNIFORM_SCALE = 2;
public static final int TYPE_GENERAL_SCALE = 4;
public static final int TYPE_MASK_SCALE = (TYPE_UNIFORM_SCALE |
TYPE_GENERAL_SCALE);
public static final int TYPE_FLIP = 64;
public static final int TYPE_QUADRANT_ROTATION = 8;
public static final int TYPE_GENERAL_ROTATION = 16;
public static final int TYPE_MASK_ROTATION = (TYPE_QUADRANT_ROTATION |
TYPE_GENERAL_ROTATION);
public static final int TYPE_GENERAL_TRANSFORM = 32;
static final int APPLY_IDENTITY = 0;
static final int APPLY_TRANSLATE = 1;
static final int APPLY_SCALE = 2;
static final int APPLY_SHEAR = 4;
private static final int HI_SHIFT = 3;
private static final int HI_IDENTITY = APPLY_IDENTITY << HI_SHIFT;
private static final int HI_TRANSLATE = APPLY_TRANSLATE << HI_SHIFT;
private static final int HI_SCALE = APPLY_SCALE << HI_SHIFT;
private static final int HI_SHEAR = APPLY_SHEAR << HI_SHIFT;
double m00;
double m10;
double m01;
double m11;
double m02;
double m12;
transient int state;
private transient int type;
private AffineTransform(double m00, double m10,
double m01, double m11,
double m02, double m12,
int state) {
this.m00 = m00;
this.m10 = m10;
this.m01 = m01;
this.m11 = m11;
this.m02 = m02;
this.m12 = m12;
this.state = state;
this.type = TYPE_UNKNOWN;
}
public AffineTransform() {
m00 = m11 = 1.0;
}
public AffineTransform(AffineTransform Tx) {
this.m00 = Tx.m00;
this.m10 = Tx.m10;
this.m01 = Tx.m01;
this.m11 = Tx.m11;
this.m02 = Tx.m02;
this.m12 = Tx.m12;
this.state = Tx.state;
this.type = Tx.type;
}
@ConstructorProperties({ "scaleX", "shearY", "shearX", "scaleY", "translateX", "translateY" })
public AffineTransform(float m00, float m10,
float m01, float m11,
float m02, float m12) {
this.m00 = m00;
this.m10 = m10;
this.m01 = m01;
this.m11 = m11;
this.m02 = m02;
this.m12 = m12;
updateState();
}
public AffineTransform(float[] flatmatrix) {
m00 = flatmatrix[0];
m10 = flatmatrix[1];
m01 = flatmatrix[2];
m11 = flatmatrix[3];
if (flatmatrix.length > 5) {
m02 = flatmatrix[4];
m12 = flatmatrix[5];
}
updateState();
}
public AffineTransform(double m00, double m10,
double m01, double m11,
double m02, double m12) {
this.m00 = m00;
this.m10 = m10;
this.m01 = m01;
this.m11 = m11;
this.m02 = m02;
this.m12 = m12;
updateState();
}
public AffineTransform(double[] flatmatrix) {
m00 = flatmatrix[0];
m10 = flatmatrix[1];
m01 = flatmatrix[2];
m11 = flatmatrix[3];
if (flatmatrix.length > 5) {
m02 = flatmatrix[4];
m12 = flatmatrix[5];
}
updateState();
}
public static AffineTransform getTranslateInstance(double tx, double ty) {
AffineTransform Tx = new AffineTransform();
Tx.setToTranslation(tx, ty);
return Tx;
}
public static AffineTransform getRotateInstance(double theta) {
AffineTransform Tx = new AffineTransform();
Tx.setToRotation(theta);
return Tx;
}
public static AffineTransform getRotateInstance(double theta,
double anchorx,
double anchory)
{
AffineTransform Tx = new AffineTransform();
Tx.setToRotation(theta, anchorx, anchory);
return Tx;
}
public static AffineTransform getRotateInstance(double vecx, double vecy) {
AffineTransform Tx = new AffineTransform();
Tx.setToRotation(vecx, vecy);
return Tx;
}
public static AffineTransform getRotateInstance(double vecx,
double vecy,
double anchorx,
double anchory)
{
AffineTransform Tx = new AffineTransform();
Tx.setToRotation(vecx, vecy, anchorx, anchory);
return Tx;
}
public static AffineTransform getQuadrantRotateInstance(int numquadrants) {
AffineTransform Tx = new AffineTransform();
Tx.setToQuadrantRotation(numquadrants);
return Tx;
}
public static AffineTransform getQuadrantRotateInstance(int numquadrants,
double anchorx,
double anchory)
{
AffineTransform Tx = new AffineTransform();
Tx.setToQuadrantRotation(numquadrants, anchorx, anchory);
return Tx;
}
public static AffineTransform getScaleInstance(double sx, double sy) {
AffineTransform Tx = new AffineTransform();
Tx.setToScale(sx, sy);
return Tx;
}
public static AffineTransform getShearInstance(double shx, double shy) {
AffineTransform Tx = new AffineTransform();
Tx.setToShear(shx, shy);
return Tx;
}
public int getType() {
if (type == TYPE_UNKNOWN) {
calculateType();
}
return type;
}
@SuppressWarnings("fallthrough")
private void calculateType() {
int ret = TYPE_IDENTITY;
boolean sgn0, sgn1;
double M0, M1, M2, M3;
updateState();
switch (state) {
default:
stateError();
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
ret = TYPE_TRANSLATION;
case (APPLY_SHEAR | APPLY_SCALE):
if ((M0 = m00) * (M2 = m01) + (M3 = m10) * (M1 = m11) != 0) {
this.type = TYPE_GENERAL_TRANSFORM;
return;
}
sgn0 = (M0 >= 0.0);
sgn1 = (M1 >= 0.0);
if (sgn0 == sgn1) {
if (M0 != M1 || M2 != -M3) {
ret |= (TYPE_GENERAL_ROTATION | TYPE_GENERAL_SCALE);
} else if (M0 * M1 - M2 * M3 != 1.0) {
ret |= (TYPE_GENERAL_ROTATION | TYPE_UNIFORM_SCALE);
} else {
ret |= TYPE_GENERAL_ROTATION;
}
} else {
if (M0 != -M1 || M2 != M3) {
ret |= (TYPE_GENERAL_ROTATION |
TYPE_FLIP |
TYPE_GENERAL_SCALE);
} else if (M0 * M1 - M2 * M3 != 1.0) {
ret |= (TYPE_GENERAL_ROTATION |
TYPE_FLIP |
TYPE_UNIFORM_SCALE);
} else {
ret |= (TYPE_GENERAL_ROTATION | TYPE_FLIP);
}
}
break;
case (APPLY_SHEAR | APPLY_TRANSLATE):
ret = TYPE_TRANSLATION;
case (APPLY_SHEAR):
sgn0 = ((M0 = m01) >= 0.0);
sgn1 = ((M1 = m10) >= 0.0);
if (sgn0 != sgn1) {
if (M0 != -M1) {
ret |= (TYPE_QUADRANT_ROTATION | TYPE_GENERAL_SCALE);
} else if (M0 != 1.0 && M0 != -1.0) {
ret |= (TYPE_QUADRANT_ROTATION | TYPE_UNIFORM_SCALE);
} else {
ret |= TYPE_QUADRANT_ROTATION;
}
} else {
if (M0 == M1) {
ret |= (TYPE_QUADRANT_ROTATION |
TYPE_FLIP |
TYPE_UNIFORM_SCALE);
} else {
ret |= (TYPE_QUADRANT_ROTATION |
TYPE_FLIP |
TYPE_GENERAL_SCALE);
}
}
break;
case (APPLY_SCALE | APPLY_TRANSLATE):
ret = TYPE_TRANSLATION;
case (APPLY_SCALE):
sgn0 = ((M0 = m00) >= 0.0);
sgn1 = ((M1 = m11) >= 0.0);
if (sgn0 == sgn1) {
if (sgn0) {
if (M0 == M1) {
ret |= TYPE_UNIFORM_SCALE;
} else {
ret |= TYPE_GENERAL_SCALE;
}
} else {
if (M0 != M1) {
ret |= (TYPE_QUADRANT_ROTATION | TYPE_GENERAL_SCALE);
} else if (M0 != -1.0) {
ret |= (TYPE_QUADRANT_ROTATION | TYPE_UNIFORM_SCALE);
} else {
ret |= TYPE_QUADRANT_ROTATION;
}
}
} else {
if (M0 == -M1) {
if (M0 == 1.0 || M0 == -1.0) {
ret |= TYPE_FLIP;
} else {
ret |= (TYPE_FLIP | TYPE_UNIFORM_SCALE);
}
} else {
ret |= (TYPE_FLIP | TYPE_GENERAL_SCALE);
}
}
break;
case (APPLY_TRANSLATE):
ret = TYPE_TRANSLATION;
break;
case (APPLY_IDENTITY):
break;
}
this.type = ret;
}
@SuppressWarnings("fallthrough")
public double getDeterminant() {
switch (state) {
default:
stateError();
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
case (APPLY_SHEAR | APPLY_SCALE):
return m00 * m11 - m01 * m10;
case (APPLY_SHEAR | APPLY_TRANSLATE):
case (APPLY_SHEAR):
return -(m01 * m10);
case (APPLY_SCALE | APPLY_TRANSLATE):
case (APPLY_SCALE):
return m00 * m11;
case (APPLY_TRANSLATE):
case (APPLY_IDENTITY):
return 1.0;
}
}
void updateState() {
if (m01 == 0.0 && m10 == 0.0) {
if (m00 == 1.0 && m11 == 1.0) {
if (m02 == 0.0 && m12 == 0.0) {
state = APPLY_IDENTITY;
type = TYPE_IDENTITY;
} else {
state = APPLY_TRANSLATE;
type = TYPE_TRANSLATION;
}
} else {
if (m02 == 0.0 && m12 == 0.0) {
state = APPLY_SCALE;
type = TYPE_UNKNOWN;
} else {
state = (APPLY_SCALE | APPLY_TRANSLATE);
type = TYPE_UNKNOWN;
}
}
} else {
if (m00 == 0.0 && m11 == 0.0) {
if (m02 == 0.0 && m12 == 0.0) {
state = APPLY_SHEAR;
type = TYPE_UNKNOWN;
} else {
state = (APPLY_SHEAR | APPLY_TRANSLATE);
type = TYPE_UNKNOWN;
}
} else {
if (m02 == 0.0 && m12 == 0.0) {
state = (APPLY_SHEAR | APPLY_SCALE);
type = TYPE_UNKNOWN;
} else {
state = (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE);
type = TYPE_UNKNOWN;
}
}
}
}
private void stateError() {
throw new InternalError("missing case in transform state switch");
}
public void getMatrix(double[] flatmatrix) {
flatmatrix[0] = m00;
flatmatrix[1] = m10;
flatmatrix[2] = m01;
flatmatrix[3] = m11;
if (flatmatrix.length > 5) {
flatmatrix[4] = m02;
flatmatrix[5] = m12;
}
}
public double getScaleX() {
return m00;
}
public double getScaleY() {
return m11;
}
public double getShearX() {
return m01;
}
public double getShearY() {
return m10;
}
public double getTranslateX() {
return m02;
}
public double getTranslateY() {
return m12;
}
public void translate(double tx, double ty) {
switch (state) {
default:
stateError();
return;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
m02 = tx * m00 + ty * m01 + m02;
m12 = tx * m10 + ty * m11 + m12;
if (m02 == 0.0 && m12 == 0.0) {
state = APPLY_SHEAR | APPLY_SCALE;
if (type != TYPE_UNKNOWN) {
type -= TYPE_TRANSLATION;
}
}
return;
case (APPLY_SHEAR | APPLY_SCALE):
m02 = tx * m00 + ty * m01;
m12 = tx * m10 + ty * m11;
if (m02 != 0.0 || m12 != 0.0) {
state = APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE;
type |= TYPE_TRANSLATION;
}
return;
case (APPLY_SHEAR | APPLY_TRANSLATE):
m02 = ty * m01 + m02;
m12 = tx * m10 + m12;
if (m02 == 0.0 && m12 == 0.0) {
state = APPLY_SHEAR;
if (type != TYPE_UNKNOWN) {
type -= TYPE_TRANSLATION;
}
}
return;
case (APPLY_SHEAR):
m02 = ty * m01;
m12 = tx * m10;
if (m02 != 0.0 || m12 != 0.0) {
state = APPLY_SHEAR | APPLY_TRANSLATE;
type |= TYPE_TRANSLATION;
}
return;
case (APPLY_SCALE | APPLY_TRANSLATE):
m02 = tx * m00 + m02;
m12 = ty * m11 + m12;
if (m02 == 0.0 && m12 == 0.0) {
state = APPLY_SCALE;
if (type != TYPE_UNKNOWN) {
type -= TYPE_TRANSLATION;
}
}
return;
case (APPLY_SCALE):
m02 = tx * m00;
m12 = ty * m11;
if (m02 != 0.0 || m12 != 0.0) {
state = APPLY_SCALE | APPLY_TRANSLATE;
type |= TYPE_TRANSLATION;
}
return;
case (APPLY_TRANSLATE):
m02 = tx + m02;
m12 = ty + m12;
if (m02 == 0.0 && m12 == 0.0) {
state = APPLY_IDENTITY;
type = TYPE_IDENTITY;
}
return;
case (APPLY_IDENTITY):
m02 = tx;
m12 = ty;
if (tx != 0.0 || ty != 0.0) {
state = APPLY_TRANSLATE;
type = TYPE_TRANSLATION;
}
return;
}
}
private static final int[] rot90conversion = {
APPLY_SHEAR,
APPLY_SHEAR | APPLY_TRANSLATE,
APPLY_SHEAR,
APPLY_SHEAR | APPLY_TRANSLATE,
APPLY_SCALE,
APPLY_SCALE | APPLY_TRANSLATE,
APPLY_SHEAR | APPLY_SCALE,
APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE,
};
private void rotate90() {
double M0 = m00;
m00 = m01;
m01 = -M0;
M0 = m10;
m10 = m11;
m11 = -M0;
int state = rot90conversion[this.state];
if ((state & (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &&
m00 == 1.0 && m11 == 1.0)
{
state -= APPLY_SCALE;
}
this.state = state;
type = TYPE_UNKNOWN;
}
private void rotate180() {
m00 = -m00;
m11 = -m11;
int state = this.state;
if ((state & (APPLY_SHEAR)) != 0) {
m01 = -m01;
m10 = -m10;
} else {
if (m00 == 1.0 && m11 == 1.0) {
this.state = state & ~APPLY_SCALE;
} else {
this.state = state | APPLY_SCALE;
}
}
type = TYPE_UNKNOWN;
}
private void rotate270() {
double M0 = m00;
m00 = -m01;
m01 = M0;
M0 = m10;
m10 = -m11;
m11 = M0;
int state = rot90conversion[this.state];
if ((state & (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &&
m00 == 1.0 && m11 == 1.0)
{
state -= APPLY_SCALE;
}
this.state = state;
type = TYPE_UNKNOWN;
}
public void rotate(double theta) {
double sin = Math.sin(theta);
if (sin == 1.0) {
rotate90();
} else if (sin == -1.0) {
rotate270();
} else {
double cos = Math.cos(theta);
if (cos == -1.0) {
rotate180();
} else if (cos != 1.0) {
double M0, M1;
M0 = m00;
M1 = m01;
m00 =  cos * M0 + sin * M1;
m01 = -sin * M0 + cos * M1;
M0 = m10;
M1 = m11;
m10 =  cos * M0 + sin * M1;
m11 = -sin * M0 + cos * M1;
updateState();
}
}
}
public void rotate(double theta, double anchorx, double anchory) {
translate(anchorx, anchory);
rotate(theta);
translate(-anchorx, -anchory);
}
public void rotate(double vecx, double vecy) {
if (vecy == 0.0) {
if (vecx < 0.0) {
rotate180();
}
} else if (vecx == 0.0) {
if (vecy > 0.0) {
rotate90();
} else {                  rotate270();
}
} else {
double len = Math.sqrt(vecx * vecx + vecy * vecy);
double sin = vecy / len;
double cos = vecx / len;
double M0, M1;
M0 = m00;
M1 = m01;
m00 =  cos * M0 + sin * M1;
m01 = -sin * M0 + cos * M1;
M0 = m10;
M1 = m11;
m10 =  cos * M0 + sin * M1;
m11 = -sin * M0 + cos * M1;
updateState();
}
}
public void rotate(double vecx, double vecy,
double anchorx, double anchory)
{
translate(anchorx, anchory);
rotate(vecx, vecy);
translate(-anchorx, -anchory);
}
public void quadrantRotate(int numquadrants) {
switch (numquadrants & 3) {
case 0:
break;
case 1:
rotate90();
break;
case 2:
rotate180();
break;
case 3:
rotate270();
break;
}
}
public void quadrantRotate(int numquadrants,
double anchorx, double anchory)
{
switch (numquadrants & 3) {
case 0:
return;
case 1:
m02 += anchorx * (m00 - m01) + anchory * (m01 + m00);
m12 += anchorx * (m10 - m11) + anchory * (m11 + m10);
rotate90();
break;
case 2:
m02 += anchorx * (m00 + m00) + anchory * (m01 + m01);
m12 += anchorx * (m10 + m10) + anchory * (m11 + m11);
rotate180();
break;
case 3:
m02 += anchorx * (m00 + m01) + anchory * (m01 - m00);
m12 += anchorx * (m10 + m11) + anchory * (m11 - m10);
rotate270();
break;
}
if (m02 == 0.0 && m12 == 0.0) {
state &= ~APPLY_TRANSLATE;
} else {
state |= APPLY_TRANSLATE;
}
}
@SuppressWarnings("fallthrough")
public void scale(double sx, double sy) {
int state = this.state;
switch (state) {
default:
stateError();
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
case (APPLY_SHEAR | APPLY_SCALE):
m00 *= sx;
m11 *= sy;
case (APPLY_SHEAR | APPLY_TRANSLATE):
case (APPLY_SHEAR):
m01 *= sy;
m10 *= sx;
if (m01 == 0 && m10 == 0) {
state &= APPLY_TRANSLATE;
if (m00 == 1.0 && m11 == 1.0) {
this.type = (state == APPLY_IDENTITY
? TYPE_IDENTITY
: TYPE_TRANSLATION);
} else {
state |= APPLY_SCALE;
this.type = TYPE_UNKNOWN;
}
this.state = state;
}
return;
case (APPLY_SCALE | APPLY_TRANSLATE):
case (APPLY_SCALE):
m00 *= sx;
m11 *= sy;
if (m00 == 1.0 && m11 == 1.0) {
this.state = (state &= APPLY_TRANSLATE);
this.type = (state == APPLY_IDENTITY
? TYPE_IDENTITY
: TYPE_TRANSLATION);
} else {
this.type = TYPE_UNKNOWN;
}
return;
case (APPLY_TRANSLATE):
case (APPLY_IDENTITY):
m00 = sx;
m11 = sy;
if (sx != 1.0 || sy != 1.0) {
this.state = state | APPLY_SCALE;
this.type = TYPE_UNKNOWN;
}
return;
}
}
public void shear(double shx, double shy) {
int state = this.state;
switch (state) {
default:
stateError();
return;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
case (APPLY_SHEAR | APPLY_SCALE):
double M0, M1;
M0 = m00;
M1 = m01;
m00 = M0 + M1 * shy;
m01 = M0 * shx + M1;
M0 = m10;
M1 = m11;
m10 = M0 + M1 * shy;
m11 = M0 * shx + M1;
updateState();
return;
case (APPLY_SHEAR | APPLY_TRANSLATE):
case (APPLY_SHEAR):
m00 = m01 * shy;
m11 = m10 * shx;
if (m00 != 0.0 || m11 != 0.0) {
this.state = state | APPLY_SCALE;
}
this.type = TYPE_UNKNOWN;
return;
case (APPLY_SCALE | APPLY_TRANSLATE):
case (APPLY_SCALE):
m01 = m00 * shx;
m10 = m11 * shy;
if (m01 != 0.0 || m10 != 0.0) {
this.state = state | APPLY_SHEAR;
}
this.type = TYPE_UNKNOWN;
return;
case (APPLY_TRANSLATE):
case (APPLY_IDENTITY):
m01 = shx;
m10 = shy;
if (m01 != 0.0 || m10 != 0.0) {
this.state = state | APPLY_SCALE | APPLY_SHEAR;
this.type = TYPE_UNKNOWN;
}
return;
}
}
public void setToIdentity() {
m00 = m11 = 1.0;
m10 = m01 = m02 = m12 = 0.0;
state = APPLY_IDENTITY;
type = TYPE_IDENTITY;
}
public void setToTranslation(double tx, double ty) {
m00 = 1.0;
m10 = 0.0;
m01 = 0.0;
m11 = 1.0;
m02 = tx;
m12 = ty;
if (tx != 0.0 || ty != 0.0) {
state = APPLY_TRANSLATE;
type = TYPE_TRANSLATION;
} else {
state = APPLY_IDENTITY;
type = TYPE_IDENTITY;
}
}
public void setToRotation(double theta) {
double sin = Math.sin(theta);
double cos;
if (sin == 1.0 || sin == -1.0) {
cos = 0.0;
state = APPLY_SHEAR;
type = TYPE_QUADRANT_ROTATION;
} else {
cos = Math.cos(theta);
if (cos == -1.0) {
sin = 0.0;
state = APPLY_SCALE;
type = TYPE_QUADRANT_ROTATION;
} else if (cos == 1.0) {
sin = 0.0;
state = APPLY_IDENTITY;
type = TYPE_IDENTITY;
} else {
state = APPLY_SHEAR | APPLY_SCALE;
type = TYPE_GENERAL_ROTATION;
}
}
m00 =  cos;
m10 =  sin;
m01 = -sin;
m11 =  cos;
m02 =  0.0;
m12 =  0.0;
}
public void setToRotation(double theta, double anchorx, double anchory) {
setToRotation(theta);
double sin = m10;
double oneMinusCos = 1.0 - m00;
m02 = anchorx * oneMinusCos + anchory * sin;
m12 = anchory * oneMinusCos - anchorx * sin;
if (m02 != 0.0 || m12 != 0.0) {
state |= APPLY_TRANSLATE;
type |= TYPE_TRANSLATION;
}
}
public void setToRotation(double vecx, double vecy) {
double sin, cos;
if (vecy == 0) {
sin = 0.0;
if (vecx < 0.0) {
cos = -1.0;
state = APPLY_SCALE;
type = TYPE_QUADRANT_ROTATION;
} else {
cos = 1.0;
state = APPLY_IDENTITY;
type = TYPE_IDENTITY;
}
} else if (vecx == 0) {
cos = 0.0;
sin = (vecy > 0.0) ? 1.0 : -1.0;
state = APPLY_SHEAR;
type = TYPE_QUADRANT_ROTATION;
} else {
double len = Math.sqrt(vecx * vecx + vecy * vecy);
cos = vecx / len;
sin = vecy / len;
state = APPLY_SHEAR | APPLY_SCALE;
type = TYPE_GENERAL_ROTATION;
}
m00 =  cos;
m10 =  sin;
m01 = -sin;
m11 =  cos;
m02 =  0.0;
m12 =  0.0;
}
public void setToRotation(double vecx, double vecy,
double anchorx, double anchory)
{
setToRotation(vecx, vecy);
double sin = m10;
double oneMinusCos = 1.0 - m00;
m02 = anchorx * oneMinusCos + anchory * sin;
m12 = anchory * oneMinusCos - anchorx * sin;
if (m02 != 0.0 || m12 != 0.0) {
state |= APPLY_TRANSLATE;
type |= TYPE_TRANSLATION;
}
}
public void setToQuadrantRotation(int numquadrants) {
switch (numquadrants & 3) {
case 0:
m00 =  1.0;
m10 =  0.0;
m01 =  0.0;
m11 =  1.0;
m02 =  0.0;
m12 =  0.0;
state = APPLY_IDENTITY;
type = TYPE_IDENTITY;
break;
case 1:
m00 =  0.0;
m10 =  1.0;
m01 = -1.0;
m11 =  0.0;
m02 =  0.0;
m12 =  0.0;
state = APPLY_SHEAR;
type = TYPE_QUADRANT_ROTATION;
break;
case 2:
m00 = -1.0;
m10 =  0.0;
m01 =  0.0;
m11 = -1.0;
m02 =  0.0;
m12 =  0.0;
state = APPLY_SCALE;
type = TYPE_QUADRANT_ROTATION;
break;
case 3:
m00 =  0.0;
m10 = -1.0;
m01 =  1.0;
m11 =  0.0;
m02 =  0.0;
m12 =  0.0;
state = APPLY_SHEAR;
type = TYPE_QUADRANT_ROTATION;
break;
}
}
public void setToQuadrantRotation(int numquadrants,
double anchorx, double anchory)
{
switch (numquadrants & 3) {
case 0:
m00 =  1.0;
m10 =  0.0;
m01 =  0.0;
m11 =  1.0;
m02 =  0.0;
m12 =  0.0;
state = APPLY_IDENTITY;
type = TYPE_IDENTITY;
break;
case 1:
m00 =  0.0;
m10 =  1.0;
m01 = -1.0;
m11 =  0.0;
m02 =  anchorx + anchory;
m12 =  anchory - anchorx;
if (m02 == 0.0 && m12 == 0.0) {
state = APPLY_SHEAR;
type = TYPE_QUADRANT_ROTATION;
} else {
state = APPLY_SHEAR | APPLY_TRANSLATE;
type = TYPE_QUADRANT_ROTATION | TYPE_TRANSLATION;
}
break;
case 2:
m00 = -1.0;
m10 =  0.0;
m01 =  0.0;
m11 = -1.0;
m02 =  anchorx + anchorx;
m12 =  anchory + anchory;
if (m02 == 0.0 && m12 == 0.0) {
state = APPLY_SCALE;
type = TYPE_QUADRANT_ROTATION;
} else {
state = APPLY_SCALE | APPLY_TRANSLATE;
type = TYPE_QUADRANT_ROTATION | TYPE_TRANSLATION;
}
break;
case 3:
m00 =  0.0;
m10 = -1.0;
m01 =  1.0;
m11 =  0.0;
m02 =  anchorx - anchory;
m12 =  anchory + anchorx;
if (m02 == 0.0 && m12 == 0.0) {
state = APPLY_SHEAR;
type = TYPE_QUADRANT_ROTATION;
} else {
state = APPLY_SHEAR | APPLY_TRANSLATE;
type = TYPE_QUADRANT_ROTATION | TYPE_TRANSLATION;
}
break;
}
}
public void setToScale(double sx, double sy) {
m00 = sx;
m10 = 0.0;
m01 = 0.0;
m11 = sy;
m02 = 0.0;
m12 = 0.0;
if (sx != 1.0 || sy != 1.0) {
state = APPLY_SCALE;
type = TYPE_UNKNOWN;
} else {
state = APPLY_IDENTITY;
type = TYPE_IDENTITY;
}
}
public void setToShear(double shx, double shy) {
m00 = 1.0;
m01 = shx;
m10 = shy;
m11 = 1.0;
m02 = 0.0;
m12 = 0.0;
if (shx != 0.0 || shy != 0.0) {
state = (APPLY_SHEAR | APPLY_SCALE);
type = TYPE_UNKNOWN;
} else {
state = APPLY_IDENTITY;
type = TYPE_IDENTITY;
}
}
public void setTransform(AffineTransform Tx) {
this.m00 = Tx.m00;
this.m10 = Tx.m10;
this.m01 = Tx.m01;
this.m11 = Tx.m11;
this.m02 = Tx.m02;
this.m12 = Tx.m12;
this.state = Tx.state;
this.type = Tx.type;
}
public void setTransform(double m00, double m10,
double m01, double m11,
double m02, double m12) {
this.m00 = m00;
this.m10 = m10;
this.m01 = m01;
this.m11 = m11;
this.m02 = m02;
this.m12 = m12;
updateState();
}
@SuppressWarnings("fallthrough")
public void concatenate(AffineTransform Tx) {
double M0, M1;
double T00, T01, T10, T11;
double T02, T12;
int mystate = state;
int txstate = Tx.state;
switch ((txstate << HI_SHIFT) | mystate) {
case (HI_IDENTITY | APPLY_IDENTITY):
case (HI_IDENTITY | APPLY_TRANSLATE):
case (HI_IDENTITY | APPLY_SCALE):
case (HI_IDENTITY | APPLY_SCALE | APPLY_TRANSLATE):
case (HI_IDENTITY | APPLY_SHEAR):
case (HI_IDENTITY | APPLY_SHEAR | APPLY_TRANSLATE):
case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE):
case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
return;
case (HI_SHEAR | HI_SCALE | HI_TRANSLATE | APPLY_IDENTITY):
m01 = Tx.m01;
m10 = Tx.m10;
case (HI_SCALE | HI_TRANSLATE | APPLY_IDENTITY):
m00 = Tx.m00;
m11 = Tx.m11;
case (HI_TRANSLATE | APPLY_IDENTITY):
m02 = Tx.m02;
m12 = Tx.m12;
state = txstate;
type = Tx.type;
return;
case (HI_SHEAR | HI_SCALE | APPLY_IDENTITY):
m01 = Tx.m01;
m10 = Tx.m10;
case (HI_SCALE | APPLY_IDENTITY):
m00 = Tx.m00;
m11 = Tx.m11;
state = txstate;
type = Tx.type;
return;
case (HI_SHEAR | HI_TRANSLATE | APPLY_IDENTITY):
m02 = Tx.m02;
m12 = Tx.m12;
case (HI_SHEAR | APPLY_IDENTITY):
m01 = Tx.m01;
m10 = Tx.m10;
m00 = m11 = 0.0;
state = txstate;
type = Tx.type;
return;
case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE):
case (HI_TRANSLATE | APPLY_SHEAR | APPLY_TRANSLATE):
case (HI_TRANSLATE | APPLY_SHEAR):
case (HI_TRANSLATE | APPLY_SCALE | APPLY_TRANSLATE):
case (HI_TRANSLATE | APPLY_SCALE):
case (HI_TRANSLATE | APPLY_TRANSLATE):
translate(Tx.m02, Tx.m12);
return;
case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE):
case (HI_SCALE | APPLY_SHEAR | APPLY_TRANSLATE):
case (HI_SCALE | APPLY_SHEAR):
case (HI_SCALE | APPLY_SCALE | APPLY_TRANSLATE):
case (HI_SCALE | APPLY_SCALE):
case (HI_SCALE | APPLY_TRANSLATE):
scale(Tx.m00, Tx.m11);
return;
case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE):
T01 = Tx.m01; T10 = Tx.m10;
M0 = m00;
m00 = m01 * T10;
m01 = M0 * T01;
M0 = m10;
m10 = m11 * T10;
m11 = M0 * T01;
type = TYPE_UNKNOWN;
return;
case (HI_SHEAR | APPLY_SHEAR | APPLY_TRANSLATE):
case (HI_SHEAR | APPLY_SHEAR):
m00 = m01 * Tx.m10;
m01 = 0.0;
m11 = m10 * Tx.m01;
m10 = 0.0;
state = mystate ^ (APPLY_SHEAR | APPLY_SCALE);
type = TYPE_UNKNOWN;
return;
case (HI_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
case (HI_SHEAR | APPLY_SCALE):
m01 = m00 * Tx.m01;
m00 = 0.0;
m10 = m11 * Tx.m10;
m11 = 0.0;
state = mystate ^ (APPLY_SHEAR | APPLY_SCALE);
type = TYPE_UNKNOWN;
return;
case (HI_SHEAR | APPLY_TRANSLATE):
m00 = 0.0;
m01 = Tx.m01;
m10 = Tx.m10;
m11 = 0.0;
state = APPLY_TRANSLATE | APPLY_SHEAR;
type = TYPE_UNKNOWN;
return;
}
T00 = Tx.m00; T01 = Tx.m01; T02 = Tx.m02;
T10 = Tx.m10; T11 = Tx.m11; T12 = Tx.m12;
switch (mystate) {
default:
stateError();
case (APPLY_SHEAR | APPLY_SCALE):
state = mystate | txstate;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
M0 = m00;
M1 = m01;
m00  = T00 * M0 + T10 * M1;
m01  = T01 * M0 + T11 * M1;
m02 += T02 * M0 + T12 * M1;
M0 = m10;
M1 = m11;
m10  = T00 * M0 + T10 * M1;
m11  = T01 * M0 + T11 * M1;
m12 += T02 * M0 + T12 * M1;
type = TYPE_UNKNOWN;
return;
case (APPLY_SHEAR | APPLY_TRANSLATE):
case (APPLY_SHEAR):
M0 = m01;
m00  = T10 * M0;
m01  = T11 * M0;
m02 += T12 * M0;
M0 = m10;
m10  = T00 * M0;
m11  = T01 * M0;
m12 += T02 * M0;
break;
case (APPLY_SCALE | APPLY_TRANSLATE):
case (APPLY_SCALE):
M0 = m00;
m00  = T00 * M0;
m01  = T01 * M0;
m02 += T02 * M0;
M0 = m11;
m10  = T10 * M0;
m11  = T11 * M0;
m12 += T12 * M0;
break;
case (APPLY_TRANSLATE):
m00  = T00;
m01  = T01;
m02 += T02;
m10  = T10;
m11  = T11;
m12 += T12;
state = txstate | APPLY_TRANSLATE;
type = TYPE_UNKNOWN;
return;
}
updateState();
}
@SuppressWarnings("fallthrough")
public void preConcatenate(AffineTransform Tx) {
double M0, M1;
double T00, T01, T10, T11;
double T02, T12;
int mystate = state;
int txstate = Tx.state;
switch ((txstate << HI_SHIFT) | mystate) {
case (HI_IDENTITY | APPLY_IDENTITY):
case (HI_IDENTITY | APPLY_TRANSLATE):
case (HI_IDENTITY | APPLY_SCALE):
case (HI_IDENTITY | APPLY_SCALE | APPLY_TRANSLATE):
case (HI_IDENTITY | APPLY_SHEAR):
case (HI_IDENTITY | APPLY_SHEAR | APPLY_TRANSLATE):
case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE):
case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
return;
case (HI_TRANSLATE | APPLY_IDENTITY):
case (HI_TRANSLATE | APPLY_SCALE):
case (HI_TRANSLATE | APPLY_SHEAR):
case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE):
m02 = Tx.m02;
m12 = Tx.m12;
state = mystate | APPLY_TRANSLATE;
type |= TYPE_TRANSLATION;
return;
case (HI_TRANSLATE | APPLY_TRANSLATE):
case (HI_TRANSLATE | APPLY_SCALE | APPLY_TRANSLATE):
case (HI_TRANSLATE | APPLY_SHEAR | APPLY_TRANSLATE):
case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
m02 = m02 + Tx.m02;
m12 = m12 + Tx.m12;
return;
case (HI_SCALE | APPLY_TRANSLATE):
case (HI_SCALE | APPLY_IDENTITY):
state = mystate | APPLY_SCALE;
case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE):
case (HI_SCALE | APPLY_SHEAR | APPLY_TRANSLATE):
case (HI_SCALE | APPLY_SHEAR):
case (HI_SCALE | APPLY_SCALE | APPLY_TRANSLATE):
case (HI_SCALE | APPLY_SCALE):
T00 = Tx.m00;
T11 = Tx.m11;
if ((mystate & APPLY_SHEAR) != 0) {
m01 = m01 * T00;
m10 = m10 * T11;
if ((mystate & APPLY_SCALE) != 0) {
m00 = m00 * T00;
m11 = m11 * T11;
}
} else {
m00 = m00 * T00;
m11 = m11 * T11;
}
if ((mystate & APPLY_TRANSLATE) != 0) {
m02 = m02 * T00;
m12 = m12 * T11;
}
type = TYPE_UNKNOWN;
return;
case (HI_SHEAR | APPLY_SHEAR | APPLY_TRANSLATE):
case (HI_SHEAR | APPLY_SHEAR):
mystate = mystate | APPLY_SCALE;
case (HI_SHEAR | APPLY_TRANSLATE):
case (HI_SHEAR | APPLY_IDENTITY):
case (HI_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
case (HI_SHEAR | APPLY_SCALE):
state = mystate ^ APPLY_SHEAR;
case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE):
T01 = Tx.m01;
T10 = Tx.m10;
M0 = m00;
m00 = m10 * T01;
m10 = M0 * T10;
M0 = m01;
m01 = m11 * T01;
m11 = M0 * T10;
M0 = m02;
m02 = m12 * T01;
m12 = M0 * T10;
type = TYPE_UNKNOWN;
return;
}
T00 = Tx.m00; T01 = Tx.m01; T02 = Tx.m02;
T10 = Tx.m10; T11 = Tx.m11; T12 = Tx.m12;
switch (mystate) {
default:
stateError();
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
M0 = m02;
M1 = m12;
T02 += M0 * T00 + M1 * T01;
T12 += M0 * T10 + M1 * T11;
case (APPLY_SHEAR | APPLY_SCALE):
m02 = T02;
m12 = T12;
M0 = m00;
M1 = m10;
m00 = M0 * T00 + M1 * T01;
m10 = M0 * T10 + M1 * T11;
M0 = m01;
M1 = m11;
m01 = M0 * T00 + M1 * T01;
m11 = M0 * T10 + M1 * T11;
break;
case (APPLY_SHEAR | APPLY_TRANSLATE):
M0 = m02;
M1 = m12;
T02 += M0 * T00 + M1 * T01;
T12 += M0 * T10 + M1 * T11;
case (APPLY_SHEAR):
m02 = T02;
m12 = T12;
M0 = m10;
m00 = M0 * T01;
m10 = M0 * T11;
M0 = m01;
m01 = M0 * T00;
m11 = M0 * T10;
break;
case (APPLY_SCALE | APPLY_TRANSLATE):
M0 = m02;
M1 = m12;
T02 += M0 * T00 + M1 * T01;
T12 += M0 * T10 + M1 * T11;
case (APPLY_SCALE):
m02 = T02;
m12 = T12;
M0 = m00;
m00 = M0 * T00;
m10 = M0 * T10;
M0 = m11;
m01 = M0 * T01;
m11 = M0 * T11;
break;
case (APPLY_TRANSLATE):
M0 = m02;
M1 = m12;
T02 += M0 * T00 + M1 * T01;
T12 += M0 * T10 + M1 * T11;
case (APPLY_IDENTITY):
m02 = T02;
m12 = T12;
m00 = T00;
m10 = T10;
m01 = T01;
m11 = T11;
state = mystate | txstate;
type = TYPE_UNKNOWN;
return;
}
updateState();
}
public AffineTransform createInverse()
throws NoninvertibleTransformException
{
double det;
switch (state) {
default:
stateError();
return null;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
det = m00 * m11 - m01 * m10;
if (Math.abs(det) <= Double.MIN_VALUE) {
throw new NoninvertibleTransformException("Determinant is "+
det);
}
return new AffineTransform( m11 / det, -m10 / det,
-m01 / det,  m00 / det,
(m01 * m12 - m11 * m02) / det,
(m10 * m02 - m00 * m12) / det,
(APPLY_SHEAR |
APPLY_SCALE |
APPLY_TRANSLATE));
case (APPLY_SHEAR | APPLY_SCALE):
det = m00 * m11 - m01 * m10;
if (Math.abs(det) <= Double.MIN_VALUE) {
throw new NoninvertibleTransformException("Determinant is "+
det);
}
return new AffineTransform( m11 / det, -m10 / det,
-m01 / det,  m00 / det,
0.0,        0.0,
(APPLY_SHEAR | APPLY_SCALE));
case (APPLY_SHEAR | APPLY_TRANSLATE):
if (m01 == 0.0 || m10 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
return new AffineTransform( 0.0,        1.0 / m01,
1.0 / m10,  0.0,
-m12 / m10, -m02 / m01,
(APPLY_SHEAR | APPLY_TRANSLATE));
case (APPLY_SHEAR):
if (m01 == 0.0 || m10 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
return new AffineTransform(0.0,       1.0 / m01,
1.0 / m10, 0.0,
0.0,       0.0,
(APPLY_SHEAR));
case (APPLY_SCALE | APPLY_TRANSLATE):
if (m00 == 0.0 || m11 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
return new AffineTransform( 1.0 / m00,  0.0,
0.0,        1.0 / m11,
-m02 / m00, -m12 / m11,
(APPLY_SCALE | APPLY_TRANSLATE));
case (APPLY_SCALE):
if (m00 == 0.0 || m11 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
return new AffineTransform(1.0 / m00, 0.0,
0.0,       1.0 / m11,
0.0,       0.0,
(APPLY_SCALE));
case (APPLY_TRANSLATE):
return new AffineTransform( 1.0,  0.0,
0.0,  1.0,
-m02, -m12,
(APPLY_TRANSLATE));
case (APPLY_IDENTITY):
return new AffineTransform();
}
}
public void invert()
throws NoninvertibleTransformException
{
double M00, M01, M02;
double M10, M11, M12;
double det;
switch (state) {
default:
stateError();
return;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
M00 = m00; M01 = m01; M02 = m02;
M10 = m10; M11 = m11; M12 = m12;
det = M00 * M11 - M01 * M10;
if (Math.abs(det) <= Double.MIN_VALUE) {
throw new NoninvertibleTransformException("Determinant is "+
det);
}
m00 =  M11 / det;
m10 = -M10 / det;
m01 = -M01 / det;
m11 =  M00 / det;
m02 = (M01 * M12 - M11 * M02) / det;
m12 = (M10 * M02 - M00 * M12) / det;
break;
case (APPLY_SHEAR | APPLY_SCALE):
M00 = m00; M01 = m01;
M10 = m10; M11 = m11;
det = M00 * M11 - M01 * M10;
if (Math.abs(det) <= Double.MIN_VALUE) {
throw new NoninvertibleTransformException("Determinant is "+
det);
}
m00 =  M11 / det;
m10 = -M10 / det;
m01 = -M01 / det;
m11 =  M00 / det;
break;
case (APPLY_SHEAR | APPLY_TRANSLATE):
M01 = m01; M02 = m02;
M10 = m10; M12 = m12;
if (M01 == 0.0 || M10 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
m10 = 1.0 / M01;
m01 = 1.0 / M10;
m02 = -M12 / M10;
m12 = -M02 / M01;
break;
case (APPLY_SHEAR):
M01 = m01;
M10 = m10;
if (M01 == 0.0 || M10 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
m10 = 1.0 / M01;
m01 = 1.0 / M10;
break;
case (APPLY_SCALE | APPLY_TRANSLATE):
M00 = m00; M02 = m02;
M11 = m11; M12 = m12;
if (M00 == 0.0 || M11 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
m00 = 1.0 / M00;
m11 = 1.0 / M11;
m02 = -M02 / M00;
m12 = -M12 / M11;
break;
case (APPLY_SCALE):
M00 = m00;
M11 = m11;
if (M00 == 0.0 || M11 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
m00 = 1.0 / M00;
m11 = 1.0 / M11;
break;
case (APPLY_TRANSLATE):
m02 = -m02;
m12 = -m12;
break;
case (APPLY_IDENTITY):
break;
}
}
public Point2D transform(Point2D ptSrc, Point2D ptDst) {
if (ptDst == null) {
if (ptSrc instanceof Point2D.Double) {
ptDst = new Point2D.Double();
} else {
ptDst = new Point2D.Float();
}
}
double x = ptSrc.getX();
double y = ptSrc.getY();
switch (state) {
default:
stateError();
return null;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
ptDst.setLocation(x * m00 + y * m01 + m02,
x * m10 + y * m11 + m12);
return ptDst;
case (APPLY_SHEAR | APPLY_SCALE):
ptDst.setLocation(x * m00 + y * m01, x * m10 + y * m11);
return ptDst;
case (APPLY_SHEAR | APPLY_TRANSLATE):
ptDst.setLocation(y * m01 + m02, x * m10 + m12);
return ptDst;
case (APPLY_SHEAR):
ptDst.setLocation(y * m01, x * m10);
return ptDst;
case (APPLY_SCALE | APPLY_TRANSLATE):
ptDst.setLocation(x * m00 + m02, y * m11 + m12);
return ptDst;
case (APPLY_SCALE):
ptDst.setLocation(x * m00, y * m11);
return ptDst;
case (APPLY_TRANSLATE):
ptDst.setLocation(x + m02, y + m12);
return ptDst;
case (APPLY_IDENTITY):
ptDst.setLocation(x, y);
return ptDst;
}
}
public void transform(Point2D[] ptSrc, int srcOff,
Point2D[] ptDst, int dstOff,
int numPts) {
int state = this.state;
while (--numPts >= 0) {
Point2D src = ptSrc[srcOff++];
double x = src.getX();
double y = src.getY();
Point2D dst = ptDst[dstOff++];
if (dst == null) {
if (src instanceof Point2D.Double) {
dst = new Point2D.Double();
} else {
dst = new Point2D.Float();
}
ptDst[dstOff - 1] = dst;
}
switch (state) {
default:
stateError();
return;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
dst.setLocation(x * m00 + y * m01 + m02,
x * m10 + y * m11 + m12);
break;
case (APPLY_SHEAR | APPLY_SCALE):
dst.setLocation(x * m00 + y * m01, x * m10 + y * m11);
break;
case (APPLY_SHEAR | APPLY_TRANSLATE):
dst.setLocation(y * m01 + m02, x * m10 + m12);
break;
case (APPLY_SHEAR):
dst.setLocation(y * m01, x * m10);
break;
case (APPLY_SCALE | APPLY_TRANSLATE):
dst.setLocation(x * m00 + m02, y * m11 + m12);
break;
case (APPLY_SCALE):
dst.setLocation(x * m00, y * m11);
break;
case (APPLY_TRANSLATE):
dst.setLocation(x + m02, y + m12);
break;
case (APPLY_IDENTITY):
dst.setLocation(x, y);
break;
}
}
}
public void transform(float[] srcPts, int srcOff,
float[] dstPts, int dstOff,
int numPts) {
double M00, M01, M02, M10, M11, M12;            if (dstPts == srcPts &&
dstOff > srcOff && dstOff < srcOff + numPts * 2)
{
System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
srcOff = dstOff;
}
switch (state) {
default:
stateError();
return;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
M00 = m00; M01 = m01; M02 = m02;
M10 = m10; M11 = m11; M12 = m12;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
double y = srcPts[srcOff++];
dstPts[dstOff++] = (float) (M00 * x + M01 * y + M02);
dstPts[dstOff++] = (float) (M10 * x + M11 * y + M12);
}
return;
case (APPLY_SHEAR | APPLY_SCALE):
M00 = m00; M01 = m01;
M10 = m10; M11 = m11;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
double y = srcPts[srcOff++];
dstPts[dstOff++] = (float) (M00 * x + M01 * y);
dstPts[dstOff++] = (float) (M10 * x + M11 * y);
}
return;
case (APPLY_SHEAR | APPLY_TRANSLATE):
M01 = m01; M02 = m02;
M10 = m10; M12 = m12;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
dstPts[dstOff++] = (float) (M01 * srcPts[srcOff++] + M02);
dstPts[dstOff++] = (float) (M10 * x + M12);
}
return;
case (APPLY_SHEAR):
M01 = m01; M10 = m10;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
dstPts[dstOff++] = (float) (M01 * srcPts[srcOff++]);
dstPts[dstOff++] = (float) (M10 * x);
}
return;
case (APPLY_SCALE | APPLY_TRANSLATE):
M00 = m00; M02 = m02;
M11 = m11; M12 = m12;
while (--numPts >= 0) {
dstPts[dstOff++] = (float) (M00 * srcPts[srcOff++] + M02);
dstPts[dstOff++] = (float) (M11 * srcPts[srcOff++] + M12);
}
return;
case (APPLY_SCALE):
M00 = m00; M11 = m11;
while (--numPts >= 0) {
dstPts[dstOff++] = (float) (M00 * srcPts[srcOff++]);
dstPts[dstOff++] = (float) (M11 * srcPts[srcOff++]);
}
return;
case (APPLY_TRANSLATE):
M02 = m02; M12 = m12;
while (--numPts >= 0) {
dstPts[dstOff++] = (float) (srcPts[srcOff++] + M02);
dstPts[dstOff++] = (float) (srcPts[srcOff++] + M12);
}
return;
case (APPLY_IDENTITY):
if (srcPts != dstPts || srcOff != dstOff) {
System.arraycopy(srcPts, srcOff, dstPts, dstOff,
numPts * 2);
}
return;
}
}
public void transform(double[] srcPts, int srcOff,
double[] dstPts, int dstOff,
int numPts) {
double M00, M01, M02, M10, M11, M12;            if (dstPts == srcPts &&
dstOff > srcOff && dstOff < srcOff + numPts * 2)
{
System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
srcOff = dstOff;
}
switch (state) {
default:
stateError();
return;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
M00 = m00; M01 = m01; M02 = m02;
M10 = m10; M11 = m11; M12 = m12;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
double y = srcPts[srcOff++];
dstPts[dstOff++] = M00 * x + M01 * y + M02;
dstPts[dstOff++] = M10 * x + M11 * y + M12;
}
return;
case (APPLY_SHEAR | APPLY_SCALE):
M00 = m00; M01 = m01;
M10 = m10; M11 = m11;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
double y = srcPts[srcOff++];
dstPts[dstOff++] = M00 * x + M01 * y;
dstPts[dstOff++] = M10 * x + M11 * y;
}
return;
case (APPLY_SHEAR | APPLY_TRANSLATE):
M01 = m01; M02 = m02;
M10 = m10; M12 = m12;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;
dstPts[dstOff++] = M10 * x + M12;
}
return;
case (APPLY_SHEAR):
M01 = m01; M10 = m10;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
dstPts[dstOff++] = M01 * srcPts[srcOff++];
dstPts[dstOff++] = M10 * x;
}
return;
case (APPLY_SCALE | APPLY_TRANSLATE):
M00 = m00; M02 = m02;
M11 = m11; M12 = m12;
while (--numPts >= 0) {
dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;
dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;
}
return;
case (APPLY_SCALE):
M00 = m00; M11 = m11;
while (--numPts >= 0) {
dstPts[dstOff++] = M00 * srcPts[srcOff++];
dstPts[dstOff++] = M11 * srcPts[srcOff++];
}
return;
case (APPLY_TRANSLATE):
M02 = m02; M12 = m12;
while (--numPts >= 0) {
dstPts[dstOff++] = srcPts[srcOff++] + M02;
dstPts[dstOff++] = srcPts[srcOff++] + M12;
}
return;
case (APPLY_IDENTITY):
if (srcPts != dstPts || srcOff != dstOff) {
System.arraycopy(srcPts, srcOff, dstPts, dstOff,
numPts * 2);
}
return;
}
}
public void transform(float[] srcPts, int srcOff,
double[] dstPts, int dstOff,
int numPts) {
double M00, M01, M02, M10, M11, M12;            switch (state) {
default:
stateError();
return;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
M00 = m00; M01 = m01; M02 = m02;
M10 = m10; M11 = m11; M12 = m12;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
double y = srcPts[srcOff++];
dstPts[dstOff++] = M00 * x + M01 * y + M02;
dstPts[dstOff++] = M10 * x + M11 * y + M12;
}
return;
case (APPLY_SHEAR | APPLY_SCALE):
M00 = m00; M01 = m01;
M10 = m10; M11 = m11;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
double y = srcPts[srcOff++];
dstPts[dstOff++] = M00 * x + M01 * y;
dstPts[dstOff++] = M10 * x + M11 * y;
}
return;
case (APPLY_SHEAR | APPLY_TRANSLATE):
M01 = m01; M02 = m02;
M10 = m10; M12 = m12;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;
dstPts[dstOff++] = M10 * x + M12;
}
return;
case (APPLY_SHEAR):
M01 = m01; M10 = m10;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
dstPts[dstOff++] = M01 * srcPts[srcOff++];
dstPts[dstOff++] = M10 * x;
}
return;
case (APPLY_SCALE | APPLY_TRANSLATE):
M00 = m00; M02 = m02;
M11 = m11; M12 = m12;
while (--numPts >= 0) {
dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;
dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;
}
return;
case (APPLY_SCALE):
M00 = m00; M11 = m11;
while (--numPts >= 0) {
dstPts[dstOff++] = M00 * srcPts[srcOff++];
dstPts[dstOff++] = M11 * srcPts[srcOff++];
}
return;
case (APPLY_TRANSLATE):
M02 = m02; M12 = m12;
while (--numPts >= 0) {
dstPts[dstOff++] = srcPts[srcOff++] + M02;
dstPts[dstOff++] = srcPts[srcOff++] + M12;
}
return;
case (APPLY_IDENTITY):
while (--numPts >= 0) {
dstPts[dstOff++] = srcPts[srcOff++];
dstPts[dstOff++] = srcPts[srcOff++];
}
return;
}
}
public void transform(double[] srcPts, int srcOff,
float[] dstPts, int dstOff,
int numPts) {
double M00, M01, M02, M10, M11, M12;            switch (state) {
default:
stateError();
return;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
M00 = m00; M01 = m01; M02 = m02;
M10 = m10; M11 = m11; M12 = m12;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
double y = srcPts[srcOff++];
dstPts[dstOff++] = (float) (M00 * x + M01 * y + M02);
dstPts[dstOff++] = (float) (M10 * x + M11 * y + M12);
}
return;
case (APPLY_SHEAR | APPLY_SCALE):
M00 = m00; M01 = m01;
M10 = m10; M11 = m11;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
double y = srcPts[srcOff++];
dstPts[dstOff++] = (float) (M00 * x + M01 * y);
dstPts[dstOff++] = (float) (M10 * x + M11 * y);
}
return;
case (APPLY_SHEAR | APPLY_TRANSLATE):
M01 = m01; M02 = m02;
M10 = m10; M12 = m12;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
dstPts[dstOff++] = (float) (M01 * srcPts[srcOff++] + M02);
dstPts[dstOff++] = (float) (M10 * x + M12);
}
return;
case (APPLY_SHEAR):
M01 = m01; M10 = m10;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
dstPts[dstOff++] = (float) (M01 * srcPts[srcOff++]);
dstPts[dstOff++] = (float) (M10 * x);
}
return;
case (APPLY_SCALE | APPLY_TRANSLATE):
M00 = m00; M02 = m02;
M11 = m11; M12 = m12;
while (--numPts >= 0) {
dstPts[dstOff++] = (float) (M00 * srcPts[srcOff++] + M02);
dstPts[dstOff++] = (float) (M11 * srcPts[srcOff++] + M12);
}
return;
case (APPLY_SCALE):
M00 = m00; M11 = m11;
while (--numPts >= 0) {
dstPts[dstOff++] = (float) (M00 * srcPts[srcOff++]);
dstPts[dstOff++] = (float) (M11 * srcPts[srcOff++]);
}
return;
case (APPLY_TRANSLATE):
M02 = m02; M12 = m12;
while (--numPts >= 0) {
dstPts[dstOff++] = (float) (srcPts[srcOff++] + M02);
dstPts[dstOff++] = (float) (srcPts[srcOff++] + M12);
}
return;
case (APPLY_IDENTITY):
while (--numPts >= 0) {
dstPts[dstOff++] = (float) (srcPts[srcOff++]);
dstPts[dstOff++] = (float) (srcPts[srcOff++]);
}
return;
}
}
@SuppressWarnings("fallthrough")
public Point2D inverseTransform(Point2D ptSrc, Point2D ptDst)
throws NoninvertibleTransformException
{
if (ptDst == null) {
if (ptSrc instanceof Point2D.Double) {
ptDst = new Point2D.Double();
} else {
ptDst = new Point2D.Float();
}
}
double x = ptSrc.getX();
double y = ptSrc.getY();
switch (state) {
default:
stateError();
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
x -= m02;
y -= m12;
case (APPLY_SHEAR | APPLY_SCALE):
double det = m00 * m11 - m01 * m10;
if (Math.abs(det) <= Double.MIN_VALUE) {
throw new NoninvertibleTransformException("Determinant is "+
det);
}
ptDst.setLocation((x * m11 - y * m01) / det,
(y * m00 - x * m10) / det);
return ptDst;
case (APPLY_SHEAR | APPLY_TRANSLATE):
x -= m02;
y -= m12;
case (APPLY_SHEAR):
if (m01 == 0.0 || m10 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
ptDst.setLocation(y / m10, x / m01);
return ptDst;
case (APPLY_SCALE | APPLY_TRANSLATE):
x -= m02;
y -= m12;
case (APPLY_SCALE):
if (m00 == 0.0 || m11 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
ptDst.setLocation(x / m00, y / m11);
return ptDst;
case (APPLY_TRANSLATE):
ptDst.setLocation(x - m02, y - m12);
return ptDst;
case (APPLY_IDENTITY):
ptDst.setLocation(x, y);
return ptDst;
}
}
public void inverseTransform(double[] srcPts, int srcOff,
double[] dstPts, int dstOff,
int numPts)
throws NoninvertibleTransformException
{
double M00, M01, M02, M10, M11, M12;            double det;
if (dstPts == srcPts &&
dstOff > srcOff && dstOff < srcOff + numPts * 2)
{
System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
srcOff = dstOff;
}
switch (state) {
default:
stateError();
return;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
M00 = m00; M01 = m01; M02 = m02;
M10 = m10; M11 = m11; M12 = m12;
det = M00 * M11 - M01 * M10;
if (Math.abs(det) <= Double.MIN_VALUE) {
throw new NoninvertibleTransformException("Determinant is "+
det);
}
while (--numPts >= 0) {
double x = srcPts[srcOff++] - M02;
double y = srcPts[srcOff++] - M12;
dstPts[dstOff++] = (x * M11 - y * M01) / det;
dstPts[dstOff++] = (y * M00 - x * M10) / det;
}
return;
case (APPLY_SHEAR | APPLY_SCALE):
M00 = m00; M01 = m01;
M10 = m10; M11 = m11;
det = M00 * M11 - M01 * M10;
if (Math.abs(det) <= Double.MIN_VALUE) {
throw new NoninvertibleTransformException("Determinant is "+
det);
}
while (--numPts >= 0) {
double x = srcPts[srcOff++];
double y = srcPts[srcOff++];
dstPts[dstOff++] = (x * M11 - y * M01) / det;
dstPts[dstOff++] = (y * M00 - x * M10) / det;
}
return;
case (APPLY_SHEAR | APPLY_TRANSLATE):
M01 = m01; M02 = m02;
M10 = m10; M12 = m12;
if (M01 == 0.0 || M10 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
while (--numPts >= 0) {
double x = srcPts[srcOff++] - M02;
dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M10;
dstPts[dstOff++] = x / M01;
}
return;
case (APPLY_SHEAR):
M01 = m01; M10 = m10;
if (M01 == 0.0 || M10 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
while (--numPts >= 0) {
double x = srcPts[srcOff++];
dstPts[dstOff++] = srcPts[srcOff++] / M10;
dstPts[dstOff++] = x / M01;
}
return;
case (APPLY_SCALE | APPLY_TRANSLATE):
M00 = m00; M02 = m02;
M11 = m11; M12 = m12;
if (M00 == 0.0 || M11 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
while (--numPts >= 0) {
dstPts[dstOff++] = (srcPts[srcOff++] - M02) / M00;
dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M11;
}
return;
case (APPLY_SCALE):
M00 = m00; M11 = m11;
if (M00 == 0.0 || M11 == 0.0) {
throw new NoninvertibleTransformException("Determinant is 0");
}
while (--numPts >= 0) {
dstPts[dstOff++] = srcPts[srcOff++] / M00;
dstPts[dstOff++] = srcPts[srcOff++] / M11;
}
return;
case (APPLY_TRANSLATE):
M02 = m02; M12 = m12;
while (--numPts >= 0) {
dstPts[dstOff++] = srcPts[srcOff++] - M02;
dstPts[dstOff++] = srcPts[srcOff++] - M12;
}
return;
case (APPLY_IDENTITY):
if (srcPts != dstPts || srcOff != dstOff) {
System.arraycopy(srcPts, srcOff, dstPts, dstOff,
numPts * 2);
}
return;
}
}
public Point2D deltaTransform(Point2D ptSrc, Point2D ptDst) {
if (ptDst == null) {
if (ptSrc instanceof Point2D.Double) {
ptDst = new Point2D.Double();
} else {
ptDst = new Point2D.Float();
}
}
double x = ptSrc.getX();
double y = ptSrc.getY();
switch (state) {
default:
stateError();
return null;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
case (APPLY_SHEAR | APPLY_SCALE):
ptDst.setLocation(x * m00 + y * m01, x * m10 + y * m11);
return ptDst;
case (APPLY_SHEAR | APPLY_TRANSLATE):
case (APPLY_SHEAR):
ptDst.setLocation(y * m01, x * m10);
return ptDst;
case (APPLY_SCALE | APPLY_TRANSLATE):
case (APPLY_SCALE):
ptDst.setLocation(x * m00, y * m11);
return ptDst;
case (APPLY_TRANSLATE):
case (APPLY_IDENTITY):
ptDst.setLocation(x, y);
return ptDst;
}
}
public void deltaTransform(double[] srcPts, int srcOff,
double[] dstPts, int dstOff,
int numPts) {
double M00, M01, M10, M11;              if (dstPts == srcPts &&
dstOff > srcOff && dstOff < srcOff + numPts * 2)
{
System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
srcOff = dstOff;
}
switch (state) {
default:
stateError();
return;
case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
case (APPLY_SHEAR | APPLY_SCALE):
M00 = m00; M01 = m01;
M10 = m10; M11 = m11;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
double y = srcPts[srcOff++];
dstPts[dstOff++] = x * M00 + y * M01;
dstPts[dstOff++] = x * M10 + y * M11;
}
return;
case (APPLY_SHEAR | APPLY_TRANSLATE):
case (APPLY_SHEAR):
M01 = m01; M10 = m10;
while (--numPts >= 0) {
double x = srcPts[srcOff++];
dstPts[dstOff++] = srcPts[srcOff++] * M01;
dstPts[dstOff++] = x * M10;
}
return;
case (APPLY_SCALE | APPLY_TRANSLATE):
case (APPLY_SCALE):
M00 = m00; M11 = m11;
while (--numPts >= 0) {
dstPts[dstOff++] = srcPts[srcOff++] * M00;
dstPts[dstOff++] = srcPts[srcOff++] * M11;
}
return;
case (APPLY_TRANSLATE):
case (APPLY_IDENTITY):
if (srcPts != dstPts || srcOff != dstOff) {
System.arraycopy(srcPts, srcOff, dstPts, dstOff,
numPts * 2);
}
return;
}
}
public Shape createTransformedShape(Shape pSrc) {
if (pSrc == null) {
return null;
}
return new Path2D.Double(pSrc, this);
}
private static double _matround(double matval) {
return Math.rint(matval * 1E15) / 1E15;
}
public String toString() {
return ("AffineTransform[["
+ _matround(m00) + ", "
+ _matround(m01) + ", "
+ _matround(m02) + "], ["
+ _matround(m10) + ", "
+ _matround(m11) + ", "
+ _matround(m12) + "]]");
}
public boolean isIdentity() {
return (state == APPLY_IDENTITY || (getType() == TYPE_IDENTITY));
}
public Object clone() {
try {
return super.clone();
} catch (CloneNotSupportedException e) {
throw new InternalError(e);
}
}
public int hashCode() {
long bits = Double.doubleToLongBits(m00);
bits = bits * 31 + Double.doubleToLongBits(m01);
bits = bits * 31 + Double.doubleToLongBits(m02);
bits = bits * 31 + Double.doubleToLongBits(m10);
bits = bits * 31 + Double.doubleToLongBits(m11);
bits = bits * 31 + Double.doubleToLongBits(m12);
return (((int) bits) ^ ((int) (bits >> 32)));
}
public boolean equals(Object obj) {
if (!(obj instanceof AffineTransform)) {
return false;
}
AffineTransform a = (AffineTransform)obj;
return ((m00 == a.m00) && (m01 == a.m01) && (m02 == a.m02) &&
(m10 == a.m10) && (m11 == a.m11) && (m12 == a.m12));
}
@Serial
private static final long serialVersionUID = 1330973210523860834L;
@Serial
private void writeObject(java.io.ObjectOutputStream s)
throws java.io.IOException
{
s.defaultWriteObject();
}
@Serial
private void readObject(java.io.ObjectInputStream s)
throws java.lang.ClassNotFoundException, java.io.IOException
{
s.defaultReadObject();
updateState();
}
}
package java.awt.image;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Point2D;
import java.awt.AlphaComposite;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Transparency;
import java.lang.annotation.Native;
import sun.awt.image.ImagingLib;
public class AffineTransformOp implements BufferedImageOp, RasterOp {
private AffineTransform xform;
RenderingHints hints;
@Native public static final int TYPE_NEAREST_NEIGHBOR = 1;
@Native public static final int TYPE_BILINEAR = 2;
@Native public static final int TYPE_BICUBIC = 3;
int interpolationType = TYPE_NEAREST_NEIGHBOR;
public AffineTransformOp(AffineTransform xform, RenderingHints hints){
validateTransform(xform);
this.xform = (AffineTransform) xform.clone();
this.hints = hints;
if (hints != null) {
Object value = hints.get(RenderingHints.KEY_INTERPOLATION);
if (value == null) {
value = hints.get(RenderingHints.KEY_RENDERING);
if (value == RenderingHints.VALUE_RENDER_SPEED) {
interpolationType = TYPE_NEAREST_NEIGHBOR;
}
else if (value == RenderingHints.VALUE_RENDER_QUALITY) {
interpolationType = TYPE_BILINEAR;
}
}
else if (value == RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR) {
interpolationType = TYPE_NEAREST_NEIGHBOR;
}
else if (value == RenderingHints.VALUE_INTERPOLATION_BILINEAR) {
interpolationType = TYPE_BILINEAR;
}
else if (value == RenderingHints.VALUE_INTERPOLATION_BICUBIC) {
interpolationType = TYPE_BICUBIC;
}
}
else {
interpolationType = TYPE_NEAREST_NEIGHBOR;
}
}
public AffineTransformOp(AffineTransform xform, int interpolationType) {
validateTransform(xform);
this.xform = (AffineTransform)xform.clone();
switch(interpolationType) {
case TYPE_NEAREST_NEIGHBOR:
case TYPE_BILINEAR:
case TYPE_BICUBIC:
break;
default:
throw new IllegalArgumentException("Unknown interpolation type: "+
interpolationType);
}
this.interpolationType = interpolationType;
}
public final int getInterpolationType() {
return interpolationType;
}
public final BufferedImage filter(BufferedImage src, BufferedImage dst) {
if (src == null) {
throw new NullPointerException("src image is null");
}
if (src == dst) {
throw new IllegalArgumentException("src image cannot be the "+
"same as the dst image");
}
boolean needToConvert = false;
ColorModel srcCM = src.getColorModel();
ColorModel dstCM;
BufferedImage origDst = dst;
if (dst == null) {
dst = createCompatibleDestImage(src, null);
dstCM = srcCM;
origDst = dst;
}
else {
dstCM = dst.getColorModel();
if (srcCM.getColorSpace().getType() !=
dstCM.getColorSpace().getType())
{
int type = xform.getType();
boolean needTrans = ((type&
(AffineTransform.TYPE_MASK_ROTATION|
AffineTransform.TYPE_GENERAL_TRANSFORM))
!= 0);
if (! needTrans &&
type != AffineTransform.TYPE_TRANSLATION &&
type != AffineTransform.TYPE_IDENTITY)
{
double[] mtx = new double[4];
xform.getMatrix(mtx);
needTrans = (mtx[0] != (int)mtx[0] || mtx[3] != (int)mtx[3]);
}
if (needTrans &&
srcCM.getTransparency() == Transparency.OPAQUE)
{
ColorConvertOp ccop = new ColorConvertOp(hints);
BufferedImage tmpSrc = null;
int sw = src.getWidth();
int sh = src.getHeight();
if (dstCM.getTransparency() == Transparency.OPAQUE) {
tmpSrc = new BufferedImage(sw, sh,
BufferedImage.TYPE_INT_ARGB);
}
else {
WritableRaster r =
dstCM.createCompatibleWritableRaster(sw, sh);
tmpSrc = new BufferedImage(dstCM, r,
dstCM.isAlphaPremultiplied(),
null);
}
src = ccop.filter(src, tmpSrc);
}
else {
needToConvert = true;
dst = createCompatibleDestImage(src, null);
}
}
}
if (interpolationType != TYPE_NEAREST_NEIGHBOR &&
dst.getColorModel() instanceof IndexColorModel) {
dst = new BufferedImage(dst.getWidth(), dst.getHeight(),
BufferedImage.TYPE_INT_ARGB);
}
if (ImagingLib.filter(this, src, dst) == null) {
throw new ImagingOpException ("Unable to transform src image");
}
if (needToConvert) {
ColorConvertOp ccop = new ColorConvertOp(hints);
ccop.filter(dst, origDst);
}
else if (origDst != dst) {
java.awt.Graphics2D g = origDst.createGraphics();
try {
g.setComposite(AlphaComposite.Src);
g.drawImage(dst, 0, 0, null);
} finally {
g.dispose();
}
}
return origDst;
}
public final WritableRaster filter(Raster src, WritableRaster dst) {
if (src == null) {
throw new NullPointerException("src image is null");
}
if (dst == null) {
dst = createCompatibleDestRaster(src);
}
if (src == dst) {
throw new IllegalArgumentException("src image cannot be the "+
"same as the dst image");
}
if (src.getNumBands() != dst.getNumBands()) {
throw new IllegalArgumentException("Number of src bands ("+
src.getNumBands()+
") does not match number of "+
" dst bands ("+
dst.getNumBands()+")");
}
if (ImagingLib.filter(this, src, dst) == null) {
throw new ImagingOpException ("Unable to transform src image");
}
return dst;
}
public final Rectangle2D getBounds2D (BufferedImage src) {
return getBounds2D(src.getRaster());
}
public final Rectangle2D getBounds2D (Raster src) {
int w = src.getWidth();
int h = src.getHeight();
float[] pts = {0, 0, w, 0, w, h, 0, h};
xform.transform(pts, 0, pts, 0, 4);
float fmaxX = pts[0];
float fmaxY = pts[1];
float fminX = pts[0];
float fminY = pts[1];
for (int i=2; i < 8; i+=2) {
if (pts[i] > fmaxX) {
fmaxX = pts[i];
}
else if (pts[i] < fminX) {
fminX = pts[i];
}
if (pts[i+1] > fmaxY) {
fmaxY = pts[i+1];
}
else if (pts[i+1] < fminY) {
fminY = pts[i+1];
}
}
return new Rectangle2D.Float(fminX, fminY, fmaxX-fminX, fmaxY-fminY);
}
public BufferedImage createCompatibleDestImage (BufferedImage src,
ColorModel destCM) {
BufferedImage image;
Rectangle r = getBounds2D(src).getBounds();
int w = r.x + r.width;
int h = r.y + r.height;
if (w <= 0) {
throw new RasterFormatException("Transformed width ("+w+
") is less than or equal to 0.");
}
if (h <= 0) {
throw new RasterFormatException("Transformed height ("+h+
") is less than or equal to 0.");
}
if (destCM == null) {
ColorModel cm = src.getColorModel();
if (interpolationType != TYPE_NEAREST_NEIGHBOR &&
(cm instanceof IndexColorModel ||
cm.getTransparency() == Transparency.OPAQUE))
{
image = new BufferedImage(w, h,
BufferedImage.TYPE_INT_ARGB);
}
else {
image = new BufferedImage(cm,
src.getRaster().createCompatibleWritableRaster(w,h),
cm.isAlphaPremultiplied(), null);
}
}
else {
image = new BufferedImage(destCM,
destCM.createCompatibleWritableRaster(w,h),
destCM.isAlphaPremultiplied(), null);
}
return image;
}
public WritableRaster createCompatibleDestRaster (Raster src) {
Rectangle2D r = getBounds2D(src);
return src.createCompatibleWritableRaster((int)r.getX(),
(int)r.getY(),
(int)r.getWidth(),
(int)r.getHeight());
}
public final Point2D getPoint2D (Point2D srcPt, Point2D dstPt) {
return xform.transform (srcPt, dstPt);
}
public final AffineTransform getTransform() {
return (AffineTransform) xform.clone();
}
public final RenderingHints getRenderingHints() {
if (hints == null) {
Object val;
switch(interpolationType) {
case TYPE_NEAREST_NEIGHBOR:
val = RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR;
break;
case TYPE_BILINEAR:
val = RenderingHints.VALUE_INTERPOLATION_BILINEAR;
break;
case TYPE_BICUBIC:
val = RenderingHints.VALUE_INTERPOLATION_BICUBIC;
break;
default:
throw new InternalError("Unknown interpolation type "+
interpolationType);
}
hints = new RenderingHints(RenderingHints.KEY_INTERPOLATION, val);
}
return hints;
}
void validateTransform(AffineTransform xform) {
if (Math.abs(xform.getDeterminant()) <= Double.MIN_VALUE) {
throw new ImagingOpException("Unable to invert transform "+xform);
}
}
}
package jdk.internal.agent;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.lang.management.ManagementFactory;
import java.lang.reflect.Method;
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.net.UnknownHostException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.text.MessageFormat;
import java.util.HashMap;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.ServiceLoader;
import java.util.function.Function;
import java.util.function.Predicate;
import javax.management.remote.JMXConnectorServer;
import javax.management.remote.JMXServiceURL;
import static jdk.internal.agent.AgentConfigurationError.*;
import jdk.internal.vm.VMSupport;
import sun.management.jdp.JdpController;
import sun.management.jdp.JdpException;
import sun.management.jmxremote.ConnectorBootstrap;
public class Agent {
private abstract static class StatusCollector {
protected static final Map<String, String> DEFAULT_PROPS = new HashMap<>();
static {
DEFAULT_PROPS.put(ConnectorBootstrap.PropertyNames.PORT,
ConnectorBootstrap.DefaultValues.PORT);
DEFAULT_PROPS.put(ConnectorBootstrap.PropertyNames.USE_LOCAL_ONLY,
ConnectorBootstrap.DefaultValues.USE_LOCAL_ONLY);
DEFAULT_PROPS.put(ConnectorBootstrap.PropertyNames.USE_AUTHENTICATION,
ConnectorBootstrap.DefaultValues.USE_AUTHENTICATION);
DEFAULT_PROPS.put(ConnectorBootstrap.PropertyNames.USE_SSL,
ConnectorBootstrap.DefaultValues.USE_SSL);
DEFAULT_PROPS.put(ConnectorBootstrap.PropertyNames.USE_REGISTRY_SSL,
ConnectorBootstrap.DefaultValues.USE_REGISTRY_SSL);
DEFAULT_PROPS.put(ConnectorBootstrap.PropertyNames.SSL_NEED_CLIENT_AUTH,
ConnectorBootstrap.DefaultValues.SSL_NEED_CLIENT_AUTH);
DEFAULT_PROPS.put(ConnectorBootstrap.PropertyNames.CONFIG_FILE_NAME,
ConnectorBootstrap.DefaultValues.CONFIG_FILE_NAME);
DEFAULT_PROPS.put(ConnectorBootstrap.PropertyNames.PASSWORD_FILE_NAME,
ConnectorBootstrap.DefaultValues.PASSWORD_FILE_NAME);
DEFAULT_PROPS.put(ConnectorBootstrap.PropertyNames.ACCESS_FILE_NAME,
ConnectorBootstrap.DefaultValues.ACCESS_FILE_NAME);
}
protected final StringBuilder sb = new StringBuilder();
public final String collect() {
Properties agentProps = VMSupport.getAgentProperties();
String localConnAddr = (String)agentProps.get(LOCAL_CONNECTOR_ADDRESS_PROP);
if (localConnAddr != null || jmxServer != null) {
addAgentStatus(true);
appendConnections(localConnAddr);
} else {
addAgentStatus(false);
}
return sb.toString();
}
private void appendConnections(String localConnAddr) {
appendConnectionsHeader();
if (localConnAddr != null) {
try {
JMXServiceURL u = new JMXServiceURL(localConnAddr);
addConnection(false, u);
} catch (MalformedURLException e) {
}
}
if (jmxServer != null) {
addConnection(true, jmxServer.getAddress());
}
appendConnectionsFooter();
}
private void addConnection(boolean remote, JMXServiceURL u) {
appendConnectionHeader(remote);
addConnectionDetails(u);
addConfigProperties();
appendConnectionFooter(remote);
}
private void addConfigProperties() {
appendConfigPropsHeader();
Properties remoteProps = configProps != null ?
configProps : getManagementProperties();
Map<Object, Object> props = new HashMap<>(DEFAULT_PROPS);
if (remoteProps == null) {
String loc_only = System.getProperty(
ConnectorBootstrap.PropertyNames.USE_LOCAL_ONLY
);
if (loc_only != null &&
!ConnectorBootstrap.DefaultValues.USE_LOCAL_ONLY.equals(loc_only)) {
props.put(
ConnectorBootstrap.PropertyNames.USE_LOCAL_ONLY,
loc_only
);
}
} else {
props.putAll(remoteProps);
}
props.entrySet().stream()
.filter(preprocess(Map.Entry::getKey, StatusCollector::isManagementProp))
.forEach(this::addConfigProp);
appendConfigPropsFooter();
}
private static boolean isManagementProp(Object pName) {
return pName != null && pName.toString().startsWith("com.sun.management.");
}
private static <T, V> Predicate<T> preprocess(Function<T, V> f, Predicate<V> p) {
return (T t) -> p.test(f.apply(t));
}
protected abstract void addAgentStatus(boolean enabled);
protected abstract void appendConnectionsHeader();
protected abstract void appendConnectionsFooter();
protected abstract void addConnectionDetails(JMXServiceURL u);
protected abstract void appendConnectionHeader(boolean remote);
protected abstract void appendConnectionFooter(boolean remote);
protected abstract void appendConfigPropsHeader();
protected abstract void appendConfigPropsFooter();
protected abstract void addConfigProp(Map.Entry<?, ?> prop);
}
private static final class TextStatusCollector extends StatusCollector {
@Override
protected void addAgentStatus(boolean enabled) {
sb.append("Agent: ").append(enabled ? "enabled" : "disabled").append('\n');
}
@Override
protected void appendConnectionsHeader() {
sb.append('\n');
}
@Override
protected void addConnectionDetails(JMXServiceURL u) {
sb.append("Protocol       : ").append(u.getProtocol()).append('\n')
.append("Host           : ").append(u.getHost()).append('\n')
.append("URL            : ").append(u).append('\n');
}
@Override
protected void appendConnectionHeader(boolean remote) {
sb.append("Connection Type: ").append(remote ? "remote" : "local").append('\n');
}
@Override
protected void appendConfigPropsHeader() {
sb.append("Properties     :\n");
}
@Override
protected void addConfigProp(Map.Entry<?, ?> prop) {
sb.append("  ").append(prop.getKey()).append(" = ")
.append(prop.getValue());
Object defVal = DEFAULT_PROPS.get(prop.getKey());
if (defVal != null && defVal.equals(prop.getValue())) {
sb.append(" [default]");
}
sb.append("\n");
}
@Override
protected void appendConnectionsFooter() {}
@Override
protected void appendConnectionFooter(boolean remote) {
sb.append('\n');
}
@Override
protected void appendConfigPropsFooter() {}
}
private static Properties mgmtProps;
private static ResourceBundle messageRB;
private static final String CONFIG_FILE =
"com.sun.management.config.file";
private static final String JMXREMOTE =
"com.sun.management.jmxremote";
private static final String JMXREMOTE_PORT =
"com.sun.management.jmxremote.port";
private static final String RMI_PORT =
"com.sun.management.jmxremote.rmi.port";
private static final String ENABLE_THREAD_CONTENTION_MONITORING =
"com.sun.management.enableThreadContentionMonitoring";
private static final String LOCAL_CONNECTOR_ADDRESS_PROP =
"com.sun.management.jmxremote.localConnectorAddress";
private static final String JDP_DEFAULT_ADDRESS = "224.0.23.178";
private static final int JDP_DEFAULT_PORT = 7095;
private static JMXConnectorServer jmxServer = null;
private static Properties configProps = null;
private static Properties parseString(String args) {
Properties argProps = new Properties();
if (args != null && !args.trim().isEmpty()) {
for (String option : args.split(",")) {
String s[] = option.split("=", 2);
String name = s[0].trim();
String value = (s.length > 1) ? s[1].trim() : "";
if (!name.startsWith("com.sun.management.")) {
error(INVALID_OPTION, name);
}
argProps.setProperty(name, value);
}
}
return argProps;
}
public static void premain(String args) throws Exception {
agentmain(args);
}
public static void agentmain(String args) throws Exception {
if (args == null || args.length() == 0) {
args = JMXREMOTE;                   }
Properties arg_props = parseString(args);
Properties config_props = new Properties();
String fname = arg_props.getProperty(CONFIG_FILE);
readConfiguration(fname, config_props);
config_props.putAll(arg_props);
startAgent(config_props);
}
private static synchronized void startLocalManagementAgent() {
Properties agentProps = VMSupport.getAgentProperties();
if (agentProps.get(LOCAL_CONNECTOR_ADDRESS_PROP) == null) {
JMXConnectorServer cs = ConnectorBootstrap.startLocalConnectorServer();
String address = cs.getAddress().toString();
agentProps.put(LOCAL_CONNECTOR_ADDRESS_PROP, address);
try {
ConnectorAddressLink.export(address);
} catch (Exception x) {
warning(EXPORT_ADDRESS_FAILED, x.getMessage());
}
}
}
private static synchronized void startRemoteManagementAgent(String args) throws Exception {
if (jmxServer != null) {
throw new RuntimeException(getText(INVALID_STATE, "Agent already started"));
}
try {
Properties argProps = parseString(args);
configProps = new Properties();
String fname = System.getProperty(CONFIG_FILE);
readConfiguration(fname, configProps);
Properties sysProps = System.getProperties();
synchronized (sysProps) {
configProps.putAll(sysProps);
}
String fnameUser = argProps.getProperty(CONFIG_FILE);
if (fnameUser != null) {
readConfiguration(fnameUser, configProps);
}
configProps.putAll(argProps);
final String enableThreadContentionMonitoring =
configProps.getProperty(ENABLE_THREAD_CONTENTION_MONITORING);
if (enableThreadContentionMonitoring != null) {
ManagementFactory.getThreadMXBean().
setThreadContentionMonitoringEnabled(true);
}
String jmxremotePort = configProps.getProperty(JMXREMOTE_PORT);
if (jmxremotePort != null) {
jmxServer = ConnectorBootstrap.
startRemoteConnectorServer(jmxremotePort, configProps);
startDiscoveryService(configProps);
} else {
throw new AgentConfigurationError(INVALID_JMXREMOTE_PORT, "No port specified");
}
} catch (JdpException e) {
error(e);
} catch (AgentConfigurationError err) {
error(err);
}
}
private static synchronized void stopRemoteManagementAgent() throws Exception {
JdpController.stopDiscoveryService();
if (jmxServer != null) {
ConnectorBootstrap.unexportRegistry();
ConnectorAddressLink.unexportRemote();
jmxServer.stop();
jmxServer = null;
configProps = null;
}
}
private static synchronized String getManagementAgentStatus() throws Exception {
return new TextStatusCollector().collect();
}
private static void startAgent(Properties props) throws Exception {
String jmxremote = props.getProperty(JMXREMOTE);
String jmxremotePort = props.getProperty(JMXREMOTE_PORT);
final String enableThreadContentionMonitoring =
props.getProperty(ENABLE_THREAD_CONTENTION_MONITORING);
if (enableThreadContentionMonitoring != null) {
ManagementFactory.getThreadMXBean().
setThreadContentionMonitoringEnabled(true);
}
try {
if (jmxremote != null || jmxremotePort != null) {
if (jmxremotePort != null) {
jmxServer = ConnectorBootstrap.
startRemoteConnectorServer(jmxremotePort, props);
startDiscoveryService(props);
}
startLocalManagementAgent();
}
} catch (AgentConfigurationError e) {
error(e);
} catch (Exception e) {
error(e);
}
}
private static void startDiscoveryService(Properties props)
throws IOException, JdpException {
String discoveryPort = props.getProperty("com.sun.management.jdp.port");
String discoveryAddress = props.getProperty("com.sun.management.jdp.address");
String discoveryShouldStart = props.getProperty("com.sun.management.jmxremote.autodiscovery");
boolean shouldStart = false;
if (discoveryShouldStart == null){
shouldStart = (discoveryPort != null);
}
else{
try{
shouldStart = Boolean.parseBoolean(discoveryShouldStart);
} catch (NumberFormatException e) {
throw new AgentConfigurationError(AGENT_EXCEPTION, "Couldn't parse autodiscovery argument");
}
}
if (shouldStart) {
InetAddress address;
try {
address = (discoveryAddress == null) ?
InetAddress.getByName(JDP_DEFAULT_ADDRESS) : InetAddress.getByName(discoveryAddress);
} catch (UnknownHostException e) {
throw new AgentConfigurationError(AGENT_EXCEPTION, e, "Unable to broadcast to requested address");
}
int port = JDP_DEFAULT_PORT;
if (discoveryPort != null) {
try {
port = Integer.parseInt(discoveryPort);
} catch (NumberFormatException e) {
throw new AgentConfigurationError(AGENT_EXCEPTION, "Couldn't parse JDP port argument");
}
}
Map<String,String> remoteProps = ConnectorAddressLink.importRemoteFrom(0);
String jmxUrlStr = remoteProps.get("sun.management.JMXConnectorServer.0.remoteAddress");
String instanceName = props.getProperty("com.sun.management.jdp.name");
JdpController.startDiscoveryService(address, port, instanceName, jmxUrlStr);
}
}
public static Properties loadManagementProperties() {
Properties props = new Properties();
String fname = System.getProperty(CONFIG_FILE);
readConfiguration(fname, props);
Properties sysProps = System.getProperties();
synchronized (sysProps) {
props.putAll(sysProps);
}
return props;
}
public static synchronized Properties getManagementProperties() {
if (mgmtProps == null) {
String configFile = System.getProperty(CONFIG_FILE);
String jmxremote = System.getProperty(JMXREMOTE);
String jmxremotePort = System.getProperty(JMXREMOTE_PORT);
if (configFile == null && jmxremote == null && jmxremotePort == null) {
return null;
}
mgmtProps = loadManagementProperties();
}
return mgmtProps;
}
private static void readConfiguration(String fname, Properties p) {
if (fname == null) {
String home = System.getProperty("java.home");
if (home == null) {
throw new Error("Can't find java.home ??");
}
StringBuilder defaultFileName = new StringBuilder(home);
defaultFileName.append(File.separator).append("conf");
defaultFileName.append(File.separator).append("management");
defaultFileName.append(File.separator).append("management.properties");
fname = defaultFileName.toString();
}
final File configFile = new File(fname);
if (!configFile.exists()) {
error(CONFIG_FILE_NOT_FOUND, fname);
}
InputStream in = null;
try {
in = new FileInputStream(configFile);
p.load(in);
} catch (FileNotFoundException e) {
error(CONFIG_FILE_OPEN_FAILED, e.getMessage());
} catch (IOException e) {
error(CONFIG_FILE_OPEN_FAILED, e.getMessage());
} catch (SecurityException e) {
error(CONFIG_FILE_ACCESS_DENIED, fname);
} finally {
if (in != null) {
try {
in.close();
} catch (IOException e) {
error(CONFIG_FILE_CLOSE_FAILED, fname);
}
}
}
}
public static void startAgent() throws Exception {
String prop = System.getProperty("com.sun.management.agent.class");
if (prop == null) {
Properties props = getManagementProperties();
if (props != null) {
startAgent(props);
}
return;
}
String[] values = prop.split(":");
if (values.length < 1 || values.length > 2) {
error(AGENT_CLASS_INVALID, "\"" + prop + "\"");
}
String cname = values[0];
String args = (values.length == 2 ? values[1] : null);
if (cname == null || cname.length() == 0) {
error(AGENT_CLASS_INVALID, "\"" + prop + "\"");
}
if (cname != null) {
try {
Class<?> clz = ClassLoader.getSystemClassLoader().loadClass(cname);
Method premain = clz.getMethod("premain",
new Class<?>[]{String.class});
premain.invoke(null,
new Object[]{args});
} catch (ClassNotFoundException ex) {
error(AGENT_CLASS_NOT_FOUND, "\"" + cname + "\"");
} catch (NoSuchMethodException ex) {
error(AGENT_CLASS_PREMAIN_NOT_FOUND, "\"" + cname + "\"");
} catch (SecurityException ex) {
error(AGENT_CLASS_ACCESS_DENIED);
} catch (Exception ex) {
String msg = (ex.getCause() == null
? ex.getMessage()
: ex.getCause().getMessage());
error(AGENT_CLASS_FAILED, msg);
}
}
}
public static void error(String key) {
String keyText = getText(key);
System.err.print(getText("agent.err.error") + ": " + keyText);
throw new RuntimeException(keyText);
}
public static void error(String key, String message) {
String keyText = getText(key);
System.err.print(getText("agent.err.error") + ": " + keyText);
System.err.println(": " + message);
throw new RuntimeException(keyText + ": " + message);
}
public static void error(Exception e) {
e.printStackTrace();
System.err.println(getText(AGENT_EXCEPTION) + ": " + e.toString());
throw new RuntimeException(e);
}
public static void error(AgentConfigurationError e) {
String keyText = getText(e.getError());
String[] params = e.getParams();
System.err.print(getText("agent.err.error") + ": " + keyText);
if (params != null && params.length != 0) {
System.err.println(": " + String.join(" ", params));
}
e.printStackTrace();
throw new RuntimeException(e);
}
public static void warning(String key, String message) {
System.err.print(getText("agent.err.warning") + ": " + getText(key));
System.err.println(": " + message);
}
private static void initResource() {
try {
messageRB =
ResourceBundle.getBundle("jdk.internal.agent.resources.agent");
} catch (MissingResourceException e) {
throw new Error("Fatal: Resource for management agent is missing");
}
}
public static String getText(String key) {
if (messageRB == null) {
initResource();
}
try {
return messageRB.getString(key);
} catch (MissingResourceException e) {
return "Missing management agent resource bundle: key = \"" + key + "\"";
}
}
public static String getText(String key, String... args) {
if (messageRB == null) {
initResource();
}
String format = messageRB.getString(key);
if (format == null) {
format = "missing resource key: key = \"" + key + "\", "
+ "arguments = \"{0}\", \"{1}\", \"{2}\"";
}
return MessageFormat.format(format, (Object[]) args);
}
}
package jdk.internal.agent;
public class AgentConfigurationError extends Error {
public static final String AGENT_EXCEPTION =
"agent.err.exception";
public static final String CONFIG_FILE_NOT_FOUND    =
"agent.err.configfile.notfound";
public static final String CONFIG_FILE_OPEN_FAILED  =
"agent.err.configfile.failed";
public static final String CONFIG_FILE_CLOSE_FAILED =
"agent.err.configfile.closed.failed";
public static final String CONFIG_FILE_ACCESS_DENIED =
"agent.err.configfile.access.denied";
public static final String EXPORT_ADDRESS_FAILED =
"agent.err.exportaddress.failed";
public static final String AGENT_CLASS_NOT_FOUND =
"agent.err.agentclass.notfound";
public static final String AGENT_CLASS_FAILED =
"agent.err.agentclass.failed";
public static final String AGENT_CLASS_PREMAIN_NOT_FOUND =
"agent.err.premain.notfound";
public static final String AGENT_CLASS_ACCESS_DENIED =
"agent.err.agentclass.access.denied";
public static final String AGENT_CLASS_INVALID =
"agent.err.invalid.agentclass";
public static final String INVALID_JMXREMOTE_PORT =
"agent.err.invalid.jmxremote.port";
public static final String INVALID_JMXREMOTE_RMI_PORT =
"agent.err.invalid.jmxremote.rmi.port";
public static final String INVALID_JMXREMOTE_LOCAL_PORT =
"agent.err.invalid.jmxremote.local.port";
public static final String PASSWORD_FILE_NOT_SET =
"agent.err.password.file.notset";
public static final String PASSWORD_FILE_NOT_READABLE =
"agent.err.password.file.not.readable";
public static final String PASSWORD_FILE_READ_FAILED =
"agent.err.password.file.read.failed";
public static final String PASSWORD_FILE_NOT_FOUND =
"agent.err.password.file.notfound";
public static final String ACCESS_FILE_NOT_SET =
"agent.err.access.file.notset";
public static final String ACCESS_FILE_NOT_READABLE =
"agent.err.access.file.not.readable";
public static final String ACCESS_FILE_READ_FAILED =
"agent.err.access.file.read.failed";
public static final String ACCESS_FILE_NOT_FOUND =
"agent.err.access.file.notfound";
public static final String PASSWORD_FILE_ACCESS_NOT_RESTRICTED =
"agent.err.password.file.access.notrestricted";
public static final String FILE_ACCESS_NOT_RESTRICTED =
"agent.err.file.access.not.restricted";
public static final String FILE_NOT_FOUND =
"agent.err.file.not.found";
public static final String FILE_NOT_READABLE =
"agent.err.file.not.readable";
public static final String FILE_NOT_SET =
"agent.err.file.not.set";
public static final String FILE_READ_FAILED =
"agent.err.file.read.failed";
public static final String CONNECTOR_SERVER_IO_ERROR =
"agent.err.connector.server.io.error";
public static final String INVALID_OPTION =
"agent.err.invalid.option";
public static final String INVALID_STATE =
"agent.err.invalid.state";
private final String error;
private final String[] params;
public AgentConfigurationError(String error) {
super();
this.error = error;
this.params = null;
}
public AgentConfigurationError(String error, Throwable cause) {
super(cause);
this.error = error;
this.params = null;
}
public AgentConfigurationError(String error, String... params) {
super();
this.error = error;
this.params = params.clone();
}
public AgentConfigurationError(String error, Throwable cause, String... params) {
super(cause);
this.error = error;
this.params = params.clone();
}
public String getError() {
return error;
}
public String[] getParams() {
return params.clone();
}
private static final long serialVersionUID = 1211605593516195475L;
}
package com.sun.tools.attach;
public class AgentInitializationException extends Exception {
static final long serialVersionUID = -1508756333332806353L;
private int returnValue;
public AgentInitializationException() {
super();
this.returnValue = 0;
}
public AgentInitializationException(String s) {
super(s);
this.returnValue = 0;
}
public AgentInitializationException(String s, int returnValue) {
super(s);
this.returnValue = returnValue;
}
public int returnValue() {
return returnValue;
}
}
package com.sun.tools.attach;
public class AgentLoadException extends Exception {
static final long serialVersionUID = 688047862952114238L;
public AgentLoadException() {
super();
}
public AgentLoadException(String s) {
super(s);
}
}
package jdk.internal.org.jline.reader.impl.completer;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import jdk.internal.org.jline.reader.Candidate;
import jdk.internal.org.jline.reader.Completer;
import jdk.internal.org.jline.reader.LineReader;
import jdk.internal.org.jline.reader.ParsedLine;
public class AggregateCompleter
implements Completer
{
private final Collection<Completer> completers;
public AggregateCompleter(final Completer... completers) {
this(Arrays.asList(completers));
}
public AggregateCompleter(Collection<Completer> completers) {
assert completers != null;
this.completers = completers;
}
public Collection<Completer> getCompleters() {
return completers;
}
public void complete(LineReader reader, final ParsedLine line, final List<Candidate> candidates) {
Objects.requireNonNull(line);
Objects.requireNonNull(candidates);
completers.forEach(c -> c.complete(reader, line, candidates));
}
@Override
public String toString() {
return getClass().getSimpleName() + "{" +
"completers=" + completers +
'}';
}
}
package sun.awt.www.content.audio;
import java.io.IOException;
import java.net.ContentHandler;
import java.net.URLConnection;
import com.sun.media.sound.JavaSoundAudioClip;
public class aiff extends ContentHandler {
public Object getContent(URLConnection uc) throws IOException {
return JavaSoundAudioClip.create(uc);
}
}
package com.sun.media.sound;
import javax.sound.sampled.AudioFormat;
final class AiffFileFormat extends StandardFileFormat {
static final int AIFF_MAGIC         = 1179603533;
static final int AIFC_MAGIC                 = 0x41494643;       static final int AIFF_MAGIC2                = 0x41494646;       static final int FVER_MAGIC                 = 0x46564552;       static final int FVER_TIMESTAMP             = 0xA2805140;       static final int COMM_MAGIC                 = 0x434f4d4d;       static final int SSND_MAGIC                 = 0x53534e44;
static final int AIFC_PCM                   = 0x4e4f4e45;       static final int AIFC_ACE2                  = 0x41434532;       static final int AIFC_ACE8                  = 0x41434538;       static final int AIFC_MAC3                  = 0x4d414333;       static final int AIFC_MAC6                  = 0x4d414336;       static final int AIFC_ULAW                  = 0x756c6177;       static final int AIFC_IMA4                  = 0x696d6134;
static final int AIFF_HEADERSIZE    = 54;
private final int headerSize=AIFF_HEADERSIZE;
private final int commChunkSize=26;
private final int fverChunkSize=0;
AiffFileFormat(final Type type, final long byteLength,
final AudioFormat format, final long frameLength) {
super(type, byteLength, format, frameLength);
}
int getHeaderSize() {
return headerSize;
}
int getCommChunkSize() {
return commChunkSize;
}
int getFverChunkSize() {
return fverChunkSize;
}
int getSsndChunkOffset() {
return getHeaderSize()-16;
}
}
package com.sun.media.sound;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import javax.sound.sampled.AudioFileFormat.Type;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.UnsupportedAudioFileException;
public final class AiffFileReader extends SunFileReader {
@Override
StandardFileFormat getAudioFileFormatImpl(final InputStream stream)
throws UnsupportedAudioFileException, IOException {
DataInputStream dis = new DataInputStream(stream);
AudioFormat format = null;
int magic = dis.readInt();
if (magic != AiffFileFormat.AIFF_MAGIC) {
throw new UnsupportedAudioFileException("not an AIFF file");
}
long  frameLength = 0;
int length = dis.readInt();
int iffType = dis.readInt();
final long totallength;
if(length <= 0 ) {
length = AudioSystem.NOT_SPECIFIED;
totallength = AudioSystem.NOT_SPECIFIED;
} else {
totallength = length + 8;
}
boolean aifc = false;
if (iffType ==  AiffFileFormat.AIFC_MAGIC) {
aifc = true;
}
boolean ssndFound = false;
while (!ssndFound) {
int chunkName = dis.readInt();
int chunkLen = dis.readInt();
int chunkRead = 0;
switch (chunkName) {
case AiffFileFormat.FVER_MAGIC:
break;
case AiffFileFormat.COMM_MAGIC:
if ((!aifc && chunkLen < 18) || (aifc && chunkLen < 22)) {
throw new UnsupportedAudioFileException("Invalid AIFF/COMM chunksize");
}
int channels = dis.readUnsignedShort();
if (channels <= 0) {
throw new UnsupportedAudioFileException("Invalid number of channels");
}
frameLength = dis.readInt() & 0xffffffffL;
int sampleSizeInBits = dis.readUnsignedShort();
if (sampleSizeInBits < 1 || sampleSizeInBits > 32) {
throw new UnsupportedAudioFileException("Invalid AIFF/COMM sampleSize");
}
float sampleRate = (float) read_ieee_extended(dis);
chunkRead += (2 + 4 + 2 + 10);
AudioFormat.Encoding encoding = AudioFormat.Encoding.PCM_SIGNED;
if (aifc) {
int enc = dis.readInt(); chunkRead += 4;
switch (enc) {
case AiffFileFormat.AIFC_PCM:
encoding = AudioFormat.Encoding.PCM_SIGNED;
break;
case AiffFileFormat.AIFC_ULAW:
encoding = AudioFormat.Encoding.ULAW;
sampleSizeInBits = 8;                         break;
default:
throw new UnsupportedAudioFileException("Invalid AIFF encoding");
}
}
int frameSize = calculatePCMFrameSize(sampleSizeInBits, channels);
format =  new AudioFormat(encoding, sampleRate,
sampleSizeInBits, channels,
frameSize, sampleRate, true);
break;
case AiffFileFormat.SSND_MAGIC:
int dataOffset = dis.readInt();                 int blocksize = dis.readInt();                  chunkRead += 8;
ssndFound = true;
break;
}                         if (!ssndFound) {
int toSkip = chunkLen - chunkRead;
if (toSkip > 0) {
dis.skipBytes(toSkip);
}
}
}
if (format == null) {
throw new UnsupportedAudioFileException("missing COMM chunk");
}
Type type = aifc ? Type.AIFC : Type.AIFF;
return new AiffFileFormat(type, totallength, format, frameLength);
}
private double read_ieee_extended(DataInputStream dis) throws IOException {
double f = 0;
int expon = 0;
long hiMant = 0, loMant = 0;
long t1, t2;
double HUGE = 3.40282346638528860e+38;
expon = dis.readUnsignedShort();
t1 = (long)dis.readUnsignedShort();
t2 = (long)dis.readUnsignedShort();
hiMant = t1 << 16 | t2;
t1 = (long)dis.readUnsignedShort();
t2 = (long)dis.readUnsignedShort();
loMant = t1 << 16 | t2;
if (expon == 0 && hiMant == 0 && loMant == 0) {
f = 0;
} else {
if (expon == 0x7FFF)
f = HUGE;
else {
expon -= 16383;
expon -= 31;
f = (hiMant * Math.pow(2, expon));
expon -= 32;
f += (loMant * Math.pow(2, expon));
}
}
return f;
}
}
package com.sun.media.sound;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.SequenceInputStream;
import java.util.Objects;
import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
public final class AiffFileWriter extends SunFileWriter {
public AiffFileWriter() {
super(new AudioFileFormat.Type[]{AudioFileFormat.Type.AIFF});
}
@Override
public AudioFileFormat.Type[] getAudioFileTypes(AudioInputStream stream) {
AudioFileFormat.Type[] filetypes = new AudioFileFormat.Type[types.length];
System.arraycopy(types, 0, filetypes, 0, types.length);
AudioFormat format = stream.getFormat();
AudioFormat.Encoding encoding = format.getEncoding();
if( (AudioFormat.Encoding.ALAW.equals(encoding)) ||
(AudioFormat.Encoding.ULAW.equals(encoding)) ||
(AudioFormat.Encoding.PCM_SIGNED.equals(encoding)) ||
(AudioFormat.Encoding.PCM_UNSIGNED.equals(encoding)) ) {
return filetypes;
}
return new AudioFileFormat.Type[0];
}
@Override
public int write(AudioInputStream stream, AudioFileFormat.Type fileType, OutputStream out) throws IOException {
Objects.requireNonNull(stream);
Objects.requireNonNull(fileType);
Objects.requireNonNull(out);
AiffFileFormat aiffFileFormat = (AiffFileFormat)getAudioFileFormat(fileType, stream);
if( stream.getFrameLength() == AudioSystem.NOT_SPECIFIED ) {
throw new IOException("stream length not specified");
}
return writeAiffFile(stream, aiffFileFormat, out);
}
@Override
public int write(AudioInputStream stream, AudioFileFormat.Type fileType, File out) throws IOException {
Objects.requireNonNull(stream);
Objects.requireNonNull(fileType);
Objects.requireNonNull(out);
AiffFileFormat aiffFileFormat = (AiffFileFormat)getAudioFileFormat(fileType, stream);
final int bytesWritten;
try (final FileOutputStream fos = new FileOutputStream(out);
final BufferedOutputStream bos = new BufferedOutputStream(fos)) {
bytesWritten = writeAiffFile(stream, aiffFileFormat, bos);
}
if( aiffFileFormat.getByteLength()== AudioSystem.NOT_SPECIFIED ) {
int channels = aiffFileFormat.getFormat().getChannels();
int sampleSize = aiffFileFormat.getFormat().getSampleSizeInBits();
int ssndBlockSize = channels * ((sampleSize + 7) / 8);
int aiffLength=bytesWritten;
int ssndChunkSize=aiffLength-aiffFileFormat.getHeaderSize()+16;
long dataSize=ssndChunkSize-16;
int numFrames = (int) (dataSize / ssndBlockSize);
try (final RandomAccessFile raf = new RandomAccessFile(out, "rw")) {
raf.skipBytes(4);
raf.writeInt(aiffLength - 8);
raf.skipBytes(4 + aiffFileFormat.getFverChunkSize() + 4 + 4 + 2);
raf.writeInt(numFrames);
raf.skipBytes(2 + 10 + 4);
raf.writeInt(ssndChunkSize - 8);
}
}
return bytesWritten;
}
private AudioFileFormat getAudioFileFormat(AudioFileFormat.Type type, AudioInputStream stream) {
if (!isFileTypeSupported(type, stream)) {
throw new IllegalArgumentException("File type " + type + " not supported.");
}
AudioFormat format = null;
AiffFileFormat fileFormat = null;
AudioFormat.Encoding encoding = AudioFormat.Encoding.PCM_SIGNED;
AudioFormat streamFormat = stream.getFormat();
AudioFormat.Encoding streamEncoding = streamFormat.getEncoding();
int sampleSizeInBits;
int fileSize;
boolean convert8to16 = false;
if( (AudioFormat.Encoding.ALAW.equals(streamEncoding)) ||
(AudioFormat.Encoding.ULAW.equals(streamEncoding)) ) {
if( streamFormat.getSampleSizeInBits()==8 ) {
encoding = AudioFormat.Encoding.PCM_SIGNED;
sampleSizeInBits=16;
convert8to16 = true;
} else {
throw new IllegalArgumentException("Encoding " + streamEncoding + " supported only for 8-bit data.");
}
} else if ( streamFormat.getSampleSizeInBits()==8 ) {
encoding = AudioFormat.Encoding.PCM_UNSIGNED;
sampleSizeInBits=8;
} else {
encoding = AudioFormat.Encoding.PCM_SIGNED;
sampleSizeInBits=streamFormat.getSampleSizeInBits();
}
format = new AudioFormat( encoding,
streamFormat.getSampleRate(),
sampleSizeInBits,
streamFormat.getChannels(),
streamFormat.getFrameSize(),
streamFormat.getFrameRate(),
true);
if( stream.getFrameLength()!=AudioSystem.NOT_SPECIFIED ) {
if( convert8to16 ) {
fileSize = (int)stream.getFrameLength()*streamFormat.getFrameSize()*2 + AiffFileFormat.AIFF_HEADERSIZE;
} else {
fileSize = (int)stream.getFrameLength()*streamFormat.getFrameSize() + AiffFileFormat.AIFF_HEADERSIZE;
}
} else {
fileSize = AudioSystem.NOT_SPECIFIED;
}
fileFormat = new AiffFileFormat( AudioFileFormat.Type.AIFF,
fileSize,
format,
(int)stream.getFrameLength() );
return fileFormat;
}
private int writeAiffFile(InputStream in, AiffFileFormat aiffFileFormat, OutputStream out) throws IOException {
int bytesRead = 0;
int bytesWritten = 0;
InputStream fileStream = getFileStream(aiffFileFormat, in);
byte[] buffer = new byte[bisBufferSize];
int maxLength = aiffFileFormat.getByteLength();
while( (bytesRead = fileStream.read( buffer )) >= 0 ) {
if (maxLength>0) {
if( bytesRead < maxLength ) {
out.write( buffer, 0, bytesRead );
bytesWritten += bytesRead;
maxLength -= bytesRead;
} else {
out.write( buffer, 0, maxLength );
bytesWritten += maxLength;
maxLength = 0;
break;
}
} else {
out.write( buffer, 0, bytesRead );
bytesWritten += bytesRead;
}
}
return bytesWritten;
}
private InputStream getFileStream(AiffFileFormat aiffFileFormat, InputStream audioStream) throws IOException  {
AudioFormat format = aiffFileFormat.getFormat();
AudioFormat streamFormat = null;
AudioFormat.Encoding encoding = null;
int headerSize          = aiffFileFormat.getHeaderSize();
int fverChunkSize       = aiffFileFormat.getFverChunkSize();
int commChunkSize       = aiffFileFormat.getCommChunkSize();
int aiffLength          = -1;
int ssndChunkSize       = -1;
int ssndOffset                  = aiffFileFormat.getSsndChunkOffset();
short channels = (short) format.getChannels();
short sampleSize = (short) format.getSampleSizeInBits();
int ssndBlockSize = channels * ((sampleSize + 7) / 8);
int numFrames = aiffFileFormat.getFrameLength();
long dataSize = -1;
if( numFrames != AudioSystem.NOT_SPECIFIED) {
dataSize = (long) numFrames * ssndBlockSize;
ssndChunkSize = (int)dataSize + 16;
aiffLength = (int)dataSize+headerSize;
}
float sampleFramesPerSecond = format.getSampleRate();
int compCode = AiffFileFormat.AIFC_PCM;
byte[] header = null;
InputStream codedAudioStream = audioStream;
if( audioStream instanceof AudioInputStream ) {
streamFormat = ((AudioInputStream)audioStream).getFormat();
encoding = streamFormat.getEncoding();
if( (AudioFormat.Encoding.PCM_UNSIGNED.equals(encoding)) ||
( (AudioFormat.Encoding.PCM_SIGNED.equals(encoding)) && !streamFormat.isBigEndian() ) ) {
codedAudioStream = AudioSystem.getAudioInputStream( new AudioFormat (
AudioFormat.Encoding.PCM_SIGNED,
streamFormat.getSampleRate(),
streamFormat.getSampleSizeInBits(),
streamFormat.getChannels(),
streamFormat.getFrameSize(),
streamFormat.getFrameRate(),
true ),
(AudioInputStream)audioStream );
} else if( (AudioFormat.Encoding.ULAW.equals(encoding)) ||
(AudioFormat.Encoding.ALAW.equals(encoding)) ) {
if( streamFormat.getSampleSizeInBits() != 8 ) {
throw new IllegalArgumentException("unsupported encoding");
}
codedAudioStream = AudioSystem.getAudioInputStream( new AudioFormat (
AudioFormat.Encoding.PCM_SIGNED,
streamFormat.getSampleRate(),
streamFormat.getSampleSizeInBits() * 2,
streamFormat.getChannels(),
streamFormat.getFrameSize() * 2,
streamFormat.getFrameRate(),
true ),
(AudioInputStream)audioStream );
}
}
try (final ByteArrayOutputStream baos = new ByteArrayOutputStream();
final DataOutputStream dos = new DataOutputStream(baos)) {
dos.writeInt(AiffFileFormat.AIFF_MAGIC);
dos.writeInt((aiffLength - 8));
dos.writeInt(AiffFileFormat.AIFF_MAGIC2);
dos.writeInt(AiffFileFormat.COMM_MAGIC);
dos.writeInt((commChunkSize - 8));
dos.writeShort(channels);
dos.writeInt(numFrames);
dos.writeShort(sampleSize);
write_ieee_extended(dos, sampleFramesPerSecond);                                                                           dos.writeInt(AiffFileFormat.SSND_MAGIC);
dos.writeInt((ssndChunkSize - 8));
dos.writeInt(0);                    dos.writeInt(0);                    header = baos.toByteArray();
}
return new SequenceInputStream(new ByteArrayInputStream(header),
new NoCloseInputStream(codedAudioStream));
}
private static final int DOUBLE_MANTISSA_LENGTH = 52;
private static final int DOUBLE_EXPONENT_LENGTH = 11;
private static final long DOUBLE_SIGN_MASK     = 0x8000000000000000L;
private static final long DOUBLE_EXPONENT_MASK = 0x7FF0000000000000L;
private static final long DOUBLE_MANTISSA_MASK = 0x000FFFFFFFFFFFFFL;
private static final int DOUBLE_EXPONENT_OFFSET = 1023;
private static final int EXTENDED_EXPONENT_OFFSET = 16383;
private static final int EXTENDED_MANTISSA_LENGTH = 63;
private static final int EXTENDED_EXPONENT_LENGTH = 15;
private static final long EXTENDED_INTEGER_MASK = 0x8000000000000000L;
private void write_ieee_extended(DataOutputStream dos, float f) throws IOException {
long doubleBits = Double.doubleToLongBits((double) f);
long sign = (doubleBits & DOUBLE_SIGN_MASK)
>> (DOUBLE_EXPONENT_LENGTH + DOUBLE_MANTISSA_LENGTH);
long doubleExponent = (doubleBits & DOUBLE_EXPONENT_MASK)
>> DOUBLE_MANTISSA_LENGTH;
long doubleMantissa = doubleBits & DOUBLE_MANTISSA_MASK;
long extendedExponent = doubleExponent - DOUBLE_EXPONENT_OFFSET
+ EXTENDED_EXPONENT_OFFSET;
long extendedMantissa = doubleMantissa
<< (EXTENDED_MANTISSA_LENGTH - DOUBLE_MANTISSA_LENGTH);
long extendedSign = sign << EXTENDED_EXPONENT_LENGTH;
short extendedBits79To64 = (short) (extendedSign | extendedExponent);
long extendedBits63To0 = EXTENDED_INTEGER_MASK | extendedMantissa;
dos.writeShort(extendedBits79To64);
dos.writeLong(extendedBits63To0);
}
}
package sun.nio.ch;
import java.nio.channels.*;
import java.nio.channels.spi.AsynchronousChannelProvider;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ThreadFactory;
import java.io.IOException;
public class AixAsynchronousChannelProvider
extends AsynchronousChannelProvider
{
private static volatile AixPollPort defaultPort;
private AixPollPort defaultEventPort() throws IOException {
if (defaultPort == null) {
synchronized (AixAsynchronousChannelProvider.class) {
if (defaultPort == null) {
defaultPort = new AixPollPort(this, ThreadPool.getDefault()).start();
}
}
}
return defaultPort;
}
public AixAsynchronousChannelProvider() {
}
@Override
public AsynchronousChannelGroup openAsynchronousChannelGroup(int nThreads, ThreadFactory factory)
throws IOException
{
return new AixPollPort(this, ThreadPool.create(nThreads, factory)).start();
}
@Override
public AsynchronousChannelGroup openAsynchronousChannelGroup(ExecutorService executor, int initialSize)
throws IOException
{
return new AixPollPort(this, ThreadPool.wrap(executor, initialSize)).start();
}
private Port toPort(AsynchronousChannelGroup group) throws IOException {
if (group == null) {
return defaultEventPort();
} else {
if (!(group instanceof AixPollPort))
throw new IllegalChannelGroupException();
return (Port)group;
}
}
@Override
public AsynchronousServerSocketChannel openAsynchronousServerSocketChannel(AsynchronousChannelGroup group)
throws IOException
{
return new UnixAsynchronousServerSocketChannelImpl(toPort(group));
}
@Override
public AsynchronousSocketChannel openAsynchronousSocketChannel(AsynchronousChannelGroup group)
throws IOException
{
return new UnixAsynchronousSocketChannelImpl(toPort(group));
}
}
package sun.nio.fs;
import java.nio.file.attribute.*;
import java.util.*;
import java.io.IOException;
class AixFileStore
extends UnixFileStore
{
AixFileStore(UnixPath file) throws IOException {
super(file);
}
AixFileStore(UnixFileSystem fs, UnixMountEntry entry) throws IOException {
super(fs, entry);
}
@Override
UnixMountEntry findMountEntry() throws IOException {
AixFileSystem fs = (AixFileSystem)file().getFileSystem();
UnixPath path = null;
try {
byte[] rp = UnixNativeDispatcher.realpath(file());
path = new UnixPath(fs, rp);
} catch (UnixException x) {
x.rethrowAsIOException(file());
}
UnixPath parent = path.getParent();
while (parent != null) {
UnixFileAttributes attrs = null;
try {
attrs = UnixFileAttributes.get(parent, true);
} catch (UnixException x) {
x.rethrowAsIOException(parent);
}
if (attrs.dev() != dev())
break;
path = parent;
parent = parent.getParent();
}
byte[] dir = path.asByteArray();
for (UnixMountEntry entry: fs.getMountEntries()) {
if (Arrays.equals(dir, entry.dir()))
return entry;
}
throw new IOException("Mount point not found");
}
@Override
protected boolean isExtendedAttributesEnabled(UnixPath path) {
return false;
}
@Override
public boolean supportsFileAttributeView(Class<? extends FileAttributeView> type) {
return super.supportsFileAttributeView(type);
}
@Override
public boolean supportsFileAttributeView(String name) {
return super.supportsFileAttributeView(name);
}
}
package sun.nio.fs;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.io.IOException;
import java.util.*;
import static sun.nio.fs.AixNativeDispatcher.*;
class AixFileSystem extends UnixFileSystem {
AixFileSystem(UnixFileSystemProvider provider, String dir) {
super(provider, dir);
}
@Override
public WatchService newWatchService()
throws IOException
{
return new PollingWatchService();
}
private static class SupportedFileFileAttributeViewsHolder {
static final Set<String> supportedFileAttributeViews =
supportedFileAttributeViews();
private static Set<String> supportedFileAttributeViews() {
Set<String> result = new HashSet<String>();
result.addAll(UnixFileSystem.standardFileAttributeViews());
return Collections.unmodifiableSet(result);
}
}
@Override
public Set<String> supportedFileAttributeViews() {
return SupportedFileFileAttributeViewsHolder.supportedFileAttributeViews;
}
@Override
void copyNonPosixAttributes(int ofd, int nfd) {
}
@Override
Iterable<UnixMountEntry> getMountEntries() {
UnixMountEntry[] entries = null;
try {
entries = getmntctl();
} catch (UnixException x) {
}
if (entries == null) {
return Collections.emptyList();
}
return Arrays.asList(entries);
}
@Override
FileStore getFileStore(UnixMountEntry entry) throws IOException {
return new AixFileStore(this, entry);
}
}
package sun.nio.fs;
import java.io.IOException;
class AixFileSystemProvider extends UnixFileSystemProvider {
public AixFileSystemProvider() {
super();
}
@Override
AixFileSystem newFileSystem(String dir) {
return new AixFileSystem(this, dir);
}
@Override
AixFileStore getFileStore(UnixPath path) throws IOException {
return new AixFileStore(path);
}
}
package sun.nio.fs;
class AixNativeDispatcher extends UnixNativeDispatcher {
private AixNativeDispatcher() { }
static native UnixMountEntry[] getmntctl() throws UnixException;
private static native void init();
static {
jdk.internal.loader.BootLoader.loadLibrary("nio");
init();
}
}
package sun.nio.ch;
import java.nio.channels.spi.AsynchronousChannelProvider;
import java.io.IOException;
import java.util.HashSet;
import java.util.Iterator;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;
import jdk.internal.misc.Unsafe;
final class AixPollPort
extends Port
{
private static final Unsafe unsafe = Unsafe.getUnsafe();
static {
IOUtil.load();
init();
}
private static final int SIZEOF_POLLFD    = eventSize();
private static final int OFFSETOF_EVENTS  = eventsOffset();
private static final int OFFSETOF_REVENTS = reventsOffset();
private static final int OFFSETOF_FD      = fdOffset();
private static final int PS_ADD     = 0x0;
private static final int PS_MOD     = 0x1;
private static final int PS_DELETE  = 0x2;
private static final int MAX_POLL_EVENTS = 512;
private final int pollset;
private boolean closed;
private final int sp[];
private final int ctlSp[];
private final AtomicInteger wakeupCount = new AtomicInteger();
private final long address;
static class Event {
final PollableChannel channel;
final int events;
Event(PollableChannel channel, int events) {
this.channel = channel;
this.events = events;
}
PollableChannel channel()   { return channel; }
int events()                { return events; }
}
private final ArrayBlockingQueue<Event> queue;
private final Event NEED_TO_POLL = new Event(null, 0);
private final Event EXECUTE_TASK_OR_SHUTDOWN = new Event(null, 0);
private final Event CONTINUE_AFTER_CTL_EVENT = new Event(null, 0);
static class ControlEvent {
final int fd;
final int events;
final boolean removeOnly;
int error = 0;
ControlEvent(int fd, int events, boolean removeOnly) {
this.fd = fd;
this.events = events;
this.removeOnly = removeOnly;
}
int fd()                 { return fd; }
int events()             { return events; }
boolean removeOnly()     { return removeOnly; }
int error()              { return error; }
void setError(int error) { this.error = error; }
}
private final HashSet<ControlEvent> controlQueue = new HashSet<ControlEvent>();
private final ReentrantLock controlLock = new ReentrantLock();
AixPollPort(AsynchronousChannelProvider provider, ThreadPool pool)
throws IOException
{
super(provider, pool);
this.pollset = pollsetCreate();
int[] sv = new int[2];
try {
socketpair(sv);
pollsetCtl(pollset, PS_ADD, sv[0], Net.POLLIN);
} catch (IOException x) {
pollsetDestroy(pollset);
throw x;
}
this.sp = sv;
sv = new int[2];
try {
socketpair(sv);
pollsetCtl(pollset, PS_ADD, sv[0], Net.POLLIN);
} catch (IOException x) {
pollsetDestroy(pollset);
throw x;
}
this.ctlSp = sv;
this.address = allocatePollArray(MAX_POLL_EVENTS);
this.queue = new ArrayBlockingQueue<Event>(MAX_POLL_EVENTS);
this.queue.offer(NEED_TO_POLL);
}
AixPollPort start() {
startThreads(new EventHandlerTask());
return this;
}
private void implClose() {
synchronized (this) {
if (closed)
return;
closed = true;
}
freePollArray(address);
close0(sp[0]);
close0(sp[1]);
close0(ctlSp[0]);
close0(ctlSp[1]);
pollsetDestroy(pollset);
}
private void wakeup() {
if (wakeupCount.incrementAndGet() == 1) {
try {
interrupt(sp[1]);
} catch (IOException x) {
throw new AssertionError(x);
}
}
}
@Override
void executeOnHandlerTask(Runnable task) {
synchronized (this) {
if (closed)
throw new RejectedExecutionException();
offerTask(task);
wakeup();
}
}
@Override
void shutdownHandlerTasks() {
int nThreads = threadCount();
if (nThreads == 0) {
implClose();
} else {
while (nThreads-- > 0) {
wakeup();
}
}
}
@Override
void startPoll(int fd, int events) {
queueControlEvent(new ControlEvent(fd, events, false));
}
@Override
protected void preUnregister(int fd) {
queueControlEvent(new ControlEvent(fd, 0, true));
}
private void queueControlEvent(ControlEvent ev) {
synchronized (controlQueue) {
controlQueue.add(ev);
try {
interrupt(ctlSp[1]);
} catch (IOException x) {
throw new AssertionError(x);
}
do {
if (controlLock.tryLock()) {
try {
processControlQueue();
} finally {
controlLock.unlock();
}
} else {
try {
controlQueue.wait(100);
} catch (InterruptedException e) {
}
}
} while (controlQueue.contains(ev));
}
if (ev.error() != 0) {
throw new AssertionError();
}
}
private void processControlQueue() {
synchronized (controlQueue) {
Iterator<ControlEvent> iter = controlQueue.iterator();
while (iter.hasNext()) {
ControlEvent ev = iter.next();
pollsetCtl(pollset, PS_DELETE, ev.fd(), 0);
if (!ev.removeOnly()) {
ev.setError(pollsetCtl(pollset, PS_MOD, ev.fd(), ev.events()));
}
iter.remove();
}
controlQueue.notifyAll();
}
}
private class EventHandlerTask implements Runnable {
private Event poll() throws IOException {
try {
for (;;) {
int n;
controlLock.lock();
try {
n = pollsetPoll(pollset, address, MAX_POLL_EVENTS);
} finally {
controlLock.unlock();
}
fdToChannelLock.readLock().lock();
try {
while (n-- > 0) {
long eventAddress = getEvent(address, n);
int fd = getDescriptor(eventAddress);
if (fd != sp[0] && fd != ctlSp[0]) {
synchronized (controlQueue) {
pollsetCtl(pollset, PS_DELETE, fd, 0);
}
}
if (fd == sp[0]) {
if (wakeupCount.decrementAndGet() == 0) {
drain1(sp[0]);
}
if (n > 0) {
queue.offer(EXECUTE_TASK_OR_SHUTDOWN);
continue;
}
return EXECUTE_TASK_OR_SHUTDOWN;
}
if (fd == ctlSp[0]) {
synchronized (controlQueue) {
drain1(ctlSp[0]);
processControlQueue();
}
if (n > 0) {
continue;
}
return CONTINUE_AFTER_CTL_EVENT;
}
PollableChannel channel = fdToChannel.get(fd);
if (channel != null) {
int events = getRevents(eventAddress);
Event ev = new Event(channel, events);
if (n > 0) {
queue.offer(ev);
} else {
return ev;
}
}
}
} finally {
fdToChannelLock.readLock().unlock();
}
}
} finally {
queue.offer(NEED_TO_POLL);
}
}
public void run() {
Invoker.GroupAndInvokeCount myGroupAndInvokeCount =
Invoker.getGroupAndInvokeCount();
final boolean isPooledThread = (myGroupAndInvokeCount != null);
boolean replaceMe = false;
Event ev;
try {
for (;;) {
if (isPooledThread)
myGroupAndInvokeCount.resetInvokeCount();
try {
replaceMe = false;
ev = queue.take();
if (ev == NEED_TO_POLL) {
try {
ev = poll();
} catch (IOException x) {
x.printStackTrace();
return;
}
}
} catch (InterruptedException x) {
continue;
}
if (ev == CONTINUE_AFTER_CTL_EVENT) {
continue;
}
if (ev == EXECUTE_TASK_OR_SHUTDOWN) {
Runnable task = pollTask();
if (task == null) {
return;
}
replaceMe = true;
task.run();
continue;
}
try {
ev.channel().onEvent(ev.events(), isPooledThread);
} catch (Error | RuntimeException x) {
replaceMe = true;
throw x;
}
}
} finally {
int remaining = threadExit(this, replaceMe);
if (remaining == 0 && isShutdown()) {
implClose();
}
}
}
}
private static long allocatePollArray(int count) {
return unsafe.allocateMemory(count * SIZEOF_POLLFD);
}
private static void freePollArray(long address) {
unsafe.freeMemory(address);
}
private static long getEvent(long address, int i) {
return address + (SIZEOF_POLLFD*i);
}
private static int getDescriptor(long eventAddress) {
return unsafe.getInt(eventAddress + OFFSETOF_FD);
}
private static int getEvents(long eventAddress) {
return unsafe.getChar(eventAddress + OFFSETOF_EVENTS);
}
private static int getRevents(long eventAddress) {
return unsafe.getChar(eventAddress + OFFSETOF_REVENTS);
}
private static native void init();
private static native int eventSize();
private static native int eventsOffset();
private static native int reventsOffset();
private static native int fdOffset();
private static native int pollsetCreate() throws IOException;
private static native int pollsetCtl(int pollset, int opcode, int fd, int events);
private static native int pollsetPoll(int pollset, long pollAddress, int numfds)
throws IOException;
private static native void pollsetDestroy(int pollset);
private static native void socketpair(int[] sv) throws IOException;
private static native void interrupt(int fd) throws IOException;
private static native void drain1(int fd) throws IOException;
private static native void close0(int fd);
}
package com.sun.media.sound;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Objects;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioFormat.Encoding;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.spi.FormatConversionProvider;
public final class AlawCodec extends FormatConversionProvider {
private static final byte[] ALAW_TABH = new byte[256];
private static final byte[] ALAW_TABL = new byte[256];
private static final short[] seg_end = {
0xFF, 0x1FF, 0x3FF, 0x7FF, 0xFFF, 0x1FFF, 0x3FFF, 0x7FFF
};
static {
for (int i=0;i<256;i++) {
int input    = i ^ 0x55;
int mantissa = (input & 0xf ) << 4;
int segment  = (input & 0x70) >> 4;
int value    = mantissa+8;
if(segment>=1)
value+=0x100;
if(segment>1)
value <<= (segment -1);
if( (input & 0x80)==0 )
value = -value;
ALAW_TABL[i] = (byte)value;
ALAW_TABH[i] = (byte)(value>>8);
}
}
@Override
public AudioFormat.Encoding[] getSourceEncodings() {
return new Encoding[]{Encoding.ALAW, Encoding.PCM_SIGNED};
}
@Override
public AudioFormat.Encoding[] getTargetEncodings() {
return getSourceEncodings();
}
@Override
public AudioFormat.Encoding[] getTargetEncodings(AudioFormat sourceFormat){
if( sourceFormat.getEncoding().equals( AudioFormat.Encoding.PCM_SIGNED )) {
if( sourceFormat.getSampleSizeInBits() == 16 ) {
AudioFormat.Encoding[] enc = new AudioFormat.Encoding[1];
enc[0] = AudioFormat.Encoding.ALAW;
return enc;
} else {
return new AudioFormat.Encoding[0];
}
} else if( sourceFormat.getEncoding().equals( AudioFormat.Encoding.ALAW ) ) {
if( sourceFormat.getSampleSizeInBits() == 8 ) {
AudioFormat.Encoding[] enc = new AudioFormat.Encoding[1];
enc[0] = AudioFormat.Encoding.PCM_SIGNED;
return enc;
} else {
return new AudioFormat.Encoding[0];
}
} else {
return new AudioFormat.Encoding[0];
}
}
@Override
public AudioFormat[] getTargetFormats(AudioFormat.Encoding targetEncoding, AudioFormat sourceFormat){
Objects.requireNonNull(sourceFormat);
if( (targetEncoding.equals( AudioFormat.Encoding.PCM_SIGNED ) && sourceFormat.getEncoding().equals( AudioFormat.Encoding.ALAW)) ||
(targetEncoding.equals( AudioFormat.Encoding.ALAW) && sourceFormat.getEncoding().equals( AudioFormat.Encoding.PCM_SIGNED)) ) {
return getOutputFormats( sourceFormat );
} else {
return new AudioFormat[0];
}
}
@Override
public AudioInputStream getAudioInputStream(AudioFormat.Encoding targetEncoding, AudioInputStream sourceStream){
AudioFormat sourceFormat = sourceStream.getFormat();
AudioFormat.Encoding sourceEncoding = sourceFormat.getEncoding();
if( !isConversionSupported(targetEncoding,sourceStream.getFormat()) ) {
throw new IllegalArgumentException("Unsupported conversion: " + sourceStream.getFormat().toString() + " to " + targetEncoding.toString());
}
if( sourceEncoding.equals( targetEncoding ) ) {
return sourceStream;
}
AudioFormat targetFormat = null;
if( sourceEncoding.equals( AudioFormat.Encoding.ALAW ) &&
targetEncoding.equals( AudioFormat.Encoding.PCM_SIGNED ) ) {
targetFormat = new AudioFormat( targetEncoding,
sourceFormat.getSampleRate(),
16,
sourceFormat.getChannels(),
2*sourceFormat.getChannels(),
sourceFormat.getSampleRate(),
sourceFormat.isBigEndian());
} else if( sourceEncoding.equals( AudioFormat.Encoding.PCM_SIGNED ) &&
targetEncoding.equals( AudioFormat.Encoding.ALAW ) ) {
targetFormat = new AudioFormat( targetEncoding,
sourceFormat.getSampleRate(),
8,
sourceFormat.getChannels(),
sourceFormat.getChannels(),
sourceFormat.getSampleRate(),
false);
} else {
throw new IllegalArgumentException("Unsupported conversion: " + sourceStream.getFormat().toString() + " to " + targetEncoding.toString());
}
return getConvertedStream(targetFormat, sourceStream);
}
@Override
public AudioInputStream getAudioInputStream(AudioFormat targetFormat, AudioInputStream sourceStream){
if (!isConversionSupported(targetFormat, sourceStream.getFormat()))
throw new IllegalArgumentException("Unsupported conversion: "
+ sourceStream.getFormat().toString() + " to "
+ targetFormat.toString());
return getConvertedStream( targetFormat, sourceStream );
}
private AudioInputStream getConvertedStream(AudioFormat outputFormat, AudioInputStream stream) {
AudioInputStream cs = null;
AudioFormat inputFormat = stream.getFormat();
if( inputFormat.matches(outputFormat) ) {
cs = stream;
} else {
cs = new AlawCodecStream(stream, outputFormat);
}
return cs;
}
private AudioFormat[] getOutputFormats(AudioFormat inputFormat) {
ArrayList<AudioFormat> formats = new ArrayList<>();
AudioFormat format;
if (inputFormat.getSampleSizeInBits() == 16
&& AudioFormat.Encoding.PCM_SIGNED.equals(inputFormat.getEncoding())) {
format = new AudioFormat(AudioFormat.Encoding.ALAW,
inputFormat.getSampleRate(), 8,
inputFormat.getChannels(),
inputFormat.getChannels(),
inputFormat.getSampleRate(), false);
formats.add(format);
}
if (inputFormat.getSampleSizeInBits() == 8
&& AudioFormat.Encoding.ALAW.equals(inputFormat.getEncoding())) {
format = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED,
inputFormat.getSampleRate(), 16,
inputFormat.getChannels(),
inputFormat.getChannels() * 2,
inputFormat.getSampleRate(), false);
formats.add(format);
format = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED,
inputFormat.getSampleRate(), 16,
inputFormat.getChannels(),
inputFormat.getChannels() * 2,
inputFormat.getSampleRate(), true);
formats.add(format);
}
AudioFormat[] formatArray = new AudioFormat[formats.size()];
for (int i = 0; i < formatArray.length; i++) {
formatArray[i] = formats.get(i);
}
return formatArray;
}
private final class AlawCodecStream extends AudioInputStream {
private static final int tempBufferSize = 64;
private byte[] tempBuffer  = null;
boolean encode = false;
AudioFormat encodeFormat;
AudioFormat decodeFormat;
byte[] tabByte1 = null;
byte[] tabByte2 = null;
int highByte = 0;
int lowByte  = 1;
AlawCodecStream(AudioInputStream stream, AudioFormat outputFormat) {
super(stream, outputFormat, -1);
AudioFormat inputFormat = stream.getFormat();
if ( ! (isConversionSupported(outputFormat, inputFormat)) ) {
throw new IllegalArgumentException("Unsupported conversion: " + inputFormat.toString() + " to " + outputFormat.toString());
}
boolean PCMIsBigEndian;
if (AudioFormat.Encoding.ALAW.equals(inputFormat.getEncoding())) {
encode = false;
encodeFormat = inputFormat;
decodeFormat = outputFormat;
PCMIsBigEndian = outputFormat.isBigEndian();
} else {
encode = true;
encodeFormat = outputFormat;
decodeFormat = inputFormat;
PCMIsBigEndian = inputFormat.isBigEndian();
tempBuffer = new byte[tempBufferSize];
}
if (PCMIsBigEndian) {
tabByte1 = ALAW_TABH;
tabByte2 = ALAW_TABL;
highByte = 0;
lowByte  = 1;
} else {
tabByte1 = ALAW_TABL;
tabByte2 = ALAW_TABH;
highByte = 1;
lowByte  = 0;
}
if (stream instanceof AudioInputStream) {
frameLength = stream.getFrameLength();
}
framePos = 0;
frameSize = inputFormat.getFrameSize();
if( frameSize==AudioSystem.NOT_SPECIFIED ) {
frameSize=1;
}
}
private short search(short val, short[] table, short size) {
for(short i = 0; i < size; i++) {
if (val <= table[i]) { return i; }
}
return size;
}
@Override
public int read() throws IOException {
byte[] b = new byte[1];
return read(b, 0, b.length);
}
@Override
public int read(byte[] b) throws IOException {
return read(b, 0, b.length);
}
@Override
public int read(byte[] b, int off, int len) throws IOException {
if( len%frameSize != 0 ) {
len -= (len%frameSize);
}
if (encode) {
short QUANT_MASK = 0xF;
short SEG_SHIFT = 4;
short mask;
short seg;
int adj;
int i;
short sample;
byte enc;
int readCount = 0;
int currentPos = off;
int readLeft = len*2;
int readLen = ( (readLeft>tempBufferSize) ? tempBufferSize : readLeft );
while ((readCount = super.read(tempBuffer,0,readLen))>0) {
for (i = 0; i < readCount; i+=2) {
sample = (short)(( (tempBuffer[i + highByte]) << 8) & 0xFF00);
sample |= (short)( (tempBuffer[i + lowByte]) & 0xFF);
if(sample >= 0) {
mask = 0xD5;
} else {
mask = 0x55;
sample = (short)(-sample - 8);
}
seg = search(sample, seg_end, (short) 8);
if (seg >= 8) {
enc = (byte) (0x7F ^ mask);
} else {
enc = (byte) (seg << SEG_SHIFT);
if(seg < 2) {
enc |= (byte) ( (sample >> 4) & QUANT_MASK);
} else {
enc |= (byte) ( (sample >> (seg + 3)) & QUANT_MASK );
}
enc ^= mask;
}
b[currentPos] = enc;
currentPos++;
}
readLeft -= readCount;
readLen = ( (readLeft>tempBufferSize) ? tempBufferSize : readLeft );
}
if( currentPos==off && readCount<0 ) {                      return readCount;
}
return (currentPos - off);
} else {
int i;
int readLen = len/2;
int readOffset = off + len/2;
int readCount = super.read(b, readOffset, readLen);
for (i = off; i < (off + (readCount*2)); i+=2) {
b[i]        = tabByte1[b[readOffset] & 0xFF];
b[i+1]      = tabByte2[b[readOffset] & 0xFF];
readOffset++;
}
if( readCount<0 ) {                                 return readCount;
}
return (i - off);
}
}
@Override
public long skip(final long n) throws IOException {
return encode ? super.skip(n * 2) / 2 : super.skip(n / 2) * 2;
}
} }
package sun.security.ssl;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.text.MessageFormat;
import java.util.Locale;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLHandshakeException;
import javax.net.ssl.SSLProtocolException;
enum Alert {
CLOSE_NOTIFY            ((byte)0,   "close_notify", false),
UNEXPECTED_MESSAGE      ((byte)10,  "unexpected_message", false),
BAD_RECORD_MAC          ((byte)20,  "bad_record_mac", false),
DECRYPTION_FAILED       ((byte)21,  "decryption_failed", false),
RECORD_OVERFLOW         ((byte)22,  "record_overflow", false),
DECOMPRESSION_FAILURE   ((byte)30,  "decompression_failure", false),
HANDSHAKE_FAILURE       ((byte)40,  "handshake_failure", true),
NO_CERTIFICATE          ((byte)41,  "no_certificate", true),
BAD_CERTIFICATE         ((byte)42,  "bad_certificate", true),
UNSUPPORTED_CERTIFICATE ((byte)43,  "unsupported_certificate", true),
CERTIFICATE_REVOKED     ((byte)44,  "certificate_revoked", true),
CERTIFICATE_EXPIRED     ((byte)45,  "certificate_expired", true),
CERTIFICATE_UNKNOWN     ((byte)46,  "certificate_unknown", true),
ILLEGAL_PARAMETER       ((byte)47,  "illegal_parameter", true),
UNKNOWN_CA              ((byte)48,  "unknown_ca", true),
ACCESS_DENIED           ((byte)49,  "access_denied", true),
DECODE_ERROR            ((byte)50,  "decode_error", true),
DECRYPT_ERROR           ((byte)51,  "decrypt_error", true),
EXPORT_RESTRICTION      ((byte)60,  "export_restriction", true),
PROTOCOL_VERSION        ((byte)70,  "protocol_version", true),
INSUFFICIENT_SECURITY   ((byte)71,  "insufficient_security", true),
INTERNAL_ERROR          ((byte)80,  "internal_error", false),
INAPPROPRIATE_FALLBACK  ((byte)86,  "inappropriate_fallback", false),
USER_CANCELED           ((byte)90,  "user_canceled", false),
NO_RENEGOTIATION        ((byte)100, "no_renegotiation", true),
MISSING_EXTENSION       ((byte)109, "missing_extension", true),
UNSUPPORTED_EXTENSION   ((byte)110, "unsupported_extension", true),
CERT_UNOBTAINABLE       ((byte)111, "certificate_unobtainable", true),
UNRECOGNIZED_NAME       ((byte)112, "unrecognized_name", true),
BAD_CERT_STATUS_RESPONSE((byte)113,
"bad_certificate_status_response", true),
BAD_CERT_HASH_VALUE     ((byte)114, "bad_certificate_hash_value", true),
UNKNOWN_PSK_IDENTITY    ((byte)115, "unknown_psk_identity", true),
CERTIFICATE_REQUIRED    ((byte)116, "certificate_required", true),
NO_APPLICATION_PROTOCOL ((byte)120, "no_application_protocol", true);
final byte id;
final String description;
final boolean handshakeOnly;
static final SSLConsumer alertConsumer = new AlertConsumer();
private Alert(byte id, String description, boolean handshakeOnly) {
this.id = id;
this.description = description;
this.handshakeOnly = handshakeOnly;
}
static Alert valueOf(byte id) {
for (Alert al : Alert.values()) {
if (al.id == id) {
return al;
}
}
return null;
}
static String nameOf(byte id) {
for (Alert al : Alert.values()) {
if (al.id == id) {
return al.description;
}
}
return "UNKNOWN ALERT (" + (id & 0x0FF) + ")";
}
SSLException createSSLException(String reason) {
return createSSLException(reason, null);
}
SSLException createSSLException(String reason, Throwable cause) {
if (reason == null) {
reason = (cause != null) ? cause.getMessage() : "";
}
if (cause instanceof IOException) {
return new SSLException(reason, cause);
} else if ((this == UNEXPECTED_MESSAGE)) {
return new SSLProtocolException(reason, cause);
} else if (handshakeOnly) {
return new SSLHandshakeException(reason, cause);
} else {
return new SSLException(reason, cause);
}
}
enum Level {
WARNING ((byte)1, "warning"),
FATAL   ((byte)2, "fatal");
final byte level;
final String description;
private Level(byte level, String description) {
this.level = level;
this.description = description;
}
static Level valueOf(byte level) {
for (Level lv : Level.values()) {
if (lv.level == level) {
return lv;
}
}
return null;
}
static String nameOf(byte level) {
for (Level lv : Level.values()) {
if (lv.level == level) {
return lv.description;
}
}
return "UNKNOWN ALERT LEVEL (" + (level & 0x0FF) + ")";
}
}
private static final class AlertMessage {
private final byte level;               private final byte id;
AlertMessage(TransportContext context,
ByteBuffer m) throws IOException {
if (m.remaining() != 2) {
throw context.fatal(Alert.ILLEGAL_PARAMETER,
"Invalid Alert message: no sufficient data");
}
this.level = m.get();               this.id = m.get();              }
@Override
public String toString() {
MessageFormat messageFormat = new MessageFormat(
"\"Alert\": '{'\n" +
"  \"level\"      : \"{0}\",\n" +
"  \"description\": \"{1}\"\n" +
"'}'",
Locale.ENGLISH);
Object[] messageFields = {
Level.nameOf(level),
Alert.nameOf(id)
};
return messageFormat.format(messageFields);
}
}
private static final class AlertConsumer implements SSLConsumer {
private AlertConsumer() {
}
@Override
public void consume(ConnectionContext context,
ByteBuffer m) throws IOException {
TransportContext tc = (TransportContext)context;
AlertMessage am = new AlertMessage(tc, m);
if (SSLLogger.isOn && SSLLogger.isOn("ssl")) {
SSLLogger.fine("Received alert message", am);
}
Level level = Level.valueOf(am.level);
Alert alert = Alert.valueOf(am.id);
if (alert == Alert.CLOSE_NOTIFY) {
tc.isInputCloseNotified = true;
tc.closeInbound();
if (tc.peerUserCanceled) {
tc.closeOutbound();
} else if (tc.handshakeContext != null) {
throw tc.fatal(Alert.UNEXPECTED_MESSAGE,
"Received close_notify during handshake");
}
} else if (alert == Alert.USER_CANCELED) {
if (level == Level.WARNING) {
tc.peerUserCanceled = true;
} else {
throw tc.fatal(alert,
"Received fatal close_notify alert", true, null);
}
} else if ((level == Level.WARNING) && (alert != null)) {
if (alert.handshakeOnly && (tc.handshakeContext != null)) {
if (tc.sslConfig.isClientMode ||
alert != Alert.NO_CERTIFICATE ||
(tc.sslConfig.clientAuthType !=
ClientAuthType.CLIENT_AUTH_REQUESTED)) {
throw tc.fatal(Alert.HANDSHAKE_FAILURE,
"received handshake warning: " + alert.description);
} else {
tc.handshakeContext.handshakeConsumers.remove(
SSLHandshake.CERTIFICATE.id);
tc.handshakeContext.handshakeConsumers.remove(
SSLHandshake.CERTIFICATE_VERIFY.id);
}
}              } else {                    String diagnostic;
if (alert == null) {
alert = Alert.UNEXPECTED_MESSAGE;
diagnostic = "Unknown alert description (" + am.id + ")";
} else {
diagnostic = "Received fatal alert: " + alert.description;
}
throw tc.fatal(alert, diagnostic, true, null);
}
}
}
}
package sun.security.x509;
import java.io.IOException;
import java.math.BigInteger;
import java.security.*;
import java.security.interfaces.DSAParams;
import sun.security.util.*;
public final
class AlgIdDSA extends AlgorithmId implements DSAParams
{
@java.io.Serial
private static final long serialVersionUID = 3437177836797504046L;
private BigInteger  p , q, g;
public BigInteger   getP () { return p; }
public BigInteger   getQ () { return q; }
public BigInteger   getG () { return g; }
@Deprecated
public AlgIdDSA () {}
public AlgIdDSA (BigInteger p, BigInteger q, BigInteger g) {
super (DSA_oid);
if (p != null || q != null || g != null) {
if (p == null || q == null || g == null)
throw new ProviderException("Invalid parameters for DSS/DSA" +
" Algorithm ID");
try {
this.p = p;
this.q = q;
this.g = g;
initializeParams ();
} catch (IOException e) {
throw new ProviderException ("Construct DSS/DSA Algorithm ID");
}
}
}
public String getName ()
{ return "DSA"; }
private void initializeParams () throws IOException {
DerOutputStream out = new DerOutputStream();
out.putInteger(p);
out.putInteger(q);
out.putInteger(g);
DerOutputStream result = new DerOutputStream();
result.write(DerValue.tag_Sequence, out);
encodedParams = result.toByteArray();
}
protected void decodeParams () throws IOException {
if (encodedParams == null) {
throw new IOException("DSA alg params are null");
}
DerValue params = new DerValue(encodedParams);
if (params.tag != DerValue.tag_Sequence) {
throw new IOException("DSA alg parsing error");
}
params.data.reset ();
this.p = params.data.getBigInteger();
this.q = params.data.getBigInteger();
this.g = params.data.getBigInteger();
if (params.data.available () != 0)
throw new IOException ("AlgIdDSA params, extra="+
params.data.available ());
}
public String toString () {
return paramsToString();
}
protected String paramsToString () {
if (encodedParams == null) {
return " null\n";
} else {
return "\n    p:\n" + Debug.toHexString(p) +
"\n    q:\n" + Debug.toHexString(q) +
"\n    g:\n" + Debug.toHexString(g) +
"\n";
}
}
}
package com.sun.org.apache.xml.internal.security.algorithms;
import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
import com.sun.org.apache.xml.internal.security.utils.Constants;
import com.sun.org.apache.xml.internal.security.utils.SignatureElementProxy;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
public abstract class Algorithm extends SignatureElementProxy {
public Algorithm(Document doc, String algorithmURI) {
super(doc);
this.setAlgorithmURI(algorithmURI);
}
public Algorithm(Element element, String baseURI) throws XMLSecurityException {
super(element, baseURI);
}
public String getAlgorithmURI() {
return getLocalAttribute(Constants._ATT_ALGORITHM);
}
protected void setAlgorithmURI(String algorithmURI) {
if (algorithmURI != null) {
setLocalAttribute(Constants._ATT_ALGORITHM, algorithmURI);
}
}
}
package com.sun.org.apache.xml.internal.security.exceptions;
public class AlgorithmAlreadyRegisteredException extends XMLSecurityException {
private static final long serialVersionUID = 1L;
public AlgorithmAlreadyRegisteredException() {
super();
}
public AlgorithmAlreadyRegisteredException(String msgID) {
super(msgID);
}
public AlgorithmAlreadyRegisteredException(String msgID, Object[] exArgs) {
super(msgID, exArgs);
}
public AlgorithmAlreadyRegisteredException(Exception originalException, String msgID) {
super(originalException, msgID);
}
@Deprecated
public AlgorithmAlreadyRegisteredException(String msgID, Exception originalException) {
this(originalException, msgID);
}
public AlgorithmAlreadyRegisteredException(
Exception originalException, String msgID, Object[] exArgs
) {
super(originalException, msgID, exArgs);
}
@Deprecated
public AlgorithmAlreadyRegisteredException(String msgID, Object[] exArgs, Exception originalException) {
this(originalException, msgID, exArgs);
}
}
package sun.security.provider.certpath;
import java.security.AlgorithmConstraints;
import java.security.CryptoPrimitive;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Set;
import java.util.EnumSet;
import java.math.BigInteger;
import java.security.PublicKey;
import java.security.KeyFactory;
import java.security.AlgorithmParameters;
import java.security.GeneralSecurityException;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.security.cert.PKIXCertPathChecker;
import java.security.cert.TrustAnchor;
import java.security.cert.CRLException;
import java.security.cert.CertificateException;
import java.security.cert.CertPathValidatorException;
import java.security.cert.CertPathValidatorException.BasicReason;
import java.security.cert.PKIXReason;
import java.security.interfaces.DSAParams;
import java.security.interfaces.DSAPublicKey;
import java.security.spec.DSAPublicKeySpec;
import sun.security.util.ConstraintsParameters;
import sun.security.util.Debug;
import sun.security.util.DisabledAlgorithmConstraints;
import sun.security.validator.Validator;
import sun.security.x509.AlgorithmId;
import sun.security.x509.X509CertImpl;
public final class AlgorithmChecker extends PKIXCertPathChecker {
private static final Debug debug = Debug.getInstance("certpath");
private final AlgorithmConstraints constraints;
private final Date date;
private final String variant;
private PublicKey trustedPubKey;
private PublicKey prevPubKey;
private TrustAnchor anchor;
private static final Set<CryptoPrimitive> SIGNATURE_PRIMITIVE_SET =
Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
private static final Set<CryptoPrimitive> KU_PRIMITIVE_SET =
Collections.unmodifiableSet(EnumSet.of(
CryptoPrimitive.SIGNATURE,
CryptoPrimitive.KEY_ENCAPSULATION,
CryptoPrimitive.PUBLIC_KEY_ENCRYPTION,
CryptoPrimitive.KEY_AGREEMENT));
public AlgorithmChecker(TrustAnchor anchor, String variant) {
this(anchor, null, null, variant);
}
public AlgorithmChecker(AlgorithmConstraints constraints, String variant) {
this(null, constraints, null, variant);
}
public AlgorithmChecker(TrustAnchor anchor,
AlgorithmConstraints constraints, Date date, String variant) {
if (anchor != null) {
setTrustAnchorAndKeys(anchor);
}
this.constraints = constraints == null ?
DisabledAlgorithmConstraints.certPathConstraints() : constraints;
this.date = date;
this.variant = (variant == null ? Validator.VAR_GENERIC : variant);
}
public AlgorithmChecker(TrustAnchor anchor, Date date, String variant) {
this(anchor, null, date, variant);
}
@Override
public void init(boolean forward) throws CertPathValidatorException {
if (!forward) {
prevPubKey = trustedPubKey;
} else {
throw new
CertPathValidatorException("forward checking not supported");
}
}
@Override
public boolean isForwardCheckingSupported() {
return false;
}
@Override
public Set<String> getSupportedExtensions() {
return null;
}
@Override
public void check(Certificate cert,
Collection<String> unresolvedCritExts)
throws CertPathValidatorException {
if (!(cert instanceof X509Certificate)) {
return;
}
boolean[] keyUsage = ((X509Certificate) cert).getKeyUsage();
if (keyUsage != null && keyUsage.length < 9) {
throw new CertPathValidatorException(
"incorrect KeyUsage extension",
null, null, -1, PKIXReason.INVALID_KEY_USAGE);
}
X509CertImpl x509Cert;
AlgorithmId algorithmId;
try {
x509Cert = X509CertImpl.toImpl((X509Certificate)cert);
algorithmId = (AlgorithmId)x509Cert.get(X509CertImpl.SIG_ALG);
} catch (CertificateException ce) {
throw new CertPathValidatorException(ce);
}
AlgorithmParameters currSigAlgParams = algorithmId.getParameters();
PublicKey currPubKey = cert.getPublicKey();
String currSigAlg = x509Cert.getSigAlgName();
if (constraints instanceof DisabledAlgorithmConstraints) {
DisabledAlgorithmConstraints dac =
(DisabledAlgorithmConstraints)constraints;
if (prevPubKey != null && prevPubKey == trustedPubKey) {
CertPathConstraintsParameters cp =
new CertPathConstraintsParameters(trustedPubKey, variant,
anchor, date);
dac.permits(trustedPubKey.getAlgorithm(), cp, true);
}
CertPathConstraintsParameters cp =
new CertPathConstraintsParameters(x509Cert, variant,
anchor, date);
dac.permits(currSigAlg, currSigAlgParams, cp, true);
} else {
if (prevPubKey != null) {
if (!constraints.permits(SIGNATURE_PRIMITIVE_SET,
currSigAlg, prevPubKey, currSigAlgParams)) {
throw new CertPathValidatorException(
"Algorithm constraints check failed on " +
currSigAlg + "signature and " +
currPubKey.getAlgorithm() + " key with size of " +
sun.security.util.KeyUtil.getKeySize(currPubKey) +
"bits",
null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
}
} else {
if (!constraints.permits(SIGNATURE_PRIMITIVE_SET,
currSigAlg, currSigAlgParams)) {
throw new CertPathValidatorException(
"Algorithm constraints check failed on " +
"signature algorithm: " + currSigAlg,
null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
}
}
Set<CryptoPrimitive> primitives = KU_PRIMITIVE_SET;
if (keyUsage != null) {
primitives = EnumSet.noneOf(CryptoPrimitive.class);
if (keyUsage[0] || keyUsage[1] || keyUsage[5] || keyUsage[6]) {
primitives.add(CryptoPrimitive.SIGNATURE);
}
if (keyUsage[2]) {                          primitives.add(CryptoPrimitive.KEY_ENCAPSULATION);
}
if (keyUsage[3]) {                          primitives.add(CryptoPrimitive.PUBLIC_KEY_ENCRYPTION);
}
if (keyUsage[4]) {                          primitives.add(CryptoPrimitive.KEY_AGREEMENT);
}
if (primitives.isEmpty()) {
throw new CertPathValidatorException(
"incorrect KeyUsage extension bits",
null, null, -1, PKIXReason.INVALID_KEY_USAGE);
}
}
if (!constraints.permits(primitives, currPubKey)) {
throw new CertPathValidatorException(
"Algorithm constraints check failed on " +
currPubKey.getAlgorithm() + " key with size of " +
sun.security.util.KeyUtil.getKeySize(currPubKey) +
"bits",
null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
}
}
if (prevPubKey != null) {
if (PKIX.isDSAPublicKeyWithoutParams(currPubKey)) {
if (!(prevPubKey instanceof DSAPublicKey)) {
throw new CertPathValidatorException("Input key is not " +
"of a appropriate type for inheriting parameters");
}
DSAParams params = ((DSAPublicKey)prevPubKey).getParams();
if (params == null) {
throw new CertPathValidatorException(
"Key parameters missing from public key.");
}
try {
BigInteger y = ((DSAPublicKey)currPubKey).getY();
KeyFactory kf = KeyFactory.getInstance("DSA");
DSAPublicKeySpec ks = new DSAPublicKeySpec(y, params.getP(),
params.getQ(), params.getG());
currPubKey = kf.generatePublic(ks);
} catch (GeneralSecurityException e) {
throw new CertPathValidatorException("Unable to generate " +
"key with inherited parameters: " +
e.getMessage(), e);
}
}
}
prevPubKey = currPubKey;
}
private void setTrustAnchorAndKeys(TrustAnchor anchor) {
if (anchor.getTrustedCert() != null) {
this.trustedPubKey = anchor.getTrustedCert().getPublicKey();
} else {
this.trustedPubKey = anchor.getCAPublicKey();
}
this.anchor = anchor;
this.prevPubKey = this.trustedPubKey;
}
void trySetTrustAnchor(TrustAnchor anchor) {
if (this.trustedPubKey == null) {
setTrustAnchorAndKeys(anchor);
}
}
static void check(PublicKey key, AlgorithmId algorithmId, String variant,
TrustAnchor anchor) throws CertPathValidatorException {
DisabledAlgorithmConstraints.certPathConstraints().permits(
algorithmId.getName(), algorithmId.getParameters(),
new CertPathConstraintsParameters(key, variant, anchor, null), true);
}
}
package java.security;
import java.util.Set;
public interface AlgorithmConstraints {
boolean permits(Set<CryptoPrimitive> primitives,
String algorithm, AlgorithmParameters parameters);
boolean permits(Set<CryptoPrimitive> primitives, Key key);
boolean permits(Set<CryptoPrimitive> primitives,
String algorithm, Key key, AlgorithmParameters parameters);
}
package sun.security.util;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Arrays;
import java.util.Collection;
import java.util.regex.Pattern;
public class AlgorithmDecomposer {
private static final Pattern PATTERN =
Pattern.compile("with|and|(?<!padd)in", Pattern.CASE_INSENSITIVE);
private static final Map<String, String> DECOMPOSED_DIGEST_NAMES =
Map.of("SHA-1", "SHA1", "SHA-224", "SHA224", "SHA-256", "SHA256",
"SHA-384", "SHA384", "SHA-512", "SHA512", "SHA-512/224",
"SHA512/224", "SHA-512/256", "SHA512/256");
private static Set<String> decomposeImpl(String algorithm) {
Set<String> elements = new HashSet<>();
String[] transTokens = algorithm.split("/");
for (String transToken : transTokens) {
if (transToken.isEmpty()) {
continue;
}
String[] tokens = PATTERN.split(transToken);
for (String token : tokens) {
if (token.isEmpty()) {
continue;
}
elements.add(token);
}
}
return elements;
}
public Set<String> decompose(String algorithm) {
if (algorithm == null || algorithm.isEmpty()) {
return new HashSet<>();
}
Set<String> elements = decomposeImpl(algorithm);
if (!algorithm.contains("SHA")) {
return elements;
}
for (Map.Entry<String, String> e : DECOMPOSED_DIGEST_NAMES.entrySet()) {
if (elements.contains(e.getValue()) &&
!elements.contains(e.getKey())) {
elements.add(e.getKey());
} else if (elements.contains(e.getKey()) &&
!elements.contains(e.getValue())) {
elements.add(e.getValue());
}
}
return elements;
}
public static Collection<String> getAliases(String algorithm) {
String[] aliases;
if (algorithm.equalsIgnoreCase("DH") ||
algorithm.equalsIgnoreCase("DiffieHellman")) {
aliases = new String[] {"DH", "DiffieHellman"};
} else {
aliases = new String[] {algorithm};
}
return Arrays.asList(aliases);
}
static Set<String> decomposeName(String algorithm) {
if (algorithm == null || algorithm.isEmpty()) {
return new HashSet<>();
}
Set<String> elements = decomposeImpl(algorithm);
if (!algorithm.contains("SHA")) {
return elements;
}
for (Map.Entry<String, String> e : DECOMPOSED_DIGEST_NAMES.entrySet()) {
if (elements.contains(e.getKey())) {
if (!elements.contains(e.getValue())) {
elements.add(e.getValue());
}
elements.remove(e.getKey());
}
}
return elements;
}
static String decomposeDigestName(String algorithm) {
return DECOMPOSED_DIGEST_NAMES.getOrDefault(algorithm, algorithm);
}
}
package sun.security.x509;
import java.io.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.security.*;
import sun.security.util.*;
public class AlgorithmId implements Serializable, DerEncoder {
@java.io.Serial
private static final long serialVersionUID = 7205873507486557157L;
private ObjectIdentifier algid;
@SuppressWarnings("serial")     private AlgorithmParameters algParams;
protected transient byte[] encodedParams;
@Deprecated
public AlgorithmId() { }
public AlgorithmId(ObjectIdentifier oid) {
algid = oid;
}
public AlgorithmId(ObjectIdentifier oid, AlgorithmParameters algparams) {
algid = oid;
this.algParams = algparams;
if (algParams != null) {
try {
encodedParams = algParams.getEncoded();
} catch (IOException ioe) {
}
}
}
public AlgorithmId(ObjectIdentifier oid, DerValue params)
throws IOException {
this.algid = oid;
if (params != null) {
encodedParams = params.toByteArray();
decodeParams();
}
}
protected void decodeParams() throws IOException {
String algidName = getName();
try {
algParams = AlgorithmParameters.getInstance(algidName);
} catch (NoSuchAlgorithmException e) {
algParams = null;
return;
}
algParams.init(encodedParams.clone());
}
public final void encode(DerOutputStream out) throws IOException {
derEncode(out);
}
@Override
public void derEncode (OutputStream out) throws IOException {
DerOutputStream bytes = new DerOutputStream();
DerOutputStream tmp = new DerOutputStream();
bytes.putOID(algid);
if (algParams != null && encodedParams == null) {
encodedParams = algParams.getEncoded();
}
if (encodedParams == null) {
if (algid.equals(RSASSA_PSS_oid) || algid.equals(ed448_oid)
|| algid.equals(ed25519_oid)
|| algid.equals(x448_oid)
|| algid.equals(x25519_oid)
|| algid.equals(SHA1withECDSA_oid)
|| algid.equals(SHA224withECDSA_oid)
|| algid.equals(SHA256withECDSA_oid)
|| algid.equals(SHA384withECDSA_oid)
|| algid.equals(SHA512withECDSA_oid)) {
} else {
bytes.putNull();
}
} else {
bytes.write(encodedParams);
}
tmp.write(DerValue.tag_Sequence, bytes);
out.write(tmp.toByteArray());
}
public final byte[] encode() throws IOException {
DerOutputStream out = new DerOutputStream();
derEncode(out);
return out.toByteArray();
}
public final ObjectIdentifier getOID () {
return algid;
}
public String getName() {
String oidStr = algid.toString();
KnownOIDs o = KnownOIDs.findMatch(oidStr);
if (o == KnownOIDs.SpecifiedSHA2withECDSA) {
if (encodedParams != null) {
try {
AlgorithmId digestParams =
AlgorithmId.parse(new DerValue(encodedParams));
String digestAlg = digestParams.getName();
return digestAlg.replace("-", "") + "withECDSA";
} catch (IOException e) {
}
}
} else if (o == KnownOIDs.PBES2) {
if (algParams != null) {
return algParams.toString();
} else {
}
}
if (o != null) {
return o.stdName();
} else {
String n = aliasOidsTable().get(oidStr);
if (n != null) {
return n;
} else {
return algid.toString();
}
}
}
public AlgorithmParameters getParameters() {
return algParams;
}
public byte[] getEncodedParams() {
return (encodedParams == null ||
algid.toString().equals(KnownOIDs.SpecifiedSHA2withECDSA.value()))
? null
: encodedParams.clone();
}
public boolean equals(AlgorithmId other) {
return algid.equals((Object)other.algid) &&
Arrays.equals(encodedParams, other.encodedParams);
}
@Override
public boolean equals(Object other) {
if (this == other) {
return true;
}
if (other instanceof AlgorithmId) {
return equals((AlgorithmId) other);
} else if (other instanceof ObjectIdentifier) {
return equals((ObjectIdentifier) other);
} else {
return false;
}
}
public final boolean equals(ObjectIdentifier id) {
return algid.equals((Object)id);
}
@Override
public int hashCode() {
int hashCode = algid.hashCode();
hashCode = 31 * hashCode + Arrays.hashCode(encodedParams);
return hashCode;
}
protected String paramsToString() {
if (encodedParams == null) {
return "";
} else if (algParams != null) {
return ", " + algParams.toString();
} else {
return ", params unparsed";
}
}
@Override
public String toString() {
return getName() + paramsToString();
}
public static AlgorithmId parse(DerValue val) throws IOException {
if (val.tag != DerValue.tag_Sequence) {
throw new IOException("algid parse error, not a sequence");
}
ObjectIdentifier        algid;
DerValue                params;
DerInputStream          in = val.toDerInputStream();
algid = in.getOID();
if (in.available() == 0) {
params = null;
} else {
params = in.getDerValue();
if (params.tag == DerValue.tag_Null) {
if (params.length() != 0) {
throw new IOException("invalid NULL");
}
params = null;
}
if (in.available() != 0) {
throw new IOException("Invalid AlgorithmIdentifier: extra data");
}
}
return new AlgorithmId(algid, params);
}
@Deprecated
public static AlgorithmId getAlgorithmId(String algname)
throws NoSuchAlgorithmException {
return get(algname);
}
public static AlgorithmId get(String algname)
throws NoSuchAlgorithmException {
ObjectIdentifier oid;
try {
oid = algOID(algname);
} catch (IOException ioe) {
throw new NoSuchAlgorithmException
("Invalid ObjectIdentifier " + algname);
}
if (oid == null) {
throw new NoSuchAlgorithmException
("unrecognized algorithm name: " + algname);
}
return new AlgorithmId(oid);
}
public static AlgorithmId get(AlgorithmParameters algparams)
throws NoSuchAlgorithmException {
ObjectIdentifier oid;
String algname = algparams.getAlgorithm();
try {
oid = algOID(algname);
} catch (IOException ioe) {
throw new NoSuchAlgorithmException
("Invalid ObjectIdentifier " + algname);
}
if (oid == null) {
throw new NoSuchAlgorithmException
("unrecognized algorithm name: " + algname);
}
return new AlgorithmId(oid, algparams);
}
private static ObjectIdentifier algOID(String name) throws IOException {
if (name.startsWith("OID.")) {
name = name.substring("OID.".length());
}
KnownOIDs k = KnownOIDs.findMatch(name);
if (k != null) {
return ObjectIdentifier.of(k);
}
if (!name.contains(".")) {
name = name.toUpperCase(Locale.ENGLISH);
String oidStr = aliasOidsTable().get(name);
if (oidStr != null) {
return ObjectIdentifier.of(oidStr);
} return null;
} else {
return ObjectIdentifier.of(name);
}
}
private static volatile Map<String,String> aliasOidsTable;
public static void clearAliasOidsTable() {
aliasOidsTable = null;
}
private static Map<String,String> aliasOidsTable() {
Map<String,String> tab = aliasOidsTable;
if (tab == null) {
synchronized (AlgorithmId.class) {
if ((tab = aliasOidsTable) == null) {
aliasOidsTable = tab = collectOIDAliases();
}
}
}
return tab;
}
private static boolean isKnownProvider(Provider p) {
String pn = p.getName();
String mn = p.getClass().getModule().getName();
if (pn != null && mn != null) {
return ((mn.equals("java.base") &&
(pn.equals("SUN") || pn.equals("SunRsaSign") ||
pn.equals("SunJCE") || pn.equals("SunJSSE"))) ||
(mn.equals("jdk.crypto.ec") && pn.equals("SunEC")) ||
(mn.equals("jdk.crypto.mscapi") && pn.equals("SunMSCAPI")) ||
(mn.equals("jdk.crypto.cryptoki") &&
pn.startsWith("SunPKCS11")));
} else {
return false;
}
}
private static ConcurrentHashMap<String, String> collectOIDAliases() {
ConcurrentHashMap<String, String> t = new ConcurrentHashMap<>();
for (Provider provider : Security.getProviders()) {
if (isKnownProvider(provider)) {
continue;
}
for (Object key : provider.keySet()) {
String alias = (String)key;
String upperCaseAlias = alias.toUpperCase(Locale.ENGLISH);
int index;
if (upperCaseAlias.startsWith("ALG.ALIAS") &&
(index = upperCaseAlias.indexOf("OID.")) != -1) {
index += "OID.".length();
if (index == alias.length()) {
break;
}
String ostr = alias.substring(index);
String stdAlgName = provider.getProperty(alias);
if (stdAlgName != null) {
stdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);
}
if (KnownOIDs.findMatch(stdAlgName) == null) {
t.putIfAbsent(stdAlgName, ostr);
}
if (KnownOIDs.findMatch(ostr) == null) {
t.putIfAbsent(ostr, stdAlgName);
}
}
}
}
return t;
}
public static final ObjectIdentifier MD2_oid =
ObjectIdentifier.of(KnownOIDs.MD2);
public static final ObjectIdentifier MD5_oid =
ObjectIdentifier.of(KnownOIDs.MD5);
public static final ObjectIdentifier SHA_oid =
ObjectIdentifier.of(KnownOIDs.SHA_1);
public static final ObjectIdentifier SHA224_oid =
ObjectIdentifier.of(KnownOIDs.SHA_224);
public static final ObjectIdentifier SHA256_oid =
ObjectIdentifier.of(KnownOIDs.SHA_256);
public static final ObjectIdentifier SHA384_oid =
ObjectIdentifier.of(KnownOIDs.SHA_384);
public static final ObjectIdentifier SHA512_oid =
ObjectIdentifier.of(KnownOIDs.SHA_512);
public static final ObjectIdentifier SHA512_224_oid =
ObjectIdentifier.of(KnownOIDs.SHA_512$224);
public static final ObjectIdentifier SHA512_256_oid =
ObjectIdentifier.of(KnownOIDs.SHA_512$256);
public static final ObjectIdentifier SHA3_224_oid =
ObjectIdentifier.of(KnownOIDs.SHA3_224);
public static final ObjectIdentifier SHA3_256_oid =
ObjectIdentifier.of(KnownOIDs.SHA3_256);
public static final ObjectIdentifier SHA3_384_oid =
ObjectIdentifier.of(KnownOIDs.SHA3_384);
public static final ObjectIdentifier SHA3_512_oid =
ObjectIdentifier.of(KnownOIDs.SHA3_512);
public static final ObjectIdentifier DSA_oid =
ObjectIdentifier.of(KnownOIDs.DSA);
public static final ObjectIdentifier EC_oid =
ObjectIdentifier.of(KnownOIDs.EC);
public static final ObjectIdentifier RSAEncryption_oid =
ObjectIdentifier.of(KnownOIDs.RSA);
public static final ObjectIdentifier RSASSA_PSS_oid =
ObjectIdentifier.of(KnownOIDs.RSASSA_PSS);
public static final ObjectIdentifier MGF1_oid =
ObjectIdentifier.of(KnownOIDs.MGF1);
public static final ObjectIdentifier ed25519_oid =
ObjectIdentifier.of(KnownOIDs.Ed25519);
public static final ObjectIdentifier ed448_oid =
ObjectIdentifier.of(KnownOIDs.Ed448);
public static final ObjectIdentifier x25519_oid =
ObjectIdentifier.of(KnownOIDs.X25519);
public static final ObjectIdentifier x448_oid =
ObjectIdentifier.of(KnownOIDs.X448);
public static final ObjectIdentifier SHA1withECDSA_oid =
ObjectIdentifier.of(KnownOIDs.SHA1withECDSA);
public static final ObjectIdentifier SHA224withECDSA_oid =
ObjectIdentifier.of(KnownOIDs.SHA224withECDSA);
public static final ObjectIdentifier SHA256withECDSA_oid =
ObjectIdentifier.of(KnownOIDs.SHA256withECDSA);
public static final ObjectIdentifier SHA384withECDSA_oid =
ObjectIdentifier.of(KnownOIDs.SHA384withECDSA);
public static final ObjectIdentifier SHA512withECDSA_oid =
ObjectIdentifier.of(KnownOIDs.SHA512withECDSA);
}
package javax.xml.crypto;
import java.security.spec.AlgorithmParameterSpec;
public interface AlgorithmMethod {
String getAlgorithm();
AlgorithmParameterSpec getParameterSpec();
}
package java.security;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Objects;
import sun.security.jca.JCAUtil;
public class AlgorithmParameterGenerator {
private final Provider provider;
private final AlgorithmParameterGeneratorSpi paramGenSpi;
private final String algorithm;
protected AlgorithmParameterGenerator
(AlgorithmParameterGeneratorSpi paramGenSpi, Provider provider,
String algorithm) {
this.paramGenSpi = paramGenSpi;
this.provider = provider;
this.algorithm = algorithm;
}
public final String getAlgorithm() {
return this.algorithm;
}
public static AlgorithmParameterGenerator getInstance(String algorithm)
throws NoSuchAlgorithmException {
Objects.requireNonNull(algorithm, "null algorithm name");
try {
Object[] objs = Security.getImpl(algorithm,
"AlgorithmParameterGenerator",
(String)null);
return new AlgorithmParameterGenerator
((AlgorithmParameterGeneratorSpi)objs[0],
(Provider)objs[1],
algorithm);
} catch(NoSuchProviderException e) {
throw new NoSuchAlgorithmException(algorithm + " not found");
}
}
public static AlgorithmParameterGenerator getInstance(String algorithm,
String provider)
throws NoSuchAlgorithmException, NoSuchProviderException
{
Objects.requireNonNull(algorithm, "null algorithm name");
if (provider == null || provider.isEmpty())
throw new IllegalArgumentException("missing provider");
Object[] objs = Security.getImpl(algorithm,
"AlgorithmParameterGenerator",
provider);
return new AlgorithmParameterGenerator
((AlgorithmParameterGeneratorSpi)objs[0], (Provider)objs[1],
algorithm);
}
public static AlgorithmParameterGenerator getInstance(String algorithm,
Provider provider)
throws NoSuchAlgorithmException
{
Objects.requireNonNull(algorithm, "null algorithm name");
if (provider == null)
throw new IllegalArgumentException("missing provider");
Object[] objs = Security.getImpl(algorithm,
"AlgorithmParameterGenerator",
provider);
return new AlgorithmParameterGenerator
((AlgorithmParameterGeneratorSpi)objs[0], (Provider)objs[1],
algorithm);
}
public final Provider getProvider() {
return this.provider;
}
public final void init(int size) {
paramGenSpi.engineInit(size, JCAUtil.getDefSecureRandom());
}
public final void init(int size, SecureRandom random) {
paramGenSpi.engineInit(size, random);
}
public final void init(AlgorithmParameterSpec genParamSpec)
throws InvalidAlgorithmParameterException {
paramGenSpi.engineInit(genParamSpec, JCAUtil.getDefSecureRandom());
}
public final void init(AlgorithmParameterSpec genParamSpec,
SecureRandom random)
throws InvalidAlgorithmParameterException {
paramGenSpi.engineInit(genParamSpec, random);
}
public final AlgorithmParameters generateParameters() {
return paramGenSpi.engineGenerateParameters();
}
}
package java.security;
import java.security.spec.AlgorithmParameterSpec;
public abstract class AlgorithmParameterGeneratorSpi {
public AlgorithmParameterGeneratorSpi() {}
protected abstract void engineInit(int size, SecureRandom random);
protected abstract void engineInit(AlgorithmParameterSpec genParamSpec,
SecureRandom random)
throws InvalidAlgorithmParameterException;
protected abstract AlgorithmParameters engineGenerateParameters();
}
package java.security;
import java.io.*;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.InvalidParameterSpecException;
import java.util.Objects;
public class AlgorithmParameters {
private final Provider provider;
private final AlgorithmParametersSpi paramSpi;
private final String algorithm;
private boolean initialized = false;
protected AlgorithmParameters(AlgorithmParametersSpi paramSpi,
Provider provider, String algorithm)
{
this.paramSpi = paramSpi;
this.provider = provider;
this.algorithm = algorithm;
}
public final String getAlgorithm() {
return this.algorithm;
}
public static AlgorithmParameters getInstance(String algorithm)
throws NoSuchAlgorithmException {
Objects.requireNonNull(algorithm, "null algorithm name");
try {
Object[] objs = Security.getImpl(algorithm, "AlgorithmParameters",
(String)null);
return new AlgorithmParameters((AlgorithmParametersSpi)objs[0],
(Provider)objs[1],
algorithm);
} catch(NoSuchProviderException e) {
throw new NoSuchAlgorithmException(algorithm + " not found");
}
}
public static AlgorithmParameters getInstance(String algorithm,
String provider)
throws NoSuchAlgorithmException, NoSuchProviderException
{
Objects.requireNonNull(algorithm, "null algorithm name");
if (provider == null || provider.isEmpty())
throw new IllegalArgumentException("missing provider");
Object[] objs = Security.getImpl(algorithm, "AlgorithmParameters",
provider);
return new AlgorithmParameters((AlgorithmParametersSpi)objs[0],
(Provider)objs[1],
algorithm);
}
public static AlgorithmParameters getInstance(String algorithm,
Provider provider)
throws NoSuchAlgorithmException
{
Objects.requireNonNull(algorithm, "null algorithm name");
if (provider == null)
throw new IllegalArgumentException("missing provider");
Object[] objs = Security.getImpl(algorithm, "AlgorithmParameters",
provider);
return new AlgorithmParameters((AlgorithmParametersSpi)objs[0],
(Provider)objs[1],
algorithm);
}
public final Provider getProvider() {
return this.provider;
}
public final void init(AlgorithmParameterSpec paramSpec)
throws InvalidParameterSpecException
{
if (this.initialized)
throw new InvalidParameterSpecException("already initialized");
paramSpi.engineInit(paramSpec);
this.initialized = true;
}
public final void init(byte[] params) throws IOException {
if (this.initialized)
throw new IOException("already initialized");
paramSpi.engineInit(params);
this.initialized = true;
}
public final void init(byte[] params, String format) throws IOException {
if (this.initialized)
throw new IOException("already initialized");
paramSpi.engineInit(params, format);
this.initialized = true;
}
public final <T extends AlgorithmParameterSpec>
T getParameterSpec(Class<T> paramSpec)
throws InvalidParameterSpecException
{
if (!this.initialized) {
throw new InvalidParameterSpecException("not initialized");
}
return paramSpi.engineGetParameterSpec(paramSpec);
}
public final byte[] getEncoded() throws IOException
{
if (!this.initialized) {
throw new IOException("not initialized");
}
return paramSpi.engineGetEncoded();
}
public final byte[] getEncoded(String format) throws IOException
{
if (!this.initialized) {
throw new IOException("not initialized");
}
return paramSpi.engineGetEncoded(format);
}
public final String toString() {
if (!this.initialized) {
return null;
}
return paramSpi.engineToString();
}
}
package java.security.spec;
public interface AlgorithmParameterSpec { }
package java.security;
import java.io.*;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.InvalidParameterSpecException;
public abstract class AlgorithmParametersSpi {
public AlgorithmParametersSpi() {}
protected abstract void engineInit(AlgorithmParameterSpec paramSpec)
throws InvalidParameterSpecException;
protected abstract void engineInit(byte[] params)
throws IOException;
protected abstract void engineInit(byte[] params, String format)
throws IOException;
protected abstract
<T extends AlgorithmParameterSpec>
T engineGetParameterSpec(Class<T> paramSpec)
throws InvalidParameterSpecException;
protected abstract byte[] engineGetEncoded() throws IOException;
protected abstract byte[] engineGetEncoded(String format)
throws IOException;
protected abstract String engineToString();
}
package build.tools.cldrconverter;
class AliasEntry extends StringEntry {
AliasEntry(String qName, Container parent, String key) {
super(qName, parent, key);
}
AliasEntry(String qName, Container parent, String key, String value) {
super(qName, parent, key, value);
}
}
package sun.jvmstat.perfdata.monitor;
import java.net.*;
import java.io.*;
import java.util.*;
public class AliasFileParser {
private static final String ALIAS = "alias";
private URL inputfile;
private StreamTokenizer st;
private Token currentToken;
AliasFileParser(URL inputfile) {
this.inputfile = inputfile;
}
private class Token {
public String sval;
public int ttype;
public Token(int ttype, String sval) {
this.ttype = ttype;
this.sval = sval;
}
}
private void nextToken() throws IOException {
st.nextToken();
currentToken = new Token(st.ttype, st.sval);
}
private void match(int ttype, String token)
throws IOException, SyntaxException {
if ((currentToken.ttype == ttype)
&& (currentToken.sval.compareTo(token) == 0)) {
nextToken();
} else {
throw new SyntaxException(st.lineno());
}
}
private void match(int ttype) throws IOException, SyntaxException {
if (currentToken.ttype == ttype) {
nextToken();
} else {
throw new SyntaxException(st.lineno());
}
}
private void match(String token) throws IOException, SyntaxException {
match(StreamTokenizer.TT_WORD, token);
}
public void parse(Map<String, ArrayList<String>> map) throws SyntaxException, IOException {
if (inputfile == null) {
return;
}
BufferedReader r = new BufferedReader(
new InputStreamReader(inputfile.openStream()));
st = new StreamTokenizer(r);
st.slashSlashComments(true);
st.slashStarComments(true);
st.wordChars('_','_');
nextToken();
while (currentToken.ttype != StreamTokenizer.TT_EOF) {
if ((currentToken.ttype != StreamTokenizer.TT_WORD)
|| !currentToken.sval.equals(ALIAS)) {
nextToken();
continue;
}
match(ALIAS);
String name = currentToken.sval;
match(StreamTokenizer.TT_WORD);
ArrayList<String> aliases = new ArrayList<String>();
do {
aliases.add(currentToken.sval);
match(StreamTokenizer.TT_WORD);
} while ((currentToken.ttype != StreamTokenizer.TT_EOF)
&& !currentToken.sval.equals(ALIAS));
map.put(name, aliases);
}
}
}
package com.sun.java.swing.action;
import javax.swing.KeyStroke;
public class AlignCenterAction extends StateChangeAction
{
public AlignCenterAction()
{
this("text/AlignCenter16.gif");
}
public AlignCenterAction(String iconPath)
{
super("Center", ActionManager.getIcon(iconPath));
putValue("ActionCommandKey", "align-center-command");
putValue("ShortDescription", "Center");
putValue("LongDescription", "Adjust the placement of text to the center of the line");
putValue("MnemonicKey", VALUE_MNEMONIC);
putValue("AcceleratorKey", VALUE_ACCELERATOR);
}
public static final String VALUE_COMMAND = "align-center-command";
public static final String VALUE_NAME = "Center";
public static final String VALUE_SMALL_ICON = "text/AlignCenter16.gif";
public static final String VALUE_LARGE_ICON = "text/AlignCenter24.gif";
public static final Integer VALUE_MNEMONIC = 78;
public static final KeyStroke VALUE_ACCELERATOR = KeyStroke.getKeyStroke(69, 2);
public static final String VALUE_SHORT_DESCRIPTION = "Center";
public static final String VALUE_LONG_DESCRIPTION = "Adjust the placement of text to the center of the line";
}
package com.sun.java.swing.action;
import javax.swing.KeyStroke;
public class AlignLeftAction extends StateChangeAction
{
public AlignLeftAction()
{
this("text/AlignLeft16.gif");
}
public AlignLeftAction(String iconPath)
{
super("Left Align", ActionManager.getIcon(iconPath));
putValue("ActionCommandKey", "align-left-command");
putValue("ShortDescription", "Left Align");
putValue("LongDescription", "Adjust the placement of text along the left edge");
putValue("MnemonicKey", VALUE_MNEMONIC);
putValue("AcceleratorKey", VALUE_ACCELERATOR);
}
public static final String VALUE_COMMAND = "align-left-command";
public static final String VALUE_NAME = "Left Align";
public static final String VALUE_SMALL_ICON = "text/AlignLeft16.gif";
public static final String VALUE_LARGE_ICON = "text/AlignLeft24.gif";
public static final Integer VALUE_MNEMONIC = 76;
public static final KeyStroke VALUE_ACCELERATOR = KeyStroke.getKeyStroke(76, 2);
public static final String VALUE_SHORT_DESCRIPTION = "Left Align";
public static final String VALUE_LONG_DESCRIPTION = "Adjust the placement of text along the left edge";
}
package sun.tools.jstat;
import java.util.*;
public abstract class Alignment {
private static int nextOrdinal = 0;
private static HashMap<String, Alignment> map = new HashMap<String, Alignment>();
private static final String blanks = "                                                                                                                                                               ";
private final String name;
private final int value = nextOrdinal++;
protected abstract String align(String s, int width);
public static final Alignment CENTER = new Alignment("center") {
protected String align(String s, int width) {
int length = s.length();
if (length >= width) {
return s;
}
int pad = width - length;
int pad2 = pad / 2;
int padr = pad % 2;
if (pad2 == 0) {
return s + blanks.substring(0, padr);
} else {
return  blanks.substring(0, pad2) + s +
blanks.substring(0, pad2 + padr);
}
}
};
public static final Alignment LEFT = new Alignment("left") {
protected String align(String s, int width) {
int length = s.length();
if (length >= width) {
return s;
}
int pad = width - length;
return s+blanks.substring(0, pad);
}
};
public static final Alignment RIGHT = new Alignment("right") {
protected String align(String s, int width) {
int length = s.length();
if (length >= width) {
return s;
}
int pad = width - length;
return blanks.substring(0, pad) + s;
}
};
public static Alignment toAlignment(String s) {
return map.get(s);
}
public static Set<String> keySet() {
return map.keySet();
}
public String toString() {
return name;
}
private Alignment(String name) {
this.name = name;
map.put(name, this);
}
}
package compiler.unsafe;
import jdk.internal.misc.Unsafe;
public class AlignmentGapAccess {
private static final Unsafe UNSAFE = Unsafe.getUnsafe();
static class A           { int  fa; }
static class B extends A { byte fb; }
static final long FA_OFFSET = UNSAFE.objectFieldOffset(A.class, "fa");
static final long FB_OFFSET = UNSAFE.objectFieldOffset(B.class, "fb");
static int test(B obj) {
return UNSAFE.getInt(obj, FB_OFFSET + 1);
}
public static void main(String[] args) {
for (int i = 0; i < 20_000; i++) {
test(new B());
}
System.out.println("TEST PASSED");
}
}
package compiler.loopopts.superword;
public class AlignmentOnePack {
static int iFld;
public static void test(int[] intArr, short[] shortArr) {
for (int j = 8; j < intArr.length;j++) {
shortArr[10] = 10;
shortArr[j] = 30;
intArr[7] = 260;
intArr[j-1] = 400;
iFld = intArr[j];
}
}
public static void main(String[] args) throws Exception {
int[] a = new int[16];
short[] c = new short[16];
for (int i = 0; i < 10000; i++) {
test(a, c);
}
}
}
package com.sun.java.swing.action;
import javax.swing.KeyStroke;
public class AlignRightAction extends StateChangeAction
{
public AlignRightAction()
{
this("text/AlignRight16.gif");
}
public AlignRightAction(String iconPath)
{
super("Right Align", ActionManager.getIcon(iconPath));
putValue("ActionCommandKey", "align-right-command");
putValue("ShortDescription", "Right Align");
putValue("LongDescription", "Adjust the placement of text along the right edge");
putValue("MnemonicKey", VALUE_MNEMONIC);
putValue("AcceleratorKey", VALUE_ACCELERATOR);
}
public static final String VALUE_COMMAND = "align-right-command";
public static final String VALUE_NAME = "Right Align";
public static final String VALUE_SMALL_ICON = "text/AlignRight16.gif";
public static final String VALUE_LARGE_ICON = "text/AlignRight24.gif";
public static final Integer VALUE_MNEMONIC = 82;
public static final KeyStroke VALUE_ACCELERATOR = KeyStroke.getKeyStroke(82, 2);
public static final String VALUE_SHORT_DESCRIPTION = "Right Align";
public static final String VALUE_LONG_DESCRIPTION = "Adjust the placement of text along the right edge";
}
package compiler.vectorapi;
import compiler.lib.ir_framework.*;
import java.util.Random;
import jdk.incubator.vector.IntVector;
import jdk.incubator.vector.LongVector;
import jdk.incubator.vector.VectorMask;
import jdk.incubator.vector.VectorOperators;
import jdk.incubator.vector.VectorSpecies;
import jdk.test.lib.Asserts;
import jdk.test.lib.Utils;
public class AllBitsSetVectorMatchRuleTest {
private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;
private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;
private static int LENGTH = 128;
private static final Random RD = Utils.getRandomInstance();
private static int[] ia;
private static int[] ib;
private static int[] ir;
private static boolean[] ma;
private static boolean[] mb;
private static boolean[] mc;
private static boolean[] mr;
static {
ia = new int[LENGTH];
ib = new int[LENGTH];
ir = new int[LENGTH];
ma = new boolean[LENGTH];
mb = new boolean[LENGTH];
mc = new boolean[LENGTH];
mr = new boolean[LENGTH];
for (int i = 0; i < LENGTH; i++) {
ia[i] = RD.nextInt(25);
ib[i] = RD.nextInt(25);
ma[i] = RD.nextBoolean();
mb[i] = RD.nextBoolean();
mc[i] = RD.nextBoolean();
}
}
@Test
@Warmup(10000)
@IR(counts = { "bic", " >= 1" })
public static void testAllBitsSetVector() {
IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);
IntVector bv = IntVector.fromArray(I_SPECIES, ib, 0);
av.not().lanewise(VectorOperators.AND_NOT, bv).intoArray(ir, 0);
for (int i = 0; i < I_SPECIES.length(); i++) {
Asserts.assertEquals((~ia[i]) & (~ib[i]), ir[i]);
}
}
@Test
@Warmup(10000)
@IR(counts = { "bic", " >= 1" })
public static void testAllBitsSetMask() {
VectorMask<Long> avm = VectorMask.fromArray(L_SPECIES, ma, 0);
VectorMask<Long> bvm = VectorMask.fromArray(L_SPECIES, mb, 0);
VectorMask<Long> cvm = VectorMask.fromArray(L_SPECIES, mc, 0);
avm.andNot(bvm).andNot(cvm).intoArray(mr, 0);
for (int i = 0; i < L_SPECIES.length(); i++) {
Asserts.assertEquals((ma[i] & (!mb[i])) & (!mc[i]), mr[i]);
}
}
public static void main(String[] args) {
TestFramework.runWithFlags("--add-modules=jdk.incubator.vector");
}
}
package jdk.javadoc.internal.doclets.formats.html;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import javax.lang.model.element.TypeElement;
import com.sun.source.doctree.DeprecatedTree;
import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;
import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;
import jdk.javadoc.internal.doclets.toolkit.Content;
import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
import jdk.javadoc.internal.doclets.toolkit.util.IndexBuilder;
import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;
import jdk.javadoc.internal.doclets.toolkit.util.Utils.ElementFlag;
public class AllClassesIndexWriter extends HtmlDocletWriter {
protected IndexBuilder indexBuilder;
public AllClassesIndexWriter(HtmlConfiguration configuration,
DocPath filename, IndexBuilder indexBuilder) {
super(configuration, filename);
this.indexBuilder = indexBuilder;
}
public static void generate(HtmlConfiguration configuration,
IndexBuilder indexBuilder) throws DocFileIOException {
generate(configuration, indexBuilder, DocPaths.ALLCLASSES_INDEX);
}
private static void generate(HtmlConfiguration configuration, IndexBuilder indexBuilder,
DocPath fileName) throws DocFileIOException {
AllClassesIndexWriter allClassGen = new AllClassesIndexWriter(configuration,
fileName, indexBuilder);
allClassGen.buildAllClassesFile();
}
protected void buildAllClassesFile() throws DocFileIOException {
String label = resources.getText("doclet.All_Classes_And_Interfaces");
Content allClassesContent = new ContentBuilder();
addContents(allClassesContent);
Content mainContent = new ContentBuilder();
mainContent.add(allClassesContent);
HtmlTree body = getBody(getWindowTitle(label));
body.add(new BodyContents()
.setHeader(getHeader(PageMode.ALL_CLASSES))
.addMainContent(mainContent)
.setFooter(getFooter()));
printHtmlDocument(null, "class index", body);
}
protected void addContents(Content target) {
Table table = new Table(HtmlStyle.summaryTable)
.setHeader(new TableHeader(contents.classLabel, contents.descriptionLabel))
.setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast)
.setId(HtmlIds.ALL_CLASSES_TABLE)
.setDefaultTab(contents.allClassesAndInterfacesLabel)
.addTab(contents.interfaces, utils::isPlainInterface)
.addTab(contents.classes, e -> utils.isNonThrowableClass((TypeElement)e))
.addTab(contents.enums, utils::isEnum)
.addTab(contents.records, e -> utils.isRecord((TypeElement)e))
.addTab(contents.exceptionClasses, e -> utils.isThrowable((TypeElement)e))
.addTab(contents.annotationTypes, utils::isAnnotationInterface);
for (Character unicode : indexBuilder.getFirstCharacters()) {
for (IndexItem indexItem : indexBuilder.getItems(unicode)) {
TypeElement typeElement = (TypeElement) indexItem.getElement();
if (typeElement != null && utils.isCoreClass(typeElement)) {
addTableRow(table, typeElement);
}
}
}
Content titleContent = contents.allClassesAndInterfacesLabel;
var pHeading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,
HtmlStyle.title, titleContent);
var headerDiv = HtmlTree.DIV(HtmlStyle.header, pHeading);
target.add(headerDiv);
if (!table.isEmpty()) {
target.add(table);
}
}
protected void addTableRow(Table table, TypeElement klass) {
List<Content> rowContents = new ArrayList<>();
Content classLink = getLink(new HtmlLinkInfo(
configuration, HtmlLinkInfo.Kind.INDEX, klass));
ContentBuilder description = new ContentBuilder();
Set<ElementFlag> flags = utils.elementFlags(klass);
if (flags.contains(ElementFlag.PREVIEW)) {
description.add(contents.previewPhrase);
addSummaryComment(klass, description);
} else if (flags.contains(ElementFlag.DEPRECATED)) {
description.add(getDeprecatedPhrase(klass));
List<? extends DeprecatedTree> tags = utils.getDeprecatedTrees(klass);
if (!tags.isEmpty()) {
addSummaryDeprecatedComment(klass, tags.get(0), description);
}
} else {
addSummaryComment(klass, description);
}
rowContents.add(classLink);
rowContents.add(description);
table.addRow(klass, rowContents);
}
}
package java2d.demos.Fonts;
import static java.awt.Color.BLACK;
import static java.awt.Color.GRAY;
import static java.awt.Color.WHITE;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.GraphicsEnvironment;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;
import java2d.AnimatingControlsSurface;
import java2d.CustomControls;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JSlider;
import javax.swing.SwingConstants;
import javax.swing.border.EtchedBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
@SuppressWarnings("serial")
public class AllFonts extends AnimatingControlsSurface {
private static final List<Font> fonts = new ArrayList<Font>();
static {
GraphicsEnvironment ge =
GraphicsEnvironment.getLocalGraphicsEnvironment();
for (Font font : ge.getAllFonts()) {
if (font.canDisplayUpTo(font.getName()) != 0) {
fonts.add(font);
}
}
}
private int nStrs;
private int strH;
private int fi;
protected int fsize = 14;
protected List<Font> v = new ArrayList<Font>();
public AllFonts() {
setBackground(WHITE);
setSleepAmount(500);
setControls(new Component[] { new DemoControls(this) });
}
public void handleThread(int state) {
}
@Override
public void reset(int w, int h) {
v.clear();
Font f = fonts.get(0).deriveFont(Font.PLAIN, fsize);
FontMetrics fm = getFontMetrics(f);
strH = (fm.getAscent() + fm.getDescent());
nStrs = h / strH + 1;
fi = 0;
}
@Override
public void step(int w, int h) {
if (fi < fonts.size()) {
v.add(fonts.get(fi).deriveFont(Font.PLAIN, fsize));
}
if (v.size() == nStrs && !v.isEmpty() || fi > fonts.size()) {
v.remove(0);
}
fi = v.isEmpty() ? 0 : ++fi;
}
@Override
public void render(int w, int h, Graphics2D g2) {
g2.setColor(BLACK);
int yy = (fi >= fonts.size()) ? 0 : h - v.size() * strH - strH / 2;
for (int i = 0; i < v.size(); i++) {
Font f = v.get(i);
int sw = getFontMetrics(f).stringWidth(f.getName());
g2.setFont(f);
g2.drawString(f.getName(), (w / 2 - sw / 2), yy += strH);
}
}
public static void main(String[] argv) {
createDemoFrame(new AllFonts());
}
static class DemoControls extends CustomControls implements ActionListener,
ChangeListener {
AllFonts demo;
JSlider slider;
int[] fsize = { 8, 14, 18, 24 };
JMenuItem[] menuitem = new JMenuItem[fsize.length];
Font[] font = new Font[fsize.length];
@SuppressWarnings("LeakingThisInConstructor")
public DemoControls(AllFonts demo) {
this.demo = demo;
setBackground(GRAY);
int sleepAmount = (int) demo.getSleepAmount();
slider = new JSlider(SwingConstants.HORIZONTAL, 0, 999, sleepAmount);
slider.setBorder(new EtchedBorder());
slider.setPreferredSize(new Dimension(90, 22));
slider.addChangeListener(this);
add(slider);
JMenuBar menubar = new JMenuBar();
add(menubar);
JMenu menu = menubar.add(new JMenu("Font Size"));
for (int i = 0; i < fsize.length; i++) {
font[i] = new Font(Font.SERIF, Font.PLAIN, fsize[i]);
menuitem[i] = menu.add(new JMenuItem(String.valueOf(fsize[i])));
menuitem[i].setFont(font[i]);
menuitem[i].addActionListener(this);
}
}
@Override
public void actionPerformed(ActionEvent e) {
for (int i = 0; i < fsize.length; i++) {
if (e.getSource().equals(menuitem[i])) {
demo.fsize = fsize[i];
Dimension d = demo.getSize();
demo.reset(d.width, d.height);
break;
}
}
}
@Override
public void stateChanged(ChangeEvent e) {
demo.setSleepAmount(slider.getValue());
}
}
}
package jdk.vm.ci.meta;
public abstract class AllocatableValue extends Value implements JavaValue {
public static final AllocatableValue[] NONE = {};
public AllocatableValue(ValueKind<?> kind) {
super(kind);
}
}
package compiler.jvmci.compilerToVM;
import compiler.jvmci.common.CTVMUtilities;
import jdk.test.lib.Asserts;
import jdk.test.lib.util.Pair;
import jdk.test.lib.Utils;
import jdk.vm.ci.hotspot.CompilerToVMHelper;
import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
import jdk.test.whitebox.code.NMethod;
import java.lang.reflect.Executable;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class AllocateCompileIdTest {
private static final int SOME_REPEAT_VALUE = 5;
private final HashSet<Integer> ids = new HashSet<>();
public static void main(String[] args) {
AllocateCompileIdTest test = new AllocateCompileIdTest();
createTestCasesCorrectBci().forEach(test::runSanityCorrectTest);
createTestCasesIncorrectBci().forEach(test::runSanityIncorrectTest);
}
private static List<CompileCodeTestCase> createTestCasesCorrectBci() {
List<CompileCodeTestCase> result = new ArrayList<>();
try {
Class<?> aClass = DummyClass.class;
Method method = aClass.getMethod("withLoop");
Object receiver = new DummyClass();
result.add(new CompileCodeTestCase(receiver, method, 17));
result.add(new CompileCodeTestCase(receiver, method, -1));
} catch (NoSuchMethodException e) {
throw new Error("TEST BUG : " + e, e);
}
return result;
}
private static List<Pair<CompileCodeTestCase, Class<? extends Throwable>>>
createTestCasesIncorrectBci() {
List<Pair<CompileCodeTestCase, Class<? extends Throwable>>> result
= new ArrayList<>();
try {
Class<?> aClass = DummyClass.class;
Object receiver = new DummyClass();
Method method = aClass.getMethod("dummyInstanceFunction");
byte[] bytecode = CompilerToVMHelper.getBytecode(CTVMUtilities
.getResolvedMethod(method));
Stream.of(
bytecode.length + 4,
bytecode.length + 50,
bytecode.length + 200,
-4, -50, -200)
.map(bci -> new Pair<CompileCodeTestCase,
Class<? extends Throwable>>(
new CompileCodeTestCase(receiver, method, bci),
IllegalArgumentException.class))
.collect(Collectors.toList());
} catch (NoSuchMethodException e) {
throw new Error("TEST BUG : " + e.getMessage(), e);
}
return result;
}
private void runSanityCorrectTest(CompileCodeTestCase testCase) {
System.out.println(testCase);
Executable aMethod = testCase.executable;
testCase.invoke(Utils.getNullValues(aMethod.getParameterTypes()));
int bci = testCase.bci;
HotSpotResolvedJavaMethod method = CTVMUtilities
.getResolvedMethod(aMethod);
for (int i = 0; i < SOME_REPEAT_VALUE; ++i) {
int wbCompileID = getWBCompileID(testCase);
int id = CompilerToVMHelper.allocateCompileId(method, bci);
Asserts.assertNE(id, 0, testCase + " : zero compile id");
Asserts.assertGT(id, wbCompileID, testCase
+ " : allocated 'compile id' not  greater than existed");
Asserts.assertTrue(ids.add(wbCompileID), testCase
+ " : vm compilation allocated existing id " + id);
Asserts.assertTrue(ids.add(id), testCase
+ " : allocateCompileId returned existing id " + id);
}
}
private void runSanityIncorrectTest(
Pair<CompileCodeTestCase, Class<? extends Throwable>> testCase) {
System.out.println(testCase);
Class<? extends Throwable> exception = testCase.second;
Executable aMethod = testCase.first.executable;
int bci = testCase.first.bci;
HotSpotResolvedJavaMethod method = CTVMUtilities
.getResolvedMethod(aMethod);
Utils.runAndCheckException(
() -> CompilerToVMHelper.allocateCompileId(method, bci),
exception);
}
private int getWBCompileID(CompileCodeTestCase testCase) {
NMethod nm = testCase.deoptimizeAndCompile();
if (nm == null || nm.compile_id <= 0) {
throw new Error("TEST BUG : cannot compile method " + testCase);
}
return nm.compile_id;
}
}
package sun.nio.ch;
class AllocatedNativeObject                                 extends NativeObject
{
AllocatedNativeObject(int size, boolean pageAligned) {
super(size, pageAligned);
}
synchronized void free() {
if (allocationAddress != 0) {
unsafe.freeMemory(allocationAddress);
allocationAddress = 0;
}
}
}
package compiler.intrinsics.unsafe;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.util.concurrent.Callable;
public class AllocateUninitializedArray {
static final int ITERS = Integer.getInteger("iters", 1);
static final jdk.internal.misc.Unsafe UNSAFE;
static {
try {
Field f = jdk.internal.misc.Unsafe.class.getDeclaredField("theUnsafe");
f.setAccessible(true);
UNSAFE = (jdk.internal.misc.Unsafe) f.get(null);
} catch (Exception e) {
throw new RuntimeException("Unable to get Unsafe instance.", e);
}
}
public static void main(String... args) throws Exception {
testIAE(AllConstants::testObject);
testIAE(LengthIsConstant::testObject);
testIAE(ClassIsConstant::testObject);
testIAE(NothingIsConstant::testObject);
testIAE(AllConstants::testArray);
testIAE(LengthIsConstant::testArray);
testIAE(ClassIsConstant::testArray);
testIAE(NothingIsConstant::testArray);
testIAE(AllConstants::testNull);
testIAE(LengthIsConstant::testNull);
testIAE(ClassIsConstant::testNull);
testIAE(NothingIsConstant::testNull);
testOK(boolean[].class, 10, AllConstants::testBoolean);
testOK(byte[].class,    10, AllConstants::testByte);
testOK(short[].class,   10, AllConstants::testShort);
testOK(char[].class,    10, AllConstants::testChar);
testOK(int[].class,     10, AllConstants::testInt);
testOK(float[].class,   10, AllConstants::testFloat);
testOK(long[].class,    10, AllConstants::testLong);
testOK(double[].class,  10, AllConstants::testDouble);
testOK(null,            10, AllConstants::testVoid);
testOK(boolean[].class, 10, LengthIsConstant::testBoolean);
testOK(byte[].class,    10, LengthIsConstant::testByte);
testOK(short[].class,   10, LengthIsConstant::testShort);
testOK(char[].class,    10, LengthIsConstant::testChar);
testOK(int[].class,     10, LengthIsConstant::testInt);
testOK(float[].class,   10, LengthIsConstant::testFloat);
testOK(long[].class,    10, LengthIsConstant::testLong);
testOK(double[].class,  10, LengthIsConstant::testDouble);
testOK(null,            10, LengthIsConstant::testVoid);
testOK(boolean[].class, 10, ClassIsConstant::testBoolean);
testOK(byte[].class,    10, ClassIsConstant::testByte);
testOK(short[].class,   10, ClassIsConstant::testShort);
testOK(char[].class,    10, ClassIsConstant::testChar);
testOK(int[].class,     10, ClassIsConstant::testInt);
testOK(float[].class,   10, ClassIsConstant::testFloat);
testOK(long[].class,    10, ClassIsConstant::testLong);
testOK(double[].class,  10, ClassIsConstant::testDouble);
testOK(null,            10, ClassIsConstant::testVoid);
testOK(boolean[].class, 10, NothingIsConstant::testBoolean);
testOK(byte[].class,    10, NothingIsConstant::testByte);
testOK(short[].class,   10, NothingIsConstant::testShort);
testOK(char[].class,    10, NothingIsConstant::testChar);
testOK(int[].class,     10, NothingIsConstant::testInt);
testOK(float[].class,   10, NothingIsConstant::testFloat);
testOK(long[].class,    10, NothingIsConstant::testLong);
testOK(double[].class,  10, NothingIsConstant::testDouble);
testOK(null,            10, NothingIsConstant::testVoid);
}
public static void testOK(Class<?> expectClass, int expectLen, Callable<Object> test) throws Exception {
for (int c = 0; c < ITERS; c++) {
Object res = test.call();
if (res == null) {
if (expectClass != null) {
throw new IllegalStateException("Unexpected null result");
}
continue;
}
Class<?> actualClass = res.getClass();
if (!actualClass.equals(expectClass)) {
throw new IllegalStateException("Wrong class: expected = " + expectClass + ", but got " + actualClass);
}
int actualLen = Array.getLength(res);
if (actualLen != expectLen) {
throw new IllegalStateException("Wrong length: expected = " + expectLen + ", but got " + actualLen);
}
}
}
static volatile Object sink;
public static void testIAE(Callable<Object> test) throws Exception {
for (int c = 0; c < ITERS; c++) {
try {
sink = test.call();
throw new IllegalStateException("Expected IAE");
} catch (IllegalArgumentException iae) {
}
}
}
static volatile int sampleLenNeg  = -1;
static volatile int sampleLenZero = 0;
static volatile int sampleLen     = 10;
static volatile Class<?> classBoolean = boolean.class;
static volatile Class<?> classByte    = byte.class;
static volatile Class<?> classShort   = short.class;
static volatile Class<?> classChar    = char.class;
static volatile Class<?> classInt     = int.class;
static volatile Class<?> classFloat   = float.class;
static volatile Class<?> classLong    = long.class;
static volatile Class<?> classDouble  = double.class;
static volatile Class<?> classVoid    = void.class;
static volatile Class<?> classObject  = Object.class;
static volatile Class<?> classArray   = Object[].class;
static volatile Class<?> classNull    = null;
static class AllConstants {
static Object testBoolean() { return UNSAFE.allocateUninitializedArray(boolean.class,  10); }
static Object testByte()    { return UNSAFE.allocateUninitializedArray(byte.class,     10); }
static Object testShort()   { return UNSAFE.allocateUninitializedArray(short.class,    10); }
static Object testChar()    { return UNSAFE.allocateUninitializedArray(char.class,     10); }
static Object testInt()     { return UNSAFE.allocateUninitializedArray(int.class,      10); }
static Object testFloat()   { return UNSAFE.allocateUninitializedArray(float.class,    10); }
static Object testLong()    { return UNSAFE.allocateUninitializedArray(long.class,     10); }
static Object testDouble()  { return UNSAFE.allocateUninitializedArray(double.class,   10); }
static Object testVoid()    { return UNSAFE.allocateUninitializedArray(void.class,     10); }
static Object testObject()  { return UNSAFE.allocateUninitializedArray(Object.class,   10); }
static Object testArray()   { return UNSAFE.allocateUninitializedArray(Object[].class, 10); }
static Object testNull()    { return UNSAFE.allocateUninitializedArray(null,           10); }
static Object testZero()    { return UNSAFE.allocateUninitializedArray(int.class,      0);  }
static Object testNeg()     { return UNSAFE.allocateUninitializedArray(int.class,      -1); }
}
static class ClassIsConstant {
static Object testBoolean() { return UNSAFE.allocateUninitializedArray(boolean.class,  sampleLen); }
static Object testByte()    { return UNSAFE.allocateUninitializedArray(byte.class,     sampleLen); }
static Object testShort()   { return UNSAFE.allocateUninitializedArray(short.class,    sampleLen); }
static Object testChar()    { return UNSAFE.allocateUninitializedArray(char.class,     sampleLen); }
static Object testInt()     { return UNSAFE.allocateUninitializedArray(int.class,      sampleLen); }
static Object testFloat()   { return UNSAFE.allocateUninitializedArray(float.class,    sampleLen); }
static Object testLong()    { return UNSAFE.allocateUninitializedArray(long.class,     sampleLen); }
static Object testDouble()  { return UNSAFE.allocateUninitializedArray(double.class,   sampleLen); }
static Object testVoid()    { return UNSAFE.allocateUninitializedArray(void.class,     sampleLen); }
static Object testObject()  { return UNSAFE.allocateUninitializedArray(Object.class,   sampleLen); }
static Object testArray()   { return UNSAFE.allocateUninitializedArray(Object[].class, sampleLen); }
static Object testNull()    { return UNSAFE.allocateUninitializedArray(null,           sampleLen); }
static Object testZero()    { return UNSAFE.allocateUninitializedArray(int.class,      sampleLenZero); }
static Object testNeg()     { return UNSAFE.allocateUninitializedArray(int.class,      sampleLenNeg); }
}
static class LengthIsConstant {
static Object testBoolean() { return UNSAFE.allocateUninitializedArray(classBoolean, 10); }
static Object testByte()    { return UNSAFE.allocateUninitializedArray(classByte,    10); }
static Object testShort()   { return UNSAFE.allocateUninitializedArray(classShort,   10); }
static Object testChar()    { return UNSAFE.allocateUninitializedArray(classChar,    10); }
static Object testInt()     { return UNSAFE.allocateUninitializedArray(classInt,     10); }
static Object testFloat()   { return UNSAFE.allocateUninitializedArray(classFloat,   10); }
static Object testLong()    { return UNSAFE.allocateUninitializedArray(classLong,    10); }
static Object testDouble()  { return UNSAFE.allocateUninitializedArray(classDouble,  10); }
static Object testVoid()    { return UNSAFE.allocateUninitializedArray(classVoid,    10); }
static Object testObject()  { return UNSAFE.allocateUninitializedArray(classObject,  10); }
static Object testArray()   { return UNSAFE.allocateUninitializedArray(classArray,   10); }
static Object testNull()    { return UNSAFE.allocateUninitializedArray(classNull,    10); }
static Object testZero()    { return UNSAFE.allocateUninitializedArray(classInt,     0);  }
static Object testNeg()     { return UNSAFE.allocateUninitializedArray(classInt,     -1); }
}
static class NothingIsConstant {
static Object testBoolean() { return UNSAFE.allocateUninitializedArray(classBoolean, sampleLen); }
static Object testByte()    { return UNSAFE.allocateUninitializedArray(classByte,    sampleLen); }
static Object testShort()   { return UNSAFE.allocateUninitializedArray(classShort,   sampleLen); }
static Object testChar()    { return UNSAFE.allocateUninitializedArray(classChar,    sampleLen); }
static Object testInt()     { return UNSAFE.allocateUninitializedArray(classInt,     sampleLen); }
static Object testFloat()   { return UNSAFE.allocateUninitializedArray(classFloat,   sampleLen); }
static Object testLong()    { return UNSAFE.allocateUninitializedArray(classLong,    sampleLen); }
static Object testDouble()  { return UNSAFE.allocateUninitializedArray(classDouble,  sampleLen); }
static Object testVoid()    { return UNSAFE.allocateUninitializedArray(classVoid,    sampleLen); }
static Object testObject()  { return UNSAFE.allocateUninitializedArray(classObject,  sampleLen); }
static Object testArray()   { return UNSAFE.allocateUninitializedArray(classArray,   sampleLen); }
static Object testNull()    { return UNSAFE.allocateUninitializedArray(classNull,    sampleLen); }
static Object testZero()    { return UNSAFE.allocateUninitializedArray(classInt,     sampleLenZero); }
static Object testNeg()     { return UNSAFE.allocateUninitializedArray(classInt,     sampleLenNeg); }
}
}
package gc.testlibrary;
public class Allocation {
public static volatile Object obj;
public static void blackHole(Object obj) {
Allocation.obj = obj;
Allocation.obj = null;
}
}
package compiler.whitebox;
import jdk.test.lib.Asserts;
import jdk.test.lib.InfiniteLoop;
import jdk.test.whitebox.WhiteBox;
import jdk.test.whitebox.code.BlobType;
import java.lang.management.MemoryPoolMXBean;
import java.util.ArrayList;
import java.util.EnumSet;
public class AllocationCodeBlobTest {
private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
private static final long CODE_CACHE_SIZE
= WHITE_BOX.getUintxVMFlag("ReservedCodeCacheSize");
private static final int SIZE = 1;
public static void main(String[] args) {
Thread t = new Thread(
new InfiniteLoop(WHITE_BOX::forceNMethodSweep, 1L),
"ForcedSweeper");
t.setDaemon(true);
System.out.println("Starting " + t.getName());
t.start();
EnumSet<BlobType> blobTypes = BlobType.getAvailable();
for (BlobType type : blobTypes) {
new AllocationCodeBlobTest(type).test();
}
t = new Thread(
new InfiniteLoop(WHITE_BOX::deoptimizeAll, 1L),
"Deoptimize Thread");
t.setDaemon(true);
System.out.println("Starting " + t.getName());
t.start();
for (int i = 0; i < 10_000; ++i) {
for (BlobType type : blobTypes) {
long addr = WHITE_BOX.allocateCodeBlob(SIZE, type.id);
}
}
}
private final BlobType type;
private final MemoryPoolMXBean bean;
private AllocationCodeBlobTest(BlobType type) {
this.type = type;
bean = type.getMemoryPool();
}
private void test() {
System.out.printf("type %s%n", type);
long start = getUsage();
long addr1 = WHITE_BOX.allocateCodeBlob(SIZE, type.id);
long firstAllocation = getUsage();
WHITE_BOX.freeCodeBlob(addr1);
long firstFree = getUsage();
long addr2 = WHITE_BOX.allocateCodeBlob(SIZE, type.id);
long secondAllocation = getUsage();
WHITE_BOX.freeCodeBlob(addr2);
Asserts.assertNE(0, addr1, "first allocation failed");
Asserts.assertNE(0, addr2, "second allocation failed");
Asserts.assertLTE(start + SIZE, firstAllocation,
"allocation should increase memory usage: "
+ start + " + " + SIZE + " <= " + firstAllocation);
Asserts.assertLTE(firstFree, firstAllocation,
"free shouldn't increase memory usage: "
+ firstFree + " <= " + firstAllocation);
Asserts.assertEQ(firstAllocation, secondAllocation);
System.out.println("allocating till possible...");
ArrayList<Long> blobs = new ArrayList<>();
int size = (int) (CODE_CACHE_SIZE >> 7);
while ((addr1 = WHITE_BOX.allocateCodeBlob(size, type.id)) != 0) {
blobs.add(addr1);
}
for (Long blob : blobs) {
WHITE_BOX.freeCodeBlob(blob);
}
}
private long getUsage() {
return bean.getUsage().getUsed();
}
}
package gc.arguments;
import java.util.concurrent.Callable;
public final class AllocationHelper {
private final int arrayLength;
private final int maxIterations;
private final int chunkSize;
private static Object garbageStorage;
private byte garbage[][];
private final Callable<?> verifierInstance;
public AllocationHelper(int maxIterations, int arrayLength, int chunkSize, Callable<?> verifier) {
if ((arrayLength <= 0) || (maxIterations <= 0) || (chunkSize <= 0)) {
throw new IllegalArgumentException("maxIterations, arrayLength and chunkSize should be greater then 0.");
}
this.arrayLength = arrayLength;
this.maxIterations = maxIterations;
this.chunkSize = chunkSize;
verifierInstance = verifier;
garbage = new byte[this.arrayLength][];
garbageStorage = garbage;
}
private void allocateMemoryOneIteration() {
for (int j = 0; j < arrayLength; j++) {
garbage[j] = new byte[chunkSize];
}
}
public void allocateMemoryAndVerify() throws Exception {
for (int i = 0; i < maxIterations; i++) {
allocateMemoryOneIteration();
if (verifierInstance != null) {
verifierInstance.call();
}
}
}
public void allocateMemoryAndVerifyNoOOME() throws Exception {
try {
allocateMemoryAndVerify();
} catch (OutOfMemoryError e) {
}
}
public void release() {
if (garbage != null) {
garbage = null;
garbageStorage = null;
}
}
}
package com.sun.org.apache.bcel.internal.generic;
public interface AllocationInstruction {
}
package jdk.javadoc.internal.doclets.formats.html;
import javax.lang.model.element.PackageElement;
import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;
import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;
import jdk.javadoc.internal.doclets.formats.html.markup.Text;
import jdk.javadoc.internal.doclets.toolkit.Content;
import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
public class AllPackagesIndexWriter extends HtmlDocletWriter {
public AllPackagesIndexWriter(HtmlConfiguration configuration, DocPath filename) {
super(configuration, filename);
}
public static void generate(HtmlConfiguration configuration) throws DocFileIOException {
generate(configuration, DocPaths.ALLPACKAGES_INDEX);
}
private static void generate(HtmlConfiguration configuration, DocPath fileName) throws DocFileIOException {
AllPackagesIndexWriter allPkgGen = new AllPackagesIndexWriter(configuration, fileName);
allPkgGen.buildAllPackagesFile();
}
protected void buildAllPackagesFile() throws DocFileIOException {
String label = resources.getText("doclet.All_Packages");
Content mainContent = new ContentBuilder();
addPackages(mainContent);
Content titleContent = contents.allPackagesLabel;
var pHeading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,
HtmlStyle.title, titleContent);
var headerDiv = HtmlTree.DIV(HtmlStyle.header, pHeading);
HtmlTree body = getBody(getWindowTitle(label));
body.add(new BodyContents()
.setHeader(getHeader(PageMode.ALL_PACKAGES))
.addMainContent(headerDiv)
.addMainContent(mainContent)
.setFooter(getFooter()));
printHtmlDocument(null, "package index", body);
}
protected void addPackages(Content target) {
Table table = new Table(HtmlStyle.summaryTable)
.setCaption(Text.of(contents.packageSummaryLabel.toString()))
.setHeader(new TableHeader(contents.packageLabel, contents.descriptionLabel))
.setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast);
for (PackageElement pkg : configuration.packages) {
if (!(options.noDeprecated() && utils.isDeprecated(pkg))) {
Content packageLinkContent = getPackageLink(pkg, getLocalizedPackageName(pkg));
Content summaryContent = new ContentBuilder();
addSummaryComment(pkg, summaryContent);
table.addRow(pkg, packageLinkContent, summaryContent);
}
}
target.add(table);
}
}
package java.security;
import sun.security.util.SecurityConstants;
import java.util.Enumeration;
public final class AllPermission extends Permission {
@java.io.Serial
private static final long serialVersionUID = -2916474571451318075L;
public AllPermission() {
super("<all permissions>");
}
public AllPermission(String name, String actions) {
this();
}
public boolean implies(Permission p) {
return true;
}
public boolean equals(Object obj) {
return (obj instanceof AllPermission);
}
public int hashCode() {
return 1;
}
public String getActions() {
return "<all actions>";
}
public PermissionCollection newPermissionCollection() {
return new AllPermissionCollection();
}
}
final class AllPermissionCollection
extends PermissionCollection
implements java.io.Serializable
{
@java.io.Serial
private static final long serialVersionUID = -4023755556366636806L;
private boolean all_allowed;
public AllPermissionCollection() {
all_allowed = false;
}
public void add(Permission permission) {
if (! (permission instanceof AllPermission))
throw new IllegalArgumentException("invalid permission: "+
permission);
if (isReadOnly())
throw new SecurityException("attempt to add a Permission to a readonly PermissionCollection");
all_allowed = true;     }
public boolean implies(Permission permission) {
return all_allowed;     }
public Enumeration<Permission> elements() {
return new Enumeration<>() {
private boolean hasMore = all_allowed;
public boolean hasMoreElements() {
return hasMore;
}
public Permission nextElement() {
hasMore = false;
return SecurityConstants.ALL_PERMISSION;
}
};
}
}
package com.sun.org.apache.bcel.internal.generic;
import com.sun.org.apache.bcel.internal.Const;
public class ALOAD extends LoadInstruction {
ALOAD() {
super(Const.ALOAD, Const.ALOAD_0);
}
public ALOAD(final int n) {
super(Const.ALOAD, Const.ALOAD_0, n);
}
@Override
public void accept( final Visitor v ) {
super.accept(v);
v.visitALOAD(this);
}
}
package sun.java2d.pipe;
import java.awt.Rectangle;
import java.awt.Shape;
import sun.java2d.SunGraphics2D;
public class AlphaColorPipe implements CompositePipe, ParallelogramPipe {
public AlphaColorPipe() {
}
public Object startSequence(SunGraphics2D sg, Shape s, Rectangle dev,
int[] abox) {
return sg;
}
public boolean needTile(Object context, int x, int y, int w, int h) {
return true;
}
public void renderPathTile(Object context,
byte[] atile, int offset, int tilesize,
int x, int y, int w, int h) {
SunGraphics2D sg = (SunGraphics2D) context;
sg.alphafill.MaskFill(sg, sg.getSurfaceData(), sg.composite,
x, y, w, h,
atile, offset, tilesize);
}
public void skipTile(Object context, int x, int y) {
return;
}
public void endSequence(Object context) {
return;
}
public void fillParallelogram(SunGraphics2D sg,
double ux1, double uy1,
double ux2, double uy2,
double x, double y,
double dx1, double dy1,
double dx2, double dy2)
{
sg.alphafill.FillAAPgram(sg, sg.getSurfaceData(), sg.composite,
x, y, dx1, dy1, dx2, dy2);
}
public void drawParallelogram(SunGraphics2D sg,
double ux1, double uy1,
double ux2, double uy2,
double x, double y,
double dx1, double dy1,
double dx2, double dy2,
double lw1, double lw2)
{
sg.alphafill.DrawAAPgram(sg, sg.getSurfaceData(), sg.composite,
x, y, dx1, dy1, dx2, dy2, lw1, lw2);
}
}
package java.awt;
import java.awt.image.ColorModel;
import java.lang.annotation.Native;
import sun.java2d.SunCompositeContext;
public final class AlphaComposite implements Composite {
@Native public static final int     CLEAR           = 1;
@Native public static final int     SRC             = 2;
@Native public static final int     DST             = 9;
@Native public static final int     SRC_OVER        = 3;
@Native public static final int     DST_OVER        = 4;
@Native public static final int     SRC_IN          = 5;
@Native public static final int     DST_IN          = 6;
@Native public static final int     SRC_OUT         = 7;
@Native public static final int     DST_OUT         = 8;
@Native public static final int     SRC_ATOP        = 10;
@Native public static final int     DST_ATOP        = 11;
@Native public static final int     XOR             = 12;
public static final AlphaComposite Clear    = new AlphaComposite(CLEAR);
public static final AlphaComposite Src      = new AlphaComposite(SRC);
public static final AlphaComposite Dst      = new AlphaComposite(DST);
public static final AlphaComposite SrcOver  = new AlphaComposite(SRC_OVER);
public static final AlphaComposite DstOver  = new AlphaComposite(DST_OVER);
public static final AlphaComposite SrcIn    = new AlphaComposite(SRC_IN);
public static final AlphaComposite DstIn    = new AlphaComposite(DST_IN);
public static final AlphaComposite SrcOut   = new AlphaComposite(SRC_OUT);
public static final AlphaComposite DstOut   = new AlphaComposite(DST_OUT);
public static final AlphaComposite SrcAtop  = new AlphaComposite(SRC_ATOP);
public static final AlphaComposite DstAtop  = new AlphaComposite(DST_ATOP);
public static final AlphaComposite Xor      = new AlphaComposite(XOR);
@Native private static final int MIN_RULE = CLEAR;
@Native private static final int MAX_RULE = XOR;
float extraAlpha;
int rule;
private AlphaComposite(int rule) {
this(rule, 1.0f);
}
private AlphaComposite(int rule, float alpha) {
if (rule < MIN_RULE || rule > MAX_RULE) {
throw new IllegalArgumentException("unknown composite rule");
}
if (alpha >= 0.0f && alpha <= 1.0f) {
this.rule = rule;
this.extraAlpha = alpha;
} else {
throw new IllegalArgumentException("alpha value out of range");
}
}
public static AlphaComposite getInstance(int rule) {
switch (rule) {
case CLEAR:
return Clear;
case SRC:
return Src;
case DST:
return Dst;
case SRC_OVER:
return SrcOver;
case DST_OVER:
return DstOver;
case SRC_IN:
return SrcIn;
case DST_IN:
return DstIn;
case SRC_OUT:
return SrcOut;
case DST_OUT:
return DstOut;
case SRC_ATOP:
return SrcAtop;
case DST_ATOP:
return DstAtop;
case XOR:
return Xor;
default:
throw new IllegalArgumentException("unknown composite rule");
}
}
public static AlphaComposite getInstance(int rule, float alpha) {
if (alpha == 1.0f) {
return getInstance(rule);
}
return new AlphaComposite(rule, alpha);
}
public CompositeContext createContext(ColorModel srcColorModel,
ColorModel dstColorModel,
RenderingHints hints) {
return new SunCompositeContext(this, srcColorModel, dstColorModel);
}
public float getAlpha() {
return extraAlpha;
}
public int getRule() {
return rule;
}
public AlphaComposite derive(int rule) {
return (this.rule == rule)
? this
: getInstance(rule, this.extraAlpha);
}
public AlphaComposite derive(float alpha) {
return (this.extraAlpha == alpha)
? this
: getInstance(this.rule, alpha);
}
public int hashCode() {
return (Float.floatToIntBits(extraAlpha) * 31 + rule);
}
public boolean equals(Object obj) {
if (!(obj instanceof AlphaComposite)) {
return false;
}
AlphaComposite ac = (AlphaComposite) obj;
if (rule != ac.rule) {
return false;
}
if (extraAlpha != ac.extraAlpha) {
return false;
}
return true;
}
}
package sun.java2d.pipe;
import java.lang.ref.WeakReference;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.PaintContext;
import java.awt.Transparency;
import java.awt.image.ColorModel;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.awt.image.BufferedImage;
import sun.awt.image.BufImgSurfaceData;
import sun.java2d.SunGraphics2D;
import sun.java2d.SurfaceData;
import sun.java2d.loops.Blit;
import sun.java2d.loops.MaskBlit;
import sun.java2d.loops.CompositeType;
import sun.java2d.loops.GraphicsPrimitiveMgr;
public class AlphaPaintPipe implements CompositePipe {
static WeakReference<Raster> cachedLastRaster;
static WeakReference<ColorModel> cachedLastColorModel;
static WeakReference<SurfaceData> cachedLastData;
static class TileContext {
SunGraphics2D sunG2D;
PaintContext paintCtxt;
ColorModel paintModel;
WeakReference<Raster> lastRaster;
WeakReference<SurfaceData> lastData;
MaskBlit lastMask;
Blit     lastBlit;
SurfaceData dstData;
public TileContext(SunGraphics2D sg, PaintContext pc) {
sunG2D = sg;
paintCtxt = pc;
paintModel = pc.getColorModel();
dstData = sg.getSurfaceData();
synchronized (AlphaPaintPipe.class) {
if (cachedLastColorModel != null &&
cachedLastColorModel.get() == paintModel)
{
this.lastRaster = cachedLastRaster;
this.lastData = cachedLastData;
}
}
}
}
public Object startSequence(SunGraphics2D sg, Shape s, Rectangle devR,
int[] abox) {
PaintContext paintContext =
sg.paint.createContext(sg.getDeviceColorModel(),
devR,
s.getBounds2D(),
sg.cloneTransform(),
sg.getRenderingHints());
return new TileContext(sg, paintContext);
}
public boolean needTile(Object context, int x, int y, int w, int h) {
return true;
}
private static final int TILE_SIZE = 32;
public void renderPathTile(Object ctx,
byte[] atile, int offset, int tilesize,
int x, int y, int w, int h) {
TileContext context = (TileContext) ctx;
PaintContext paintCtxt = context.paintCtxt;
SunGraphics2D sg = context.sunG2D;
SurfaceData dstData = context.dstData;
SurfaceData srcData = null;
Raster lastRas = null;
if (context.lastData != null && context.lastRaster != null) {
srcData = context.lastData.get();
lastRas = context.lastRaster.get();
if (srcData == null || lastRas == null) {
srcData = null;
lastRas = null;
}
}
ColorModel paintModel = context.paintModel;
for (int rely = 0; rely < h; rely += TILE_SIZE) {
int ty = y + rely;
int th = Math.min(h-rely, TILE_SIZE);
for (int relx = 0; relx < w; relx += TILE_SIZE) {
int tx = x + relx;
int tw = Math.min(w-relx, TILE_SIZE);
Raster srcRaster = paintCtxt.getRaster(tx, ty, tw, th);
if ((srcRaster.getMinX() != 0) || (srcRaster.getMinY() != 0)) {
srcRaster = srcRaster.createTranslatedChild(0, 0);
}
if (lastRas != srcRaster) {
lastRas = srcRaster;
context.lastRaster = new WeakReference<>(lastRas);
BufferedImage bImg =
new BufferedImage(paintModel,
(WritableRaster) srcRaster,
paintModel.isAlphaPremultiplied(),
null);
srcData = BufImgSurfaceData.createData(bImg);
context.lastData = new WeakReference<>(srcData);
context.lastMask = null;
context.lastBlit = null;
}
if (atile == null) {
if (context.lastBlit == null) {
CompositeType comptype = sg.imageComp;
if (CompositeType.SrcOverNoEa.equals(comptype) &&
paintModel.getTransparency() == Transparency.OPAQUE)
{
comptype = CompositeType.SrcNoEa;
}
context.lastBlit =
Blit.getFromCache(srcData.getSurfaceType(),
comptype,
dstData.getSurfaceType());
}
context.lastBlit.Blit(srcData, dstData,
sg.composite, null,
0, 0, tx, ty, tw, th);
} else {
if (context.lastMask == null) {
CompositeType comptype = sg.imageComp;
if (CompositeType.SrcOverNoEa.equals(comptype) &&
paintModel.getTransparency() == Transparency.OPAQUE)
{
comptype = CompositeType.SrcNoEa;
}
context.lastMask =
MaskBlit.getFromCache(srcData.getSurfaceType(),
comptype,
dstData.getSurfaceType());
}
int toff = offset + rely * tilesize + relx;
context.lastMask.MaskBlit(srcData, dstData,
sg.composite, null,
0, 0, tx, ty, tw, th,
atile, toff, tilesize);
}
}
}
}
public void skipTile(Object context, int x, int y) {
return;
}
public void endSequence(Object ctx) {
TileContext context = (TileContext) ctx;
if (context.paintCtxt != null) {
context.paintCtxt.dispose();
}
synchronized (AlphaPaintPipe.class) {
if (context.lastData != null) {
cachedLastRaster = context.lastRaster;
if (cachedLastColorModel == null ||
cachedLastColorModel.get() != context.paintModel)
{
cachedLastColorModel =
new WeakReference<>(context.paintModel);
}
cachedLastData = context.lastData;
}
}
}
}
package sun.security.ssl;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.Security;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLProtocolException;
import javax.net.ssl.SSLSocket;
import sun.security.ssl.SSLExtension.ExtensionConsumer;
import sun.security.ssl.SSLExtension.SSLExtensionSpec;
import sun.security.ssl.SSLHandshake.HandshakeMessage;
final class AlpnExtension {
static final HandshakeProducer chNetworkProducer = new CHAlpnProducer();
static final ExtensionConsumer chOnLoadConsumer = new CHAlpnConsumer();
static final HandshakeAbsence chOnLoadAbsence = new CHAlpnAbsence();
static final HandshakeProducer shNetworkProducer = new SHAlpnProducer();
static final ExtensionConsumer shOnLoadConsumer = new SHAlpnConsumer();
static final HandshakeAbsence shOnLoadAbsence = new SHAlpnAbsence();
static final HandshakeProducer eeNetworkProducer = new SHAlpnProducer();
static final ExtensionConsumer eeOnLoadConsumer = new SHAlpnConsumer();
static final HandshakeAbsence eeOnLoadAbsence = new SHAlpnAbsence();
static final SSLStringizer alpnStringizer = new AlpnStringizer();
static final Charset alpnCharset;
static {
@SuppressWarnings("removal")
String alpnCharsetString = AccessController.doPrivileged(
(PrivilegedAction<String>) ()
-> Security.getProperty("jdk.tls.alpnCharset"));
if ((alpnCharsetString == null)
|| (alpnCharsetString.length() == 0)) {
alpnCharsetString = "ISO_8859_1";
}
alpnCharset = Charset.forName(alpnCharsetString);
}
static final class AlpnSpec implements SSLExtensionSpec {
final List<String> applicationProtocols;
private AlpnSpec(String[] applicationProtocols) {
this.applicationProtocols = List.of(applicationProtocols);
}
private AlpnSpec(HandshakeContext hc,
ByteBuffer buffer) throws IOException {
if (buffer.remaining() < 2) {
throw hc.conContext.fatal(Alert.DECODE_ERROR,
new SSLProtocolException(
"Invalid application_layer_protocol_negotiation: " +
"insufficient data (length=" + buffer.remaining() + ")"));
}
int listLen = Record.getInt16(buffer);
if (listLen < 2 || listLen != buffer.remaining()) {
throw hc.conContext.fatal(Alert.DECODE_ERROR,
new SSLProtocolException(
"Invalid application_layer_protocol_negotiation: " +
"incorrect list length (length=" + listLen + ")"));
}
List<String> protocolNames = new LinkedList<>();
while (buffer.hasRemaining()) {
byte[] bytes = Record.getBytes8(buffer);
if (bytes.length == 0) {
throw hc.conContext.fatal(Alert.DECODE_ERROR,
new SSLProtocolException(
"Invalid application_layer_protocol_negotiation " +
"extension: empty application protocol name"));
}
String appProtocol = new String(bytes, alpnCharset);
protocolNames.add(appProtocol);
}
this.applicationProtocols =
Collections.unmodifiableList(protocolNames);
}
@Override
public String toString() {
return applicationProtocols.toString();
}
}
private static final class AlpnStringizer implements SSLStringizer {
@Override
public String toString(HandshakeContext hc, ByteBuffer buffer) {
try {
return (new AlpnSpec(hc, buffer)).toString();
} catch (IOException ioe) {
return ioe.getMessage();
}
}
}
private static final class CHAlpnProducer implements HandshakeProducer {
static final int MAX_AP_LENGTH = 255;
static final int MAX_AP_LIST_LENGTH = 65535;
private CHAlpnProducer() {
}
@Override
public byte[] produce(ConnectionContext context,
HandshakeMessage message) throws IOException {
ClientHandshakeContext chc = (ClientHandshakeContext)context;
if (!chc.sslConfig.isAvailable(SSLExtension.CH_ALPN)) {
if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
SSLLogger.info(
"Ignore client unavailable extension: " +
SSLExtension.CH_ALPN.name);
}
chc.applicationProtocol = "";
chc.conContext.applicationProtocol = "";
return null;
}
String[] laps = chc.sslConfig.applicationProtocols;
if ((laps == null) || (laps.length == 0)) {
if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
SSLLogger.info(
"No available application protocols");
}
return null;
}
int listLength = 0;                 for (String ap : laps) {
int length = ap.getBytes(alpnCharset).length;
if (length == 0) {
if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
SSLLogger.severe(
"Application protocol name cannot be empty");
}
throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
"Application protocol name cannot be empty");
}
if (length <= MAX_AP_LENGTH) {
listLength += (length + 1);
} else {
if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
SSLLogger.severe(
"Application protocol name (" + ap +
") exceeds the size limit (" +
MAX_AP_LENGTH + " bytes)");
}
throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
"Application protocol name (" + ap +
") exceeds the size limit (" +
MAX_AP_LENGTH + " bytes)");
}
if (listLength > MAX_AP_LIST_LENGTH) {
if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
SSLLogger.severe(
"The configured application protocols (" +
Arrays.toString(laps) +
") exceed the size limit (" +
MAX_AP_LIST_LENGTH + " bytes)");
}
throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
"The configured application protocols (" +
Arrays.toString(laps) +
") exceed the size limit (" +
MAX_AP_LIST_LENGTH + " bytes)");
}
}
byte[] extData = new byte[listLength + 2];
ByteBuffer m = ByteBuffer.wrap(extData);
Record.putInt16(m, listLength);
for (String ap : laps) {
Record.putBytes8(m, ap.getBytes(alpnCharset));
}
chc.handshakeExtensions.put(SSLExtension.CH_ALPN,
new AlpnSpec(chc.sslConfig.applicationProtocols));
return extData;
}
}
private static final class CHAlpnConsumer implements ExtensionConsumer {
private CHAlpnConsumer() {
}
@Override
public void consume(ConnectionContext context,
HandshakeMessage message, ByteBuffer buffer) throws IOException {
ServerHandshakeContext shc = (ServerHandshakeContext)context;
if (!shc.sslConfig.isAvailable(SSLExtension.CH_ALPN)) {
shc.applicationProtocol = "";
shc.conContext.applicationProtocol = "";
if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
SSLLogger.info(
"Ignore server unavailable extension: " +
SSLExtension.CH_ALPN.name);
}
return;                 }
boolean noAPSelector;
if (shc.conContext.transport instanceof SSLEngine) {
noAPSelector = (shc.sslConfig.engineAPSelector == null);
} else {
noAPSelector = (shc.sslConfig.socketAPSelector == null);
}
boolean noAlpnProtocols =
shc.sslConfig.applicationProtocols == null ||
shc.sslConfig.applicationProtocols.length == 0;
if (noAPSelector && noAlpnProtocols) {
shc.applicationProtocol = "";
shc.conContext.applicationProtocol = "";
if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
SSLLogger.fine(
"Ignore server unenabled extension: " +
SSLExtension.CH_ALPN.name);
}
return;                 }
AlpnSpec spec = new AlpnSpec(shc, buffer);
if (noAPSelector) {                     List<String> protocolNames = spec.applicationProtocols;
boolean matched = false;
for (String ap : shc.sslConfig.applicationProtocols) {
if (protocolNames.contains(ap)) {
shc.applicationProtocol = ap;
shc.conContext.applicationProtocol = ap;
matched = true;
break;
}
}
if (!matched) {
throw shc.conContext.fatal(Alert.NO_APPLICATION_PROTOCOL,
"No matching application layer protocol values");
}
}
shc.handshakeExtensions.put(SSLExtension.CH_ALPN, spec);
}
}
private static final class CHAlpnAbsence implements HandshakeAbsence {
@Override
public void absent(ConnectionContext context,
HandshakeMessage message) throws IOException {
ServerHandshakeContext shc = (ServerHandshakeContext)context;
shc.applicationProtocol = "";
shc.conContext.applicationProtocol = "";
}
}
private static final class SHAlpnProducer implements HandshakeProducer {
private SHAlpnProducer() {
}
@Override
public byte[] produce(ConnectionContext context,
HandshakeMessage message) throws IOException {
ServerHandshakeContext shc = (ServerHandshakeContext)context;
AlpnSpec requestedAlps =
(AlpnSpec)shc.handshakeExtensions.get(SSLExtension.CH_ALPN);
if (requestedAlps == null) {
if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
SSLLogger.fine(
"Ignore unavailable extension: " +
SSLExtension.SH_ALPN.name);
}
shc.applicationProtocol = "";
shc.conContext.applicationProtocol = "";
return null;
}
List<String> alps = requestedAlps.applicationProtocols;
if (shc.conContext.transport instanceof SSLEngine) {
if (shc.sslConfig.engineAPSelector != null) {
SSLEngine engine = (SSLEngine)shc.conContext.transport;
shc.applicationProtocol =
shc.sslConfig.engineAPSelector.apply(engine, alps);
if ((shc.applicationProtocol == null) ||
(!shc.applicationProtocol.isEmpty() &&
!alps.contains(shc.applicationProtocol))) {
throw shc.conContext.fatal(
Alert.NO_APPLICATION_PROTOCOL,
"No matching application layer protocol values");
}
}
} else {
if (shc.sslConfig.socketAPSelector != null) {
SSLSocket socket = (SSLSocket)shc.conContext.transport;
shc.applicationProtocol =
shc.sslConfig.socketAPSelector.apply(socket, alps);
if ((shc.applicationProtocol == null) ||
(!shc.applicationProtocol.isEmpty() &&
!alps.contains(shc.applicationProtocol))) {
throw shc.conContext.fatal(
Alert.NO_APPLICATION_PROTOCOL,
"No matching application layer protocol values");
}
}
}
if ((shc.applicationProtocol == null) ||
(shc.applicationProtocol.isEmpty())) {
shc.applicationProtocol = "";
shc.conContext.applicationProtocol = "";
if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
SSLLogger.warning(
"Ignore, no negotiated application layer protocol");
}
return null;
}
byte[] bytes = shc.applicationProtocol.getBytes(alpnCharset);
int listLen = bytes.length + 1;
byte[] extData = new byte[listLen + 2];                 ByteBuffer m = ByteBuffer.wrap(extData);
Record.putInt16(m, listLen);
Record.putBytes8(m, bytes);
shc.conContext.applicationProtocol = shc.applicationProtocol;
shc.handshakeExtensions.remove(SSLExtension.CH_ALPN);
return extData;
}
}
private static final class SHAlpnConsumer implements ExtensionConsumer {
private SHAlpnConsumer() {
}
@Override
public void consume(ConnectionContext context,
HandshakeMessage message, ByteBuffer buffer) throws IOException {
ClientHandshakeContext chc = (ClientHandshakeContext)context;
AlpnSpec requestedAlps =
(AlpnSpec)chc.handshakeExtensions.get(SSLExtension.CH_ALPN);
if (requestedAlps == null ||
requestedAlps.applicationProtocols == null ||
requestedAlps.applicationProtocols.isEmpty()) {
throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
"Unexpected " + SSLExtension.CH_ALPN.name + " extension");
}
AlpnSpec spec = new AlpnSpec(chc, buffer);
if (spec.applicationProtocols.size() != 1) {
throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
"Invalid " + SSLExtension.CH_ALPN.name + " extension: " +
"Only one application protocol name " +
"is allowed in ServerHello message");
}
if (!requestedAlps.applicationProtocols.containsAll(
spec.applicationProtocols)) {
throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
"Invalid " + SSLExtension.CH_ALPN.name + " extension: " +
"Only client specified application protocol " +
"is allowed in ServerHello message");
}
chc.applicationProtocol = spec.applicationProtocols.get(0);
chc.conContext.applicationProtocol = chc.applicationProtocol;
chc.handshakeExtensions.remove(SSLExtension.CH_ALPN);
}
}
private static final class SHAlpnAbsence implements HandshakeAbsence {
@Override
public void absent(ConnectionContext context,
HandshakeMessage message) throws IOException {
ClientHandshakeContext chc = (ClientHandshakeContext)context;
chc.applicationProtocol = "";
chc.conContext.applicationProtocol = "";
}
}
}
package java.rmi;
public class AlreadyBoundException extends java.lang.Exception {
private static final long serialVersionUID = 9218657361741657110L;
public AlreadyBoundException() {
super();
}
public AlreadyBoundException(String s) {
super(s);
}
}
package javax.xml.catalog;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
class AltCatalog extends BaseEntry {
URI catalogURI;
AltCatalog(CatalogEntryType type, String base) {
super(type, base);
}
void setCatalog(String catalog) {
URL url = verifyURI("catalog", baseURI, catalog);
try {
catalogURI = url.toURI();
} catch (URISyntaxException ex) {
CatalogMessages.reportRunTimeError(CatalogMessages.ERR_OTHER, ex);
}
}
String getCatalogId() {
return catalogURI.toASCIIString();
}
URI getCatalogURI() {
return catalogURI;
}
public URI matchURI(String id, int currentMatch) {
return null;
}
}
package jdk.internal.joptsimple;
import jdk.internal.joptsimple.internal.Messages;
import java.util.Locale;
import static java.util.Collections.*;
import static jdk.internal.joptsimple.ParserRules.*;
class AlternativeLongOptionSpec extends ArgumentAcceptingOptionSpec<String> {
AlternativeLongOptionSpec() {
super( singletonList( RESERVED_FOR_EXTENSIONS ),
true,
Messages.message(
Locale.getDefault(),
"jdk.internal.joptsimple.HelpFormatterMessages",
AlternativeLongOptionSpec.class,
"description" ) );
describedAs( Messages.message(
Locale.getDefault(),
"jdk.internal.joptsimple.HelpFormatterMessages",
AlternativeLongOptionSpec.class,
"arg.description" ) );
}
@Override
protected void detectOptionArgument( OptionParser parser, ArgumentList arguments, OptionSet detectedOptions ) {
if ( !arguments.hasMore() )
throw new OptionMissingRequiredArgumentException( this );
arguments.treatNextAsLongOption();
}
}
package com.sun.org.apache.xalan.internal.xsltc.compiler;
import com.sun.org.apache.bcel.internal.generic.GOTO;
import com.sun.org.apache.bcel.internal.generic.InstructionHandle;
import com.sun.org.apache.bcel.internal.generic.InstructionList;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ClassGenerator;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.MethodGenerator;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
final class AlternativePattern extends Pattern {
private final Pattern _left;
private final Pattern _right;
public AlternativePattern(Pattern left, Pattern right) {
_left = left;
_right = right;
}
public void setParser(Parser parser) {
super.setParser(parser);
_left.setParser(parser);
_right.setParser(parser);
}
public Pattern getLeft() {
return _left;
}
public Pattern getRight() {
return _right;
}
public Type typeCheck(SymbolTable stable) throws TypeCheckError {
_left.typeCheck(stable);
_right.typeCheck(stable);
return null;
}
public double getPriority() {
double left = _left.getPriority();
double right = _right.getPriority();
if (left < right)
return(left);
else
return(right);
}
public String toString() {
return "alternative(" + _left + ", " + _right + ')';
}
public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
final InstructionList il = methodGen.getInstructionList();
_left.translate(classGen, methodGen);
final InstructionHandle gotot = il.append(new GOTO(null));
il.append(methodGen.loadContextNode());
_right.translate(classGen, methodGen);
_left._trueList.backPatch(gotot);
_left._falseList.backPatch(gotot.getNext());
_trueList.append(_right._trueList.add(gotot));
_falseList.append(_right._falseList);
}
}
package build.tools.jdwpgen;
import java.util.*;
import java.io.*;
class AltNode extends AbstractGroupNode implements TypeNode {
SelectNode select = null;
void constrain(Context ctx) {
super.constrain(ctx);
if (!(nameNode instanceof NameValueNode)) {
error("Alt name must have value: " + nameNode);
}
if (parent instanceof SelectNode) {
select = (SelectNode)parent;
} else {
error("Alt must be in Select");
}
}
void document(PrintWriter writer) {
writer.println("<tr>");
writer.println("<th colspan=\"2\" scope=\"row\">"
+ indentElement(structIndent,
"Case " + nameNode.name
+ " - if <i>" + ((SelectNode)parent).typeNode.name + "</i>" +
" is " + nameNode.value() + ":"));
writer.println("<td>" + comment() + "&nbsp;");
writer.println("</tr>");
++structIndent;
super.document(writer);
--structIndent;
}
String javaClassImplements() {
return " extends " + select.commonBaseClass();
}
void genJavaClassSpecifics(PrintWriter writer, int depth) {
indent(writer, depth);
writer.print("static final " + select.typeNode.javaType());
writer.println(" ALT_ID = " + nameNode.value() + ";");
if (context.isWritingCommand()) {
genJavaCreateMethod(writer, depth);
} else {
indent(writer, depth);
writer.println(select.typeNode.javaParam() + "() {");
indent(writer, depth+1);
writer.println("return ALT_ID;");
indent(writer, depth);
writer.println("}");
}
super.genJavaClassSpecifics(writer, depth);
}
void genJavaWriteMethod(PrintWriter writer, int depth) {
genJavaWriteMethod(writer, depth, "");
}
void genJavaReadsSelectCase(PrintWriter writer, int depth, String common) {
indent(writer, depth);
writer.println("case " + nameNode.value() + ":");
indent(writer, depth+1);
writer.println(common + " = new " + name + "(vm, ps);");
indent(writer, depth+1);
writer.println("break;");
}
void genJavaCreateMethod(PrintWriter writer, int depth) {
indent(writer, depth);
writer.print("static " + select.name() + " create(");
writer.print(javaParams());
writer.println(") {");
indent(writer, depth+1);
writer.print("return new " + select.name() + "(");
writer.print("ALT_ID, new " + javaClassName() + "(");
for (Iterator<Node> it = components.iterator(); it.hasNext();) {
TypeNode tn = (TypeNode)it.next();
writer.print(tn.name());
if (it.hasNext()) {
writer.print(", ");
}
}
writer.println("));");
indent(writer, depth);
writer.println("}");
}
}
package sun.jvm.hotspot.utilities;
public interface AltPlatformInfo {
public boolean knownCPU(String cpu);
public String getCPU(String cpu);
}
package com.sun.tools.example.debug.tty;
public class AmbiguousMethodException extends Exception
{
private static final long serialVersionUID = -5372629264936918654L;
public AmbiguousMethodException()
{
super();
}
public AmbiguousMethodException(String s)
{
super(s);
}
}
package jdk.vm.ci.amd64;
import static jdk.vm.ci.code.MemoryBarriers.LOAD_LOAD;
import static jdk.vm.ci.code.MemoryBarriers.LOAD_STORE;
import static jdk.vm.ci.code.MemoryBarriers.STORE_STORE;
import static jdk.vm.ci.code.Register.SPECIAL;
import java.nio.ByteOrder;
import java.util.EnumSet;
import jdk.vm.ci.code.Architecture;
import jdk.vm.ci.code.CPUFeatureName;
import jdk.vm.ci.code.Register;
import jdk.vm.ci.code.Register.RegisterCategory;
import jdk.vm.ci.code.RegisterArray;
import jdk.vm.ci.meta.JavaKind;
import jdk.vm.ci.meta.PlatformKind;
public class AMD64 extends Architecture {
public static final RegisterCategory CPU = new RegisterCategory("CPU");
public static final Register rax = new Register(0, 0, "rax", CPU);
public static final Register rcx = new Register(1, 1, "rcx", CPU);
public static final Register rdx = new Register(2, 2, "rdx", CPU);
public static final Register rbx = new Register(3, 3, "rbx", CPU);
public static final Register rsp = new Register(4, 4, "rsp", CPU);
public static final Register rbp = new Register(5, 5, "rbp", CPU);
public static final Register rsi = new Register(6, 6, "rsi", CPU);
public static final Register rdi = new Register(7, 7, "rdi", CPU);
public static final Register r8  = new Register(8,  8,  "r8", CPU);
public static final Register r9  = new Register(9,  9,  "r9", CPU);
public static final Register r10 = new Register(10, 10, "r10", CPU);
public static final Register r11 = new Register(11, 11, "r11", CPU);
public static final Register r12 = new Register(12, 12, "r12", CPU);
public static final Register r13 = new Register(13, 13, "r13", CPU);
public static final Register r14 = new Register(14, 14, "r14", CPU);
public static final Register r15 = new Register(15, 15, "r15", CPU);
public static final Register[] cpuRegisters = {
rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi,
r8, r9, r10, r11, r12, r13, r14, r15
};
public static final RegisterCategory XMM = new RegisterCategory("XMM");
public static final Register xmm0 = new Register(16, 0, "xmm0", XMM);
public static final Register xmm1 = new Register(17, 1, "xmm1", XMM);
public static final Register xmm2 = new Register(18, 2, "xmm2", XMM);
public static final Register xmm3 = new Register(19, 3, "xmm3", XMM);
public static final Register xmm4 = new Register(20, 4, "xmm4", XMM);
public static final Register xmm5 = new Register(21, 5, "xmm5", XMM);
public static final Register xmm6 = new Register(22, 6, "xmm6", XMM);
public static final Register xmm7 = new Register(23, 7, "xmm7", XMM);
public static final Register xmm8  = new Register(24,  8, "xmm8",  XMM);
public static final Register xmm9  = new Register(25,  9, "xmm9",  XMM);
public static final Register xmm10 = new Register(26, 10, "xmm10", XMM);
public static final Register xmm11 = new Register(27, 11, "xmm11", XMM);
public static final Register xmm12 = new Register(28, 12, "xmm12", XMM);
public static final Register xmm13 = new Register(29, 13, "xmm13", XMM);
public static final Register xmm14 = new Register(30, 14, "xmm14", XMM);
public static final Register xmm15 = new Register(31, 15, "xmm15", XMM);
public static final Register xmm16 = new Register(32, 16, "xmm16", XMM);
public static final Register xmm17 = new Register(33, 17, "xmm17", XMM);
public static final Register xmm18 = new Register(34, 18, "xmm18", XMM);
public static final Register xmm19 = new Register(35, 19, "xmm19", XMM);
public static final Register xmm20 = new Register(36, 20, "xmm20", XMM);
public static final Register xmm21 = new Register(37, 21, "xmm21", XMM);
public static final Register xmm22 = new Register(38, 22, "xmm22", XMM);
public static final Register xmm23 = new Register(39, 23, "xmm23", XMM);
public static final Register xmm24 = new Register(40, 24, "xmm24", XMM);
public static final Register xmm25 = new Register(41, 25, "xmm25", XMM);
public static final Register xmm26 = new Register(42, 26, "xmm26", XMM);
public static final Register xmm27 = new Register(43, 27, "xmm27", XMM);
public static final Register xmm28 = new Register(44, 28, "xmm28", XMM);
public static final Register xmm29 = new Register(45, 29, "xmm29", XMM);
public static final Register xmm30 = new Register(46, 30, "xmm30", XMM);
public static final Register xmm31 = new Register(47, 31, "xmm31", XMM);
public static final Register[] xmmRegistersSSE = {
xmm0, xmm1, xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,
xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15
};
public static final Register[] xmmRegistersAVX512 = {
xmm0, xmm1, xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,
xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,
xmm16, xmm17, xmm18, xmm19, xmm20, xmm21, xmm22, xmm23,
xmm24, xmm25, xmm26, xmm27, xmm28, xmm29, xmm30, xmm31
};
public static final RegisterCategory MASK = new RegisterCategory("MASK", false);
public static final Register k0 = new Register(48, 0, "k0", MASK);
public static final Register k1 = new Register(49, 1, "k1", MASK);
public static final Register k2 = new Register(50, 2, "k2", MASK);
public static final Register k3 = new Register(51, 3, "k3", MASK);
public static final Register k4 = new Register(52, 4, "k4", MASK);
public static final Register k5 = new Register(53, 5, "k5", MASK);
public static final Register k6 = new Register(54, 6, "k6", MASK);
public static final Register k7 = new Register(55, 7, "k7", MASK);
public static final RegisterArray valueRegistersSSE = new RegisterArray(
rax,  rcx,  rdx,   rbx,   rsp,   rbp,   rsi,   rdi,
r8,   r9,   r10,   r11,   r12,   r13,   r14,   r15,
xmm0, xmm1, xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,
xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15
);
public static final RegisterArray valueRegistersAVX512 = new RegisterArray(
rax,  rcx,  rdx,   rbx,   rsp,   rbp,   rsi,   rdi,
r8,   r9,   r10,   r11,   r12,   r13,   r14,   r15,
xmm0, xmm1, xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,
xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,
xmm16, xmm17, xmm18, xmm19, xmm20, xmm21, xmm22, xmm23,
xmm24, xmm25, xmm26, xmm27, xmm28, xmm29, xmm30, xmm31,
k0, k1, k2, k3, k4, k5, k6, k7
);
public static final Register rip = new Register(56, -1, "rip", SPECIAL);
public static final RegisterArray allRegisters = new RegisterArray(
rax,  rcx,  rdx,   rbx,   rsp,   rbp,   rsi,   rdi,
r8,   r9,   r10,   r11,   r12,   r13,   r14,   r15,
xmm0, xmm1, xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,
xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,
xmm16, xmm17, xmm18, xmm19, xmm20, xmm21, xmm22, xmm23,
xmm24, xmm25, xmm26, xmm27, xmm28, xmm29, xmm30, xmm31,
k0, k1, k2, k3, k4, k5, k6, k7,
rip
);
public enum CPUFeature implements CPUFeatureName {
CX8,
CMOV,
FXSR,
HT,
MMX,
AMD_3DNOW_PREFETCH,
SSE,
SSE2,
SSE3,
SSSE3,
SSE4A,
SSE4_1,
SSE4_2,
POPCNT,
LZCNT,
TSC,
TSCINV,
TSCINV_BIT,
AVX,
AVX2,
AES,
ERMS,
CLMUL,
BMI1,
BMI2,
RTM,
ADX,
AVX512F,
AVX512DQ,
AVX512PF,
AVX512ER,
AVX512CD,
AVX512BW,
AVX512VL,
SHA,
FMA,
VZEROUPPER,
AVX512_VPOPCNTDQ,
AVX512_VPCLMULQDQ,
AVX512_VAES,
AVX512_VNNI,
FLUSH,
FLUSHOPT,
CLWB,
AVX512_VBMI2,
AVX512_VBMI,
HV,
SERIALIZE,
RDTSCP,
RDPID,
FSRM,
GFNI,
AVX512_BITALG,
}
private final EnumSet<CPUFeature> features;
public enum Flag {
UseCountLeadingZerosInstruction,
UseCountTrailingZerosInstruction
}
private final EnumSet<Flag> flags;
private final AMD64Kind largestKind;
public AMD64(EnumSet<CPUFeature> features, EnumSet<Flag> flags) {
super("AMD64", AMD64Kind.QWORD, ByteOrder.LITTLE_ENDIAN, true, allRegisters, LOAD_LOAD | LOAD_STORE | STORE_STORE, 1, 8);
this.features = features;
this.flags = flags;
assert features.contains(CPUFeature.SSE2) : "minimum config for x64";
if (features.contains(CPUFeature.AVX512F)) {
largestKind = AMD64Kind.V512_QWORD;
} else if (features.contains(CPUFeature.AVX)) {
largestKind = AMD64Kind.V256_QWORD;
} else {
largestKind = AMD64Kind.V128_QWORD;
}
}
@Override
public EnumSet<CPUFeature> getFeatures() {
return features;
}
public EnumSet<Flag> getFlags() {
return flags;
}
@Override
public RegisterArray getAvailableValueRegisters() {
if (features.contains(CPUFeature.AVX512F)) {
return valueRegistersAVX512;
} else {
return valueRegistersSSE;
}
}
@Override
public PlatformKind getPlatformKind(JavaKind javaKind) {
switch (javaKind) {
case Boolean:
case Byte:
return AMD64Kind.BYTE;
case Short:
case Char:
return AMD64Kind.WORD;
case Int:
return AMD64Kind.DWORD;
case Long:
case Object:
return AMD64Kind.QWORD;
case Float:
return AMD64Kind.SINGLE;
case Double:
return AMD64Kind.DOUBLE;
default:
return null;
}
}
@Override
public boolean canStoreValue(RegisterCategory category, PlatformKind platformKind) {
AMD64Kind kind = (AMD64Kind) platformKind;
if (kind.isInteger()) {
return category.equals(CPU);
} else if (kind.isXMM()) {
return category.equals(XMM);
} else {
assert kind.isMask();
return category.equals(MASK);
}
}
@Override
public AMD64Kind getLargestStorableKind(RegisterCategory category) {
if (category.equals(CPU)) {
return AMD64Kind.QWORD;
} else if (category.equals(XMM)) {
return largestKind;
} else if (category.equals(MASK)) {
return AMD64Kind.MASK64;
} else {
return null;
}
}
}
package sun.jvm.hotspot.runtime.amd64;
import sun.jvm.hotspot.debugger.*;
import sun.jvm.hotspot.debugger.amd64.*;
import sun.jvm.hotspot.code.*;
import sun.jvm.hotspot.interpreter.*;
import sun.jvm.hotspot.oops.*;
import sun.jvm.hotspot.runtime.*;
import sun.jvm.hotspot.runtime.x86.*;
import sun.jvm.hotspot.types.*;
import sun.jvm.hotspot.utilities.*;
public class AMD64CurrentFrameGuess {
private AMD64ThreadContext context;
private JavaThread       thread;
private Address          spFound;
private Address          fpFound;
private Address          pcFound;
private static final boolean DEBUG = System.getProperty("sun.jvm.hotspot.runtime.amd64.AMD64Frame.DEBUG")
!= null;
public AMD64CurrentFrameGuess(AMD64ThreadContext context,
JavaThread thread) {
this.context = context;
this.thread  = thread;
}
private boolean validateInterpreterFrame(Address sp, Address fp, Address pc) {
VM vm = VM.getVM();
X86Frame f = new X86Frame(sp, fp, pc);
Method method = null;
try {
method = f.getInterpreterFrameMethod();
} catch (WrongTypeException | AddressException | NullPointerException e) {
if (DEBUG) {
System.out.println("CurrentFrameGuess: frame->method is invalid");
}
}
if (method != null && f.getInterpreterFrameBCP() != null) {
if (method.getConstMethod().isAddressInMethod(f.getInterpreterFrameBCP())) {
setValues(sp, fp, pc);
return true;
} else {
if (DEBUG) {
System.out.println("CurrentFrameGuess: frame->bcp is invalid");
}
}
}
Address returnAddress = context.getRegisterAsAddress(AMD64ThreadContext.RAX);
CodeCache c = VM.getVM().getCodeCache();
if (returnAddress == null || !c.contains(returnAddress)) {
returnAddress = sp.getAddressAt(0);        if (returnAddress == null || !c.contains(returnAddress)) {
if (DEBUG) {
System.out.println("CurrentFrameGuess: Cannot find valid returnAddress");
}
setValues(sp, fp, pc);
return false;       } else {
if (DEBUG) {
System.out.println("CurrentFrameGuess: returnAddress found on stack: " + returnAddress);
}
}
} else {
if (DEBUG) {
System.out.println("CurrentFrameGuess: returnAddress found in RAX: " + returnAddress);
}
}
Address returnAddress2 = null;
try {
returnAddress2 = f.getSenderPC();
} catch (AddressException e) {
if (DEBUG) {
System.out.println("CurrentFrameGuess: senderPC is invalid");
}
}
if (DEBUG) {
System.out.println("CurrentFrameGuess: returnAddress2: " + returnAddress2);
}
if (returnAddress.equals(returnAddress2)) {
if (DEBUG) {
System.out.println("CurrentFrameGuess: frame pushed but not initialized.");
}
sp = f.getSenderSP();
fp = f.getLink();
setValues(sp, fp, returnAddress);
if (vm.getInterpreter().contains(returnAddress)) {
if (DEBUG) {
System.out.println("CurrentFrameGuess: Interpreted: using previous frame.");
}
return true;
} else {
if (DEBUG) {
System.out.println("CurrentFrameGuess: Not Interpreted: using previous frame.");
}
return false;
}
} else {
setValues(sp, fp, returnAddress);
if (DEBUG) {
System.out.println("CurrentFrameGuess: Frame not yet pushed. Previous frame not interpreted.");
}
return false;
}
}
public boolean run(long regionInBytesToSearch) {
Address sp  = context.getRegisterAsAddress(AMD64ThreadContext.RSP);
Address pc  = context.getRegisterAsAddress(AMD64ThreadContext.RIP);
Address fp  = context.getRegisterAsAddress(AMD64ThreadContext.RBP);
if (sp == null) {
return checkLastJavaSP();
}
Address end = sp.addOffsetTo(regionInBytesToSearch);
VM vm       = VM.getVM();
setValues(null, null, null);
if (!vm.isJavaPCDbg(pc)) {
return checkLastJavaSP();
} else {
if (vm.isClientCompiler()) {
setValues(sp, fp, pc);
return true;
} else {
if (vm.getInterpreter().contains(pc)) {
if (validateInterpreterFrame(sp, fp, pc)) {
if (DEBUG) {
System.out.println("CurrentFrameGuess: choosing interpreter frame: sp = " +
spFound + ", fp = " + fpFound + ", pc = " + pcFound);
}
return true;           } else {
sp = spFound;
fp = fpFound;
pc = pcFound;
setValues(null, null, null);
if (pcFound == null) {
return false;
}
if (!vm.isJavaPCDbg(pc)) {
return checkLastJavaSP();
}
}
}
if (DEBUG) {
System.out.println("CurrentFrameGuess: sp = " + sp + ", pc = " + pc);
}
for (long offset = 0;
offset < regionInBytesToSearch;
offset += vm.getAddressSize()) {
try {
Address curSP = sp.addOffsetTo(offset);
Frame frame = new X86Frame(curSP, null, pc);
RegisterMap map = thread.newRegisterMap(false);
while (frame != null) {
if (frame.isEntryFrame() && frame.entryFrameIsFirst()) {
if (DEBUG) {
System.out.println("CurrentFrameGuess: Choosing sp = " + curSP + ", pc = " + pc);
}
setValues(curSP, null, pc);
return true;
}
Frame oldFrame = frame;
frame = frame.sender(map);
if (frame.getSP().lessThanOrEqual(oldFrame.getSP())) {
if (DEBUG) {
System.out.println("CurrentFrameGuess: frame <= oldFrame: " + frame);
}
break;
}
}
} catch (Exception e) {
if (DEBUG) {
System.out.println("CurrentFrameGuess: Exception " + e + " at offset " + offset);
}
}
}
return false;
}
}
}
private boolean checkLastJavaSP() {
if (DEBUG) {
System.out.println("CurrentFrameGuess: choosing last Java frame: sp = " +
thread.getLastJavaSP() + ", fp = " + thread.getLastJavaFP());
}
if (thread.getLastJavaSP() == null) {
return false;     }
setValues(thread.getLastJavaSP(), thread.getLastJavaFP(), null);
return true;
}
public Address getSP() { return spFound; }
public Address getFP() { return fpFound; }
public Address getPC() { return pcFound; }
private void setValues(Address sp, Address fp, Address pc) {
spFound = sp;
fpFound = fp;
pcFound = pc;
}
}
package jdk.vm.ci.hotspot.amd64;
import static jdk.vm.ci.common.InitTimer.timer;
import java.util.EnumSet;
import java.util.Map;
import jdk.vm.ci.amd64.AMD64;
import jdk.vm.ci.amd64.AMD64.CPUFeature;
import jdk.vm.ci.code.Architecture;
import jdk.vm.ci.code.RegisterConfig;
import jdk.vm.ci.code.TargetDescription;
import jdk.vm.ci.code.stack.StackIntrospection;
import jdk.vm.ci.common.InitTimer;
import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;
import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;
import jdk.vm.ci.hotspot.HotSpotJVMCIBackendFactory;
import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
import jdk.vm.ci.hotspot.HotSpotMetaAccessProvider;
import jdk.vm.ci.hotspot.HotSpotStackIntrospection;
import jdk.vm.ci.meta.ConstantReflectionProvider;
import jdk.vm.ci.runtime.JVMCIBackend;
public class AMD64HotSpotJVMCIBackendFactory implements HotSpotJVMCIBackendFactory {
private static EnumSet<CPUFeature> computeFeatures(AMD64HotSpotVMConfig config) {
Map<String, Long> constants = config.getStore().getConstants();
Map<String, String> renaming = Map.of("3DNOW_PREFETCH", "AMD_3DNOW_PREFETCH");
assert config.useSSE >= 2 : "minimum config for x64";
EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, renaming);
features.add(AMD64.CPUFeature.SSE);
features.add(AMD64.CPUFeature.SSE2);
return features;
}
private static EnumSet<AMD64.Flag> computeFlags(AMD64HotSpotVMConfig config) {
EnumSet<AMD64.Flag> flags = EnumSet.noneOf(AMD64.Flag.class);
if (config.useCountLeadingZerosInstruction) {
flags.add(AMD64.Flag.UseCountLeadingZerosInstruction);
}
if (config.useCountTrailingZerosInstruction) {
flags.add(AMD64.Flag.UseCountTrailingZerosInstruction);
}
return flags;
}
private static TargetDescription createTarget(AMD64HotSpotVMConfig config) {
final int stackFrameAlignment = 16;
final int implicitNullCheckLimit = 4096;
final boolean inlineObjects = true;
Architecture arch = new AMD64(computeFeatures(config), computeFlags(config));
return new TargetDescription(arch, true, stackFrameAlignment, implicitNullCheckLimit, inlineObjects);
}
protected HotSpotConstantReflectionProvider createConstantReflection(HotSpotJVMCIRuntime runtime) {
return new HotSpotConstantReflectionProvider(runtime);
}
private static RegisterConfig createRegisterConfig(AMD64HotSpotVMConfig config, TargetDescription target) {
return new AMD64HotSpotRegisterConfig(target, config.useCompressedOops, config.windowsOs);
}
protected HotSpotCodeCacheProvider createCodeCache(HotSpotJVMCIRuntime runtime, TargetDescription target, RegisterConfig regConfig) {
return new HotSpotCodeCacheProvider(runtime, target, regConfig);
}
protected HotSpotMetaAccessProvider createMetaAccess(HotSpotJVMCIRuntime runtime) {
return new HotSpotMetaAccessProvider(runtime);
}
@Override
public String getArchitecture() {
return "AMD64";
}
@Override
public String toString() {
return "JVMCIBackend:" + getArchitecture();
}
@Override
@SuppressWarnings("try")
public JVMCIBackend createJVMCIBackend(HotSpotJVMCIRuntime runtime, JVMCIBackend host) {
assert host == null;
AMD64HotSpotVMConfig config = new AMD64HotSpotVMConfig(runtime.getConfigStore());
TargetDescription target = createTarget(config);
RegisterConfig regConfig;
HotSpotCodeCacheProvider codeCache;
ConstantReflectionProvider constantReflection;
HotSpotMetaAccessProvider metaAccess;
StackIntrospection stackIntrospection;
try (InitTimer t = timer("create providers")) {
try (InitTimer rt = timer("create MetaAccess provider")) {
metaAccess = createMetaAccess(runtime);
}
try (InitTimer rt = timer("create RegisterConfig")) {
regConfig = createRegisterConfig(config, target);
}
try (InitTimer rt = timer("create CodeCache provider")) {
codeCache = createCodeCache(runtime, target, regConfig);
}
try (InitTimer rt = timer("create ConstantReflection provider")) {
constantReflection = createConstantReflection(runtime);
}
try (InitTimer rt = timer("create StackIntrospection provider")) {
stackIntrospection = new HotSpotStackIntrospection(runtime);
}
}
try (InitTimer rt = timer("instantiate backend")) {
return createBackend(metaAccess, codeCache, constantReflection, stackIntrospection);
}
}
protected JVMCIBackend createBackend(HotSpotMetaAccessProvider metaAccess, HotSpotCodeCacheProvider codeCache, ConstantReflectionProvider constantReflection,
StackIntrospection stackIntrospection) {
return new JVMCIBackend(metaAccess, codeCache, constantReflection, stackIntrospection);
}
}
package jdk.vm.ci.hotspot.amd64;
import static jdk.vm.ci.amd64.AMD64.r12;
import static jdk.vm.ci.amd64.AMD64.r15;
import static jdk.vm.ci.amd64.AMD64.r8;
import static jdk.vm.ci.amd64.AMD64.r9;
import static jdk.vm.ci.amd64.AMD64.rax;
import static jdk.vm.ci.amd64.AMD64.rcx;
import static jdk.vm.ci.amd64.AMD64.rdi;
import static jdk.vm.ci.amd64.AMD64.rdx;
import static jdk.vm.ci.amd64.AMD64.rsi;
import static jdk.vm.ci.amd64.AMD64.rsp;
import static jdk.vm.ci.amd64.AMD64.xmm0;
import static jdk.vm.ci.amd64.AMD64.xmm1;
import static jdk.vm.ci.amd64.AMD64.xmm2;
import static jdk.vm.ci.amd64.AMD64.xmm3;
import static jdk.vm.ci.amd64.AMD64.xmm4;
import static jdk.vm.ci.amd64.AMD64.xmm5;
import static jdk.vm.ci.amd64.AMD64.xmm6;
import static jdk.vm.ci.amd64.AMD64.xmm7;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import jdk.vm.ci.code.Architecture;
import jdk.vm.ci.code.CallingConvention;
import jdk.vm.ci.code.CallingConvention.Type;
import jdk.vm.ci.code.Register;
import jdk.vm.ci.code.RegisterArray;
import jdk.vm.ci.code.RegisterAttributes;
import jdk.vm.ci.code.RegisterConfig;
import jdk.vm.ci.code.StackSlot;
import jdk.vm.ci.code.TargetDescription;
import jdk.vm.ci.code.ValueKindFactory;
import jdk.vm.ci.common.JVMCIError;
import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
import jdk.vm.ci.meta.AllocatableValue;
import jdk.vm.ci.meta.JavaKind;
import jdk.vm.ci.meta.JavaType;
import jdk.vm.ci.meta.PlatformKind;
import jdk.vm.ci.meta.Value;
import jdk.vm.ci.meta.ValueKind;
public class AMD64HotSpotRegisterConfig implements RegisterConfig {
private final TargetDescription target;
private final RegisterArray allocatable;
private final RegisterArray callerSaved;
private final boolean allAllocatableAreCallerSaved;
private final RegisterAttributes[] attributesMap;
@Override
public RegisterArray getAllocatableRegisters() {
return allocatable;
}
@Override
public RegisterArray filterAllocatableRegisters(PlatformKind kind, RegisterArray registers) {
ArrayList<Register> list = new ArrayList<>();
for (Register reg : registers) {
if (target.arch.canStoreValue(reg.getRegisterCategory(), kind)) {
list.add(reg);
}
}
RegisterArray ret = new RegisterArray(list);
return ret;
}
@Override
public RegisterAttributes[] getAttributesMap() {
return attributesMap.clone();
}
private final RegisterArray javaGeneralParameterRegisters;
private final RegisterArray nativeGeneralParameterRegisters;
private final RegisterArray javaXMMParameterRegisters;
private final RegisterArray nativeXMMParameterRegisters;
private final boolean windowsOS;
private final boolean needsNativeStackHomeSpace;
private static final RegisterArray reservedRegisters = new RegisterArray(rsp, r15);
private static RegisterArray initAllocatable(Architecture arch, boolean reserveForHeapBase) {
RegisterArray allRegisters = arch.getAvailableValueRegisters();
Register[] registers = new Register[allRegisters.size() - reservedRegisters.size() - (reserveForHeapBase ? 1 : 0)];
List<Register> reservedRegistersList = reservedRegisters.asList();
int idx = 0;
for (Register reg : allRegisters) {
if (reservedRegistersList.contains(reg)) {
continue;
}
if (reserveForHeapBase && reg.equals(r12)) {
continue;
}
registers[idx++] = reg;
}
assert idx == registers.length;
return new RegisterArray(registers);
}
public AMD64HotSpotRegisterConfig(TargetDescription target, boolean useCompressedOops, boolean windowsOs) {
this(target, initAllocatable(target.arch, useCompressedOops), windowsOs);
assert callerSaved.size() >= allocatable.size();
}
public AMD64HotSpotRegisterConfig(TargetDescription target, RegisterArray allocatable, boolean windowsOS) {
this.target = target;
this.windowsOS = windowsOS;
if (windowsOS) {
javaGeneralParameterRegisters = new RegisterArray(rdx, r8, r9, rdi, rsi, rcx);
nativeGeneralParameterRegisters = new RegisterArray(rcx, rdx, r8, r9);
nativeXMMParameterRegisters = new RegisterArray(xmm0, xmm1, xmm2, xmm3);
this.needsNativeStackHomeSpace = true;
} else {
javaGeneralParameterRegisters = new RegisterArray(rsi, rdx, rcx, r8, r9, rdi);
nativeGeneralParameterRegisters = new RegisterArray(rdi, rsi, rdx, rcx, r8, r9);
nativeXMMParameterRegisters = new RegisterArray(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7);
this.needsNativeStackHomeSpace = false;
}
javaXMMParameterRegisters = new RegisterArray(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7);
this.allocatable = allocatable;
Set<Register> callerSaveSet = new HashSet<>();
allocatable.addTo(callerSaveSet);
javaXMMParameterRegisters.addTo(callerSaveSet);
callerSaveSet.addAll(javaGeneralParameterRegisters.asList());
nativeGeneralParameterRegisters.addTo(callerSaveSet);
callerSaved = new RegisterArray(callerSaveSet);
allAllocatableAreCallerSaved = true;
attributesMap = RegisterAttributes.createMap(this, target.arch.getRegisters());
}
@Override
public RegisterArray getCallerSaveRegisters() {
return callerSaved;
}
@Override
public RegisterArray getCalleeSaveRegisters() {
return null;
}
@Override
public boolean areAllAllocatableRegistersCallerSaved() {
return allAllocatableAreCallerSaved;
}
@Override
public CallingConvention getCallingConvention(Type type, JavaType returnType, JavaType[] parameterTypes, ValueKindFactory<?> valueKindFactory) {
HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;
if (type == HotSpotCallingConventionType.NativeCall) {
return callingConvention(nativeGeneralParameterRegisters, nativeXMMParameterRegisters, windowsOS, returnType, parameterTypes, hotspotType, valueKindFactory);
}
return callingConvention(javaGeneralParameterRegisters, javaXMMParameterRegisters, false, returnType, parameterTypes, hotspotType, valueKindFactory);
}
@Override
public RegisterArray getCallingConventionRegisters(Type type, JavaKind kind) {
HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;
switch (kind) {
case Boolean:
case Byte:
case Short:
case Char:
case Int:
case Long:
case Object:
return hotspotType == HotSpotCallingConventionType.NativeCall ? nativeGeneralParameterRegisters : javaGeneralParameterRegisters;
case Float:
case Double:
return hotspotType == HotSpotCallingConventionType.NativeCall ? nativeXMMParameterRegisters : javaXMMParameterRegisters;
default:
throw JVMCIError.shouldNotReachHere();
}
}
private CallingConvention callingConvention(RegisterArray generalParameterRegisters, RegisterArray xmmParameterRegisters, boolean unified, JavaType returnType, JavaType[] parameterTypes,
HotSpotCallingConventionType type,
ValueKindFactory<?> valueKindFactory) {
assert !unified || generalParameterRegisters.size() == xmmParameterRegisters.size() : "must be same size in unified mode";
AllocatableValue[] locations = new AllocatableValue[parameterTypes.length];
int currentGeneral = 0;
int currentXMM = 0;
int currentStackOffset = type == HotSpotCallingConventionType.NativeCall && needsNativeStackHomeSpace ? generalParameterRegisters.size() * target.wordSize : 0;
for (int i = 0; i < parameterTypes.length; i++) {
final JavaKind kind = parameterTypes[i].getJavaKind().getStackKind();
switch (kind) {
case Byte:
case Boolean:
case Short:
case Char:
case Int:
case Long:
case Object:
if (currentGeneral < generalParameterRegisters.size()) {
Register register = generalParameterRegisters.get(currentGeneral++);
locations[i] = register.asValue(valueKindFactory.getValueKind(kind));
}
break;
case Float:
case Double:
if ((unified ? currentGeneral : currentXMM) < xmmParameterRegisters.size()) {
Register register = xmmParameterRegisters.get(unified ? currentGeneral++ : currentXMM++);
locations[i] = register.asValue(valueKindFactory.getValueKind(kind));
}
break;
default:
throw JVMCIError.shouldNotReachHere();
}
if (locations[i] == null) {
ValueKind<?> valueKind = valueKindFactory.getValueKind(kind);
locations[i] = StackSlot.get(valueKind, currentStackOffset, !type.out);
currentStackOffset += Math.max(valueKind.getPlatformKind().getSizeInBytes(), target.wordSize);
}
}
assert !unified || currentXMM == 0 : "shouldn't be used in unified mode";
JavaKind returnKind = returnType == null ? JavaKind.Void : returnType.getJavaKind();
AllocatableValue returnLocation = returnKind == JavaKind.Void ? Value.ILLEGAL : getReturnRegister(returnKind).asValue(valueKindFactory.getValueKind(returnKind.getStackKind()));
return new CallingConvention(currentStackOffset, returnLocation, locations);
}
@Override
public Register getReturnRegister(JavaKind kind) {
switch (kind) {
case Boolean:
case Byte:
case Char:
case Short:
case Int:
case Long:
case Object:
return rax;
case Float:
case Double:
return xmm0;
case Void:
case Illegal:
return null;
default:
throw new UnsupportedOperationException("no return register for type " + kind);
}
}
@Override
public Register getFrameRegister() {
return rsp;
}
@Override
public String toString() {
return String.format("Allocatable: " + getAllocatableRegisters() + "%n" + "CallerSave:  " + getCallerSaveRegisters() + "%n");
}
}
package jdk.vm.ci.hotspot.amd64;
import jdk.vm.ci.hotspot.HotSpotVMConfigAccess;
import jdk.vm.ci.hotspot.HotSpotVMConfigStore;
import jdk.vm.ci.services.Services;
class AMD64HotSpotVMConfig extends HotSpotVMConfigAccess {
AMD64HotSpotVMConfig(HotSpotVMConfigStore config) {
super(config);
}
final boolean windowsOs = Services.getSavedProperty("os.name", "").startsWith("Windows");
final boolean useCountLeadingZerosInstruction = getFlag("UseCountLeadingZerosInstruction", Boolean.class);
final boolean useCountTrailingZerosInstruction = getFlag("UseCountTrailingZerosInstruction", Boolean.class);
final boolean useCompressedOops = getFlag("UseCompressedOops", Boolean.class);
final int useSSE = getFlag("UseSSE", Integer.class);
final int useAVX = getFlag("UseAVX", Integer.class);
final long vmVersionFeatures = getFieldValue("Abstract_VM_Version::_features", Long.class, "uint64_t");
final long amd64CX8 = getConstant("VM_Version::CPU_CX8", Long.class);
final long amd64CMOV = getConstant("VM_Version::CPU_CMOV", Long.class);
final long amd64FXSR = getConstant("VM_Version::CPU_FXSR", Long.class);
final long amd64HT = getConstant("VM_Version::CPU_HT", Long.class);
final long amd64MMX = getConstant("VM_Version::CPU_MMX", Long.class);
final long amd643DNOWPREFETCH = getConstant("VM_Version::CPU_3DNOW_PREFETCH", Long.class);
final long amd64SSE = getConstant("VM_Version::CPU_SSE", Long.class);
final long amd64SSE2 = getConstant("VM_Version::CPU_SSE2", Long.class);
final long amd64SSE3 = getConstant("VM_Version::CPU_SSE3", Long.class);
final long amd64SSSE3 = getConstant("VM_Version::CPU_SSSE3", Long.class);
final long amd64SSE4A = getConstant("VM_Version::CPU_SSE4A", Long.class);
final long amd64SSE41 = getConstant("VM_Version::CPU_SSE4_1", Long.class);
final long amd64SSE42 = getConstant("VM_Version::CPU_SSE4_2", Long.class);
final long amd64POPCNT = getConstant("VM_Version::CPU_POPCNT", Long.class);
final long amd64LZCNT = getConstant("VM_Version::CPU_LZCNT", Long.class);
final long amd64TSC = getConstant("VM_Version::CPU_TSC", Long.class);
final long amd64TSCINV = getConstant("VM_Version::CPU_TSCINV", Long.class);
final long amd64AVX = getConstant("VM_Version::CPU_AVX", Long.class);
final long amd64AVX2 = getConstant("VM_Version::CPU_AVX2", Long.class);
final long amd64AES = getConstant("VM_Version::CPU_AES", Long.class);
final long amd64ERMS = getConstant("VM_Version::CPU_ERMS", Long.class);
final long amd64CLMUL = getConstant("VM_Version::CPU_CLMUL", Long.class);
final long amd64BMI1 = getConstant("VM_Version::CPU_BMI1", Long.class);
final long amd64BMI2 = getConstant("VM_Version::CPU_BMI2", Long.class);
final long amd64RTM = getConstant("VM_Version::CPU_RTM", Long.class);
final long amd64ADX = getConstant("VM_Version::CPU_ADX", Long.class);
final long amd64AVX512F = getConstant("VM_Version::CPU_AVX512F", Long.class);
final long amd64AVX512DQ = getConstant("VM_Version::CPU_AVX512DQ", Long.class);
final long amd64AVX512PF = getConstant("VM_Version::CPU_AVX512PF", Long.class);
final long amd64AVX512ER = getConstant("VM_Version::CPU_AVX512ER", Long.class);
final long amd64AVX512CD = getConstant("VM_Version::CPU_AVX512CD", Long.class);
final long amd64AVX512BW = getConstant("VM_Version::CPU_AVX512BW", Long.class);
final long amd64AVX512VL = getConstant("VM_Version::CPU_AVX512VL", Long.class);
final long amd64SHA = getConstant("VM_Version::CPU_SHA", Long.class);
final long amd64FMA = getConstant("VM_Version::CPU_FMA", Long.class);
}
package sun.jvm.hotspot.runtime.amd64;
import java.util.*;
import sun.jvm.hotspot.debugger.*;
import sun.jvm.hotspot.types.*;
import sun.jvm.hotspot.runtime.*;
import sun.jvm.hotspot.utilities.Observable;
import sun.jvm.hotspot.utilities.Observer;
public class AMD64JavaCallWrapper extends JavaCallWrapper {
private static AddressField lastJavaFPField;
static {
VM.registerVMInitializedObserver(new Observer() {
public void update(Observable o, Object data) {
initialize(VM.getVM().getTypeDataBase());
}
});
}
private static synchronized void initialize(TypeDataBase db) {
Type type = db.lookupType("JavaFrameAnchor");
lastJavaFPField  = type.getAddressField("_last_Java_fp");
}
public AMD64JavaCallWrapper(Address addr) {
super(addr);
}
public Address getLastJavaFP() {
return lastJavaFPField.getValue(addr.addOffsetTo(anchorField.getOffset()));
}
}
package jdk.vm.ci.amd64;
import jdk.vm.ci.meta.PlatformKind;
public enum AMD64Kind implements PlatformKind {
BYTE(1),
WORD(2),
DWORD(4),
QWORD(8),
SINGLE(4),
DOUBLE(8),
V32_BYTE(4, BYTE),
V32_WORD(4, WORD),
V64_BYTE(8, BYTE),
V64_WORD(8, WORD),
V64_DWORD(8, DWORD),
V128_BYTE(16, BYTE),
V128_WORD(16, WORD),
V128_DWORD(16, DWORD),
V128_QWORD(16, QWORD),
V128_SINGLE(16, SINGLE),
V128_DOUBLE(16, DOUBLE),
V256_BYTE(32, BYTE),
V256_WORD(32, WORD),
V256_DWORD(32, DWORD),
V256_QWORD(32, QWORD),
V256_SINGLE(32, SINGLE),
V256_DOUBLE(32, DOUBLE),
V512_BYTE(64, BYTE),
V512_WORD(64, WORD),
V512_DWORD(64, DWORD),
V512_QWORD(64, QWORD),
V512_SINGLE(64, SINGLE),
V512_DOUBLE(64, DOUBLE),
MASK8(1),
MASK16(2),
MASK32(4),
MASK64(8);
private final int size;
private final int vectorLength;
private final AMD64Kind scalar;
private final EnumKey<AMD64Kind> key = new EnumKey<>(this);
AMD64Kind(int size) {
this.size = size;
this.scalar = this;
this.vectorLength = 1;
}
AMD64Kind(int size, AMD64Kind scalar) {
this.size = size;
this.scalar = scalar;
assert size % scalar.size == 0;
this.vectorLength = size / scalar.size;
}
public AMD64Kind getScalar() {
return scalar;
}
@Override
public int getSizeInBytes() {
return size;
}
@Override
public int getVectorLength() {
return vectorLength;
}
@Override
public Key getKey() {
return key;
}
public boolean isInteger() {
switch (this) {
case BYTE:
case WORD:
case DWORD:
case QWORD:
return true;
default:
return false;
}
}
public boolean isXMM() {
switch (this) {
case SINGLE:
case DOUBLE:
case V32_BYTE:
case V32_WORD:
case V64_BYTE:
case V64_WORD:
case V64_DWORD:
case V128_BYTE:
case V128_WORD:
case V128_DWORD:
case V128_QWORD:
case V128_SINGLE:
case V128_DOUBLE:
case V256_BYTE:
case V256_WORD:
case V256_DWORD:
case V256_QWORD:
case V256_SINGLE:
case V256_DOUBLE:
case V512_BYTE:
case V512_WORD:
case V512_DWORD:
case V512_QWORD:
case V512_SINGLE:
case V512_DOUBLE:
return true;
default:
return false;
}
}
public boolean isMask() {
switch (this) {
case MASK8:
case MASK16:
case MASK32:
case MASK64:
return true;
default:
return false;
}
}
@Override
public char getTypeChar() {
switch (this) {
case BYTE:
return 'b';
case WORD:
return 'w';
case DWORD:
return 'd';
case QWORD:
return 'q';
case SINGLE:
return 'S';
case DOUBLE:
return 'D';
case V32_BYTE:
case V32_WORD:
case V64_BYTE:
case V64_WORD:
case V64_DWORD:
return 'v';
case V128_BYTE:
case V128_WORD:
case V128_DWORD:
case V128_QWORD:
case V128_SINGLE:
case V128_DOUBLE:
return 'x';
case V256_BYTE:
case V256_WORD:
case V256_DWORD:
case V256_QWORD:
case V256_SINGLE:
case V256_DOUBLE:
return 'y';
case V512_BYTE:
case V512_WORD:
case V512_DWORD:
case V512_QWORD:
case V512_SINGLE:
case V512_DOUBLE:
return 'z';
case MASK8:
case MASK16:
case MASK32:
case MASK64:
return 'k';
default:
return '-';
}
}
}
package jdk.vm.ci.code.test.amd64;
import static jdk.vm.ci.amd64.AMD64.xmm0;
import jdk.vm.ci.amd64.AMD64;
import jdk.vm.ci.amd64.AMD64Kind;
import jdk.vm.ci.code.CallingConvention;
import jdk.vm.ci.code.CodeCacheProvider;
import jdk.vm.ci.code.DebugInfo;
import jdk.vm.ci.code.Register;
import jdk.vm.ci.code.RegisterValue;
import jdk.vm.ci.code.StackSlot;
import jdk.vm.ci.code.site.ConstantReference;
import jdk.vm.ci.code.site.DataSectionReference;
import jdk.vm.ci.code.test.TestAssembler;
import jdk.vm.ci.code.test.TestHotSpotVMConfig;
import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
import jdk.vm.ci.hotspot.HotSpotConstant;
import jdk.vm.ci.hotspot.HotSpotForeignCallTarget;
import jdk.vm.ci.meta.AllocatableValue;
import jdk.vm.ci.meta.JavaKind;
import jdk.vm.ci.meta.VMConstant;
public class AMD64TestAssembler extends TestAssembler {
private static final Register scratchRegister = AMD64.r12;
private static final Register doubleScratch = AMD64.xmm15;
public AMD64TestAssembler(CodeCacheProvider codeCache, TestHotSpotVMConfig config) {
super(codeCache, config, 16, 16, AMD64Kind.DWORD, AMD64.rax, AMD64.rcx, AMD64.rdi, AMD64.r8, AMD64.r9, AMD64.r10);
}
private void emitFatNop() {
code.emitByte(0x0F);
code.emitByte(0x1F);
code.emitByte(0x44);
code.emitByte(0x00);
code.emitByte(0x00);
}
@Override
public void emitPrologue() {
emitFatNop();
code.emitByte(0x50 | AMD64.rbp.encoding);          emitMove(true, AMD64.rbp, AMD64.rsp);              setDeoptRescueSlot(newStackSlot(AMD64Kind.QWORD));
}
@Override
public void emitEpilogue() {
recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);
recordCall(new HotSpotForeignCallTarget(config.handleDeoptStub), 5, true, null);
code.emitByte(0xE8);         code.emitInt(0xDEADDEAD);
}
@Override
public void emitGrowStack(int size) {
code.emitByte(0x48);
code.emitByte(0x81);
code.emitByte(0xEC);
code.emitInt(size);
}
@Override
public Register emitIntArg0() {
return codeCache.getRegisterConfig().getCallingConventionRegisters(HotSpotCallingConventionType.JavaCall, JavaKind.Int).get(0);
}
@Override
public Register emitIntArg1() {
return codeCache.getRegisterConfig().getCallingConventionRegisters(HotSpotCallingConventionType.JavaCall, JavaKind.Int).get(1);
}
private void emitREX(boolean w, int r, int x, int b) {
int wrxb = (w ? 0x08 : 0) | ((r >> 3) << 2) | ((x >> 3) << 1) | (b >> 3);
if (wrxb != 0) {
code.emitByte(0x40 | wrxb);
}
}
private void emitModRMReg(boolean w, int opcode, int r, int m) {
emitREX(w, r, 0, m);
code.emitByte((byte) opcode);
code.emitByte((byte) 0xC0 | ((r & 0x7) << 3) | (m & 0x7));
}
private void emitModRMMemory(boolean w, int opcode, int r, int b, int offset) {
emitREX(w, r, 0, b);
code.emitByte((byte) opcode);
code.emitByte((byte) 0x80 | ((r & 0x7) << 3) | (b & 0x7));
code.emitInt(offset);
}
@Override
public Register emitLoadInt(int c) {
Register ret = newRegister();
return emitLoadInt(ret, c);
}
public Register emitLoadInt(Register ret, int c) {
emitREX(false, 0, 0, ret.encoding);
code.emitByte(0xB8 | (ret.encoding & 0x7));         code.emitInt(c);
return ret;
}
@Override
public Register emitLoadLong(long c) {
Register ret = newRegister();
return emitLoadLong(ret, c);
}
public Register emitLoadLong(Register ret, long c) {
emitREX(true, 0, 0, ret.encoding);
code.emitByte(0xB8 | (ret.encoding & 0x7));         code.emitLong(c);
return ret;
}
@Override
public Register emitLoadFloat(float c) {
Register ret = AMD64.xmm0;
return emitLoadFloat(ret, c);
}
public Register emitLoadFloat(Register ret, float c) {
DataSectionReference ref = new DataSectionReference();
ref.setOffset(data.position());
data.emitFloat(c);
recordDataPatchInCode(ref);
emitREX(false, ret.encoding, 0, 0);
code.emitByte(0xF3);
code.emitByte(0x0F);
code.emitByte(0x10);                                       code.emitByte(0x05 | ((ret.encoding & 0x7) << 3));         code.emitInt(0xDEADDEAD);
return ret;
}
public Register emitLoadDouble(double c) {
Register ret = AMD64.xmm0;
return emitLoadDouble(ret, c);
}
public Register emitLoadDouble(Register ret, double c) {
DataSectionReference ref = new DataSectionReference();
ref.setOffset(data.position());
data.emitDouble(c);
recordDataPatchInCode(ref);
emitREX(false, ret.encoding, 0, 0);
code.emitByte(0xF2);
code.emitByte(0x0F);
code.emitByte(0x10);                                       code.emitByte(0x05 | ((ret.encoding & 0x7) << 3));         code.emitInt(0xDEADDEAD);
return ret;
}
@Override
public Register emitLoadPointer(HotSpotConstant c) {
recordDataPatchInCode(new ConstantReference((VMConstant) c));
if (c.isCompressed()) {
Register ret = newRegister();
emitREX(false, 0, 0, ret.encoding);
code.emitByte(0xB8 | (ret.encoding & 0x7));             code.emitInt(0xDEADDEAD);
return ret;
} else {
return emitLoadLong(0xDEADDEADDEADDEADL);
}
}
private Register emitLoadPointer(DataSectionReference ref, boolean narrow) {
recordDataPatchInCode(ref);
Register ret = newRegister();
emitREX(!narrow, ret.encoding, 0, 0);
code.emitByte(0x8B);                                       code.emitByte(0x05 | ((ret.encoding & 0x7) << 3));         code.emitInt(0xDEADDEAD);
return ret;
}
@Override
public Register emitLoadPointer(DataSectionReference ref) {
return emitLoadPointer(ref, false);
}
@Override
public Register emitLoadNarrowPointer(DataSectionReference ref) {
return emitLoadPointer(ref, true);
}
@Override
public Register emitLoadPointer(Register b, int offset) {
Register ret = newRegister();
emitModRMMemory(true, 0x8B, ret.encoding, b.encoding, offset);         return ret;
}
private int getAdjustedOffset(StackSlot ret) {
if (ret.getRawOffset() < 0) {
return ret.getRawOffset() + 16;
} else {
return -(frameSize - ret.getRawOffset()) + 16;
}
}
@Override
public StackSlot emitIntToStack(Register a) {
StackSlot ret = newStackSlot(AMD64Kind.DWORD);
return emitIntToStack(ret, a);
}
public StackSlot emitIntToStack(StackSlot ret, Register a) {
emitModRMMemory(false, 0x89, a.encoding, AMD64.rbp.encoding, getAdjustedOffset(ret));
return ret;
}
@Override
public StackSlot emitLongToStack(Register a) {
StackSlot ret = newStackSlot(AMD64Kind.QWORD);
return emitLongToStack(ret, a);
}
public StackSlot emitLongToStack(StackSlot ret, Register a) {
emitModRMMemory(true, 0x89, a.encoding, AMD64.rbp.encoding, getAdjustedOffset(ret));
return ret;
}
@Override
public StackSlot emitFloatToStack(Register a) {
StackSlot ret = newStackSlot(AMD64Kind.SINGLE);
return emitFloatToStack(ret, a);
}
public StackSlot emitFloatToStack(StackSlot ret, Register a) {
emitREX(false, a.encoding, 0, 0);
code.emitByte(0xF3);
code.emitByte(0x0F);
code.emitByte(0x11);                                       code.emitByte(0x85 | ((a.encoding & 0x7) << 3));           code.emitInt(getAdjustedOffset(ret));
return ret;
}
@Override
public StackSlot emitDoubleToStack(Register a) {
StackSlot ret = newStackSlot(AMD64Kind.DOUBLE);
return emitDoubleToStack(ret, a);
}
public StackSlot emitDoubleToStack(StackSlot ret, Register a) {
emitREX(false, a.encoding, 0, 0);
code.emitByte(0xF2);
code.emitByte(0x0F);
code.emitByte(0x11);                                       code.emitByte(0x85 | ((a.encoding & 0x7) << 3));           code.emitInt(getAdjustedOffset(ret));
return ret;
}
@Override
public StackSlot emitPointerToStack(Register a) {
StackSlot ret = newStackSlot(AMD64Kind.QWORD);
emitModRMMemory(true, 0x89, a.encoding, AMD64.rbp.encoding, ret.getRawOffset() + 16);
return ret;
}
@Override
public StackSlot emitNarrowPointerToStack(Register a) {
StackSlot ret = newStackSlot(AMD64Kind.DWORD);
emitModRMMemory(false, 0x89, a.encoding, AMD64.rbp.encoding, ret.getRawOffset() + 16);
return ret;
}
@Override
public Register emitUncompressPointer(Register compressed, long base, int shift) {
if (shift > 0) {
emitModRMReg(true, 0xC1, 4, compressed.encoding);
code.emitByte(shift);
}
if (base == 0) {
return compressed;
} else {
Register tmp = emitLoadLong(base);
emitModRMReg(true, 0x03, tmp.encoding, compressed.encoding);
return tmp;
}
}
@Override
public Register emitIntAdd(Register a, Register b) {
emitModRMReg(false, 0x03, a.encoding, b.encoding);
return a;
}
private void emitMove(boolean w, Register to, Register from) {
if (to != from) {
emitModRMReg(w, 0x8B, to.encoding, from.encoding);
}
}
@Override
public void emitIntRet(Register a) {
emitMove(false, AMD64.rax, a);                     emitMove(true, AMD64.rsp, AMD64.rbp);              code.emitByte(0x58 | AMD64.rbp.encoding);          code.emitByte(0xC3);                           }
@Override
public void emitFloatRet(Register a) {
assert a == xmm0 : "Unimplemented move " + a;
emitMove(true, AMD64.rsp, AMD64.rbp);              code.emitByte(0x58 | AMD64.rbp.encoding);          code.emitByte(0xC3);                           }
@Override
public void emitPointerRet(Register a) {
emitMove(true, AMD64.rax, a);                      emitMove(true, AMD64.rsp, AMD64.rbp);              code.emitByte(0x58 | AMD64.rbp.encoding);          code.emitByte(0xC3);                           }
@Override
public void emitTrap(DebugInfo info) {
recordImplicitException(info);
code.emitByte(0x8B);
code.emitByte(0x04);
code.emitByte(0x25);
code.emitInt(0);
}
@Override
public void emitLoad(AllocatableValue av, Object prim) {
if (av instanceof RegisterValue) {
Register reg = ((RegisterValue) av).getRegister();
if (prim instanceof Float) {
emitLoadFloat(reg, (Float) prim);
} else if (prim instanceof Double) {
emitLoadDouble(reg, (Double) prim);
} else if (prim instanceof Integer) {
emitLoadInt(reg, (Integer) prim);
} else if (prim instanceof Long) {
emitLoadLong(reg, (Long) prim);
}
} else if (av instanceof StackSlot) {
StackSlot slot = (StackSlot) av;
if (prim instanceof Float) {
emitFloatToStack(slot, emitLoadFloat(doubleScratch, (Float) prim));
} else if (prim instanceof Double) {
emitDoubleToStack(slot, emitLoadDouble(doubleScratch, (Double) prim));
} else if (prim instanceof Integer) {
emitIntToStack(slot, emitLoadInt(scratchRegister, (Integer) prim));
} else if (prim instanceof Long) {
emitLongToStack(slot, emitLoadLong(scratchRegister, (Long) prim));
} else {
assert false : "Unimplemented";
}
} else {
throw new IllegalArgumentException("Unknown value " + av);
}
}
@Override
public void emitCallPrologue(CallingConvention cc, Object... prim) {
emitGrowStack(cc.getStackSize());
frameSize += cc.getStackSize();
AllocatableValue[] args = cc.getArguments();
for (int i = args.length - 1; i >= 0; i--) {
emitLoad(args[i], prim[i]);
}
}
@Override
public void emitCall(long addr) {
Register target = emitLoadLong(addr);
code.emitByte(0xFF);         int enc = target.encoding;
if (enc >= 8) {
code.emitByte(0x41);
enc -= 8;
}
code.emitByte(0xD0 | enc);
}
@Override
public void emitCallEpilogue(CallingConvention cc) {
emitGrowStack(-cc.getStackSize());
frameSize -= cc.getStackSize();
}
}
package sun.jvm.hotspot.debugger.amd64;
import java.lang.annotation.Native;
import sun.jvm.hotspot.debugger.*;
import sun.jvm.hotspot.debugger.cdbg.*;
public abstract class AMD64ThreadContext implements ThreadContext {
@Native
public static final int R15 = 0;
public static final int R14 = 1;
public static final int R13 = 2;
public static final int R12 = 3;
public static final int R11 = 4;
public static final int R10 = 5;
public static final int R9  = 6;
public static final int R8  = 7;
public static final int RDI = 8;
public static final int RSI = 9;
public static final int RBP = 10;
public static final int RBX = 11;
public static final int RDX = 12;
public static final int RCX = 13;
public static final int RAX = 14;
public static final int TRAPNO = 15;
public static final int ERR = 16;
public static final int RIP = 17;
public static final int CS = 18;
public static final int RFL = 19;
public static final int RSP = 20;
public static final int SS = 21;
public static final int FS = 22;
public static final int GS = 23;
public static final int ES = 24;
public static final int DS = 25;
public static final int FSBASE = 26;
public static final int GSBASE = 27;
public static final int NPRGREG = 28;
private static final String[] regNames = {
"r15",  "r14", "r13", "r12", "r11", "r10", "r9", "r8",
"rdi",  "rsi", "rbp", "rbx", "rdx", "rcx", "rax", "trapno",
"err",  "rip", "cs",  "rfl", "rsp", "ss",  "fs", "gs",
"es",   "ds",  "fsbase", "gsbase"
};
private long[] data;
public AMD64ThreadContext() {
data = new long[NPRGREG];
}
public int getNumRegisters() {
return NPRGREG;
}
public String getRegisterName(int index) {
return regNames[index];
}
public void setRegister(int index, long value) {
data[index] = value;
}
public long getRegister(int index) {
return data[index];
}
public CFrame getTopFrame(Debugger dbg) {
return null;
}
public abstract void setRegisterAsAddress(int index, Address value);
public abstract Address getRegisterAsAddress(int index);
}
package jdk.internal.org.objectweb.asm.tree.analysis;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import jdk.internal.org.objectweb.asm.Opcodes;
import jdk.internal.org.objectweb.asm.Type;
import jdk.internal.org.objectweb.asm.tree.AbstractInsnNode;
import jdk.internal.org.objectweb.asm.tree.IincInsnNode;
import jdk.internal.org.objectweb.asm.tree.InsnList;
import jdk.internal.org.objectweb.asm.tree.JumpInsnNode;
import jdk.internal.org.objectweb.asm.tree.LabelNode;
import jdk.internal.org.objectweb.asm.tree.LookupSwitchInsnNode;
import jdk.internal.org.objectweb.asm.tree.MethodNode;
import jdk.internal.org.objectweb.asm.tree.TableSwitchInsnNode;
import jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode;
import jdk.internal.org.objectweb.asm.tree.VarInsnNode;
public class Analyzer<V extends Value> implements Opcodes {
private final Interpreter<V> interpreter;
private InsnList insnList;
private int insnListSize;
private List<TryCatchBlockNode>[] handlers;
private Frame<V>[] frames;
private Subroutine[] subroutines;
private boolean[] inInstructionsToProcess;
private int[] instructionsToProcess;
private int numInstructionsToProcess;
public Analyzer(final Interpreter<V> interpreter) {
this.interpreter = interpreter;
}
@SuppressWarnings("unchecked")
public Frame<V>[] analyze(final String owner, final MethodNode method) throws AnalyzerException {
if ((method.access & (ACC_ABSTRACT | ACC_NATIVE)) != 0) {
frames = (Frame<V>[]) new Frame<?>[0];
return frames;
}
insnList = method.instructions;
insnListSize = insnList.size();
handlers = (List<TryCatchBlockNode>[]) new List<?>[insnListSize];
frames = (Frame<V>[]) new Frame<?>[insnListSize];
subroutines = new Subroutine[insnListSize];
inInstructionsToProcess = new boolean[insnListSize];
instructionsToProcess = new int[insnListSize];
numInstructionsToProcess = 0;
for (int i = 0; i < method.tryCatchBlocks.size(); ++i) {
TryCatchBlockNode tryCatchBlock = method.tryCatchBlocks.get(i);
int startIndex = insnList.indexOf(tryCatchBlock.start);
int endIndex = insnList.indexOf(tryCatchBlock.end);
for (int j = startIndex; j < endIndex; ++j) {
List<TryCatchBlockNode> insnHandlers = handlers[j];
if (insnHandlers == null) {
insnHandlers = new ArrayList<>();
handlers[j] = insnHandlers;
}
insnHandlers.add(tryCatchBlock);
}
}
Subroutine main = new Subroutine(null, method.maxLocals, null);
List<AbstractInsnNode> jsrInsns = new ArrayList<>();
findSubroutine(0, main, jsrInsns);
Map<LabelNode, Subroutine> jsrSubroutines = new HashMap<>();
while (!jsrInsns.isEmpty()) {
JumpInsnNode jsrInsn = (JumpInsnNode) jsrInsns.remove(0);
Subroutine subroutine = jsrSubroutines.get(jsrInsn.label);
if (subroutine == null) {
subroutine = new Subroutine(jsrInsn.label, method.maxLocals, jsrInsn);
jsrSubroutines.put(jsrInsn.label, subroutine);
findSubroutine(insnList.indexOf(jsrInsn.label), subroutine, jsrInsns);
} else {
subroutine.callers.add(jsrInsn);
}
}
for (int i = 0; i < insnListSize; ++i) {
if (subroutines[i] != null && subroutines[i].start == null) {
subroutines[i] = null;
}
}
Frame<V> currentFrame = computeInitialFrame(owner, method);
merge(0, currentFrame, null);
init(owner, method);
while (numInstructionsToProcess > 0) {
int insnIndex = instructionsToProcess[--numInstructionsToProcess];
Frame<V> oldFrame = frames[insnIndex];
Subroutine subroutine = subroutines[insnIndex];
inInstructionsToProcess[insnIndex] = false;
AbstractInsnNode insnNode = null;
try {
insnNode = method.instructions.get(insnIndex);
int insnOpcode = insnNode.getOpcode();
int insnType = insnNode.getType();
if (insnType == AbstractInsnNode.LABEL
|| insnType == AbstractInsnNode.LINE
|| insnType == AbstractInsnNode.FRAME) {
merge(insnIndex + 1, oldFrame, subroutine);
newControlFlowEdge(insnIndex, insnIndex + 1);
} else {
currentFrame.init(oldFrame).execute(insnNode, interpreter);
subroutine = subroutine == null ? null : new Subroutine(subroutine);
if (insnNode instanceof JumpInsnNode) {
JumpInsnNode jumpInsn = (JumpInsnNode) insnNode;
if (insnOpcode != GOTO && insnOpcode != JSR) {
currentFrame.initJumpTarget(insnOpcode,  null);
merge(insnIndex + 1, currentFrame, subroutine);
newControlFlowEdge(insnIndex, insnIndex + 1);
}
int jumpInsnIndex = insnList.indexOf(jumpInsn.label);
currentFrame.initJumpTarget(insnOpcode, jumpInsn.label);
if (insnOpcode == JSR) {
merge(
jumpInsnIndex,
currentFrame,
new Subroutine(jumpInsn.label, method.maxLocals, jumpInsn));
} else {
merge(jumpInsnIndex, currentFrame, subroutine);
}
newControlFlowEdge(insnIndex, jumpInsnIndex);
} else if (insnNode instanceof LookupSwitchInsnNode) {
LookupSwitchInsnNode lookupSwitchInsn = (LookupSwitchInsnNode) insnNode;
int targetInsnIndex = insnList.indexOf(lookupSwitchInsn.dflt);
currentFrame.initJumpTarget(insnOpcode, lookupSwitchInsn.dflt);
merge(targetInsnIndex, currentFrame, subroutine);
newControlFlowEdge(insnIndex, targetInsnIndex);
for (int i = 0; i < lookupSwitchInsn.labels.size(); ++i) {
LabelNode label = lookupSwitchInsn.labels.get(i);
targetInsnIndex = insnList.indexOf(label);
currentFrame.initJumpTarget(insnOpcode, label);
merge(targetInsnIndex, currentFrame, subroutine);
newControlFlowEdge(insnIndex, targetInsnIndex);
}
} else if (insnNode instanceof TableSwitchInsnNode) {
TableSwitchInsnNode tableSwitchInsn = (TableSwitchInsnNode) insnNode;
int targetInsnIndex = insnList.indexOf(tableSwitchInsn.dflt);
currentFrame.initJumpTarget(insnOpcode, tableSwitchInsn.dflt);
merge(targetInsnIndex, currentFrame, subroutine);
newControlFlowEdge(insnIndex, targetInsnIndex);
for (int i = 0; i < tableSwitchInsn.labels.size(); ++i) {
LabelNode label = tableSwitchInsn.labels.get(i);
currentFrame.initJumpTarget(insnOpcode, label);
targetInsnIndex = insnList.indexOf(label);
merge(targetInsnIndex, currentFrame, subroutine);
newControlFlowEdge(insnIndex, targetInsnIndex);
}
} else if (insnOpcode == RET) {
if (subroutine == null) {
throw new AnalyzerException(insnNode, "RET instruction outside of a subroutine");
}
for (int i = 0; i < subroutine.callers.size(); ++i) {
JumpInsnNode caller = subroutine.callers.get(i);
int jsrInsnIndex = insnList.indexOf(caller);
if (frames[jsrInsnIndex] != null) {
merge(
jsrInsnIndex + 1,
frames[jsrInsnIndex],
currentFrame,
subroutines[jsrInsnIndex],
subroutine.localsUsed);
newControlFlowEdge(insnIndex, jsrInsnIndex + 1);
}
}
} else if (insnOpcode != ATHROW && (insnOpcode < IRETURN || insnOpcode > RETURN)) {
if (subroutine != null) {
if (insnNode instanceof VarInsnNode) {
int varIndex = ((VarInsnNode) insnNode).var;
subroutine.localsUsed[varIndex] = true;
if (insnOpcode == LLOAD
|| insnOpcode == DLOAD
|| insnOpcode == LSTORE
|| insnOpcode == DSTORE) {
subroutine.localsUsed[varIndex + 1] = true;
}
} else if (insnNode instanceof IincInsnNode) {
int varIndex = ((IincInsnNode) insnNode).var;
subroutine.localsUsed[varIndex] = true;
}
}
merge(insnIndex + 1, currentFrame, subroutine);
newControlFlowEdge(insnIndex, insnIndex + 1);
}
}
List<TryCatchBlockNode> insnHandlers = handlers[insnIndex];
if (insnHandlers != null) {
for (TryCatchBlockNode tryCatchBlock : insnHandlers) {
Type catchType;
if (tryCatchBlock.type == null) {
catchType = Type.getObjectType("java/lang/Throwable");
} else {
catchType = Type.getObjectType(tryCatchBlock.type);
}
if (newControlFlowExceptionEdge(insnIndex, tryCatchBlock)) {
Frame<V> handler = newFrame(oldFrame);
handler.clearStack();
handler.push(interpreter.newExceptionValue(tryCatchBlock, handler, catchType));
merge(insnList.indexOf(tryCatchBlock.handler), handler, subroutine);
}
}
}
} catch (AnalyzerException e) {
throw new AnalyzerException(
e.node, "Error at instruction " + insnIndex + ": " + e.getMessage(), e);
} catch (RuntimeException e) {
throw new AnalyzerException(
insnNode, "Error at instruction " + insnIndex + ": " + e.getMessage(), e);
}
}
return frames;
}
public Frame<V>[] analyzeAndComputeMaxs(final String owner, final MethodNode method)
throws AnalyzerException {
method.maxLocals = computeMaxLocals(method);
method.maxStack = -1;
analyze(owner, method);
method.maxStack = computeMaxStack(frames);
return frames;
}
private static int computeMaxLocals(final MethodNode method) {
int maxLocals = Type.getArgumentsAndReturnSizes(method.desc) >> 2;
for (AbstractInsnNode insnNode : method.instructions) {
if (insnNode instanceof VarInsnNode) {
int local = ((VarInsnNode) insnNode).var;
int size =
(insnNode.getOpcode() == Opcodes.LLOAD
|| insnNode.getOpcode() == Opcodes.DLOAD
|| insnNode.getOpcode() == Opcodes.LSTORE
|| insnNode.getOpcode() == Opcodes.DSTORE)
? 2
: 1;
maxLocals = Math.max(maxLocals, local + size);
} else if (insnNode instanceof IincInsnNode) {
int local = ((IincInsnNode) insnNode).var;
maxLocals = Math.max(maxLocals, local + 1);
}
}
return maxLocals;
}
private static int computeMaxStack(final Frame<?>[] frames) {
int maxStack = 0;
for (Frame<?> frame : frames) {
if (frame != null) {
int stackSize = 0;
for (int i = 0; i < frame.getStackSize(); ++i) {
stackSize += frame.getStack(i).getSize();
}
maxStack = Math.max(maxStack, stackSize);
}
}
return maxStack;
}
private void findSubroutine(
final int insnIndex, final Subroutine subroutine, final List<AbstractInsnNode> jsrInsns)
throws AnalyzerException {
ArrayList<Integer> instructionIndicesToProcess = new ArrayList<>();
instructionIndicesToProcess.add(insnIndex);
while (!instructionIndicesToProcess.isEmpty()) {
int currentInsnIndex =
instructionIndicesToProcess.remove(instructionIndicesToProcess.size() - 1);
if (currentInsnIndex < 0 || currentInsnIndex >= insnListSize) {
throw new AnalyzerException(null, "Execution can fall off the end of the code");
}
if (subroutines[currentInsnIndex] != null) {
continue;
}
subroutines[currentInsnIndex] = new Subroutine(subroutine);
AbstractInsnNode currentInsn = insnList.get(currentInsnIndex);
if (currentInsn instanceof JumpInsnNode) {
if (currentInsn.getOpcode() == JSR) {
jsrInsns.add(currentInsn);
} else {
JumpInsnNode jumpInsn = (JumpInsnNode) currentInsn;
instructionIndicesToProcess.add(insnList.indexOf(jumpInsn.label));
}
} else if (currentInsn instanceof TableSwitchInsnNode) {
TableSwitchInsnNode tableSwitchInsn = (TableSwitchInsnNode) currentInsn;
findSubroutine(insnList.indexOf(tableSwitchInsn.dflt), subroutine, jsrInsns);
for (int i = tableSwitchInsn.labels.size() - 1; i >= 0; --i) {
LabelNode labelNode = tableSwitchInsn.labels.get(i);
instructionIndicesToProcess.add(insnList.indexOf(labelNode));
}
} else if (currentInsn instanceof LookupSwitchInsnNode) {
LookupSwitchInsnNode lookupSwitchInsn = (LookupSwitchInsnNode) currentInsn;
findSubroutine(insnList.indexOf(lookupSwitchInsn.dflt), subroutine, jsrInsns);
for (int i = lookupSwitchInsn.labels.size() - 1; i >= 0; --i) {
LabelNode labelNode = lookupSwitchInsn.labels.get(i);
instructionIndicesToProcess.add(insnList.indexOf(labelNode));
}
}
List<TryCatchBlockNode> insnHandlers = handlers[currentInsnIndex];
if (insnHandlers != null) {
for (TryCatchBlockNode tryCatchBlock : insnHandlers) {
instructionIndicesToProcess.add(insnList.indexOf(tryCatchBlock.handler));
}
}
switch (currentInsn.getOpcode()) {
case GOTO:
case RET:
case TABLESWITCH:
case LOOKUPSWITCH:
case IRETURN:
case LRETURN:
case FRETURN:
case DRETURN:
case ARETURN:
case RETURN:
case ATHROW:
break;
default:
instructionIndicesToProcess.add(currentInsnIndex + 1);
break;
}
}
}
private Frame<V> computeInitialFrame(final String owner, final MethodNode method) {
Frame<V> frame = newFrame(method.maxLocals, method.maxStack);
int currentLocal = 0;
boolean isInstanceMethod = (method.access & ACC_STATIC) == 0;
if (isInstanceMethod) {
Type ownerType = Type.getObjectType(owner);
frame.setLocal(
currentLocal, interpreter.newParameterValue(isInstanceMethod, currentLocal, ownerType));
currentLocal++;
}
Type[] argumentTypes = Type.getArgumentTypes(method.desc);
for (Type argumentType : argumentTypes) {
frame.setLocal(
currentLocal,
interpreter.newParameterValue(isInstanceMethod, currentLocal, argumentType));
currentLocal++;
if (argumentType.getSize() == 2) {
frame.setLocal(currentLocal, interpreter.newEmptyValue(currentLocal));
currentLocal++;
}
}
while (currentLocal < method.maxLocals) {
frame.setLocal(currentLocal, interpreter.newEmptyValue(currentLocal));
currentLocal++;
}
frame.setReturn(interpreter.newReturnTypeValue(Type.getReturnType(method.desc)));
return frame;
}
public Frame<V>[] getFrames() {
return frames;
}
public List<TryCatchBlockNode> getHandlers(final int insnIndex) {
return handlers[insnIndex];
}
protected void init(final String owner, final MethodNode method) throws AnalyzerException {
}
protected Frame<V> newFrame(final int numLocals, final int numStack) {
return new Frame<>(numLocals, numStack);
}
protected Frame<V> newFrame(final Frame<? extends V> frame) {
return new Frame<>(frame);
}
protected void newControlFlowEdge(final int insnIndex, final int successorIndex) {
}
protected boolean newControlFlowExceptionEdge(final int insnIndex, final int successorIndex) {
return true;
}
protected boolean newControlFlowExceptionEdge(
final int insnIndex, final TryCatchBlockNode tryCatchBlock) {
return newControlFlowExceptionEdge(insnIndex, insnList.indexOf(tryCatchBlock.handler));
}
private void merge(final int insnIndex, final Frame<V> frame, final Subroutine subroutine)
throws AnalyzerException {
boolean changed;
Frame<V> oldFrame = frames[insnIndex];
if (oldFrame == null) {
frames[insnIndex] = newFrame(frame);
changed = true;
} else {
changed = oldFrame.merge(frame, interpreter);
}
Subroutine oldSubroutine = subroutines[insnIndex];
if (oldSubroutine == null) {
if (subroutine != null) {
subroutines[insnIndex] = new Subroutine(subroutine);
changed = true;
}
} else {
if (subroutine != null) {
changed |= oldSubroutine.merge(subroutine);
}
}
if (changed && !inInstructionsToProcess[insnIndex]) {
inInstructionsToProcess[insnIndex] = true;
instructionsToProcess[numInstructionsToProcess++] = insnIndex;
}
}
private void merge(
final int insnIndex,
final Frame<V> frameBeforeJsr,
final Frame<V> frameAfterRet,
final Subroutine subroutineBeforeJsr,
final boolean[] localsUsed)
throws AnalyzerException {
frameAfterRet.merge(frameBeforeJsr, localsUsed);
boolean changed;
Frame<V> oldFrame = frames[insnIndex];
if (oldFrame == null) {
frames[insnIndex] = newFrame(frameAfterRet);
changed = true;
} else {
changed = oldFrame.merge(frameAfterRet, interpreter);
}
Subroutine oldSubroutine = subroutines[insnIndex];
if (oldSubroutine != null && subroutineBeforeJsr != null) {
changed |= oldSubroutine.merge(subroutineBeforeJsr);
}
if (changed && !inInstructionsToProcess[insnIndex]) {
inInstructionsToProcess[insnIndex] = true;
instructionsToProcess[numInstructionsToProcess++] = insnIndex;
}
}
}
package jdk.internal.org.objectweb.asm.commons;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import jdk.internal.org.objectweb.asm.ConstantDynamic;
import jdk.internal.org.objectweb.asm.Handle;
import jdk.internal.org.objectweb.asm.Label;
import jdk.internal.org.objectweb.asm.MethodVisitor;
import jdk.internal.org.objectweb.asm.Opcodes;
import jdk.internal.org.objectweb.asm.Type;
public class AnalyzerAdapter extends MethodVisitor {
public List<Object> locals;
public List<Object> stack;
private List<Label> labels;
public Map<Object, Object> uninitializedTypes;
private int maxStack;
private int maxLocals;
private String owner;
public AnalyzerAdapter(
final String owner,
final int access,
final String name,
final String descriptor,
final MethodVisitor methodVisitor) {
this( Opcodes.ASM9, owner, access, name, descriptor, methodVisitor);
if (getClass() != AnalyzerAdapter.class) {
throw new IllegalStateException();
}
}
protected AnalyzerAdapter(
final int api,
final String owner,
final int access,
final String name,
final String descriptor,
final MethodVisitor methodVisitor) {
super(api, methodVisitor);
this.owner = owner;
locals = new ArrayList<>();
stack = new ArrayList<>();
uninitializedTypes = new HashMap<>();
if ((access & Opcodes.ACC_STATIC) == 0) {
if ("<init>".equals(name)) {
locals.add(Opcodes.UNINITIALIZED_THIS);
} else {
locals.add(owner);
}
}
for (Type argumentType : Type.getArgumentTypes(descriptor)) {
switch (argumentType.getSort()) {
case Type.BOOLEAN:
case Type.CHAR:
case Type.BYTE:
case Type.SHORT:
case Type.INT:
locals.add(Opcodes.INTEGER);
break;
case Type.FLOAT:
locals.add(Opcodes.FLOAT);
break;
case Type.LONG:
locals.add(Opcodes.LONG);
locals.add(Opcodes.TOP);
break;
case Type.DOUBLE:
locals.add(Opcodes.DOUBLE);
locals.add(Opcodes.TOP);
break;
case Type.ARRAY:
locals.add(argumentType.getDescriptor());
break;
case Type.OBJECT:
locals.add(argumentType.getInternalName());
break;
default:
throw new AssertionError();
}
}
maxLocals = locals.size();
}
@Override
public void visitFrame(
final int type,
final int numLocal,
final Object[] local,
final int numStack,
final Object[] stack) {
if (type != Opcodes.F_NEW) {             throw new IllegalArgumentException(
"AnalyzerAdapter only accepts expanded frames (see ClassReader.EXPAND_FRAMES)");
}
super.visitFrame(type, numLocal, local, numStack, stack);
if (this.locals != null) {
this.locals.clear();
this.stack.clear();
} else {
this.locals = new ArrayList<>();
this.stack = new ArrayList<>();
}
visitFrameTypes(numLocal, local, this.locals);
visitFrameTypes(numStack, stack, this.stack);
maxLocals = Math.max(maxLocals, this.locals.size());
maxStack = Math.max(maxStack, this.stack.size());
}
private static void visitFrameTypes(
final int numTypes, final Object[] frameTypes, final List<Object> result) {
for (int i = 0; i < numTypes; ++i) {
Object frameType = frameTypes[i];
result.add(frameType);
if (frameType == Opcodes.LONG || frameType == Opcodes.DOUBLE) {
result.add(Opcodes.TOP);
}
}
}
@Override
public void visitInsn(final int opcode) {
super.visitInsn(opcode);
execute(opcode, 0, null);
if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {
this.locals = null;
this.stack = null;
}
}
@Override
public void visitIntInsn(final int opcode, final int operand) {
super.visitIntInsn(opcode, operand);
execute(opcode, operand, null);
}
@Override
public void visitVarInsn(final int opcode, final int varIndex) {
super.visitVarInsn(opcode, varIndex);
boolean isLongOrDouble =
opcode == Opcodes.LLOAD
|| opcode == Opcodes.DLOAD
|| opcode == Opcodes.LSTORE
|| opcode == Opcodes.DSTORE;
maxLocals = Math.max(maxLocals, varIndex + (isLongOrDouble ? 2 : 1));
execute(opcode, varIndex, null);
}
@Override
public void visitTypeInsn(final int opcode, final String type) {
if (opcode == Opcodes.NEW) {
if (labels == null) {
Label label = new Label();
labels = new ArrayList<>(3);
labels.add(label);
if (mv != null) {
mv.visitLabel(label);
}
}
for (Label label : labels) {
uninitializedTypes.put(label, type);
}
}
super.visitTypeInsn(opcode, type);
execute(opcode, 0, type);
}
@Override
public void visitFieldInsn(
final int opcode, final String owner, final String name, final String descriptor) {
super.visitFieldInsn(opcode, owner, name, descriptor);
execute(opcode, 0, descriptor);
}
@Override
public void visitMethodInsn(
final int opcodeAndSource,
final String owner,
final String name,
final String descriptor,
final boolean isInterface) {
if (api < Opcodes.ASM5 && (opcodeAndSource & Opcodes.SOURCE_DEPRECATED) == 0) {
super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
return;
}
super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
int opcode = opcodeAndSource & ~Opcodes.SOURCE_MASK;
if (this.locals == null) {
labels = null;
return;
}
pop(descriptor);
if (opcode != Opcodes.INVOKESTATIC) {
Object value = pop();
if (opcode == Opcodes.INVOKESPECIAL && name.equals("<init>")) {
Object initializedValue;
if (value == Opcodes.UNINITIALIZED_THIS) {
initializedValue = this.owner;
} else {
initializedValue = uninitializedTypes.get(value);
}
for (int i = 0; i < locals.size(); ++i) {
if (locals.get(i) == value) {
locals.set(i, initializedValue);
}
}
for (int i = 0; i < stack.size(); ++i) {
if (stack.get(i) == value) {
stack.set(i, initializedValue);
}
}
}
}
pushDescriptor(descriptor);
labels = null;
}
@Override
public void visitInvokeDynamicInsn(
final String name,
final String descriptor,
final Handle bootstrapMethodHandle,
final Object... bootstrapMethodArguments) {
super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
if (this.locals == null) {
labels = null;
return;
}
pop(descriptor);
pushDescriptor(descriptor);
labels = null;
}
@Override
public void visitJumpInsn(final int opcode, final Label label) {
super.visitJumpInsn(opcode, label);
execute(opcode, 0, null);
if (opcode == Opcodes.GOTO) {
this.locals = null;
this.stack = null;
}
}
@Override
public void visitLabel(final Label label) {
super.visitLabel(label);
if (labels == null) {
labels = new ArrayList<>(3);
}
labels.add(label);
}
@Override
public void visitLdcInsn(final Object value) {
super.visitLdcInsn(value);
if (this.locals == null) {
labels = null;
return;
}
if (value instanceof Integer) {
push(Opcodes.INTEGER);
} else if (value instanceof Long) {
push(Opcodes.LONG);
push(Opcodes.TOP);
} else if (value instanceof Float) {
push(Opcodes.FLOAT);
} else if (value instanceof Double) {
push(Opcodes.DOUBLE);
push(Opcodes.TOP);
} else if (value instanceof String) {
push("java/lang/String");
} else if (value instanceof Type) {
int sort = ((Type) value).getSort();
if (sort == Type.OBJECT || sort == Type.ARRAY) {
push("java/lang/Class");
} else if (sort == Type.METHOD) {
push("java/lang/invoke/MethodType");
} else {
throw new IllegalArgumentException();
}
} else if (value instanceof Handle) {
push("java/lang/invoke/MethodHandle");
} else if (value instanceof ConstantDynamic) {
pushDescriptor(((ConstantDynamic) value).getDescriptor());
} else {
throw new IllegalArgumentException();
}
labels = null;
}
@Override
public void visitIincInsn(final int varIndex, final int increment) {
super.visitIincInsn(varIndex, increment);
maxLocals = Math.max(maxLocals, varIndex + 1);
execute(Opcodes.IINC, varIndex, null);
}
@Override
public void visitTableSwitchInsn(
final int min, final int max, final Label dflt, final Label... labels) {
super.visitTableSwitchInsn(min, max, dflt, labels);
execute(Opcodes.TABLESWITCH, 0, null);
this.locals = null;
this.stack = null;
}
@Override
public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
super.visitLookupSwitchInsn(dflt, keys, labels);
execute(Opcodes.LOOKUPSWITCH, 0, null);
this.locals = null;
this.stack = null;
}
@Override
public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
super.visitMultiANewArrayInsn(descriptor, numDimensions);
execute(Opcodes.MULTIANEWARRAY, numDimensions, descriptor);
}
@Override
public void visitLocalVariable(
final String name,
final String descriptor,
final String signature,
final Label start,
final Label end,
final int index) {
char firstDescriptorChar = descriptor.charAt(0);
maxLocals =
Math.max(
maxLocals, index + (firstDescriptorChar == 'J' || firstDescriptorChar == 'D' ? 2 : 1));
super.visitLocalVariable(name, descriptor, signature, start, end, index);
}
@Override
public void visitMaxs(final int maxStack, final int maxLocals) {
if (mv != null) {
this.maxStack = Math.max(this.maxStack, maxStack);
this.maxLocals = Math.max(this.maxLocals, maxLocals);
mv.visitMaxs(this.maxStack, this.maxLocals);
}
}
private Object get(final int local) {
maxLocals = Math.max(maxLocals, local + 1);
return local < locals.size() ? locals.get(local) : Opcodes.TOP;
}
private void set(final int local, final Object type) {
maxLocals = Math.max(maxLocals, local + 1);
while (local >= locals.size()) {
locals.add(Opcodes.TOP);
}
locals.set(local, type);
}
private void push(final Object type) {
stack.add(type);
maxStack = Math.max(maxStack, stack.size());
}
private void pushDescriptor(final String fieldOrMethodDescriptor) {
String descriptor =
fieldOrMethodDescriptor.charAt(0) == '('
? Type.getReturnType(fieldOrMethodDescriptor).getDescriptor()
: fieldOrMethodDescriptor;
switch (descriptor.charAt(0)) {
case 'V':
return;
case 'Z':
case 'C':
case 'B':
case 'S':
case 'I':
push(Opcodes.INTEGER);
return;
case 'F':
push(Opcodes.FLOAT);
return;
case 'J':
push(Opcodes.LONG);
push(Opcodes.TOP);
return;
case 'D':
push(Opcodes.DOUBLE);
push(Opcodes.TOP);
return;
case '[':
push(descriptor);
break;
case 'L':
push(descriptor.substring(1, descriptor.length() - 1));
break;
default:
throw new AssertionError();
}
}
private Object pop() {
return stack.remove(stack.size() - 1);
}
private void pop(final int numSlots) {
int size = stack.size();
int end = size - numSlots;
for (int i = size - 1; i >= end; --i) {
stack.remove(i);
}
}
private void pop(final String descriptor) {
char firstDescriptorChar = descriptor.charAt(0);
if (firstDescriptorChar == '(') {
int numSlots = 0;
Type[] types = Type.getArgumentTypes(descriptor);
for (Type type : types) {
numSlots += type.getSize();
}
pop(numSlots);
} else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
pop(2);
} else {
pop(1);
}
}
private void execute(final int opcode, final int intArg, final String stringArg) {
if (opcode == Opcodes.JSR || opcode == Opcodes.RET) {
throw new IllegalArgumentException("JSR/RET are not supported");
}
if (this.locals == null) {
labels = null;
return;
}
Object value1;
Object value2;
Object value3;
Object t4;
switch (opcode) {
case Opcodes.NOP:
case Opcodes.INEG:
case Opcodes.LNEG:
case Opcodes.FNEG:
case Opcodes.DNEG:
case Opcodes.I2B:
case Opcodes.I2C:
case Opcodes.I2S:
case Opcodes.GOTO:
case Opcodes.RETURN:
break;
case Opcodes.ACONST_NULL:
push(Opcodes.NULL);
break;
case Opcodes.ICONST_M1:
case Opcodes.ICONST_0:
case Opcodes.ICONST_1:
case Opcodes.ICONST_2:
case Opcodes.ICONST_3:
case Opcodes.ICONST_4:
case Opcodes.ICONST_5:
case Opcodes.BIPUSH:
case Opcodes.SIPUSH:
push(Opcodes.INTEGER);
break;
case Opcodes.LCONST_0:
case Opcodes.LCONST_1:
push(Opcodes.LONG);
push(Opcodes.TOP);
break;
case Opcodes.FCONST_0:
case Opcodes.FCONST_1:
case Opcodes.FCONST_2:
push(Opcodes.FLOAT);
break;
case Opcodes.DCONST_0:
case Opcodes.DCONST_1:
push(Opcodes.DOUBLE);
push(Opcodes.TOP);
break;
case Opcodes.ILOAD:
case Opcodes.FLOAD:
case Opcodes.ALOAD:
push(get(intArg));
break;
case Opcodes.LLOAD:
case Opcodes.DLOAD:
push(get(intArg));
push(Opcodes.TOP);
break;
case Opcodes.LALOAD:
case Opcodes.D2L:
pop(2);
push(Opcodes.LONG);
push(Opcodes.TOP);
break;
case Opcodes.DALOAD:
case Opcodes.L2D:
pop(2);
push(Opcodes.DOUBLE);
push(Opcodes.TOP);
break;
case Opcodes.AALOAD:
pop(1);
value1 = pop();
if (value1 instanceof String) {
pushDescriptor(((String) value1).substring(1));
} else if (value1 == Opcodes.NULL) {
push(value1);
} else {
push("java/lang/Object");
}
break;
case Opcodes.ISTORE:
case Opcodes.FSTORE:
case Opcodes.ASTORE:
value1 = pop();
set(intArg, value1);
if (intArg > 0) {
value2 = get(intArg - 1);
if (value2 == Opcodes.LONG || value2 == Opcodes.DOUBLE) {
set(intArg - 1, Opcodes.TOP);
}
}
break;
case Opcodes.LSTORE:
case Opcodes.DSTORE:
pop(1);
value1 = pop();
set(intArg, value1);
set(intArg + 1, Opcodes.TOP);
if (intArg > 0) {
value2 = get(intArg - 1);
if (value2 == Opcodes.LONG || value2 == Opcodes.DOUBLE) {
set(intArg - 1, Opcodes.TOP);
}
}
break;
case Opcodes.IASTORE:
case Opcodes.BASTORE:
case Opcodes.CASTORE:
case Opcodes.SASTORE:
case Opcodes.FASTORE:
case Opcodes.AASTORE:
pop(3);
break;
case Opcodes.LASTORE:
case Opcodes.DASTORE:
pop(4);
break;
case Opcodes.POP:
case Opcodes.IFEQ:
case Opcodes.IFNE:
case Opcodes.IFLT:
case Opcodes.IFGE:
case Opcodes.IFGT:
case Opcodes.IFLE:
case Opcodes.IRETURN:
case Opcodes.FRETURN:
case Opcodes.ARETURN:
case Opcodes.TABLESWITCH:
case Opcodes.LOOKUPSWITCH:
case Opcodes.ATHROW:
case Opcodes.MONITORENTER:
case Opcodes.MONITOREXIT:
case Opcodes.IFNULL:
case Opcodes.IFNONNULL:
pop(1);
break;
case Opcodes.POP2:
case Opcodes.IF_ICMPEQ:
case Opcodes.IF_ICMPNE:
case Opcodes.IF_ICMPLT:
case Opcodes.IF_ICMPGE:
case Opcodes.IF_ICMPGT:
case Opcodes.IF_ICMPLE:
case Opcodes.IF_ACMPEQ:
case Opcodes.IF_ACMPNE:
case Opcodes.LRETURN:
case Opcodes.DRETURN:
pop(2);
break;
case Opcodes.DUP:
value1 = pop();
push(value1);
push(value1);
break;
case Opcodes.DUP_X1:
value1 = pop();
value2 = pop();
push(value1);
push(value2);
push(value1);
break;
case Opcodes.DUP_X2:
value1 = pop();
value2 = pop();
value3 = pop();
push(value1);
push(value3);
push(value2);
push(value1);
break;
case Opcodes.DUP2:
value1 = pop();
value2 = pop();
push(value2);
push(value1);
push(value2);
push(value1);
break;
case Opcodes.DUP2_X1:
value1 = pop();
value2 = pop();
value3 = pop();
push(value2);
push(value1);
push(value3);
push(value2);
push(value1);
break;
case Opcodes.DUP2_X2:
value1 = pop();
value2 = pop();
value3 = pop();
t4 = pop();
push(value2);
push(value1);
push(t4);
push(value3);
push(value2);
push(value1);
break;
case Opcodes.SWAP:
value1 = pop();
value2 = pop();
push(value1);
push(value2);
break;
case Opcodes.IALOAD:
case Opcodes.BALOAD:
case Opcodes.CALOAD:
case Opcodes.SALOAD:
case Opcodes.IADD:
case Opcodes.ISUB:
case Opcodes.IMUL:
case Opcodes.IDIV:
case Opcodes.IREM:
case Opcodes.IAND:
case Opcodes.IOR:
case Opcodes.IXOR:
case Opcodes.ISHL:
case Opcodes.ISHR:
case Opcodes.IUSHR:
case Opcodes.L2I:
case Opcodes.D2I:
case Opcodes.FCMPL:
case Opcodes.FCMPG:
pop(2);
push(Opcodes.INTEGER);
break;
case Opcodes.LADD:
case Opcodes.LSUB:
case Opcodes.LMUL:
case Opcodes.LDIV:
case Opcodes.LREM:
case Opcodes.LAND:
case Opcodes.LOR:
case Opcodes.LXOR:
pop(4);
push(Opcodes.LONG);
push(Opcodes.TOP);
break;
case Opcodes.FALOAD:
case Opcodes.FADD:
case Opcodes.FSUB:
case Opcodes.FMUL:
case Opcodes.FDIV:
case Opcodes.FREM:
case Opcodes.L2F:
case Opcodes.D2F:
pop(2);
push(Opcodes.FLOAT);
break;
case Opcodes.DADD:
case Opcodes.DSUB:
case Opcodes.DMUL:
case Opcodes.DDIV:
case Opcodes.DREM:
pop(4);
push(Opcodes.DOUBLE);
push(Opcodes.TOP);
break;
case Opcodes.LSHL:
case Opcodes.LSHR:
case Opcodes.LUSHR:
pop(3);
push(Opcodes.LONG);
push(Opcodes.TOP);
break;
case Opcodes.IINC:
set(intArg, Opcodes.INTEGER);
break;
case Opcodes.I2L:
case Opcodes.F2L:
pop(1);
push(Opcodes.LONG);
push(Opcodes.TOP);
break;
case Opcodes.I2F:
pop(1);
push(Opcodes.FLOAT);
break;
case Opcodes.I2D:
case Opcodes.F2D:
pop(1);
push(Opcodes.DOUBLE);
push(Opcodes.TOP);
break;
case Opcodes.F2I:
case Opcodes.ARRAYLENGTH:
case Opcodes.INSTANCEOF:
pop(1);
push(Opcodes.INTEGER);
break;
case Opcodes.LCMP:
case Opcodes.DCMPL:
case Opcodes.DCMPG:
pop(4);
push(Opcodes.INTEGER);
break;
case Opcodes.GETSTATIC:
pushDescriptor(stringArg);
break;
case Opcodes.PUTSTATIC:
pop(stringArg);
break;
case Opcodes.GETFIELD:
pop(1);
pushDescriptor(stringArg);
break;
case Opcodes.PUTFIELD:
pop(stringArg);
pop();
break;
case Opcodes.NEW:
push(labels.get(0));
break;
case Opcodes.NEWARRAY:
pop();
switch (intArg) {
case Opcodes.T_BOOLEAN:
pushDescriptor("[Z");
break;
case Opcodes.T_CHAR:
pushDescriptor("[C");
break;
case Opcodes.T_BYTE:
pushDescriptor("[B");
break;
case Opcodes.T_SHORT:
pushDescriptor("[S");
break;
case Opcodes.T_INT:
pushDescriptor("[I");
break;
case Opcodes.T_FLOAT:
pushDescriptor("[F");
break;
case Opcodes.T_DOUBLE:
pushDescriptor("[D");
break;
case Opcodes.T_LONG:
pushDescriptor("[J");
break;
default:
throw new IllegalArgumentException("Invalid array type " + intArg);
}
break;
case Opcodes.ANEWARRAY:
pop();
pushDescriptor("[" + Type.getObjectType(stringArg));
break;
case Opcodes.CHECKCAST:
pop();
pushDescriptor(Type.getObjectType(stringArg).getDescriptor());
break;
case Opcodes.MULTIANEWARRAY:
pop(intArg);
pushDescriptor(stringArg);
break;
default:
throw new IllegalArgumentException("Invalid opcode " + opcode);
}
labels = null;
}
}
package jdk.internal.org.objectweb.asm.tree.analysis;
import jdk.internal.org.objectweb.asm.tree.AbstractInsnNode;
public class AnalyzerException extends Exception {
private static final long serialVersionUID = 3154190448018943333L;
public final transient AbstractInsnNode node;
public AnalyzerException(final AbstractInsnNode insn, final String message) {
super(message);
this.node = insn;
}
public AnalyzerException(
final AbstractInsnNode insn, final String message, final Throwable cause) {
super(message, cause);
this.node = insn;
}
public AnalyzerException(
final AbstractInsnNode insn,
final String message,
final Object expected,
final Value actual) {
super(
(message == null ? "Expected " : message + ": expected ")
+ expected
+ ", but found "
+ actual);
this.node = insn;
}
}
package javax.swing.event;
import java.awt.event.*;
import java.awt.*;
import javax.swing.*;
@SuppressWarnings("serial")
public class AncestorEvent extends AWTEvent {
public static final int ANCESTOR_ADDED = 1;
public static final int ANCESTOR_REMOVED = 2;
public static final int ANCESTOR_MOVED = 3;
Container ancestor;
Container ancestorParent;
public AncestorEvent(JComponent source, int id, Container ancestor, Container ancestorParent) {
super(source, id);
this.ancestor = ancestor;
this.ancestorParent = ancestorParent;
}
public Container getAncestor() {
return ancestor;
}
public Container getAncestorParent() {
return ancestorParent;
}
public JComponent getComponent() {
return (JComponent)getSource();
}
}
package javax.swing.event;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import javax.swing.*;
public interface AncestorListener extends EventListener {
public void ancestorAdded(AncestorEvent event);
public void ancestorRemoved(AncestorEvent event);
public void ancestorMoved(AncestorEvent event);
}
package javax.swing;
import javax.swing.event.*;
import java.awt.event.*;
import java.awt.Component;
import java.awt.Container;
import java.awt.Window;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
import java.io.Serializable;
@SuppressWarnings("serial")
class AncestorNotifier implements ComponentListener, PropertyChangeListener, Serializable
{
transient Component firstInvisibleAncestor;
EventListenerList listenerList = new EventListenerList();
JComponent root;
AncestorNotifier(JComponent root) {
this.root = root;
addListeners(root, true);
}
void addAncestorListener(AncestorListener l) {
listenerList.add(AncestorListener.class, l);
}
void removeAncestorListener(AncestorListener l) {
listenerList.remove(AncestorListener.class, l);
}
AncestorListener[] getAncestorListeners() {
return listenerList.getListeners(AncestorListener.class);
}
protected void fireAncestorAdded(JComponent source, int id, Container ancestor, Container ancestorParent) {
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==AncestorListener.class) {
AncestorEvent ancestorEvent =
new AncestorEvent(source, id, ancestor, ancestorParent);
((AncestorListener)listeners[i+1]).ancestorAdded(ancestorEvent);
}
}
}
protected void fireAncestorRemoved(JComponent source, int id, Container ancestor, Container ancestorParent) {
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==AncestorListener.class) {
AncestorEvent ancestorEvent =
new AncestorEvent(source, id, ancestor, ancestorParent);
((AncestorListener)listeners[i+1]).ancestorRemoved(ancestorEvent);
}
}
}
protected void fireAncestorMoved(JComponent source, int id, Container ancestor, Container ancestorParent) {
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length-2; i>=0; i-=2) {
if (listeners[i]==AncestorListener.class) {
AncestorEvent ancestorEvent =
new AncestorEvent(source, id, ancestor, ancestorParent);
((AncestorListener)listeners[i+1]).ancestorMoved(ancestorEvent);
}
}
}
void removeAllListeners() {
removeListeners(root);
}
void addListeners(Component ancestor, boolean addToFirst) {
Component a;
firstInvisibleAncestor = null;
for (a = ancestor;
firstInvisibleAncestor == null;
a = a.getParent()) {
if (addToFirst || a != ancestor) {
a.addComponentListener(this);
if (a instanceof JComponent) {
JComponent jAncestor = (JComponent)a;
jAncestor.addPropertyChangeListener(this);
}
}
if (!a.isVisible() || a.getParent() == null || a instanceof Window) {
firstInvisibleAncestor = a;
}
}
if (firstInvisibleAncestor instanceof Window &&
firstInvisibleAncestor.isVisible()) {
firstInvisibleAncestor = null;
}
}
void removeListeners(Component ancestor) {
Component a;
for (a = ancestor; a != null; a = a.getParent()) {
a.removeComponentListener(this);
if (a instanceof JComponent) {
JComponent jAncestor = (JComponent)a;
jAncestor.removePropertyChangeListener(this);
}
if (a == firstInvisibleAncestor || a instanceof Window) {
break;
}
}
}
public void componentResized(ComponentEvent e) {}
public void componentMoved(ComponentEvent e) {
Component source = e.getComponent();
fireAncestorMoved(root, AncestorEvent.ANCESTOR_MOVED,
(Container)source, source.getParent());
}
public void componentShown(ComponentEvent e) {
Component ancestor = e.getComponent();
if (ancestor == firstInvisibleAncestor) {
addListeners(ancestor, false);
if (firstInvisibleAncestor == null) {
fireAncestorAdded(root, AncestorEvent.ANCESTOR_ADDED,
(Container)ancestor, ancestor.getParent());
}
}
}
public void componentHidden(ComponentEvent e) {
Component ancestor = e.getComponent();
boolean needsNotify = firstInvisibleAncestor == null;
if ( !(ancestor instanceof Window) ) {
removeListeners(ancestor.getParent());
}
firstInvisibleAncestor = ancestor;
if (needsNotify) {
fireAncestorRemoved(root, AncestorEvent.ANCESTOR_REMOVED,
(Container)ancestor, ancestor.getParent());
}
}
public void propertyChange(PropertyChangeEvent evt) {
String s = evt.getPropertyName();
if (s!=null && (s.equals("parent") || s.equals("ancestor"))) {
JComponent component = (JComponent)evt.getSource();
if (evt.getNewValue() != null) {
if (component == firstInvisibleAncestor) {
addListeners(component, false);
if (firstInvisibleAncestor == null) {
fireAncestorAdded(root, AncestorEvent.ANCESTOR_ADDED,
component, component.getParent());
}
}
} else {
boolean needsNotify = firstInvisibleAncestor == null;
Container oldParent = (Container)evt.getOldValue();
removeListeners(oldParent);
firstInvisibleAncestor = component;
if (needsNotify) {
fireAncestorRemoved(root, AncestorEvent.ANCESTOR_REMOVED,
component, oldParent);
}
}
}
}
}
package com.sun.org.apache.xalan.internal.xsltc.compiler;
import com.sun.org.apache.bcel.internal.generic.BranchHandle;
import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
import com.sun.org.apache.bcel.internal.generic.GOTO;
import com.sun.org.apache.bcel.internal.generic.IFLT;
import com.sun.org.apache.bcel.internal.generic.ILOAD;
import com.sun.org.apache.bcel.internal.generic.INVOKEINTERFACE;
import com.sun.org.apache.bcel.internal.generic.ISTORE;
import com.sun.org.apache.bcel.internal.generic.InstructionHandle;
import com.sun.org.apache.bcel.internal.generic.InstructionList;
import com.sun.org.apache.bcel.internal.generic.LocalVariableGen;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ClassGenerator;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.MethodGenerator;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
final class AncestorPattern extends RelativePathPattern {
private final Pattern _left;            private final RelativePathPattern _right;
private InstructionHandle _loop;
public AncestorPattern(RelativePathPattern right) {
this(null, right);
}
public AncestorPattern(Pattern left, RelativePathPattern right) {
_left = left;
(_right = right).setParent(this);
if (left != null) {
left.setParent(this);
}
}
public InstructionHandle getLoopHandle() {
return _loop;
}
public void setParser(Parser parser) {
super.setParser(parser);
if (_left != null) {
_left.setParser(parser);
}
_right.setParser(parser);
}
public boolean isWildcard() {
return false;
}
public StepPattern getKernelPattern() {
return _right.getKernelPattern();
}
public void reduceKernelPattern() {
_right.reduceKernelPattern();
}
public Type typeCheck(SymbolTable stable) throws TypeCheckError {
if (_left != null) {
_left.typeCheck(stable);
}
return _right.typeCheck(stable);
}
public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
InstructionHandle parent;
final ConstantPoolGen cpg = classGen.getConstantPool();
final InstructionList il = methodGen.getInstructionList();
final LocalVariableGen local =
methodGen.addLocalVariable2("app", Util.getJCRefType(NODE_SIG),
il.getEnd());
final com.sun.org.apache.bcel.internal.generic.Instruction loadLocal =
new ILOAD(local.getIndex());
final com.sun.org.apache.bcel.internal.generic.Instruction storeLocal =
new ISTORE(local.getIndex());
if (_right instanceof StepPattern) {
il.append(DUP);
il.append(storeLocal);
_right.translate(classGen, methodGen);
il.append(methodGen.loadDOM());
il.append(loadLocal);
}
else {
_right.translate(classGen, methodGen);
if (_right instanceof AncestorPattern) {
il.append(methodGen.loadDOM());
il.append(SWAP);
}
}
if (_left != null) {
final int getParent = cpg.addInterfaceMethodref(DOM_INTF,
GET_PARENT,
GET_PARENT_SIG);
parent = il.append(new INVOKEINTERFACE(getParent, 2));
il.append(DUP);
il.append(storeLocal);
_falseList.add(il.append(new IFLT(null)));
il.append(loadLocal);
_left.translate(classGen, methodGen);
final SyntaxTreeNode p = getParent();
if (p == null || p instanceof Instruction ||
p instanceof TopLevelElement)
{
}
else {
il.append(loadLocal);
}
final BranchHandle exit = il.append(new GOTO(null));
_loop = il.append(methodGen.loadDOM());
il.append(loadLocal);
local.setEnd(_loop);
il.append(new GOTO(parent));
exit.setTarget(il.append(NOP));
_left.backPatchFalseList(_loop);
_trueList.append(_left._trueList);
}
else {
il.append(POP2);
}
if (_right instanceof AncestorPattern) {
final AncestorPattern ancestor = (AncestorPattern) _right;
_falseList.backPatch(ancestor.getLoopHandle());            }
_trueList.append(_right._trueList);
_falseList.append(_right._falseList);
}
public String toString() {
return "AncestorPattern(" + _left + ", " + _right + ')';
}
}
package sun.security.util;
import java.io.File;
import java.io.FileInputStream;
import java.security.AccessController;
import java.security.KeyStore;
import java.security.PrivilegedAction;
import java.security.cert.X509Certificate;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
import javax.security.auth.x500.X500Principal;
import sun.security.x509.X509CertImpl;
public class AnchorCertificates {
private static final Debug debug = Debug.getInstance("certpath");
private static final String HASH = "SHA-256";
private static Set<String> certs = Collections.emptySet();
private static Set<X500Principal> certIssuers = Collections.emptySet();
static  {
@SuppressWarnings("removal")
var dummy = AccessController.doPrivileged(new PrivilegedAction<>() {
@Override
public Void run() {
File f = new File(FilePaths.cacerts());
try {
KeyStore cacerts;
cacerts = KeyStore.getInstance("JKS");
try (FileInputStream fis = new FileInputStream(f)) {
cacerts.load(fis, null);
certs = new HashSet<>();
certIssuers = new HashSet<>();
Enumeration<String> list = cacerts.aliases();
while (list.hasMoreElements()) {
String alias = list.nextElement();
if (alias.contains(" [jdk")) {
X509Certificate cert = (X509Certificate) cacerts
.getCertificate(alias);
String fp =
X509CertImpl.getFingerprint(HASH, cert, debug);
if (fp != null) {
certs.add(fp);
certIssuers.add(cert.getSubjectX500Principal());
}
}
}
}
} catch (Exception e) {
if (debug != null) {
debug.println("Error parsing cacerts");
e.printStackTrace();
}
}
return null;
}
});
}
public static boolean contains(X509Certificate cert) {
String key = X509CertImpl.getFingerprint(HASH, cert, debug);
boolean result = (key == null ? false : certs.contains(key));
if (result && debug != null) {
debug.println("AnchorCertificate.contains: matched " +
cert.getSubjectX500Principal());
}
return result;
}
public static boolean issuerOf(X509Certificate cert) {
return certIssuers.contains(cert.getIssuerX500Principal());
}
private AnchorCertificates() {}
}
package com.sun.org.apache.xpath.internal.operations;
import com.sun.org.apache.xpath.internal.XPathContext;
import com.sun.org.apache.xpath.internal.objects.XBoolean;
import com.sun.org.apache.xpath.internal.objects.XObject;
public class And extends Operation
{
static final long serialVersionUID = 392330077126534022L;
public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
{
XObject expr1 = m_left.execute(xctxt);
if (expr1.bool())
{
XObject expr2 = m_right.execute(xctxt);
return expr2.bool() ? XBoolean.S_TRUE : XBoolean.S_FALSE;
}
else
return XBoolean.S_FALSE;
}
public boolean bool(XPathContext xctxt)
throws javax.xml.transform.TransformerException
{
return (m_left.bool(xctxt) && m_right.bool(xctxt));
}
}
package compiler.intrinsics.bmi.verifycode;
import compiler.intrinsics.bmi.TestAndnI;
import java.lang.reflect.Method;
public class AndnTestI extends BmiIntrinsicBase.BmiTestCase {
protected AndnTestI(Method method) {
super(method);
instrMask = new byte[]{
(byte) 0xFF,
(byte) 0x1F,
(byte) 0x00,
(byte) 0xFF};
instrPattern = new byte[]{
(byte) 0xC4,                 (byte) 0x02,                 (byte) 0x00,
(byte) 0xF2};
}
public static void main(String[] args) throws Exception {
BmiIntrinsicBase.verifyTestCase(AndnTestI::new, TestAndnI.AndnIExpr.class.getDeclaredMethods());
BmiIntrinsicBase.verifyTestCase(AndnTestI::new, TestAndnI.AndnICommutativeExpr.class.getDeclaredMethods());
}
}
package compiler.intrinsics.bmi.verifycode;
import compiler.intrinsics.bmi.TestAndnL;
import java.lang.reflect.Method;
public class AndnTestL extends AndnTestI {
protected AndnTestL(Method method) {
super(method);
isLongOperation = true;
}
public static void main(String[] args) throws Exception {
BmiIntrinsicBase.verifyTestCase(AndnTestL::new, TestAndnL.AndnLExpr.class.getDeclaredMethods());
BmiIntrinsicBase.verifyTestCase(AndnTestL::new, TestAndnL.AndnLCommutativeExpr.class.getDeclaredMethods());
}
}
package javax.management;
class AndQueryExp extends QueryEval implements QueryExp {
private static final long serialVersionUID = -1081892073854801359L;
private QueryExp exp1;
private QueryExp exp2;
public AndQueryExp() {
}
public AndQueryExp(QueryExp q1, QueryExp q2) {
exp1 = q1;
exp2 = q2;
}
public QueryExp getLeftExp()  {
return exp1;
}
public QueryExp getRightExp()  {
return exp2;
}
public boolean apply(ObjectName name) throws BadStringOperationException, BadBinaryOpValueExpException,
BadAttributeValueExpException, InvalidApplicationException  {
return exp1.apply(name) && exp2.apply(name);
}
@Override
public String toString() {
return "(" + exp1 + ") and (" + exp2 + ")";
}
}
package com.sun.hotspot.igv.graph;
import java.util.ArrayList;
import java.util.List;
public class AndSelector implements Selector {
private Selector selector1;
private Selector selector2;
public AndSelector(Selector s1, Selector s2) {
this.selector1 = s1;
this.selector2 = s2;
}
@Override
public List<Figure> selected(Diagram d) {
List<Figure> l1 = selector1.selected(d);
List<Figure> l2 = selector2.selected(d);
List<Figure> result = new ArrayList<>();
for (Figure f : l2) {
if (l1.contains(f)) {
result.add(f);
}
}
return result;
}
}
package com.sun.org.apache.bcel.internal.generic;
import com.sun.org.apache.bcel.internal.ExceptionConst;
public class ANEWARRAY extends CPInstruction implements LoadClass, AllocationInstruction,
ExceptionThrower, StackConsumer, StackProducer {
ANEWARRAY() {
}
public ANEWARRAY(final int index) {
super(com.sun.org.apache.bcel.internal.Const.ANEWARRAY, index);
}
@Override
public Class<?>[] getExceptions() {
return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION,
ExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTION);
}
@Override
public void accept( final Visitor v ) {
v.visitLoadClass(this);
v.visitAllocationInstruction(this);
v.visitExceptionThrower(this);
v.visitStackProducer(this);
v.visitTypedInstruction(this);
v.visitCPInstruction(this);
v.visitANEWARRAY(this);
}
@Override
public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {
Type t = getType(cpg);
if (t instanceof ArrayType) {
t = ((ArrayType) t).getBasicType();
}
return (t instanceof ObjectType) ? (ObjectType) t : null;
}
}
package java2d;
public interface AnimatingContext {
public void step(int w, int h);
public void reset(int newwidth, int newheight);
}
package java2d;
import static java2d.CustomControlsContext.State.START;
import java.awt.Component;
@SuppressWarnings("serial")
public abstract class AnimatingControlsSurface extends AnimatingSurface
implements CustomControlsContext {
@Override
public void setControls(Component[] controls) {
this.controls = controls;
}
@Override
public void setConstraints(String[] constraints) {
this.constraints = constraints;
}
@Override
public String[] getConstraints() {
return constraints;
}
@Override
public Component[] getControls() {
return controls;
}
@Override
public void handleThread(CustomControlsContext.State state) {
for (Component control : controls) {
if (control instanceof CustomControls) {
if (state == START) {
((CustomControls) control).start();
} else {
((CustomControls) control).stop();
}
}
}
}
private Component[] controls;
private String[] constraints = { java.awt.BorderLayout.NORTH };
}
package java2d;
@SuppressWarnings("serial")
public abstract class AnimatingSurface extends Surface implements Runnable {
private volatile boolean running = false;
private volatile Thread thread;
public abstract void step(int w, int h);
public abstract void reset(int newwidth, int newheight);
public synchronized void start() {
if (!running() && !dontThread) {
thread = new Thread(this);
thread.setPriority(Thread.MIN_PRIORITY);
thread.setName(name + " Demo");
thread.start();
running = true;
}
}
public synchronized void stop() {
if (thread != null) {
running = false;
thread.interrupt();
}
thread = null;
notifyAll();
}
@Override
@SuppressWarnings("SleepWhileHoldingLock")
public void run() {
while (running() && !isShowing() || getSize().width == 0) {
try {
Thread.sleep(200);
} catch (InterruptedException ignored) {
}
}
while (running()) {
repaint();
try {
Thread.sleep(sleepAmount);
} catch (InterruptedException ignored) {
}
}
synchronized (this) {
running = false;
}
}
public synchronized boolean running() {
return running;
}
public synchronized void doRepaint() {
if (running() && thread != null) {
thread.interrupt();
}
}
}
package com.sun.java.swing.plaf.windows;
import java.security.AccessController;
import sun.security.action.GetBooleanAction;
import java.util.*;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import com.sun.java.swing.plaf.windows.TMSchema.State;
import static com.sun.java.swing.plaf.windows.TMSchema.State.*;
import com.sun.java.swing.plaf.windows.TMSchema.Part;
import com.sun.java.swing.plaf.windows.TMSchema.Prop;
import com.sun.java.swing.plaf.windows.XPStyle.Skin;
import sun.awt.AppContext;
class AnimationController implements ActionListener, PropertyChangeListener {
@SuppressWarnings("removal")
private static final boolean VISTA_ANIMATION_DISABLED =
AccessController.doPrivileged(new GetBooleanAction("swing.disablevistaanimation"));
private static final Object ANIMATION_CONTROLLER_KEY =
new StringBuilder("ANIMATION_CONTROLLER_KEY");
private final Map<JComponent, Map<Part, AnimationState>> animationStateMap =
new WeakHashMap<JComponent, Map<Part, AnimationState>>();
private final javax.swing.Timer timer =
new javax.swing.Timer(1000/30, this);
private static synchronized AnimationController getAnimationController() {
AppContext appContext = AppContext.getAppContext();
Object obj = appContext.get(ANIMATION_CONTROLLER_KEY);
if (obj == null) {
obj = new AnimationController();
appContext.put(ANIMATION_CONTROLLER_KEY, obj);
}
return (AnimationController) obj;
}
private AnimationController() {
timer.setRepeats(true);
timer.setCoalesce(true);
UIManager.addPropertyChangeListener(this);
}
private static void triggerAnimation(JComponent c,
Part part, State newState) {
if (c instanceof javax.swing.JTabbedPane
|| part == Part.TP_BUTTON) {
return;
}
AnimationController controller =
AnimationController.getAnimationController();
State oldState = controller.getState(c, part);
if (oldState != newState) {
controller.putState(c, part, newState);
if (newState == State.DEFAULTED) {
oldState = State.HOT;
}
if (oldState != null) {
long duration;
if (newState == State.DEFAULTED) {
duration = 1000;
} else {
XPStyle xp = XPStyle.getXP();
duration = (xp != null)
? xp.getThemeTransitionDuration(
c, part,
normalizeState(oldState),
normalizeState(newState),
Prop.TRANSITIONDURATIONS)
: 1000;
}
controller.startAnimation(c, part, oldState, newState, duration);
}
}
}
private static State normalizeState(State state) {
State rv;
switch (state) {
case DOWNPRESSED:
case LEFTPRESSED:
case RIGHTPRESSED:
rv = UPPRESSED;
break;
case DOWNDISABLED:
case LEFTDISABLED:
case RIGHTDISABLED:
rv = UPDISABLED;
break;
case DOWNHOT:
case LEFTHOT:
case RIGHTHOT:
rv = UPHOT;
break;
case DOWNNORMAL:
case LEFTNORMAL:
case RIGHTNORMAL:
rv = UPNORMAL;
break;
default :
rv = state;
break;
}
return rv;
}
private synchronized State getState(JComponent component, Part part) {
State rv = null;
Object tmpObject =
component.getClientProperty(PartUIClientPropertyKey.getKey(part));
if (tmpObject instanceof State) {
rv = (State) tmpObject;
}
return rv;
}
private synchronized void putState(JComponent component, Part part,
State state) {
component.putClientProperty(PartUIClientPropertyKey.getKey(part),
state);
}
private synchronized void startAnimation(JComponent component,
Part part,
State startState,
State endState,
long millis) {
boolean isForwardAndReverse = false;
if (endState == State.DEFAULTED) {
isForwardAndReverse = true;
}
Map<Part, AnimationState> map = animationStateMap.get(component);
if (millis <= 0) {
if (map != null) {
map.remove(part);
if (map.size() == 0) {
animationStateMap.remove(component);
}
}
return;
}
if (map == null) {
map = new EnumMap<Part, AnimationState>(Part.class);
animationStateMap.put(component, map);
}
map.put(part,
new AnimationState(startState, millis, isForwardAndReverse));
if (! timer.isRunning()) {
timer.start();
}
}
static void paintSkin(JComponent component, Skin skin,
Graphics g, int dx, int dy, int dw, int dh, State state) {
if (VISTA_ANIMATION_DISABLED) {
skin.paintSkinRaw(g, dx, dy, dw, dh, state);
return;
}
triggerAnimation(component, skin.part, state);
AnimationController controller = getAnimationController();
synchronized (controller) {
AnimationState animationState = null;
Map<Part, AnimationState> map =
controller.animationStateMap.get(component);
if (map != null) {
animationState = map.get(skin.part);
}
if (animationState != null) {
animationState.paintSkin(skin, g, dx, dy, dw, dh, state);
} else {
skin.paintSkinRaw(g, dx, dy, dw, dh, state);
}
}
}
public synchronized void propertyChange(PropertyChangeEvent e) {
if ("lookAndFeel" == e.getPropertyName()
&& ! (e.getNewValue() instanceof WindowsLookAndFeel) ) {
dispose();
}
}
public synchronized void actionPerformed(ActionEvent e) {
java.util.List<JComponent> componentsToRemove = null;
java.util.List<Part> partsToRemove = null;
for (JComponent component : animationStateMap.keySet()) {
component.repaint();
if (partsToRemove != null) {
partsToRemove.clear();
}
Map<Part, AnimationState> map = animationStateMap.get(component);
if (! component.isShowing()
|| map == null
|| map.size() == 0) {
if (componentsToRemove == null) {
componentsToRemove = new ArrayList<JComponent>();
}
componentsToRemove.add(component);
continue;
}
for (Part part : map.keySet()) {
if (map.get(part).isDone()) {
if (partsToRemove == null) {
partsToRemove = new ArrayList<Part>();
}
partsToRemove.add(part);
}
}
if (partsToRemove != null) {
if (partsToRemove.size() == map.size()) {
if (componentsToRemove == null) {
componentsToRemove = new ArrayList<JComponent>();
}
componentsToRemove.add(component);
} else {
for (Part part : partsToRemove) {
map.remove(part);
}
}
}
}
if (componentsToRemove != null) {
for (JComponent component : componentsToRemove) {
animationStateMap.remove(component);
}
}
if (animationStateMap.size() == 0) {
timer.stop();
}
}
private synchronized void dispose() {
timer.stop();
UIManager.removePropertyChangeListener(this);
synchronized (AnimationController.class) {
AppContext.getAppContext()
.put(ANIMATION_CONTROLLER_KEY, null);
}
}
private static class AnimationState {
private final State startState;
private final long duration;
private long startTime;
private boolean isForward = true;
private boolean isForwardAndReverse;
private float progress;
AnimationState(final State startState,
final long milliseconds,
boolean isForwardAndReverse) {
assert startState != null && milliseconds > 0;
assert SwingUtilities.isEventDispatchThread();
this.startState = startState;
this.duration = milliseconds * 1000000;
this.startTime = System.nanoTime();
this.isForwardAndReverse = isForwardAndReverse;
progress = 0f;
}
private void updateProgress() {
assert SwingUtilities.isEventDispatchThread();
if (isDone()) {
return;
}
long currentTime = System.nanoTime();
progress = ((float) (currentTime - startTime))
/ duration;
progress = Math.max(progress, 0);             if (progress >= 1) {
progress = 1;
if (isForwardAndReverse) {
startTime = currentTime;
progress = 0;
isForward = ! isForward;
}
}
}
void paintSkin(Skin skin, Graphics _g,
int dx, int dy, int dw, int dh, State state) {
assert SwingUtilities.isEventDispatchThread();
updateProgress();
if (! isDone()) {
Graphics2D g = (Graphics2D) _g.create();
if (skin.haveToSwitchStates()) {
skin.paintSkinRaw(g, dx, dy, dw, dh, state);
g.setComposite(AlphaComposite.SrcOver.derive(1 - progress));
skin.paintSkinRaw(g, dx, dy, dw, dh, startState);
} else {
skin.paintSkinRaw(g, dx, dy, dw, dh, startState);
float alpha;
if (isForward) {
alpha = progress;
} else {
alpha = 1 - progress;
}
g.setComposite(AlphaComposite.SrcOver.derive(alpha));
skin.paintSkinRaw(g, dx, dy, dw, dh, state);
}
g.dispose();
} else {
skin.paintSkinRaw(_g, dx, dy, dw, dh, state);
skin.switchStates(false);
}
}
boolean isDone() {
assert SwingUtilities.isEventDispatchThread();
return  progress >= 1;
}
}
private static class PartUIClientPropertyKey
implements UIClientPropertyKey {
private static final Map<Part, PartUIClientPropertyKey> map =
new EnumMap<Part, PartUIClientPropertyKey>(Part.class);
static synchronized PartUIClientPropertyKey getKey(Part part) {
PartUIClientPropertyKey rv = map.get(part);
if (rv == null) {
rv = new PartUIClientPropertyKey(part);
map.put(part, rv);
}
return rv;
}
private final Part part;
private PartUIClientPropertyKey(Part part) {
this.part  = part;
}
public String toString() {
return part.toString();
}
}
}
package com.sun.tools.javac.code;
import java.lang.annotation.Annotation;
import java.lang.annotation.Inherited;
import java.lang.annotation.Repeatable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import javax.lang.model.AnnotatedConstruct;
import com.sun.tools.javac.model.AnnotationProxyMaker;
import com.sun.tools.javac.util.DefinedBy;
import com.sun.tools.javac.util.DefinedBy.Api;
import com.sun.tools.javac.util.List;
import com.sun.tools.javac.util.ListBuffer;
public abstract class AnnoConstruct implements AnnotatedConstruct {
@Override @DefinedBy(Api.LANGUAGE_MODEL)
public abstract List<? extends Attribute.Compound> getAnnotationMirrors();
protected <A extends Annotation> Attribute.Compound getAttribute(Class<A> annoType) {
String name = annoType.getName();
for (Attribute.Compound anno : getAnnotationMirrors()) {
if (name.equals(anno.type.tsym.flatName().toString()))
return anno;
}
return null;
}
@SuppressWarnings("unchecked")
protected <A extends Annotation> A[] getInheritedAnnotations(Class<A> annoType) {
return (A[]) java.lang.reflect.Array.newInstance(annoType, 0);      }
@DefinedBy(Api.LANGUAGE_MODEL)
public <A extends Annotation> A[] getAnnotationsByType(Class<A> annoType) {
if (!annoType.isAnnotation())
throw new IllegalArgumentException("Not an annotation type: "
+ annoType);
Class <? extends Annotation> containerType = getContainer(annoType);
if (containerType == null) {
A res = getAnnotation(annoType);
int size = res == null ? 0 : 1;
@SuppressWarnings("unchecked")             A[] arr = (A[])java.lang.reflect.Array.newInstance(annoType, size);
if (res != null)
arr[0] = res;
return arr;
}
String annoTypeName = annoType.getName();
String containerTypeName = containerType.getName();
int directIndex = -1, containerIndex = -1;
Attribute.Compound direct = null, container = null;
int index = -1;
for (Attribute.Compound attribute : getAnnotationMirrors()) {
index++;
if (attribute.type.tsym.flatName().contentEquals(annoTypeName)) {
directIndex = index;
direct = attribute;
} else if(containerTypeName != null &&
attribute.type.tsym.flatName().contentEquals(containerTypeName)) {
containerIndex = index;
container = attribute;
}
}
if (direct == null && container == null &&
annoType.isAnnotationPresent(Inherited.class))
return getInheritedAnnotations(annoType);
Attribute.Compound[] contained = unpackContained(container);
if (direct == null && contained.length == 0 &&
annoType.isAnnotationPresent(Inherited.class))
return getInheritedAnnotations(annoType);
int size = (direct == null ? 0 : 1) + contained.length;
@SuppressWarnings("unchecked")         A[] arr = (A[])java.lang.reflect.Array.newInstance(annoType, size);
int insert = -1;
int length = arr.length;
if (directIndex >= 0 && containerIndex >= 0) {
if (directIndex < containerIndex) {
arr[0] = AnnotationProxyMaker.generateAnnotation(direct, annoType);
insert = 1;
} else {
arr[arr.length - 1] = AnnotationProxyMaker.generateAnnotation(direct, annoType);
insert = 0;
length--;
}
} else if (directIndex >= 0) {
arr[0] = AnnotationProxyMaker.generateAnnotation(direct, annoType);
return arr;
} else {
insert = 0;
}
for (int i = 0; i + insert < length; i++)
arr[insert + i] = AnnotationProxyMaker.generateAnnotation(contained[i], annoType);
return arr;
}
private Attribute.Compound[] unpackContained(Attribute.Compound container) {
Attribute[] contained0 = null;
if (container != null)
contained0 = unpackAttributes(container);
ListBuffer<Attribute.Compound> compounds = new ListBuffer<>();
if (contained0 != null) {
for (Attribute a : contained0)
if (a instanceof Attribute.Compound attributeCompound)
compounds = compounds.append(attributeCompound);
}
return compounds.toArray(new Attribute.Compound[compounds.size()]);
}
@DefinedBy(Api.LANGUAGE_MODEL)
public <A extends Annotation> A getAnnotation(Class<A> annoType) {
if (!annoType.isAnnotation())
throw new IllegalArgumentException("Not an annotation type: " + annoType);
Attribute.Compound c = getAttribute(annoType);
return c == null ? null : AnnotationProxyMaker.generateAnnotation(c, annoType);
}
private static Class<? extends Annotation> getContainer(Class<? extends Annotation> annoType) {
Repeatable repeatable = annoType.getAnnotation(Repeatable.class);
return (repeatable == null) ? null : repeatable.value();
}
private static Attribute[] unpackAttributes(Attribute.Compound container) {
return ((Attribute.Array)container.member(container.type.tsym.name.table.names.value)).values;
}
}
package com.sun.tools.javac.comp;
import com.sun.tools.javac.code.*;
import com.sun.tools.javac.code.Attribute.Compound;
import com.sun.tools.javac.code.Attribute.TypeCompound;
import com.sun.tools.javac.code.Kinds.KindSelector;
import com.sun.tools.javac.code.Scope.WriteableScope;
import com.sun.tools.javac.code.Source.Feature;
import com.sun.tools.javac.code.Symbol.*;
import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
import com.sun.tools.javac.comp.Check.CheckContext;
import com.sun.tools.javac.resources.CompilerProperties.Errors;
import com.sun.tools.javac.resources.CompilerProperties.Fragments;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.tree.JCTree.*;
import com.sun.tools.javac.tree.TreeInfo;
import com.sun.tools.javac.tree.TreeMaker;
import com.sun.tools.javac.tree.TreeScanner;
import com.sun.tools.javac.util.*;
import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
import com.sun.tools.javac.util.List;
import javax.tools.JavaFileObject;
import java.util.*;
import static com.sun.tools.javac.code.Flags.SYNTHETIC;
import static com.sun.tools.javac.code.Kinds.Kind.MDL;
import static com.sun.tools.javac.code.Kinds.Kind.MTH;
import static com.sun.tools.javac.code.Kinds.Kind.PCK;
import static com.sun.tools.javac.code.Kinds.Kind.TYP;
import static com.sun.tools.javac.code.Kinds.Kind.VAR;
import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
import static com.sun.tools.javac.code.TypeTag.ARRAY;
import static com.sun.tools.javac.code.TypeTag.CLASS;
import static com.sun.tools.javac.tree.JCTree.Tag.ANNOTATION;
import static com.sun.tools.javac.tree.JCTree.Tag.ASSIGN;
import static com.sun.tools.javac.tree.JCTree.Tag.IDENT;
import static com.sun.tools.javac.tree.JCTree.Tag.NEWARRAY;
import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
public class Annotate {
protected static final Context.Key<Annotate> annotateKey = new Context.Key<>();
public static Annotate instance(Context context) {
Annotate instance = context.get(annotateKey);
if (instance == null)
instance = new Annotate(context);
return instance;
}
private final Attr attr;
private final Check chk;
private final ConstFold cfolder;
private final DeferredLintHandler deferredLintHandler;
private final Enter enter;
private final Lint lint;
private final Log log;
private final Names names;
private final Resolve resolve;
private final TreeMaker make;
private final Symtab syms;
private final TypeEnvs typeEnvs;
private final Types types;
private final Attribute theUnfinishedDefaultValue;
private final boolean allowRepeatedAnnos;
private final String sourceName;
protected Annotate(Context context) {
context.put(annotateKey, this);
attr = Attr.instance(context);
chk = Check.instance(context);
cfolder = ConstFold.instance(context);
deferredLintHandler = DeferredLintHandler.instance(context);
enter = Enter.instance(context);
log = Log.instance(context);
lint = Lint.instance(context);
make = TreeMaker.instance(context);
names = Names.instance(context);
resolve = Resolve.instance(context);
syms = Symtab.instance(context);
typeEnvs = TypeEnvs.instance(context);
types = Types.instance(context);
theUnfinishedDefaultValue =  new Attribute.Error(syms.errType);
Source source = Source.instance(context);
allowRepeatedAnnos = Feature.REPEATED_ANNOTATIONS.allowedInSource(source);
sourceName = source.name;
blockCount = 1;
}
private int blockCount = 0;
public void blockAnnotations() {
blockCount++;
}
public void unblockAnnotations() {
blockCount--;
if (blockCount == 0)
flush();
}
public void unblockAnnotationsNoFlush() {
blockCount--;
}
public boolean annotationsBlocked() {return blockCount > 0; }
public void enterDone() {
unblockAnnotations();
}
public List<TypeCompound> fromAnnotations(List<JCAnnotation> annotations) {
if (annotations.isEmpty()) {
return List.nil();
}
ListBuffer<TypeCompound> buf = new ListBuffer<>();
for (JCAnnotation anno : annotations) {
Assert.checkNonNull(anno.attribute);
buf.append((TypeCompound) anno.attribute);
}
return buf.toList();
}
public void normal(Runnable r) {
q.append(r);
}
public void validate(Runnable a) {
validateQ.append(a);
}
public void flush() {
if (annotationsBlocked()) return;
if (isFlushing()) return;
startFlushing();
try {
while (q.nonEmpty()) {
q.next().run();
}
while (typesQ.nonEmpty()) {
typesQ.next().run();
}
while (afterTypesQ.nonEmpty()) {
afterTypesQ.next().run();
}
while (validateQ.nonEmpty()) {
validateQ.next().run();
}
} finally {
doneFlushing();
}
}
private ListBuffer<Runnable> q = new ListBuffer<>();
private ListBuffer<Runnable> validateQ = new ListBuffer<>();
private int flushCount = 0;
private boolean isFlushing() { return flushCount > 0; }
private void startFlushing() { flushCount++; }
private void doneFlushing() { flushCount--; }
ListBuffer<Runnable> typesQ = new ListBuffer<>();
ListBuffer<Runnable> afterTypesQ = new ListBuffer<>();
public void typeAnnotation(Runnable a) {
typesQ.append(a);
}
public void afterTypes(Runnable a) {
afterTypesQ.append(a);
}
public void annotateLater(List<JCAnnotation> annotations, Env<AttrContext> localEnv,
Symbol s, DiagnosticPosition deferPos)
{
if (annotations.isEmpty()) {
return;
}
s.resetAnnotations();
normal(() -> {
Assert.check(s.kind == PCK || s.annotationsPendingCompletion());
JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);
DiagnosticPosition prevLintPos =
deferPos != null
? deferredLintHandler.setPos(deferPos)
: deferredLintHandler.immediate();
Lint prevLint = deferPos != null ? null : chk.setLint(lint);
try {
if (s.hasAnnotations() && annotations.nonEmpty())
log.error(annotations.head.pos, Errors.AlreadyAnnotated(Kinds.kindName(s), s));
Assert.checkNonNull(s, "Symbol argument to actualEnterAnnotations is null");
annotateNow(s, annotations, localEnv, false, false);
} finally {
if (prevLint != null)
chk.setLint(prevLint);
deferredLintHandler.setPos(prevLintPos);
log.useSource(prev);
}
});
validate(() -> {             JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);
try {
chk.validateAnnotations(annotations, TreeInfo.declarationFor(s, localEnv.tree), s);
} finally {
log.useSource(prev);
}
});
}
public void annotateDefaultValueLater(JCExpression defaultValue, Env<AttrContext> localEnv,
MethodSymbol m, DiagnosticPosition deferPos)
{
normal(() -> {
JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);
DiagnosticPosition prevLintPos = deferredLintHandler.setPos(deferPos);
try {
enterDefaultValue(defaultValue, localEnv, m);
} finally {
deferredLintHandler.setPos(prevLintPos);
log.useSource(prev);
}
});
validate(() -> {             JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);
try {
chk.validateAnnotationTree(defaultValue);
} finally {
log.useSource(prev);
}
});
}
private void enterDefaultValue(JCExpression defaultValue,
Env<AttrContext> localEnv, MethodSymbol m) {
m.defaultValue = attributeAnnotationValue(m.type.getReturnType(), defaultValue, localEnv);
}
private <T extends Attribute.Compound> void annotateNow(Symbol toAnnotate,
List<JCAnnotation> withAnnotations, Env<AttrContext> env, boolean typeAnnotations,
boolean isTypeParam)
{
Map<TypeSymbol, ListBuffer<T>> annotated = new LinkedHashMap<>();
Map<T, DiagnosticPosition> pos = new HashMap<>();
for (List<JCAnnotation> al = withAnnotations; !al.isEmpty(); al = al.tail) {
JCAnnotation a = al.head;
T c;
if (typeAnnotations) {
@SuppressWarnings("unchecked")
T tmp = (T)attributeTypeAnnotation(a, syms.annotationType, env);
c = tmp;
} else {
@SuppressWarnings("unchecked")
T tmp = (T)attributeAnnotation(a, syms.annotationType, env);
c = tmp;
}
Assert.checkNonNull(c, "Failed to create annotation");
if (a.type.isErroneous() || a.type.tsym.isAnnotationType()) {
if (annotated.containsKey(a.type.tsym)) {
if (!allowRepeatedAnnos) {
log.error(DiagnosticFlag.SOURCE_LEVEL, a.pos(), Feature.REPEATED_ANNOTATIONS.error(sourceName));
}
ListBuffer<T> l = annotated.get(a.type.tsym);
l = l.append(c);
annotated.put(a.type.tsym, l);
pos.put(c, a.pos());
} else {
annotated.put(a.type.tsym, ListBuffer.of(c));
pos.put(c, a.pos());
}
}
if (!c.type.isErroneous()
&& (toAnnotate.kind == MDL || toAnnotate.owner.kind != MTH)
&& types.isSameType(c.type, syms.deprecatedType)) {
toAnnotate.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
if (isAttributeTrue(c.member(names.forRemoval))) {
toAnnotate.flags_field |= Flags.DEPRECATED_REMOVAL;
}
}
if (!c.type.isErroneous()
&& types.isSameType(c.type, syms.previewFeatureType)) {
toAnnotate.flags_field |= Flags.PREVIEW_API;
if (isAttributeTrue(c.member(names.reflective))) {
toAnnotate.flags_field |= Flags.PREVIEW_REFLECTIVE;
}
}
if (!c.type.isErroneous()
&& toAnnotate.kind == TYP
&& types.isSameType(c.type, syms.valueBasedType)) {
toAnnotate.flags_field |= Flags.VALUE_BASED;
}
}
List<T> buf = List.nil();
for (ListBuffer<T> lb : annotated.values()) {
if (lb.size() == 1) {
buf = buf.prepend(lb.first());
} else {
AnnotationContext<T> ctx = new AnnotationContext<>(env, annotated, pos, typeAnnotations);
T res = makeContainerAnnotation(lb.toList(), ctx, toAnnotate, isTypeParam);
if (res != null)
buf = buf.prepend(res);
}
}
if (typeAnnotations) {
@SuppressWarnings("unchecked")
List<TypeCompound> attrs = (List<TypeCompound>)buf.reverse();
toAnnotate.appendUniqueTypeAttributes(attrs);
} else {
@SuppressWarnings("unchecked")
List<Attribute.Compound> attrs =  (List<Attribute.Compound>)buf.reverse();
toAnnotate.resetAnnotations();
toAnnotate.setDeclarationAttributes(attrs);
}
}
private boolean isAttributeTrue(Attribute attr) {
return (attr instanceof Attribute.Constant constant)
&& constant.type == syms.booleanType
&& ((Integer) constant.value) != 0;
}
public Attribute.Compound attributeAnnotation(JCAnnotation tree, Type expectedAnnotationType,
Env<AttrContext> env)
{
if (tree.attribute != null && tree.type != null)
return tree.attribute;
List<Pair<MethodSymbol, Attribute>> elems = attributeAnnotationValues(tree, expectedAnnotationType, env);
Attribute.Compound ac = new Attribute.Compound(tree.type, elems);
return tree.attribute = ac;
}
public Attribute.TypeCompound attributeTypeAnnotation(JCAnnotation a, Type expectedAnnotationType,
Env<AttrContext> env)
{
if (a.attribute == null || a.type == null || !(a.attribute instanceof Attribute.TypeCompound typeCompound)) {
List<Pair<MethodSymbol,Attribute>> elems =
attributeAnnotationValues(a, expectedAnnotationType, env);
Attribute.TypeCompound tc =
new Attribute.TypeCompound(a.type, elems, TypeAnnotationPosition.unknown);
a.attribute = tc;
return tc;
} else {
return typeCompound;
}
}
private List<Pair<MethodSymbol, Attribute>> attributeAnnotationValues(JCAnnotation a,
Type expected, Env<AttrContext> env)
{
Type at = (a.annotationType.type != null ?
a.annotationType.type : attr.attribType(a.annotationType, env));
a.type = chk.checkType(a.annotationType.pos(), at, expected);
boolean isError = a.type.isErroneous();
if (!a.type.tsym.isAnnotationType() && !isError) {
log.error(a.annotationType.pos(), Errors.NotAnnotationType(a.type));
isError = true;
}
List<JCExpression> args = a.args;
boolean elidedValue = false;
if (args.length() == 1 && !args.head.hasTag(ASSIGN)) {
args.head = make.at(args.head.pos).
Assign(make.Ident(names.value), args.head);
elidedValue = true;
}
ListBuffer<Pair<MethodSymbol,Attribute>> buf = new ListBuffer<>();
for (List<JCExpression> tl = args; tl.nonEmpty(); tl = tl.tail) {
Pair<MethodSymbol, Attribute> p = attributeAnnotationNameValuePair(tl.head, a.type, isError, env, elidedValue);
if (p != null && !p.fst.type.isErroneous())
buf.append(p);
}
return buf.toList();
}
private Pair<MethodSymbol, Attribute> attributeAnnotationNameValuePair(JCExpression nameValuePair,
Type thisAnnotationType, boolean badAnnotation, Env<AttrContext> env, boolean elidedValue)
{
if (!nameValuePair.hasTag(ASSIGN)) {
log.error(nameValuePair.pos(), Errors.AnnotationValueMustBeNameValue);
attributeAnnotationValue(nameValuePair.type = syms.errType, nameValuePair, env);
return null;
}
JCAssign assign = (JCAssign)nameValuePair;
if (!assign.lhs.hasTag(IDENT)) {
log.error(nameValuePair.pos(), Errors.AnnotationValueMustBeNameValue);
attributeAnnotationValue(nameValuePair.type = syms.errType, nameValuePair, env);
return null;
}
JCIdent left = (JCIdent)assign.lhs;
Symbol method = resolve.resolveQualifiedMethod(elidedValue ? assign.rhs.pos() : left.pos(),
env, thisAnnotationType,
left.name, List.nil(), null);
left.sym = method;
left.type = method.type;
if (method.owner != thisAnnotationType.tsym && !badAnnotation)
log.error(left.pos(), Errors.NoAnnotationMember(left.name, thisAnnotationType));
Type resultType = method.type.getReturnType();
Attribute value = attributeAnnotationValue(resultType, assign.rhs, env);
nameValuePair.type = resultType;
return method.type.isErroneous() ? null : new Pair<>((MethodSymbol)method, value);
}
private Attribute attributeAnnotationValue(Type expectedElementType, JCExpression tree,
Env<AttrContext> env)
{
try {
expectedElementType.tsym.complete();
} catch(CompletionFailure e) {
log.error(tree.pos(), Errors.CantResolve(Kinds.kindName(e.sym), e.sym.getQualifiedName(), null, null));
expectedElementType = syms.errType;
}
if (expectedElementType.hasTag(ARRAY)) {
return getAnnotationArrayValue(expectedElementType, tree, env);
}
if (tree.hasTag(NEWARRAY)) {
if (!expectedElementType.isErroneous())
log.error(tree.pos(), Errors.AnnotationValueNotAllowableType);
JCNewArray na = (JCNewArray)tree;
if (na.elemtype != null) {
log.error(na.elemtype.pos(), Errors.NewNotAllowedInAnnotation);
}
for (List<JCExpression> l = na.elems; l.nonEmpty(); l=l.tail) {
attributeAnnotationValue(syms.errType,
l.head,
env);
}
return new Attribute.Error(syms.errType);
}
if (expectedElementType.tsym.isAnnotationType()) {
if (tree.hasTag(ANNOTATION)) {
return attributeAnnotation((JCAnnotation)tree, expectedElementType, env);
} else {
log.error(tree.pos(), Errors.AnnotationValueMustBeAnnotation);
expectedElementType = syms.errType;
}
}
if (tree.hasTag(ANNOTATION)) {
if (!expectedElementType.isErroneous())
log.error(tree.pos(), Errors.AnnotationNotValidForType(expectedElementType));
attributeAnnotation((JCAnnotation)tree, syms.errType, env);
return new Attribute.Error(((JCAnnotation)tree).annotationType.type);
}
MemberEnter.InitTreeVisitor initTreeVisitor = new MemberEnter.InitTreeVisitor() {
@Override
public void visitTypeIdent(JCPrimitiveTypeTree that) {}
@Override
public void visitTypeArray(JCArrayTypeTree that) {}
};
tree.accept(initTreeVisitor);
if (!initTreeVisitor.result) {
log.error(tree.pos(), Errors.ExpressionNotAllowableAsAnnotationValue);
return new Attribute.Error(syms.errType);
}
if (expectedElementType.isPrimitive() ||
(types.isSameType(expectedElementType, syms.stringType) && !expectedElementType.hasTag(TypeTag.ERROR))) {
return getAnnotationPrimitiveValue(expectedElementType, tree, env);
}
if (expectedElementType.tsym == syms.classType.tsym) {
return getAnnotationClassValue(expectedElementType, tree, env);
}
if (expectedElementType.hasTag(CLASS) &&
(expectedElementType.tsym.flags() & Flags.ENUM) != 0) {
return getAnnotationEnumValue(expectedElementType, tree, env);
}
if (!expectedElementType.isErroneous())
log.error(tree.pos(), Errors.AnnotationValueNotAllowableType);
return new Attribute.Error(attr.attribExpr(tree, env, expectedElementType));
}
private Attribute getAnnotationEnumValue(Type expectedElementType, JCExpression tree, Env<AttrContext> env) {
Type result = attr.attribTree(tree, env, annotationValueInfo(expectedElementType));
Symbol sym = TreeInfo.symbol(tree);
if (sym == null ||
TreeInfo.nonstaticSelect(tree) ||
sym.kind != VAR ||
(sym.flags() & Flags.ENUM) == 0) {
log.error(tree.pos(), Errors.EnumAnnotationMustBeEnumConstant);
return new Attribute.Error(result.getOriginalType());
}
VarSymbol enumerator = (VarSymbol) sym;
return new Attribute.Enum(expectedElementType, enumerator);
}
private Attribute getAnnotationClassValue(Type expectedElementType, JCExpression tree, Env<AttrContext> env) {
Type result = attr.attribTree(tree, env, annotationValueInfo(expectedElementType));
if (result.isErroneous()) {
if (TreeInfo.name(tree) == names._class &&
((JCFieldAccess) tree).selected.type.isErroneous()) {
Name n = (((JCFieldAccess) tree).selected).type.tsym.flatName();
return new Attribute.UnresolvedClass(expectedElementType,
types.createErrorType(n,
syms.unknownSymbol, syms.classType));
} else {
return new Attribute.Error(result.getOriginalType());
}
}
if (TreeInfo.name(tree) != names._class) {
log.error(tree.pos(), Errors.AnnotationValueMustBeClassLiteral);
return new Attribute.Error(syms.errType);
}
return new Attribute.Class(types,
(((JCFieldAccess) tree).selected).type);
}
private Attribute getAnnotationPrimitiveValue(Type expectedElementType, JCExpression tree, Env<AttrContext> env) {
Type result = attr.attribTree(tree, env, annotationValueInfo(expectedElementType));
if (result.isErroneous())
return new Attribute.Error(result.getOriginalType());
if (result.constValue() == null) {
log.error(tree.pos(), Errors.AttributeValueMustBeConstant);
return new Attribute.Error(expectedElementType);
}
if (tree.type != null && tree.type.tsym != null) {
queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym, tree.pos());
}
result = cfolder.coerce(result, expectedElementType);
return new Attribute.Constant(expectedElementType, result.constValue());
}
private Attr.ResultInfo annotationValueInfo(Type pt) {
return attr.unknownExprInfo.dup(pt, new AnnotationValueContext(attr.unknownExprInfo.checkContext));
}
class AnnotationValueContext extends Check.NestedCheckContext {
AnnotationValueContext(CheckContext enclosingContext) {
super(enclosingContext);
}
@Override
public boolean compatible(Type found, Type req, Warner warn) {
return found.hasTag(TypeTag.NONE) || super.compatible(found, req, warn);
}
}
private Attribute getAnnotationArrayValue(Type expectedElementType, JCExpression tree, Env<AttrContext> env) {
if (!tree.hasTag(NEWARRAY)) {
tree = make.at(tree.pos).
NewArray(null, List.nil(), List.of(tree));
}
JCNewArray na = (JCNewArray)tree;
if (na.elemtype != null) {
log.error(na.elemtype.pos(), Errors.NewNotAllowedInAnnotation);
}
ListBuffer<Attribute> buf = new ListBuffer<>();
for (List<JCExpression> l = na.elems; l.nonEmpty(); l=l.tail) {
buf.append(attributeAnnotationValue(types.elemtype(expectedElementType),
l.head,
env));
}
na.type = expectedElementType;
return new Attribute.
Array(expectedElementType, buf.toArray(new Attribute[buf.length()]));
}
private class AnnotationContext<T extends Attribute.Compound> {
public final Env<AttrContext> env;
public final Map<Symbol.TypeSymbol, ListBuffer<T>> annotated;
public final Map<T, JCDiagnostic.DiagnosticPosition> pos;
public final boolean isTypeCompound;
public AnnotationContext(Env<AttrContext> env,
Map<Symbol.TypeSymbol, ListBuffer<T>> annotated,
Map<T, JCDiagnostic.DiagnosticPosition> pos,
boolean isTypeCompound) {
Assert.checkNonNull(env);
Assert.checkNonNull(annotated);
Assert.checkNonNull(pos);
this.env = env;
this.annotated = annotated;
this.pos = pos;
this.isTypeCompound = isTypeCompound;
}
}
private <T extends Attribute.Compound> T processRepeatedAnnotations(List<T> annotations,
AnnotationContext<T> ctx, Symbol on, boolean isTypeParam)
{
T firstOccurrence = annotations.head;
List<Attribute> repeated = List.nil();
Type origAnnoType = null;
Type arrayOfOrigAnnoType = null;
Type targetContainerType = null;
MethodSymbol containerValueSymbol = null;
Assert.check(!annotations.isEmpty() && !annotations.tail.isEmpty());
int count = 0;
for (List<T> al = annotations; !al.isEmpty(); al = al.tail) {
count++;
Assert.check(count > 1 || !al.tail.isEmpty());
T currentAnno = al.head;
origAnnoType = currentAnno.type;
if (arrayOfOrigAnnoType == null) {
arrayOfOrigAnnoType = types.makeArrayType(origAnnoType);
}
boolean reportError = count > 1;
Type currentContainerType = getContainingType(currentAnno, ctx.pos.get(currentAnno), reportError);
if (currentContainerType == null) {
continue;
}
Assert.check(targetContainerType == null || currentContainerType == targetContainerType);
targetContainerType = currentContainerType;
containerValueSymbol = validateContainer(targetContainerType, origAnnoType, ctx.pos.get(currentAnno));
if (containerValueSymbol == null) {                                 continue;
}
repeated = repeated.prepend(currentAnno);
}
if (!repeated.isEmpty() && targetContainerType == null) {
log.error(ctx.pos.get(annotations.head), Errors.DuplicateAnnotationInvalidRepeated(origAnnoType));
return null;
}
if (!repeated.isEmpty()) {
repeated = repeated.reverse();
DiagnosticPosition pos = ctx.pos.get(firstOccurrence);
TreeMaker m = make.at(pos);
Pair<MethodSymbol, Attribute> p =
new Pair<MethodSymbol, Attribute>(containerValueSymbol,
new Attribute.Array(arrayOfOrigAnnoType, repeated));
if (ctx.isTypeCompound) {
Attribute.TypeCompound at = new Attribute.TypeCompound(targetContainerType, List.of(p),
((Attribute.TypeCompound)annotations.head).position);
JCAnnotation annoTree = m.TypeAnnotation(at);
if (!chk.validateAnnotationDeferErrors(annoTree))
log.error(annoTree.pos(), Errors.DuplicateAnnotationInvalidRepeated(origAnnoType));
if (!chk.isTypeAnnotation(annoTree, isTypeParam)) {
log.error(pos, isTypeParam ? Errors.InvalidRepeatableAnnotationNotApplicable(targetContainerType, on)
: Errors.InvalidRepeatableAnnotationNotApplicableInContext(targetContainerType));
}
at.setSynthesized(true);
@SuppressWarnings("unchecked")
T x = (T) at;
return x;
} else {
Attribute.Compound c = new Attribute.Compound(targetContainerType, List.of(p));
JCAnnotation annoTree = m.Annotation(c);
boolean isRecordMember = (on.flags_field & Flags.RECORD) != 0 || on.enclClass() != null && on.enclClass().isRecord();
if (!chk.annotationApplicable(annoTree, on) && (!isRecordMember || isRecordMember && (on.flags_field & Flags.GENERATED_MEMBER) == 0)) {
log.error(annoTree.pos(),
Errors.InvalidRepeatableAnnotationNotApplicable(targetContainerType, on));
}
if (!chk.validateAnnotationDeferErrors(annoTree))
log.error(annoTree.pos(), Errors.DuplicateAnnotationInvalidRepeated(origAnnoType));
c = attributeAnnotation(annoTree, targetContainerType, ctx.env);
c.setSynthesized(true);
@SuppressWarnings("unchecked")
T x = (T) c;
return x;
}
} else {
return null;         }
}
private Type getContainingType(Attribute.Compound currentAnno,
DiagnosticPosition pos,
boolean reportError)
{
Type origAnnoType = currentAnno.type;
TypeSymbol origAnnoDecl = origAnnoType.tsym;
Attribute.Compound ca = origAnnoDecl.getAnnotationTypeMetadata().getRepeatable();
if (ca == null) {             if (reportError)
log.error(pos, Errors.DuplicateAnnotationMissingContainer(origAnnoType));
return null;
}
return filterSame(extractContainingType(ca, pos, origAnnoDecl),
origAnnoType);
}
private Type filterSame(Type t, Type s) {
if (t == null || s == null) {
return t;
}
return types.isSameType(t, s) ? null : t;
}
private Type extractContainingType(Attribute.Compound ca,
DiagnosticPosition pos,
TypeSymbol annoDecl)
{
if (ca.values.isEmpty()) {
log.error(pos, Errors.InvalidRepeatableAnnotation(annoDecl));
return null;
}
Pair<MethodSymbol,Attribute> p = ca.values.head;
Name name = p.fst.name;
if (name != names.value) {             log.error(pos, Errors.InvalidRepeatableAnnotation(annoDecl));
return null;
}
if (!(p.snd instanceof Attribute.Class attributeClass)) {             log.error(pos, Errors.InvalidRepeatableAnnotation(annoDecl));
return null;
}
return attributeClass.getValue();
}
private MethodSymbol validateContainer(Type targetContainerType,
Type originalAnnoType,
DiagnosticPosition pos) {
MethodSymbol containerValueSymbol = null;
boolean fatalError = false;
Scope scope = targetContainerType.tsym.members();
int nr_value_elems = 0;
boolean error = false;
for(Symbol elm : scope.getSymbolsByName(names.value)) {
nr_value_elems++;
if (nr_value_elems == 1 &&
elm.kind == MTH) {
containerValueSymbol = (MethodSymbol)elm;
} else {
error = true;
}
}
if (error) {
log.error(pos,
Errors.InvalidRepeatableAnnotationMultipleValues(targetContainerType,
nr_value_elems));
return null;
} else if (nr_value_elems == 0) {
log.error(pos,
Errors.InvalidRepeatableAnnotationNoValue(targetContainerType));
return null;
}
if (containerValueSymbol.kind != MTH) {
log.error(pos,
Errors.InvalidRepeatableAnnotationInvalidValue(targetContainerType));
fatalError = true;
}
Type valueRetType = containerValueSymbol.type.getReturnType();
Type expectedType = types.makeArrayType(originalAnnoType);
if (!(types.isArray(valueRetType) &&
types.isSameType(expectedType, valueRetType))) {
log.error(pos,
Errors.InvalidRepeatableAnnotationValueReturn(targetContainerType,
valueRetType,
expectedType));
fatalError = true;
}
return fatalError ? null : containerValueSymbol;
}
private <T extends Attribute.Compound> T makeContainerAnnotation(List<T> toBeReplaced,
AnnotationContext<T> ctx, Symbol sym, boolean isTypeParam)
{
T validRepeated =
processRepeatedAnnotations(toBeReplaced, ctx, sym, isTypeParam);
if (validRepeated != null) {
ListBuffer<T> manualContainer = ctx.annotated.get(validRepeated.type.tsym);
if (manualContainer != null) {
log.error(ctx.pos.get(manualContainer.first()),
Errors.InvalidRepeatableAnnotationRepeatedAndContainerPresent(manualContainer.first().type.tsym));
}
}
return validRepeated;
}
public void enterTypeAnnotations(List<JCAnnotation> annotations, Env<AttrContext> env,
Symbol s, DiagnosticPosition deferPos, boolean isTypeParam)
{
Assert.checkNonNull(s, "Symbol argument to actualEnterTypeAnnotations is nul/");
JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
DiagnosticPosition prevLintPos = null;
if (deferPos != null) {
prevLintPos = deferredLintHandler.setPos(deferPos);
}
try {
annotateNow(s, annotations, env, true, isTypeParam);
} finally {
if (prevLintPos != null)
deferredLintHandler.setPos(prevLintPos);
log.useSource(prev);
}
}
public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym,
DiagnosticPosition deferPos)
{
Assert.checkNonNull(sym);
normal(() -> tree.accept(new TypeAnnotate(env, sym, deferPos)));
}
public void annotateTypeSecondStage(JCTree tree, List<JCAnnotation> annotations, Type storeAt) {
typeAnnotation(() -> {
List<Attribute.TypeCompound> compounds = fromAnnotations(annotations);
Assert.check(annotations.size() == compounds.size());
storeAt.getMetadataOfKind(Kind.ANNOTATIONS).combine(new TypeMetadata.Annotations(compounds));
});
}
public void annotateTypeParameterSecondStage(JCTree tree, List<JCAnnotation> annotations) {
typeAnnotation(() -> {
List<Attribute.TypeCompound> compounds = fromAnnotations(annotations);
Assert.check(annotations.size() == compounds.size());
});
}
private class TypeAnnotate extends TreeScanner {
private final Env<AttrContext> env;
private final Symbol sym;
private DiagnosticPosition deferPos;
public TypeAnnotate(Env<AttrContext> env, Symbol sym, DiagnosticPosition deferPos) {
this.env = env;
this.sym = sym;
this.deferPos = deferPos;
}
@Override
public void visitAnnotatedType(JCAnnotatedType tree) {
enterTypeAnnotations(tree.annotations, env, sym, deferPos, false);
scan(tree.underlyingType);
}
@Override
public void visitTypeParameter(JCTypeParameter tree) {
enterTypeAnnotations(tree.annotations, env, sym, deferPos, true);
scan(tree.bounds);
}
@Override
public void visitNewArray(JCNewArray tree) {
enterTypeAnnotations(tree.annotations, env, sym, deferPos, false);
for (List<JCAnnotation> dimAnnos : tree.dimAnnotations)
enterTypeAnnotations(dimAnnos, env, sym, deferPos, false);
scan(tree.elemtype);
scan(tree.elems);
}
@Override
public void visitMethodDef(JCMethodDecl tree) {
scan(tree.mods);
scan(tree.restype);
scan(tree.typarams);
scan(tree.recvparam);
scan(tree.params);
scan(tree.thrown);
scan(tree.defaultValue);
}
@Override
public void visitVarDef(JCVariableDecl tree) {
DiagnosticPosition prevPos = deferPos;
deferPos = tree.pos();
try {
if (sym != null && sym.kind == VAR) {
scan(tree.mods);
scan(tree.vartype);
}
scan(tree.init);
} finally {
deferPos = prevPos;
}
}
@Override
public void visitBindingPattern(JCTree.JCBindingPattern tree) {
}
@Override
public void visitClassDef(JCClassDecl tree) {
}
@Override
public void visitNewClass(JCNewClass tree) {
scan(tree.encl);
scan(tree.typeargs);
if (tree.def == null) {
scan(tree.clazz);
}
scan(tree.args);
}
}
private AnnotationTypeCompleter theSourceCompleter = new AnnotationTypeCompleter() {
@Override
public void complete(ClassSymbol sym) throws CompletionFailure {
Env<AttrContext> context = typeEnvs.get(sym);
Annotate.this.attributeAnnotationType(context);
}
};
public AnnotationTypeCompleter annotationTypeSourceCompleter() {
return theSourceCompleter;
}
private void attributeAnnotationType(Env<AttrContext> env) {
Assert.check(((JCClassDecl)env.tree).sym.isAnnotationType(),
"Trying to annotation type complete a non-annotation type");
JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
try {
JCClassDecl tree = (JCClassDecl)env.tree;
AnnotationTypeVisitor v = new AnnotationTypeVisitor(attr, chk, syms, typeEnvs);
v.scanAnnotationType(tree);
tree.sym.getAnnotationTypeMetadata().setRepeatable(v.repeatable);
tree.sym.getAnnotationTypeMetadata().setTarget(v.target);
} finally {
log.useSource(prev);
}
}
public Attribute unfinishedDefaultValue() {
return theUnfinishedDefaultValue;
}
public static interface AnnotationTypeCompleter {
void complete(ClassSymbol sym) throws CompletionFailure;
}
public class AnnotationTypeVisitor extends TreeScanner {
private Env<AttrContext> env;
private final Attr attr;
private final Check check;
private final Symtab tab;
private final TypeEnvs typeEnvs;
private Compound target;
private Compound repeatable;
public AnnotationTypeVisitor(Attr attr, Check check, Symtab tab, TypeEnvs typeEnvs) {
this.attr = attr;
this.check = check;
this.tab = tab;
this.typeEnvs = typeEnvs;
}
public Compound getRepeatable() {
return repeatable;
}
public Compound getTarget() {
return target;
}
public void scanAnnotationType(JCClassDecl decl) {
visitClassDef(decl);
}
@Override
public void visitClassDef(JCClassDecl tree) {
Env<AttrContext> prevEnv = env;
env = typeEnvs.get(tree.sym);
try {
scan(tree.mods);                             } finally {
env = prevEnv;
}
}
@Override
public void visitAnnotation(JCAnnotation tree) {
Type t = tree.annotationType.type;
if (t == null) {
t = attr.attribType(tree.annotationType, env);
tree.annotationType.type = t = check.checkType(tree.annotationType.pos(), t, tab.annotationType);
}
if (t == tab.annotationTargetType) {
target = Annotate.this.attributeAnnotation(tree, tab.annotationTargetType, env);
} else if (t == tab.repeatableType) {
repeatable = Annotate.this.attributeAnnotation(tree, tab.repeatableType, env);
}
}
}
public static class AnnotationTypeMetadata {
final ClassSymbol metaDataFor;
private Compound target;
private Compound repeatable;
private AnnotationTypeCompleter annotationTypeCompleter;
public AnnotationTypeMetadata(ClassSymbol metaDataFor, AnnotationTypeCompleter annotationTypeCompleter) {
this.metaDataFor = metaDataFor;
this.annotationTypeCompleter = annotationTypeCompleter;
}
private void init() {
while (!metaDataFor.isCompleted())
metaDataFor.complete();
if (annotationTypeCompleter != null) {
AnnotationTypeCompleter c = annotationTypeCompleter;
annotationTypeCompleter = null;
c.complete(metaDataFor);
}
}
public void complete() {
init();
}
public Compound getRepeatable() {
init();
return repeatable;
}
public void setRepeatable(Compound repeatable) {
Assert.checkNull(this.repeatable);
this.repeatable = repeatable;
}
public Compound getTarget() {
init();
return target;
}
public void setTarget(Compound target) {
Assert.checkNull(this.target);
this.target = target;
}
public Set<MethodSymbol> getAnnotationElements() {
init();
Set<MethodSymbol> members = new LinkedHashSet<>();
WriteableScope s = metaDataFor.members();
Iterable<Symbol> ss = s.getSymbols(NON_RECURSIVE);
for (Symbol sym : ss)
if (sym.kind == MTH &&
sym.name != sym.name.table.names.clinit &&
(sym.flags() & SYNTHETIC) == 0)
members.add((MethodSymbol)sym);
return members;
}
public Set<MethodSymbol> getAnnotationElementsWithDefault() {
init();
Set<MethodSymbol> members = getAnnotationElements();
Set<MethodSymbol> res = new LinkedHashSet<>();
for (MethodSymbol m : members)
if (m.defaultValue != null)
res.add(m);
return res;
}
@Override
public String toString() {
return "Annotation type for: " + metaDataFor;
}
public boolean isMetadataForAnnotationType() { return true; }
public static AnnotationTypeMetadata notAnAnnotationType() {
return NOT_AN_ANNOTATION_TYPE;
}
private static final AnnotationTypeMetadata NOT_AN_ANNOTATION_TYPE =
new AnnotationTypeMetadata(null, null) {
@Override
public void complete() {
}
@Override
public String toString() {
return "Not an annotation type";
}
@Override
public Set<MethodSymbol> getAnnotationElements() {
return new LinkedHashSet<>(0);
}
@Override
public Set<MethodSymbol> getAnnotationElementsWithDefault() {
return new LinkedHashSet<>(0);
}
@Override
public boolean isMetadataForAnnotationType() {
return false;
}
@Override
public Compound getTarget() {
return null;
}
@Override
public Compound getRepeatable() {
return null;
}
};
}
public void newRound() {
blockCount = 1;
}
public Queues setQueues(Queues nue) {
Queues stored = new Queues(q, validateQ, typesQ, afterTypesQ);
this.q = nue.q;
this.typesQ = nue.typesQ;
this.afterTypesQ = nue.afterTypesQ;
this.validateQ = nue.validateQ;
return stored;
}
static class Queues {
private final ListBuffer<Runnable> q;
private final ListBuffer<Runnable> validateQ;
private final ListBuffer<Runnable> typesQ;
private final ListBuffer<Runnable> afterTypesQ;
public Queues() {
this(new ListBuffer<Runnable>(), new ListBuffer<Runnable>(), new ListBuffer<Runnable>(), new ListBuffer<Runnable>());
}
public Queues(ListBuffer<Runnable> q, ListBuffer<Runnable> validateQ, ListBuffer<Runnable> typesQ, ListBuffer<Runnable> afterTypesQ) {
this.q = q;
this.validateQ = validateQ;
this.typesQ = typesQ;
this.afterTypesQ = afterTypesQ;
}
}
}
package java.lang.reflect;
public interface AnnotatedArrayType extends AnnotatedType {
AnnotatedType  getAnnotatedGenericComponentType();
@Override
AnnotatedType getAnnotatedOwnerType();
}
package javax.lang.model;
import java.lang.annotation.*;
import java.util.List;
import javax.lang.model.element.*;
import javax.lang.model.type.*;
public interface AnnotatedConstruct {
List<? extends AnnotationMirror> getAnnotationMirrors();
<A extends Annotation> A getAnnotation(Class<A> annotationType);
<A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType);
}
package java.lang.reflect;
import java.lang.annotation.Annotation;
import java.lang.annotation.AnnotationFormatError;
import java.lang.annotation.Repeatable;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Collectors;
import sun.reflect.annotation.AnnotationSupport;
import sun.reflect.annotation.AnnotationType;
public interface AnnotatedElement {
default boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {
return getAnnotation(annotationClass) != null;
}
<T extends Annotation> T getAnnotation(Class<T> annotationClass);
Annotation[] getAnnotations();
default <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass) {
T[] result = getDeclaredAnnotationsByType(annotationClass);
if (result.length == 0 &&              this instanceof Class &&              AnnotationType.getInstance(annotationClass).isInherited()) {              Class<?> superClass = ((Class<?>) this).getSuperclass();
if (superClass != null) {
result = superClass.getAnnotationsByType(annotationClass);
}
}
return result;
}
default <T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass) {
Objects.requireNonNull(annotationClass);
for (Annotation annotation : getDeclaredAnnotations()) {
if (annotationClass.equals(annotation.annotationType())) {
return annotationClass.cast(annotation);
}
}
return null;
}
default <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass) {
Objects.requireNonNull(annotationClass);
return AnnotationSupport.
getDirectlyAndIndirectlyPresent(Arrays.stream(getDeclaredAnnotations()).
collect(Collectors.toMap(Annotation::annotationType,
Function.identity(),
((first,second) -> first),
LinkedHashMap::new)),
annotationClass);
}
Annotation[] getDeclaredAnnotations();
}
package sun.jvm.hotspot.ui;
import java.math.*;
import java.awt.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.event.*;
import java.io.*;
import javax.swing.*;
import javax.swing.event.*;
import java.util.*;
import sun.jvm.hotspot.debugger.*;
import sun.jvm.hotspot.debugger.dummy.*;
import sun.jvm.hotspot.utilities.*;
public class AnnotatedMemoryPanel extends JPanel {
private boolean is64Bit;
private Debugger debugger;
private long    addressSize;
private HighPrecisionJScrollBar scrollBar;
private Font font;
private int bytesPerLine;
private int paintCount;
private String unmappedAddrString;
private IntervalTree annotations =
new IntervalTree(new Comparator<>() {
public int compare(Object o1, Object o2) {
Address a1 = (Address) o1;
Address a2 = (Address) o2;
if ((a1 == null) && (a2 == null)) {
return 0;
} else if (a1 == null) {
return -1;
} else if (a2 == null) {
return 1;
}
if (a1.equals(a2)) {
return 0;
} else if (a1.lessThan(a2)) {
return -1;
}
return 1;
}
});
private Address lastStartAddr;
private java.util.List<Annotation> visibleAnnotations;
private static Color[] colors = {
new Color(0.0f, 0.0f, 0.6f),     new Color(0.6f, 0.0f, 0.6f),     new Color(0.0f, 0.8f, 0.0f),     new Color(0.8f, 0.3f, 0.0f),     new Color(0.0f, 0.6f, 0.8f),     new Color(0.2f, 0.2f, 0.2f),   };
public AnnotatedMemoryPanel(Debugger debugger) {
this(debugger, false);
}
public AnnotatedMemoryPanel(Debugger debugger, boolean is64Bit, Address addrValue, Address addrLow, Address addrHigh) {
super();
init(debugger, is64Bit, addressToBigInt(addrValue), addressToBigInt(addrLow), addressToBigInt(addrHigh));
}
public AnnotatedMemoryPanel(Debugger debugger, boolean is64Bit ) {
super();
init(debugger, is64Bit, defaultMemoryLocation(is64Bit), defaultMemoryLow(is64Bit), defaultMemoryHigh(is64Bit));
}
static class AnnoX {
int     lineX;
Address highBound;
public AnnoX(int lineX, Address highBound) {
this.lineX = lineX;
this.highBound = highBound;
}
}
public synchronized void paintComponent(Graphics g) {
super.paintComponent(g);
g = g.create();
g.setFont(font);
g.setColor(Color.black);
Rectangle rect = new Rectangle();
getBounds(rect);
String firstAddressString = null;
int lineHeight;
int addrWidth;
{
Rectangle2D bounds = GraphicsUtilities.getStringBounds(unmappedAddrString, g);
lineHeight = (int) bounds.getHeight();
addrWidth  = (int) bounds.getWidth();
}
int addrX = (int) (0.25 * addrWidth);
int dataX = (int) (addrX + (1.5 * addrWidth));
int lineStartX = dataX + addrWidth + 5;
int annoStartX = (int) (lineStartX + (0.75 * addrWidth));
int numLines = rect.height / lineHeight;
BigInteger startVal  = scrollBar.getValueHP();
BigInteger perLine = new BigInteger(Integer.toString((int) addressSize));
BigInteger lineCount = new BigInteger(Integer.toString((int) (numLines - 1)));
BigInteger maxLines = scrollBar.getMaximumHP().subtract(scrollBar.getMinimumHP()).divide(perLine);
if (lineCount.compareTo(maxLines) > 0) {
lineCount = maxLines;
}
BigInteger offsetVal = lineCount.multiply(perLine);
BigInteger endVal    = startVal.add(offsetVal);
if (endVal.compareTo(scrollBar.getMaximumHP()) > 0) {
startVal = scrollBar.getMaximumHP().subtract(offsetVal);
endVal   = scrollBar.getMaximumHP();
scrollBar.setValueHP(startVal);
}
scrollBar.setVisibleAmountHP(offsetVal.add(perLine));
scrollBar.setBlockIncrementHP(offsetVal);
Address startAddr = bigIntToAddress(startVal);
Address endAddr   = bigIntToAddress(endVal);
int scrollOffset = 0;
if (lastStartAddr != null) {
scrollOffset = (int) lastStartAddr.minus(startAddr);
} else {
if (startAddr != null) {
scrollOffset = (int) (-1 * startAddr.minus(lastStartAddr));
}
}
scrollOffset = scrollOffset * lineHeight / (int) addressSize;
scrollAnnotations(scrollOffset);
lastStartAddr = startAddr;
int curY = lineHeight;
Address curAddr = startAddr;
for (int i = 0; i < numLines; i++) {
String s = bigIntToHexString(startVal);
g.drawString(s, addrX, curY);
try {
s = addressToString(startAddr.getAddressAt(i * addressSize));
}
catch (UnmappedAddressException e) {
s = unmappedAddrString;
}
g.drawString(s, dataX, curY);
curY += lineHeight;
startVal = startVal.add(perLine);
}
java.util.List<IntervalNode> va =
annotations.findAllNodesIntersecting(new Interval(startAddr.addOffsetTo(-addressSize),
endAddr.addOffsetTo(2 * addressSize)));
int curLineX = lineStartX;
int curTextX = annoStartX;
int curColorIdx = 0;
if (g instanceof Graphics2D) {
Stroke stroke = new BasicStroke(3.0f);
((Graphics2D) g).setStroke(stroke);
}
ArrayDeque<AnnoX> drawStack = new ArrayDeque<>();
layoutAnnotations(va, g, curTextX, startAddr, lineHeight);
for (Iterator<Annotation> iter = visibleAnnotations.iterator(); iter.hasNext(); ) {
Annotation anno   = iter.next();
Interval interval = anno.getInterval();
if (!drawStack.isEmpty()) {
boolean shouldContinue = true;
do {
AnnoX annoX = (AnnoX) drawStack.peek();
if (annoX.highBound.lessThanOrEqual((Address) interval.getLowEndpoint())) {
curLineX = annoX.lineX;
drawStack.pop();
shouldContinue = !drawStack.isEmpty();
} else {
shouldContinue = false;
}
} while (shouldContinue);
}
Address lineStartAddr = (Address) interval.getLowEndpoint();
int lineStartY = (int) (lineStartAddr.minus(startAddr) * lineHeight / addressSize) +
(lineHeight / 3);
Address lineEndAddr = (Address) interval.getHighEndpoint();
drawStack.push(new AnnoX(curLineX, lineEndAddr));
int lineEndY = (int) (lineEndAddr.minus(startAddr) * lineHeight / addressSize);
g.setColor(anno.getColor());
g.drawLine(curLineX, lineStartY, curLineX, lineEndY);
g.drawLine(curLineX, lineStartY, curTextX - 10, anno.getY() - (lineHeight / 2));
curLineX += 8;
anno.draw(g);
++curColorIdx;
}
}
public synchronized void addAnnotation(Annotation annotation) {
annotations.insert(annotation.getInterval(), annotation);
}
public synchronized void makeVisible(Address addr) {
BigInteger bi = addressToBigInt(addr);
scrollBar.setValueHP(bi);
}
public void print() {
printOn(System.out);
}
public void printOn(PrintStream tty) {
annotations.printOn(tty);
}
private void init(Debugger debugger, boolean is64Bit, BigInteger addrValue, BigInteger addrLow, BigInteger addrHigh) {
this.is64Bit = is64Bit;
this.debugger = debugger;
if (is64Bit) {
addressSize = 8;
unmappedAddrString = "??????????????????";
} else {
addressSize = 4;
unmappedAddrString = "??????????";
}
setLayout(new BorderLayout());
setupScrollBar(addrValue, addrLow, addrHigh);
add(scrollBar, BorderLayout.EAST);
visibleAnnotations = new ArrayList<>();
setBackground(Color.white);
addHierarchyBoundsListener(new HierarchyBoundsListener() {
public void ancestorMoved(HierarchyEvent e) {
}
public void ancestorResized(HierarchyEvent e) {
}
});
if (font == null) {
font = GraphicsUtilities.getMonospacedFont();
}
if (font == null) {
throw new RuntimeException("Error looking up monospace font Courier");
}
getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_PAGE_DOWN, 0), "PageDown");
getActionMap().put("PageDown", new AbstractAction() {
public void actionPerformed(ActionEvent e) {
scrollBar.setValueHP(scrollBar.getValueHP().add(scrollBar.getBlockIncrementHP()));
}
});
getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_PAGE_UP, 0), "PageUp");
getActionMap().put("PageUp", new AbstractAction() {
public void actionPerformed(ActionEvent e) {
scrollBar.setValueHP(scrollBar.getValueHP().subtract(scrollBar.getBlockIncrementHP()));
}
});
getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), "Down");
getActionMap().put("Down", new AbstractAction() {
public void actionPerformed(ActionEvent e) {
scrollBar.setValueHP(scrollBar.getValueHP().add(scrollBar.getUnitIncrementHP()));
}
});
getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0), "Up");
getActionMap().put("Up", new AbstractAction() {
public void actionPerformed(ActionEvent e) {
scrollBar.setValueHP(scrollBar.getValueHP().subtract(scrollBar.getUnitIncrementHP()));
}
});
setEnabled(true);
}
private void setupScrollBar(BigInteger value, BigInteger min, BigInteger max) {
scrollBar = new HighPrecisionJScrollBar( Scrollbar.VERTICAL, value, min, max);
if (is64Bit) {
bytesPerLine = 8;
scrollBar.setUnitIncrementHP(new BigInteger(1, new byte[] {
(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x08}));
scrollBar.setBlockIncrementHP(new BigInteger(1, new byte[] {
(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x40}));
} else {
bytesPerLine = 4;
scrollBar.setUnitIncrementHP(new BigInteger(1, new byte[] {
(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04}));
scrollBar.setBlockIncrementHP(new BigInteger(1, new byte[] {
(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x20}));
}
scrollBar.addChangeListener(new ChangeListener() {
public void stateChanged(ChangeEvent e) {
HighPrecisionJScrollBar h = (HighPrecisionJScrollBar) e.getSource();
repaint();
}
});
}
private static BigInteger defaultMemoryLocation(boolean is64Bit) {
if (is64Bit) {
return new BigInteger(1, new byte[] {
(byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00,
(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00});
} else {
return new BigInteger(1, new byte[] { (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00});
}
}
private static BigInteger defaultMemoryLow(boolean is64Bit) {
if (is64Bit) {
return new BigInteger(1, new byte[] {
(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00});
} else {
return new BigInteger(1, new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00});
}
}
private static BigInteger defaultMemoryHigh(boolean is64Bit) {
if (is64Bit) {
return new BigInteger(1, new byte[] {
(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,
(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFC});
} else {
return new BigInteger(1, new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFC});
}
}
private void setupScrollBar() {
setupScrollBar(defaultMemoryLocation(is64Bit),
defaultMemoryLow(is64Bit),
defaultMemoryHigh(is64Bit));
}
private String bigIntToHexString(BigInteger bi) {
StringBuilder buf = new StringBuilder();
buf.append("0x");
String val = bi.toString(16);
for (int i = 0; i < ((2 * addressSize) - val.length()); i++) {
buf.append('0');
}
buf.append(val);
return buf.toString();
}
private Address bigIntToAddress(BigInteger i) {
String s = bigIntToHexString(i);
return debugger.parseAddress(s);
}
private BigInteger addressToBigInt(Address a) {
String s = addressToString(a);
if (!s.startsWith("0x")) {
throw new NumberFormatException(s);
}
return new BigInteger(s.substring(2), 16);
}
private String addressToString(Address a) {
if (a == null) {
if (is64Bit) {
return "0x0000000000000000";
} else {
return "0x00000000";
}
}
return a.toString();
}
private void scrollAnnotations(int y) {
for (Iterator<Annotation> iter = visibleAnnotations.iterator(); iter.hasNext(); ) {
Annotation anno = iter.next();
anno.setY(anno.getY() + y);
}
}
private void layoutAnnotations(java.util.List<IntervalNode> va,
Graphics g,
int x,
Address startAddr,
int lineHeight) {
if (va.size() == 0) {
visibleAnnotations.clear();
return;
}
int deferredIndex = -1;
Annotation constraintAnnotation = null;
Annotation firstConstraintAnnotation = null;
int searchIndex = 0;
java.util.List<Annotation> newAnnos = new ArrayList<>();
for (Iterator<IntervalNode> iter = va.iterator(); iter.hasNext(); ) {
Annotation anno = (Annotation) ((IntervalNode) iter.next()).getData();
boolean found = false;
for (int i = searchIndex; i < visibleAnnotations.size(); i++) {
Annotation el = visibleAnnotations.get(i);
if (el.getLowAddress().greaterThan(anno.getLowAddress())) {
break;
}
if (el == anno) {
found = true;
searchIndex = i;
constraintAnnotation = anno;
if (firstConstraintAnnotation == null) {
firstConstraintAnnotation = constraintAnnotation;
}
break;
}
}
if (!found) {
if (constraintAnnotation != null) {
layoutAfter(anno, constraintAnnotation, g, x, startAddr, lineHeight);
constraintAnnotation = anno;
} else {
++deferredIndex;
}
}
newAnnos.add(anno);
}
if (firstConstraintAnnotation != null) {
for (int i = deferredIndex; i >= 0; i--) {
Annotation anno = (Annotation) newAnnos.get(i);
layoutBefore(anno, firstConstraintAnnotation, g, x, startAddr, lineHeight);
firstConstraintAnnotation = anno;
}
} else {
if (Assert.ASSERTS_ENABLED) {
Assert.that(constraintAnnotation == null, "logic error in layout code");
}
for (Iterator iter = newAnnos.iterator(); iter.hasNext(); ) {
Annotation anno = (Annotation) iter.next();
layoutAfter(anno, constraintAnnotation, g, x, startAddr, lineHeight);
constraintAnnotation = anno;
}
}
visibleAnnotations = newAnnos;
}
private void layoutBefore(Annotation anno, Annotation constraintAnno,
Graphics g, int x,
Address startAddr, int lineHeight) {
anno.computeWidthAndHeight(g);
if (constraintAnno != null) {
anno.setColor(prevColor(constraintAnno.getColor()));
} else {
anno.setColor(colors[0]);
}
anno.setX(x);
anno.setY((int) (((Address) anno.getInterval().getLowEndpoint()).minus(startAddr) * lineHeight / addressSize) +
(5 * lineHeight / 6));
if ((constraintAnno != null) && (anno.getY() + anno.getHeight() > constraintAnno.getY())) {
anno.setY(constraintAnno.getY() - anno.getHeight());
}
}
private void layoutAfter(Annotation anno, Annotation constraintAnno,
Graphics g, int x,
Address startAddr, int lineHeight) {
anno.computeWidthAndHeight(g);
if (constraintAnno != null) {
anno.setColor(nextColor(constraintAnno.getColor()));
} else {
anno.setColor(colors[0]);
}
anno.setX(x);
anno.setY((int) (((Address) anno.getInterval().getLowEndpoint()).minus(startAddr) * lineHeight / addressSize) +
(5 * lineHeight / 6));
if ((constraintAnno != null) && (anno.getY() < (constraintAnno.getY() + constraintAnno.getHeight()))) {
anno.setY(constraintAnno.getY() + constraintAnno.getHeight());
}
}
private Color prevColor(Color c) {
int i = findColorIndex(c);
if (i == 0) {
return colors[colors.length - 1];
} else {
return colors[i - 1];
}
}
private Color nextColor(Color c) {
return colors[(findColorIndex(c) + 1) % colors.length];
}
private int findColorIndex(Color c) {
for (int i = 0; i < colors.length; i++) {
if (colors[i] == c) {
return i;
}
}
throw new IllegalArgumentException();
}
public static void main(String[] args) {
JFrame frame = new JFrame();
DummyDebugger debugger = new DummyDebugger(new MachineDescriptionIntelX86());
AnnotatedMemoryPanel anno = new AnnotatedMemoryPanel(debugger);
frame.getContentPane().add(anno);
anno.addAnnotation(new Annotation(debugger.parseAddress("0x80000000"),
debugger.parseAddress("0x80000040"),
"Stack Frame for \"foo\""));
anno.addAnnotation(new Annotation(debugger.parseAddress("0x80000010"),
debugger.parseAddress("0x80000020"),
"Locals for \"foo\""));
anno.addAnnotation(new Annotation(debugger.parseAddress("0x80000020"),
debugger.parseAddress("0x80000030"),
"Expression stack for \"foo\""));
frame.setSize(400, 300);
frame.addWindowListener(new WindowAdapter() {
public void windowClosed(WindowEvent e) {
System.exit(0);
}
public void windowClosing(WindowEvent e) {
System.exit(0);
}
});
frame.setVisible(true);
}
}
package java.lang.reflect;
public interface AnnotatedParameterizedType extends AnnotatedType {
AnnotatedType[] getAnnotatedActualTypeArguments();
@Override
AnnotatedType getAnnotatedOwnerType();
}
package java.lang.reflect;
import java.lang.annotation.Annotation;
public interface AnnotatedType extends AnnotatedElement {
default AnnotatedType getAnnotatedOwnerType() {
return null;
}
public Type getType();
@Override
<T extends Annotation> T getAnnotation(Class<T> annotationClass);
@Override
Annotation[] getAnnotations();
@Override
Annotation[] getDeclaredAnnotations();
}
package sun.reflect.annotation;
import java.lang.annotation.*;
import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import static sun.reflect.annotation.TypeAnnotation.*;
public final class AnnotatedTypeFactory {
public static AnnotatedType buildAnnotatedType(Type type,
LocationInfo currentLoc,
TypeAnnotation[] actualTypeAnnos,
TypeAnnotation[] allOnSameTarget,
AnnotatedElement decl) {
if (type == null) {
return EMPTY_ANNOTATED_TYPE;
}
if (isArray(type))
return new AnnotatedArrayTypeImpl(type,
currentLoc,
actualTypeAnnos,
allOnSameTarget,
decl);
if (type instanceof Class) {
return new AnnotatedTypeBaseImpl(type,
currentLoc,
actualTypeAnnos,
allOnSameTarget,
decl);
} else if (type instanceof TypeVariable<?> typeVariable) {
return new AnnotatedTypeVariableImpl(typeVariable,
currentLoc,
actualTypeAnnos,
allOnSameTarget,
decl);
} else if (type instanceof ParameterizedType paramType) {
return new AnnotatedParameterizedTypeImpl(paramType,
currentLoc,
actualTypeAnnos,
allOnSameTarget,
decl);
} else if (type instanceof WildcardType wildType) {
return new AnnotatedWildcardTypeImpl(wildType,
currentLoc,
actualTypeAnnos,
allOnSameTarget,
decl);
}
throw new AssertionError("Unknown instance of Type: " + type + "\nThis should not happen.");
}
public static LocationInfo nestingForType(Type type, LocationInfo addTo) {
if (isArray(type))
return addTo;
if (type instanceof Class<?> clz) {
if (clz.getEnclosingClass() == null)
return addTo;
if (Modifier.isStatic(clz.getModifiers()))
return addTo;
return nestingForType(clz.getEnclosingClass(), addTo.pushInner());
} else if (type instanceof ParameterizedType t) {
if (t.getOwnerType() == null)
return addTo;
if (t.getRawType() instanceof Class
&& Modifier.isStatic(((Class) t.getRawType()).getModifiers()))
return addTo;
return nestingForType(t.getOwnerType(), addTo.pushInner());
}
return addTo;
}
private static boolean isArray(Type t) {
if (t instanceof Class<?> c) {
if (c.isArray())
return true;
} else if (t instanceof GenericArrayType) {
return true;
}
return false;
}
static final TypeAnnotation[] EMPTY_TYPE_ANNOTATION_ARRAY = new TypeAnnotation[0];
static final AnnotatedType EMPTY_ANNOTATED_TYPE = new AnnotatedTypeBaseImpl(null, LocationInfo.BASE_LOCATION,
EMPTY_TYPE_ANNOTATION_ARRAY, EMPTY_TYPE_ANNOTATION_ARRAY, null);
static final AnnotatedType[] EMPTY_ANNOTATED_TYPE_ARRAY = new AnnotatedType[0];
private static class AnnotatedTypeBaseImpl implements AnnotatedType {
private final Type type;
private final AnnotatedElement decl;
private final LocationInfo location;
private final TypeAnnotation[] allOnSameTargetTypeAnnotations;
private final Map<Class <? extends Annotation>, Annotation> annotations;
AnnotatedTypeBaseImpl(Type type, LocationInfo location,
TypeAnnotation[] actualTypeAnnotations, TypeAnnotation[] allOnSameTargetTypeAnnotations,
AnnotatedElement decl) {
this.type = type;
this.decl = decl;
this.location = location;
this.allOnSameTargetTypeAnnotations = allOnSameTargetTypeAnnotations;
this.annotations = TypeAnnotationParser.mapTypeAnnotations(location.filter(actualTypeAnnotations));
}
@Override
public final Annotation[] getAnnotations() {
return getDeclaredAnnotations();
}
@Override
public final <T extends Annotation> T getAnnotation(Class<T> annotation) {
return getDeclaredAnnotation(annotation);
}
@Override
public final <T extends Annotation> T[] getAnnotationsByType(Class<T> annotation) {
return getDeclaredAnnotationsByType(annotation);
}
@Override
public final Annotation[] getDeclaredAnnotations() {
return annotations.values().toArray(new Annotation[0]);
}
@Override
@SuppressWarnings("unchecked")
public final <T extends Annotation> T getDeclaredAnnotation(Class<T> annotation) {
return (T)annotations.get(annotation);
}
@Override
public final <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotation) {
return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotations, annotation);
}
@Override
public final Type getType() {
return type;
}
@Override
public AnnotatedType getAnnotatedOwnerType() {
if (!(type instanceof Class<?>))
throw new IllegalStateException("Can't compute owner");
Class<?> nested = (Class<?>)type;
Class<?> owner = nested.getDeclaringClass();
if (owner == null)                 return null;
if (nested.isPrimitive() || nested == Void.TYPE)
return null;
LocationInfo outerLoc = getLocation().popLocation((byte)1);
if (outerLoc == null) {
return buildAnnotatedType(owner, LocationInfo.BASE_LOCATION,
EMPTY_TYPE_ANNOTATION_ARRAY, EMPTY_TYPE_ANNOTATION_ARRAY, getDecl());
}
TypeAnnotation[]all = getTypeAnnotations();
List<TypeAnnotation> l = new ArrayList<>(all.length);
for (TypeAnnotation t : all)
if (t.getLocationInfo().isSameLocationInfo(outerLoc))
l.add(t);
return buildAnnotatedType(owner, outerLoc, l.toArray(EMPTY_TYPE_ANNOTATION_ARRAY), all, getDecl());
}
@Override         public String toString() {
return annotationsToString(getAnnotations(), false) +
((type instanceof Class) ? type.getTypeName(): type.toString());
}
protected String annotationsToString(Annotation[] annotations, boolean leadingSpace) {
if (annotations != null && annotations.length > 0) {
StringBuilder sb = new StringBuilder();
sb.append(Stream.of(annotations).
map(Annotation::toString).
collect(Collectors.joining(" ")));
if (leadingSpace)
sb.insert(0, " ");
else
sb.append(" ");
return sb.toString();
} else {
return "";
}
}
protected boolean equalsTypeAndAnnotations(AnnotatedType that) {
return getType().equals(that.getType()) &&
Arrays.equals(getAnnotations(), that.getAnnotations()) &&
Objects.equals(getAnnotatedOwnerType(), that.getAnnotatedOwnerType());
}
int baseHashCode() {
return type.hashCode() ^
Objects.hash((Object[])getAnnotations()) ^
Objects.hash(getAnnotatedOwnerType());
}
@Override
public boolean equals(Object o) {
if (o instanceof AnnotatedType &&
!(o instanceof AnnotatedArrayType) &&
!(o instanceof AnnotatedTypeVariable) &&
!(o instanceof AnnotatedParameterizedType) &&
!(o instanceof AnnotatedWildcardType)) {
AnnotatedType that = (AnnotatedType) o;
return equalsTypeAndAnnotations(that);
} else {
return false;
}
}
@Override
public int hashCode() {
return baseHashCode();
}
final LocationInfo getLocation() {
return location;
}
final TypeAnnotation[] getTypeAnnotations() {
return allOnSameTargetTypeAnnotations;
}
final AnnotatedElement getDecl() {
return decl;
}
}
private static final class AnnotatedArrayTypeImpl extends AnnotatedTypeBaseImpl implements AnnotatedArrayType {
AnnotatedArrayTypeImpl(Type type, LocationInfo location,
TypeAnnotation[] actualTypeAnnotations, TypeAnnotation[] allOnSameTargetTypeAnnotations,
AnnotatedElement decl) {
super(type, location, actualTypeAnnotations, allOnSameTargetTypeAnnotations, decl);
}
@Override
public AnnotatedType getAnnotatedGenericComponentType() {
Type t = getComponentType();
return AnnotatedTypeFactory.buildAnnotatedType(t,
nestingForType(t, getLocation().pushArray()),
getTypeAnnotations(),
getTypeAnnotations(),
getDecl());
}
@Override
public AnnotatedType getAnnotatedOwnerType() {
return null;
}
private Type getComponentType() {
Type t = getType();
if (t instanceof Class<?> c) {
return c.getComponentType();
}
return ((GenericArrayType)t).getGenericComponentType();
}
@Override
public String toString() {
StringBuilder sb = new StringBuilder();
AnnotatedType componentType = this;
while (componentType instanceof AnnotatedArrayType annotatedArrayType) {
sb.append(annotationsToString(annotatedArrayType.getAnnotations(), true) + "[]");
componentType = annotatedArrayType.getAnnotatedGenericComponentType();
}
sb.insert(0, componentType.toString());
return sb.toString();
}
@Override
public boolean equals(Object o) {
if (o instanceof AnnotatedArrayType that) {
return equalsTypeAndAnnotations(that) &&
Objects.equals(getAnnotatedGenericComponentType(),
that.getAnnotatedGenericComponentType());
} else {
return false;
}
}
@Override
public int hashCode() {
return baseHashCode() ^ getAnnotatedGenericComponentType().hashCode();
}
}
private static final class AnnotatedTypeVariableImpl extends AnnotatedTypeBaseImpl implements AnnotatedTypeVariable {
AnnotatedTypeVariableImpl(TypeVariable<?> type, LocationInfo location,
TypeAnnotation[] actualTypeAnnotations, TypeAnnotation[] allOnSameTargetTypeAnnotations,
AnnotatedElement decl) {
super(type, location, actualTypeAnnotations, allOnSameTargetTypeAnnotations, decl);
}
@Override
public AnnotatedType[] getAnnotatedBounds() {
return getTypeVariable().getAnnotatedBounds();
}
@Override
public AnnotatedType getAnnotatedOwnerType() {
return null;
}
private TypeVariable<?> getTypeVariable() {
return (TypeVariable)getType();
}
@Override
public boolean equals(Object o) {
if (o instanceof AnnotatedTypeVariable that) {
return equalsTypeAndAnnotations(that);
} else {
return false;
}
}
}
private static final class AnnotatedParameterizedTypeImpl extends AnnotatedTypeBaseImpl
implements AnnotatedParameterizedType {
AnnotatedParameterizedTypeImpl(ParameterizedType type, LocationInfo location,
TypeAnnotation[] actualTypeAnnotations, TypeAnnotation[] allOnSameTargetTypeAnnotations,
AnnotatedElement decl) {
super(type, location, actualTypeAnnotations, allOnSameTargetTypeAnnotations, decl);
}
@Override
public AnnotatedType[] getAnnotatedActualTypeArguments() {
Type[] arguments = getParameterizedType().getActualTypeArguments();
AnnotatedType[] res = new AnnotatedType[arguments.length];
Arrays.fill(res, EMPTY_ANNOTATED_TYPE);
int initialCapacity = getTypeAnnotations().length;
for (int i = 0; i < res.length; i++) {
List<TypeAnnotation> l = new ArrayList<>(initialCapacity);
LocationInfo newLoc = nestingForType(arguments[i], getLocation().pushTypeArg((byte)i));
for (TypeAnnotation t : getTypeAnnotations())
if (t.getLocationInfo().isSameLocationInfo(newLoc))
l.add(t);
res[i] = buildAnnotatedType(arguments[i],
newLoc,
l.toArray(EMPTY_TYPE_ANNOTATION_ARRAY),
getTypeAnnotations(),
getDecl());
}
return res;
}
@Override
public AnnotatedType getAnnotatedOwnerType() {
Type owner = getParameterizedType().getOwnerType();
if (owner == null)
return null;
LocationInfo outerLoc = getLocation().popLocation((byte)1);
if (outerLoc == null) {
return buildAnnotatedType(owner, LocationInfo.BASE_LOCATION,
EMPTY_TYPE_ANNOTATION_ARRAY, EMPTY_TYPE_ANNOTATION_ARRAY, getDecl());
}
TypeAnnotation[]all = getTypeAnnotations();
List<TypeAnnotation> l = new ArrayList<>(all.length);
for (TypeAnnotation t : all)
if (t.getLocationInfo().isSameLocationInfo(outerLoc))
l.add(t);
return buildAnnotatedType(owner, outerLoc, l.toArray(EMPTY_TYPE_ANNOTATION_ARRAY), all, getDecl());
}
private ParameterizedType getParameterizedType() {
return (ParameterizedType)getType();
}
@Override
public String toString() {
StringBuilder sb = new StringBuilder();
sb.append(annotationsToString(getAnnotations(), false));
Type t = getParameterizedType().getRawType();
sb.append(t.getTypeName());
AnnotatedType[] typeArgs = getAnnotatedActualTypeArguments();
if (typeArgs.length > 0) {
sb.append(Stream.of(typeArgs).map(AnnotatedType::toString).
collect(Collectors.joining(", ", "<", ">")));
}
return sb.toString();
}
@Override
public boolean equals(Object o) {
if (o instanceof AnnotatedParameterizedType that) {
return equalsTypeAndAnnotations(that) &&
Arrays.equals(getAnnotatedActualTypeArguments(), that.getAnnotatedActualTypeArguments());
} else {
return false;
}
}
@Override
public int hashCode() {
return baseHashCode() ^
Objects.hash((Object[])getAnnotatedActualTypeArguments());
}
}
private static final class AnnotatedWildcardTypeImpl extends AnnotatedTypeBaseImpl implements AnnotatedWildcardType {
private final boolean hasUpperBounds;
AnnotatedWildcardTypeImpl(WildcardType type, LocationInfo location,
TypeAnnotation[] actualTypeAnnotations, TypeAnnotation[] allOnSameTargetTypeAnnotations,
AnnotatedElement decl) {
super(type, location, actualTypeAnnotations, allOnSameTargetTypeAnnotations, decl);
hasUpperBounds = (type.getLowerBounds().length == 0);
}
@Override
public AnnotatedType[] getAnnotatedUpperBounds() {
if (!hasUpperBounds()) {
return new AnnotatedType[] { buildAnnotatedType(Object.class,
LocationInfo.BASE_LOCATION,
EMPTY_TYPE_ANNOTATION_ARRAY,
EMPTY_TYPE_ANNOTATION_ARRAY,
null)
};
}
return getAnnotatedBounds(getWildcardType().getUpperBounds());
}
@Override
public AnnotatedType[] getAnnotatedLowerBounds() {
if (hasUpperBounds)
return new AnnotatedType[0];
return getAnnotatedBounds(getWildcardType().getLowerBounds());
}
@Override
public AnnotatedType getAnnotatedOwnerType() {
return null;
}
private AnnotatedType[] getAnnotatedBounds(Type[] bounds) {
AnnotatedType[] res = new AnnotatedType[bounds.length];
Arrays.fill(res, EMPTY_ANNOTATED_TYPE);
int initialCapacity = getTypeAnnotations().length;
for (int i = 0; i < res.length; i++) {
LocationInfo newLoc = nestingForType(bounds[i], getLocation().pushWildcard());
List<TypeAnnotation> l = new ArrayList<>(initialCapacity);
for (TypeAnnotation t : getTypeAnnotations())
if (t.getLocationInfo().isSameLocationInfo(newLoc))
l.add(t);
res[i] = buildAnnotatedType(bounds[i],
newLoc,
l.toArray(EMPTY_TYPE_ANNOTATION_ARRAY),
getTypeAnnotations(),
getDecl());
}
return res;
}
private WildcardType getWildcardType() {
return (WildcardType)getType();
}
private boolean hasUpperBounds() {
return hasUpperBounds;
}
@Override
public String toString() {
StringBuilder sb = new StringBuilder();
sb.append(annotationsToString(getAnnotations(), false));
sb.append("?");
AnnotatedType[] bounds = getAnnotatedLowerBounds();
if (bounds.length > 0) {
sb.append(" super ");
} else {
bounds = getAnnotatedUpperBounds();
if (bounds.length > 0) {
if (bounds.length == 1) {
AnnotatedType bound = bounds[0];
if (bound.getType().equals(Object.class) &&
bound.getAnnotations().length == 0) {
return sb.toString();
}
}
sb.append(" extends ");
}
}
sb.append(Stream.of(bounds).map(AnnotatedType::toString).
collect(Collectors.joining(" & ")));
return sb.toString();
}
@Override
public boolean equals(Object o) {
if (o instanceof AnnotatedWildcardType that) {
return equalsTypeAndAnnotations(that) &&
Arrays.equals(getAnnotatedLowerBounds(), that.getAnnotatedLowerBounds()) &&
Arrays.equals(getAnnotatedUpperBounds(), that.getAnnotatedUpperBounds());
} else {
return false;
}
}
@Override
public int hashCode() {
return baseHashCode() ^
Objects.hash((Object[])getAnnotatedLowerBounds()) ^
Objects.hash((Object[])getAnnotatedUpperBounds());
}
}
}
package com.sun.source.tree;
import java.util.List;
public interface AnnotatedTypeTree extends ExpressionTree {
List<? extends AnnotationTree> getAnnotations();
ExpressionTree getUnderlyingType();
}
package java.lang.reflect;
public interface AnnotatedTypeVariable extends AnnotatedType {
AnnotatedType[] getAnnotatedBounds();
@Override
AnnotatedType getAnnotatedOwnerType();
}
package java.lang.reflect;
public interface AnnotatedWildcardType extends AnnotatedType {
AnnotatedType[] getAnnotatedLowerBounds();
AnnotatedType[] getAnnotatedUpperBounds();
@Override
AnnotatedType getAnnotatedOwnerType();
}
package java.lang.annotation;
public interface Annotation {
boolean equals(Object obj);
int hashCode();
String toString();
Class<? extends Annotation> annotationType();
}
package jdk.jfr.internal;
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.List;
import jdk.jfr.AnnotationElement;
import jdk.jfr.Description;
import jdk.jfr.Label;
import jdk.jfr.Unsigned;
public final class AnnotationConstruct {
private static final class AnnotationInvocationHandler implements InvocationHandler {
private final AnnotationElement annotationElement;
AnnotationInvocationHandler(AnnotationElement a) {
this.annotationElement = a;
}
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
String methodName = method.getName();
int parameters = method.getTypeParameters().length;
if (parameters == 0 && annotationElement.hasValue(methodName)) {
return annotationElement.getValue(methodName);
}
throw new UnsupportedOperationException("Flight Recorder proxy only supports members declared in annotation interfaces, i.e. not toString, equals etc.");
}
}
private List<AnnotationElement> annotationElements;
private byte unsignedFlag = -1;
public AnnotationConstruct(List<AnnotationElement> elements) {
this.annotationElements = List.copyOf(elements);
}
public AnnotationConstruct() {
this(List.of());
}
public void setAnnotationElements(List<AnnotationElement> elements) {
annotationElements = List.copyOf(elements);
}
public String getLabel() {
Label label = getAnnotation(Label.class);
if (label == null) {
return null;
}
return label.value();
}
public String getDescription() {
Description description = getAnnotation(Description.class);
if (description == null) {
return null;
}
return description.value();
}
@SuppressWarnings("unchecked")
public final <T> T getAnnotation(Class<? extends Annotation> clazz) {
AnnotationElement ae = getAnnotationElement(clazz);
if (ae != null) {
return (T) Proxy.newProxyInstance(clazz.getClassLoader(), new Class<?>[] { clazz }, new AnnotationInvocationHandler(ae));
}
return null;
}
public List<AnnotationElement> getUnmodifiableAnnotationElements() {
return annotationElements;
}
private AnnotationElement getAnnotationElement(Class<? extends Annotation> clazz) {
long id = Type.getTypeId(clazz);
String className = clazz.getName();
for (AnnotationElement a : getUnmodifiableAnnotationElements()) {
if (a.getTypeId() == id && a.getTypeName().equals(className)) {
return a;
}
}
for (AnnotationElement a : getUnmodifiableAnnotationElements()) {
if (a.getTypeName().equals(className)) {
return a;
}
}
return null;
}
public boolean hasUnsigned() {
if (unsignedFlag < 0) {
Unsigned unsigned = getAnnotation(Unsigned.class);
unsignedFlag = (byte) (unsigned == null ? 0 :1);
}
return unsignedFlag == (byte)1 ? true : false;
}
}
package com.sun.tools.classfile;
import java.io.IOException;
public class AnnotationDefault_attribute extends Attribute {
AnnotationDefault_attribute(ClassReader cr, int name_index, int length)
throws IOException, Annotation.InvalidAnnotation {
super(name_index, length);
default_value = Annotation.element_value.read(cr);
}
public AnnotationDefault_attribute(ConstantPool constant_pool, Annotation.element_value default_value)
throws ConstantPoolException {
this(constant_pool.getUTF8Index(Attribute.AnnotationDefault), default_value);
}
public AnnotationDefault_attribute(int name_index, Annotation.element_value default_value) {
super(name_index, default_value.length());
this.default_value = default_value;
}
public <R, D> R accept(Visitor<R, D> visitor, D data) {
return visitor.visitAnnotationDefault(this, data);
}
public final Annotation.element_value default_value;
}
package com.sun.org.apache.bcel.internal.classfile;
import java.io.DataInput;
import java.io.DataOutputStream;
import java.io.IOException;
import com.sun.org.apache.bcel.internal.Const;
public class AnnotationDefault extends Attribute {
private ElementValue defaultValue;
AnnotationDefault(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {
this(name_index, length, (ElementValue) null, constant_pool);
defaultValue = ElementValue.readElementValue(input, constant_pool);
}
public AnnotationDefault(final int name_index, final int length, final ElementValue defaultValue, final ConstantPool constant_pool) {
super(Const.ATTR_ANNOTATION_DEFAULT, name_index, length, constant_pool);
this.defaultValue = defaultValue;
}
@Override
public void accept(final Visitor v) {
v.visitAnnotationDefault(this);
}
public final void setDefaultValue(final ElementValue defaultValue) {
this.defaultValue = defaultValue;
}
public final ElementValue getDefaultValue() {
return defaultValue;
}
@Override
public Attribute copy(final ConstantPool _constant_pool) {
return (Attribute) clone();
}
@Override
public final void dump(final DataOutputStream dos) throws IOException {
super.dump(dos);
defaultValue.dump(dos);
}
}
package jdk.jfr;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.StringJoiner;
import jdk.jfr.internal.Type;
import jdk.jfr.internal.TypeLibrary;
import jdk.jfr.internal.Utils;
public final class AnnotationElement {
private final Type type;
private final List<Object> annotationValues;
private final boolean inBootClassLoader;
AnnotationElement(Type type, List<Object> objects, boolean boot) {
Objects.requireNonNull(type);
Objects.requireNonNull(objects);
this.type = type;
List<ValueDescriptor> fields = type.getFields();
int fieldCount = fields.size();
if (objects.size() != fieldCount) {
StringJoiner descriptors = new StringJoiner(",", "[", "]");
for (ValueDescriptor v : type.getFields()) {
descriptors.add(v.getName());
}
StringJoiner values = new StringJoiner(",", "[", "]");
for (Object object : objects) {
descriptors.add(String.valueOf(object));
}
throw new IllegalArgumentException("Annotation " + descriptors + " for " + type.getName() + " doesn't match number of values " + values);
}
for (int index = 0; index < fieldCount; index++) {
Object object = objects.get(index);
if (object == null) {
throw new IllegalArgumentException("Annotation value can't be null");
}
Class<?> valueType = object.getClass();
if (fields.get(index).isArray()) {
valueType = valueType.getComponentType();
}
checkType(Utils.unboxType(valueType));
}
this.annotationValues = List.copyOf(objects);
this.inBootClassLoader = boot;
}
public AnnotationElement(Class<? extends Annotation> annotationType, Map<String, Object> values) {
Objects.requireNonNull(annotationType, "annotationType");
Objects.requireNonNull(values, "values");
Utils.checkRegisterPermission();
HashMap<String, Object> map = new HashMap<>(values);
for (Map.Entry<String, Object> entry : map.entrySet()) {
if (entry.getKey() == null) {
throw new NullPointerException("Name of annotation method can't be null");
}
if (entry.getValue() == null) {
throw new NullPointerException("Return value for annotation method can't be null");
}
}
if (AnnotationElement.class.isAssignableFrom(annotationType) && annotationType.isInterface()) {
throw new IllegalArgumentException("Must be interface extending " + Annotation.class.getName());
}
if (!isKnownJFRAnnotation(annotationType) && annotationType.getAnnotation(MetadataDefinition.class) == null) {
throw new IllegalArgumentException("Annotation class must be annotated with jdk.jfr.MetadataDefinition to be valid");
}
if (isKnownJFRAnnotation(annotationType)) {
this.type = new Type(annotationType.getCanonicalName(), Type.SUPER_TYPE_ANNOTATION, Type.getTypeId(annotationType));
} else {
this.type = TypeLibrary.createAnnotationType(annotationType);
}
Method[] methods = annotationType.getDeclaredMethods();
if (methods.length != map.size()) {
throw new IllegalArgumentException("Number of declared methods must match size of value map");
}
List<Object> v = new ArrayList<>(methods.length);
Set<String> nameSet = methods.length > 1 ? new HashSet<String>() : null;
for (Method method : methods) {
String fieldName = method.getName();
Object object = map.get(fieldName);
if (object == null) {
throw new IllegalArgumentException("No method in annotation interface " + annotationType.getName() + " matching name " + fieldName);
}
Class<?> fieldType = object.getClass();
if (fieldType == Class.class) {
throw new IllegalArgumentException("Annotation value for " + fieldName + " can't be class");
}
if (object instanceof Enum) {
throw new IllegalArgumentException("Annotation value for " + fieldName + " can't be enum");
}
if (!fieldType.equals(object.getClass())) {
throw new IllegalArgumentException("Return type of annotation " + fieldType.getName() + " must match type of object" + object.getClass());
}
if (fieldType.isArray()) {
Class<?> componentType = fieldType.getComponentType();
checkType(componentType);
if (componentType.equals(String.class)) {
String[] stringArray = (String[]) object;
for (int i = 0; i < stringArray.length; i++) {
if (stringArray[i] == null) {
throw new IllegalArgumentException("Annotation value for " + fieldName + " contains null");
}
}
}
} else {
fieldType = Utils.unboxType(object.getClass());
checkType(fieldType);
}
if (nameSet!= null) {
if (nameSet.contains(fieldName)) {
throw new IllegalArgumentException("Value with name '" + fieldName + "' already exists");
}
nameSet.add(fieldName);
}
if (isKnownJFRAnnotation(annotationType)) {
ValueDescriptor vd = new ValueDescriptor(fieldType, fieldName, Collections.emptyList(), true);
type.add(vd);
}
v.add(object);
}
this.annotationValues = List.copyOf(v);
this.inBootClassLoader = annotationType.getClassLoader() == null;
}
public AnnotationElement(Class<? extends Annotation> annotationType, Object value) {
this(annotationType, Collections.singletonMap("value", Objects.requireNonNull(value)));
}
public AnnotationElement(Class<? extends Annotation> annotationType) {
this(annotationType, Collections.emptyMap());
}
public List<Object> getValues() {
return annotationValues;
}
public List<ValueDescriptor> getValueDescriptors() {
return Collections.unmodifiableList(type.getFields());
}
public List<AnnotationElement> getAnnotationElements() {
return type.getAnnotationElements();
}
public String getTypeName() {
return type.getName();
}
public Object getValue(String name) {
Objects.requireNonNull(name, "name");
int index = type.indexOf(name);
if (index != -1) {
return annotationValues.get(index);
}
StringJoiner valueNames = new StringJoiner(",", "[", "]");
for (ValueDescriptor v : type.getFields()) {
valueNames.add(v.getName());
}
throw new IllegalArgumentException("No value with name '" + name + "'. Valid names are " + valueNames);
}
public boolean hasValue(String name) {
Objects.requireNonNull(name, "name");
return type.indexOf(name) != -1;
}
public final <A> A getAnnotation(Class<? extends Annotation> annotationType) {
Objects.requireNonNull(annotationType);
return type.getAnnotation(annotationType);
}
public long getTypeId() {
return type.getId();
}
Type getType() {
return type;
}
private static void checkType(Class<?> type) {
if (type.isPrimitive()) {
return;
}
if (type == String.class) {
return;
}
throw new IllegalArgumentException("Only primitives types or java.lang.String are allowed");
}
private static boolean isKnownJFRAnnotation(Class<? extends Annotation> annotationType) {
if (annotationType == Registered.class) {
return true;
}
if (annotationType == Threshold.class) {
return true;
}
if (annotationType == StackTrace.class) {
return true;
}
if (annotationType == Period.class) {
return true;
}
if (annotationType == Enabled.class) {
return true;
}
return false;
}
boolean isInBoot() {
return inBootClassLoader;
}
}
package com.sun.org.apache.bcel.internal.classfile;
import java.io.DataOutputStream;
import java.io.IOException;
public class AnnotationElementValue extends ElementValue
{
private final AnnotationEntry annotationEntry;
public AnnotationElementValue(final int type, final AnnotationEntry annotationEntry,
final ConstantPool cpool)
{
super(type, cpool);
if (type != ANNOTATION) {
throw new IllegalArgumentException(
"Only element values of type annotation can be built with this ctor - type specified: " + type);
}
this.annotationEntry = annotationEntry;
}
@Override
public void dump(final DataOutputStream dos) throws IOException
{
dos.writeByte(super.getType());                 annotationEntry.dump(dos);
}
@Override
public String stringifyValue()
{
return annotationEntry.toString();
}
@Override
public String toString()
{
return stringifyValue();
}
public AnnotationEntry getAnnotationEntry()
{
return annotationEntry;
}
}
package com.sun.org.apache.bcel.internal.generic;
import java.io.DataOutputStream;
import java.io.IOException;
import com.sun.org.apache.bcel.internal.classfile.AnnotationElementValue;
import com.sun.org.apache.bcel.internal.classfile.ElementValue;
public class AnnotationElementValueGen extends ElementValueGen
{
private final AnnotationEntryGen a;
public AnnotationElementValueGen(final AnnotationEntryGen a, final ConstantPoolGen cpool)
{
super(ANNOTATION, cpool);
this.a = a;
}
public AnnotationElementValueGen(final int type, final AnnotationEntryGen annotation,
final ConstantPoolGen cpool)
{
super(type, cpool);
if (type != ANNOTATION) {
throw new IllegalArgumentException(
"Only element values of type annotation can be built with this ctor - type specified: " + type);
}
this.a = annotation;
}
public AnnotationElementValueGen(final AnnotationElementValue value,
final ConstantPoolGen cpool, final boolean copyPoolEntries)
{
super(ANNOTATION, cpool);
a = new AnnotationEntryGen(value.getAnnotationEntry(), cpool, copyPoolEntries);
}
@Override
public void dump(final DataOutputStream dos) throws IOException
{
dos.writeByte(super.getElementValueType());         a.dump(dos);
}
@Override
public String stringifyValue()
{
throw new UnsupportedOperationException("Not implemented yet");
}
@Override
public ElementValue getElementValue()
{
return new AnnotationElementValue(super.getElementValueType(),
a.getAnnotation(),
getConstantPool().getConstantPool());
}
public AnnotationEntryGen getAnnotation()
{
return a;
}
}
package com.sun.org.apache.bcel.internal.classfile;
import java.io.DataInput;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import com.sun.org.apache.bcel.internal.Const;
public class AnnotationEntry implements Node {
private final int typeIndex;
private final ConstantPool constantPool;
private final boolean isRuntimeVisible;
private List<ElementValuePair> elementValuePairs;
public static AnnotationEntry read(final DataInput input, final ConstantPool constant_pool, final boolean isRuntimeVisible) throws IOException {
final AnnotationEntry annotationEntry = new AnnotationEntry(input.readUnsignedShort(), constant_pool, isRuntimeVisible);
final int num_element_value_pairs = input.readUnsignedShort();
annotationEntry.elementValuePairs = new ArrayList<>();
for (int i = 0; i < num_element_value_pairs; i++) {
annotationEntry.elementValuePairs.add(
new ElementValuePair(input.readUnsignedShort(), ElementValue.readElementValue(input, constant_pool),
constant_pool));
}
return annotationEntry;
}
public AnnotationEntry(final int type_index, final ConstantPool constant_pool, final boolean isRuntimeVisible) {
this.typeIndex = type_index;
this.constantPool = constant_pool;
this.isRuntimeVisible = isRuntimeVisible;
}
public int getTypeIndex() {
return typeIndex;
}
public ConstantPool getConstantPool() {
return constantPool;
}
public boolean isRuntimeVisible() {
return isRuntimeVisible;
}
@Override
public void accept(final Visitor v) {
v.visitAnnotationEntry(this);
}
public String getAnnotationType() {
final ConstantUtf8 c = (ConstantUtf8) constantPool.getConstant(typeIndex, Const.CONSTANT_Utf8);
return c.getBytes();
}
public int getAnnotationTypeIndex() {
return typeIndex;
}
public final int getNumElementValuePairs() {
return elementValuePairs.size();
}
public ElementValuePair[] getElementValuePairs() {
return elementValuePairs.toArray(new ElementValuePair[elementValuePairs.size()]);
}
public void dump(final DataOutputStream dos) throws IOException {
dos.writeShort(typeIndex);         dos.writeShort(elementValuePairs.size());                 for (final ElementValuePair envp : elementValuePairs) {
envp.dump(dos);
}
}
public void addElementNameValuePair(final ElementValuePair elementNameValuePair) {
elementValuePairs.add(elementNameValuePair);
}
public String toShortString() {
final StringBuilder result = new StringBuilder();
result.append("@");
result.append(getAnnotationType());
final ElementValuePair[] evPairs = getElementValuePairs();
if (evPairs.length > 0) {
result.append("(");
for (final ElementValuePair element : evPairs) {
result.append(element.toShortString());
}
result.append(")");
}
return result.toString();
}
@Override
public String toString() {
return toShortString();
}
public static AnnotationEntry[] createAnnotationEntries(final Attribute[] attrs) {
final List<AnnotationEntry> accumulatedAnnotations = new ArrayList<>(attrs.length);
for (final Attribute attribute : attrs) {
if (attribute instanceof Annotations) {
final Annotations runtimeAnnotations = (Annotations) attribute;
Collections.addAll(accumulatedAnnotations, runtimeAnnotations.getAnnotationEntries());
}
}
return accumulatedAnnotations.toArray(new AnnotationEntry[accumulatedAnnotations.size()]);
}
}
package com.sun.org.apache.bcel.internal.generic;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInput;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
import com.sun.org.apache.bcel.internal.classfile.Attribute;
import com.sun.org.apache.bcel.internal.classfile.ConstantUtf8;
import com.sun.org.apache.bcel.internal.classfile.ElementValuePair;
import com.sun.org.apache.bcel.internal.classfile.RuntimeInvisibleAnnotations;
import com.sun.org.apache.bcel.internal.classfile.RuntimeInvisibleParameterAnnotations;
import com.sun.org.apache.bcel.internal.classfile.RuntimeVisibleAnnotations;
import com.sun.org.apache.bcel.internal.classfile.RuntimeVisibleParameterAnnotations;
public class AnnotationEntryGen {
private int typeIndex;
private List<ElementValuePairGen> evs;
private final ConstantPoolGen cpool;
private boolean isRuntimeVisible = false;
public AnnotationEntryGen(final AnnotationEntry a, final ConstantPoolGen cpool,
final boolean copyPoolEntries) {
this.cpool = cpool;
if (copyPoolEntries) {
typeIndex = cpool.addUtf8(a.getAnnotationType());
} else {
typeIndex = a.getAnnotationTypeIndex();
}
isRuntimeVisible = a.isRuntimeVisible();
evs = copyValues(a.getElementValuePairs(), cpool, copyPoolEntries);
}
private List<ElementValuePairGen> copyValues(final ElementValuePair[] in, final ConstantPoolGen cpool,
final boolean copyPoolEntries) {
final List<ElementValuePairGen> out = new ArrayList<>();
for (final ElementValuePair nvp : in) {
out.add(new ElementValuePairGen(nvp, cpool, copyPoolEntries));
}
return out;
}
private AnnotationEntryGen(final ConstantPoolGen cpool) {
this.cpool = cpool;
}
public AnnotationEntry getAnnotation() {
final AnnotationEntry a = new AnnotationEntry(typeIndex, cpool.getConstantPool(),
isRuntimeVisible);
for (final ElementValuePairGen element : evs) {
a.addElementNameValuePair(element.getElementNameValuePair());
}
return a;
}
public AnnotationEntryGen(final ObjectType type,
final List<ElementValuePairGen> elements, final boolean vis,
final ConstantPoolGen cpool) {
this.cpool = cpool;
this.typeIndex = cpool.addUtf8(type.getSignature());
evs = elements;
isRuntimeVisible = vis;
}
public static AnnotationEntryGen read(final DataInput dis,
final ConstantPoolGen cpool, final boolean b) throws IOException {
final AnnotationEntryGen a = new AnnotationEntryGen(cpool);
a.typeIndex = dis.readUnsignedShort();
final int elemValuePairCount = dis.readUnsignedShort();
for (int i = 0; i < elemValuePairCount; i++) {
final int nidx = dis.readUnsignedShort();
a.addElementNameValuePair(new ElementValuePairGen(nidx,
ElementValueGen.readElementValue(dis, cpool), cpool));
}
a.isRuntimeVisible(b);
return a;
}
public void dump(final DataOutputStream dos) throws IOException {
dos.writeShort(typeIndex);         dos.writeShort(evs.size());         for (final ElementValuePairGen envp : evs) {
envp.dump(dos);
}
}
public void addElementNameValuePair(final ElementValuePairGen evp) {
if (evs == null) {
evs = new ArrayList<>();
}
evs.add(evp);
}
public int getTypeIndex() {
return typeIndex;
}
public final String getTypeSignature() {
final ConstantUtf8 utf8 = (ConstantUtf8) cpool
.getConstant(typeIndex);
return utf8.getBytes();
}
public final String getTypeName() {
return getTypeSignature();            }
public List<ElementValuePairGen> getValues() {
return evs;
}
@Override
public String toString() {
final StringBuilder s = new StringBuilder(32);         s.append("AnnotationGen:[").append(getTypeName()).append(" #").append(evs.size()).append(" {");
for (int i = 0; i < evs.size(); i++) {
s.append(evs.get(i));
if (i + 1 < evs.size()) {
s.append(",");
}
}
s.append("}]");
return s.toString();
}
public String toShortString() {
final StringBuilder s = new StringBuilder();
s.append("@").append(getTypeName()).append("(");
for (int i = 0; i < evs.size(); i++) {
s.append(evs.get(i));
if (i + 1 < evs.size()) {
s.append(",");
}
}
s.append(")");
return s.toString();
}
private void isRuntimeVisible(final boolean b) {
isRuntimeVisible = b;
}
public boolean isRuntimeVisible() {
return isRuntimeVisible;
}
static Attribute[] getAnnotationAttributes(final ConstantPoolGen cp, final AnnotationEntryGen[] annotationEntryGens) {
if (annotationEntryGens.length == 0) {
return new Attribute[0];
}
try {
int countVisible = 0;
int countInvisible = 0;
for (final AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
countVisible++;
} else {
countInvisible++;
}
}
final ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
final ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
try (DataOutputStream rvaDos = new DataOutputStream(rvaBytes);
DataOutputStream riaDos = new DataOutputStream(riaBytes)) {
rvaDos.writeShort(countVisible);
riaDos.writeShort(countInvisible);
for (final AnnotationEntryGen a : annotationEntryGens) {
if (a.isRuntimeVisible()) {
a.dump(rvaDos);
} else {
a.dump(riaDos);
}
}
}
final byte[] rvaData = rvaBytes.toByteArray();
final byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (rvaData.length > 2) {
rvaIndex = cp.addUtf8("RuntimeVisibleAnnotations");
}
if (riaData.length > 2) {
riaIndex = cp.addUtf8("RuntimeInvisibleAnnotations");
}
final List<Attribute> newAttributes = new ArrayList<>();
if (rvaData.length > 2) {
newAttributes.add(
new RuntimeVisibleAnnotations(rvaIndex, rvaData.length,
new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
}
if (riaData.length > 2) {
newAttributes.add(
new RuntimeInvisibleAnnotations(riaIndex, riaData.length,
new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (final IOException e) {
System.err.println("IOException whilst processing annotations");
e.printStackTrace();
}
return null;
}
static Attribute[] getParameterAnnotationAttributes(
final ConstantPoolGen cp,
final List<AnnotationEntryGen>[] vec) {
final int[] visCount = new int[vec.length];
int totalVisCount = 0;
final int[] invisCount = new int[vec.length];
int totalInvisCount = 0;
try {
for (int i = 0; i < vec.length; i++) {
if (vec[i] != null) {
for (final AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
visCount[i]++;
totalVisCount++;
} else {
invisCount[i]++;
totalInvisCount++;
}
}
}
}
final ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
try (DataOutputStream rvaDos = new DataOutputStream(rvaBytes)) {
rvaDos.writeByte(vec.length);                 for (int i = 0; i < vec.length; i++) {
rvaDos.writeShort(visCount[i]);
if (visCount[i] > 0) {
for (final AnnotationEntryGen element : vec[i]) {
if (element.isRuntimeVisible()) {
element.dump(rvaDos);
}
}
}
}
}
final ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
try (DataOutputStream riaDos = new DataOutputStream(riaBytes)) {
riaDos.writeByte(vec.length);                 for (int i = 0; i < vec.length; i++) {
riaDos.writeShort(invisCount[i]);
if (invisCount[i] > 0) {
for (final AnnotationEntryGen element : vec[i]) {
if (!element.isRuntimeVisible()) {
element.dump(riaDos);
}
}
}
}
}
final byte[] rvaData = rvaBytes.toByteArray();
final byte[] riaData = riaBytes.toByteArray();
int rvaIndex = -1;
int riaIndex = -1;
if (totalVisCount > 0) {
rvaIndex = cp.addUtf8("RuntimeVisibleParameterAnnotations");
}
if (totalInvisCount > 0) {
riaIndex = cp.addUtf8("RuntimeInvisibleParameterAnnotations");
}
final List<Attribute> newAttributes = new ArrayList<>();
if (totalVisCount > 0) {
newAttributes
.add(new RuntimeVisibleParameterAnnotations(rvaIndex,
rvaData.length,
new DataInputStream(new ByteArrayInputStream(rvaData)),
cp.getConstantPool()));
}
if (totalInvisCount > 0) {
newAttributes
.add(new RuntimeInvisibleParameterAnnotations(riaIndex,
riaData.length,
new DataInputStream(new ByteArrayInputStream(riaData)),
cp.getConstantPool()));
}
return newAttributes.toArray(new Attribute[newAttributes.size()]);
} catch (final IOException e) {
System.err.println("IOException whilst processing parameter annotations." +
e.getMessage());
}
return null;
}
}
package java.lang.annotation;
public class AnnotationFormatError extends Error {
@java.io.Serial
private static final long serialVersionUID = -4256701562333669892L;
public AnnotationFormatError(String message) {
super(message);
}
public AnnotationFormatError(String message, Throwable cause) {
super(message, cause);
}
public AnnotationFormatError(Throwable cause) {
super(cause);
}
}
package sun.reflect.annotation;
import java.io.ObjectInputStream;
import java.lang.annotation.*;
import java.lang.reflect.*;
import java.io.Serializable;
import java.util.*;
import java.util.stream.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
class AnnotationInvocationHandler implements InvocationHandler, Serializable {
@java.io.Serial
private static final long serialVersionUID = 6182022883658399397L;
private final Class<? extends Annotation> type;
@SuppressWarnings("serial")     private final Map<String, Object> memberValues;
AnnotationInvocationHandler(Class<? extends Annotation> type, Map<String, Object> memberValues) {
Class<?>[] superInterfaces = type.getInterfaces();
if (!type.isAnnotation() ||
superInterfaces.length != 1 ||
superInterfaces[0] != java.lang.annotation.Annotation.class)
throw new AnnotationFormatError("Attempt to create proxy for a non-annotation type: " +
type.getName());
this.type = type;
this.memberValues = memberValues;
}
public Object invoke(Object proxy, Method method, Object[] args) {
String member = method.getName();
int parameterCount = method.getParameterCount();
if (parameterCount == 1 && member == "equals" &&
method.getParameterTypes()[0] == Object.class) {
return equalsImpl(proxy, args[0]);
}
if (parameterCount != 0) {
throw new AssertionError("Too many parameters for an annotation method");
}
if (member == "toString") {
return toStringImpl();
} else if (member == "hashCode") {
return hashCodeImpl();
} else if (member == "annotationType") {
return type;
}
Object result = memberValues.get(member);
if (result == null)
throw new IncompleteAnnotationException(type, member);
if (result instanceof ExceptionProxy exceptProxy)
throw exceptProxy.generateException();
if (result.getClass().isArray() && Array.getLength(result) != 0)
result = cloneArray(result);
return result;
}
private Object cloneArray(Object array) {
Class<?> type = array.getClass();
if (type == byte[].class) {
byte[] byteArray = (byte[])array;
return byteArray.clone();
}
if (type == char[].class) {
char[] charArray = (char[])array;
return charArray.clone();
}
if (type == double[].class) {
double[] doubleArray = (double[])array;
return doubleArray.clone();
}
if (type == float[].class) {
float[] floatArray = (float[])array;
return floatArray.clone();
}
if (type == int[].class) {
int[] intArray = (int[])array;
return intArray.clone();
}
if (type == long[].class) {
long[] longArray = (long[])array;
return longArray.clone();
}
if (type == short[].class) {
short[] shortArray = (short[])array;
return shortArray.clone();
}
if (type == boolean[].class) {
boolean[] booleanArray = (boolean[])array;
return booleanArray.clone();
}
Object[] objectArray = (Object[])array;
return objectArray.clone();
}
private String toStringImpl() {
StringBuilder result = new StringBuilder(128);
result.append('@');
result.append(Objects.toString(type.getCanonicalName(),
"<no canonical name>"));
result.append('(');
boolean firstMember = true;
Set<Map.Entry<String, Object>> entries = memberValues.entrySet();
boolean loneValue = entries.size() == 1;
for (Map.Entry<String, Object> e : entries) {
if (firstMember)
firstMember = false;
else
result.append(", ");
String key = e.getKey();
if (!loneValue || !"value".equals(key)) {
result.append(key);
result.append('=');
}
loneValue = false;
result.append(memberValueToString(e.getValue()));
}
result.append(')');
return result.toString();
}
private static String memberValueToString(Object value) {
Class<?> type = value.getClass();
if (!type.isArray()) {
if (type == Class.class)
return toSourceString((Class<?>) value);
else if (type == String.class)
return  toSourceString((String) value);
if (type == Character.class)
return toSourceString((char) value);
else if (type == Double.class)
return  toSourceString((double) value);
else if (type == Float.class)
return  toSourceString((float) value);
else if (type == Long.class)
return  toSourceString((long) value);
else if (type == Byte.class)
return  toSourceString((byte) value);
else if (value instanceof Enum<?> v)
return toSourceString(v);
else
return value.toString();
} else {
Stream<String> stringStream;
if (type == byte[].class)
stringStream = convert((byte[]) value);
else if (type == char[].class)
stringStream = convert((char[]) value);
else if (type == double[].class)
stringStream = DoubleStream.of((double[]) value)
.mapToObj(AnnotationInvocationHandler::toSourceString);
else if (type == float[].class)
stringStream = convert((float[]) value);
else if (type == int[].class)
stringStream = IntStream.of((int[]) value).mapToObj(String::valueOf);
else if (type == long[].class) {
stringStream = LongStream.of((long[]) value)
.mapToObj(AnnotationInvocationHandler::toSourceString);
} else if (type == short[].class)
stringStream = convert((short[]) value);
else if (type == boolean[].class)
stringStream = convert((boolean[]) value);
else if (type == Class[].class)
stringStream =
Arrays.stream((Class<?>[]) value).
map(AnnotationInvocationHandler::toSourceString);
else if (type == String[].class)
stringStream =
Arrays.stream((String[])value).
map(AnnotationInvocationHandler::toSourceString);
else if (type.getComponentType().isEnum())
stringStream =
Arrays.stream((Enum<?>[])value).
map(AnnotationInvocationHandler::toSourceString);
else
stringStream = Arrays.stream((Object[])value).map(Objects::toString);
return stringStreamToString(stringStream);
}
}
private static String toSourceString(Class<?> clazz) {
return Objects.toString(clazz.getCanonicalName(),
"<no canonical name>") + ".class";
}
private static String toSourceString(float f) {
if (Float.isFinite(f))
return Float.toString(f) + "f" ;
else {
if (Float.isInfinite(f)) {
return (f < 0.0f) ? "-1.0f/0.0f": "1.0f/0.0f";
} else
return "0.0f/0.0f";
}
}
private static String toSourceString(double d) {
if (Double.isFinite(d))
return Double.toString(d);
else {
if (Double.isInfinite(d)) {
return (d < 0.0f) ? "-1.0/0.0": "1.0/0.0";
} else
return "0.0/0.0";
}
}
private static String toSourceString(char c) {
StringBuilder sb = new StringBuilder(4);
sb.append('\'');
sb.append(quote(c));
return sb.append('\'') .toString();
}
private static String quote(char ch) {
switch (ch) {
case '\b':  return "\\b";
case '\f':  return "\\f";
case '\n':  return "\\n";
case '\r':  return "\\r";
case '\t':  return "\\t";
case '\'':  return "\\'";
case '\"':  return "\\\"";
case '\\':  return "\\\\";
default:
return (isPrintableAscii(ch))
? String.valueOf(ch)
: String.format("\\u%04x", (int) ch);
}
}
private static boolean isPrintableAscii(char ch) {
return ch >= ' ' && ch <= '~';
}
private static String toSourceString(byte b) {
return String.format("(byte)0x%02x", b);
}
private static String toSourceString(long ell) {
return String.valueOf(ell) + "L";
}
private static String toSourceString(Enum<?> enumConstant) {
return enumConstant.name();
}
private static String toSourceString(String s) {
StringBuilder sb = new StringBuilder();
sb.append('"');
for (int i = 0; i < s.length(); i++) {
sb.append(quote(s.charAt(i)));
}
sb.append('"');
return sb.toString();
}
private static Stream<String> convert(byte[] values) {
List<String> list = new ArrayList<>(values.length);
for (byte b : values)
list.add(toSourceString(b));
return list.stream();
}
private static Stream<String> convert(char[] values) {
List<String> list = new ArrayList<>(values.length);
for (char c : values)
list.add(toSourceString(c));
return list.stream();
}
private static Stream<String> convert(float[] values) {
List<String> list = new ArrayList<>(values.length);
for (float f : values) {
list.add(toSourceString(f));
}
return list.stream();
}
private static Stream<String> convert(short[] values) {
List<String> list = new ArrayList<>(values.length);
for (short s : values)
list.add(Short.toString(s));
return list.stream();
}
private static Stream<String> convert(boolean[] values) {
List<String> list = new ArrayList<>(values.length);
for (boolean b : values)
list.add(Boolean.toString(b));
return list.stream();
}
private static String stringStreamToString(Stream<String> stream) {
return stream.collect(Collectors.joining(", ", "{", "}"));
}
private Boolean equalsImpl(Object proxy, Object o) {
if (o == proxy)
return true;
if (!type.isInstance(o))
return false;
for (Method memberMethod : getMemberMethods()) {
if (memberMethod.isSynthetic())
continue;
String member = memberMethod.getName();
Object ourValue = memberValues.get(member);
Object hisValue = null;
AnnotationInvocationHandler hisHandler = asOneOfUs(o);
if (hisHandler != null) {
hisValue = hisHandler.memberValues.get(member);
} else {
try {
hisValue = memberMethod.invoke(o);
} catch (InvocationTargetException e) {
return false;
} catch (IllegalAccessException e) {
throw new AssertionError(e);
}
}
if (!memberValueEquals(ourValue, hisValue))
return false;
}
return true;
}
private AnnotationInvocationHandler asOneOfUs(Object o) {
if (Proxy.isProxyClass(o.getClass())) {
InvocationHandler handler = Proxy.getInvocationHandler(o);
if (handler instanceof AnnotationInvocationHandler annotationHandler)
return annotationHandler;
}
return null;
}
private static boolean memberValueEquals(Object v1, Object v2) {
Class<?> type = v1.getClass();
if (!type.isArray())
return v1.equals(v2);
if (v1 instanceof Object[] && v2 instanceof Object[])
return Arrays.equals((Object[]) v1, (Object[]) v2);
if (v2.getClass() != type)
return false;
if (type == byte[].class)
return Arrays.equals((byte[]) v1, (byte[]) v2);
if (type == char[].class)
return Arrays.equals((char[]) v1, (char[]) v2);
if (type == double[].class)
return Arrays.equals((double[]) v1, (double[]) v2);
if (type == float[].class)
return Arrays.equals((float[]) v1, (float[]) v2);
if (type == int[].class)
return Arrays.equals((int[]) v1, (int[]) v2);
if (type == long[].class)
return Arrays.equals((long[]) v1, (long[]) v2);
if (type == short[].class)
return Arrays.equals((short[]) v1, (short[]) v2);
assert type == boolean[].class;
return Arrays.equals((boolean[]) v1, (boolean[]) v2);
}
private Method[] getMemberMethods() {
Method[] value = memberMethods;
if (value == null) {
value = computeMemberMethods();
memberMethods = value;
}
return value;
}
@SuppressWarnings("removal")
private Method[] computeMemberMethods() {
return AccessController.doPrivileged(
new PrivilegedAction<Method[]>() {
public Method[] run() {
final Method[] methods = type.getDeclaredMethods();
validateAnnotationMethods(methods);
AccessibleObject.setAccessible(methods, true);
return methods;
}});
}
private transient volatile Method[] memberMethods;
private void validateAnnotationMethods(Method[] memberMethods) {
boolean valid = true;
Method currentMethod = null;
for(Method method : memberMethods) {
currentMethod = method;
int modifiers = method.getModifiers();
if (method.isSynthetic() &&
(modifiers & (Modifier.STATIC | Modifier.PRIVATE)) != 0 &&
method.getParameterCount() == 0) {
continue;
}
if (modifiers != (Modifier.PUBLIC | Modifier.ABSTRACT) ||
method.isDefault() ||
method.getParameterCount() != 0 ||
method.getExceptionTypes().length != 0) {
valid = false;
break;
}
Class<?> returnType = method.getReturnType();
if (returnType.isArray()) {
returnType = returnType.getComponentType();
if (returnType.isArray()) {                     valid = false;
break;
}
}
if (!((returnType.isPrimitive() && returnType != void.class) ||
returnType == java.lang.String.class ||
returnType == java.lang.Class.class ||
returnType.isEnum() ||
returnType.isAnnotation())) {
valid = false;
break;
}
String methodName = method.getName();
if ((methodName.equals("toString") && returnType == java.lang.String.class) ||
(methodName.equals("hashCode") && returnType == int.class) ||
(methodName.equals("annotationType") && returnType == java.lang.Class.class)) {
valid = false;
break;
}
}
if (valid)
return;
else
throw new AnnotationFormatError("Malformed method on an annotation type: " +
currentMethod.toString());
}
private int hashCodeImpl() {
int result = 0;
for (Map.Entry<String, Object> e : memberValues.entrySet()) {
result += (127 * e.getKey().hashCode()) ^
memberValueHashCode(e.getValue());
}
return result;
}
private static int memberValueHashCode(Object value) {
Class<?> type = value.getClass();
if (!type.isArray())                                                return value.hashCode();
if (type == byte[].class)
return Arrays.hashCode((byte[]) value);
if (type == char[].class)
return Arrays.hashCode((char[]) value);
if (type == double[].class)
return Arrays.hashCode((double[]) value);
if (type == float[].class)
return Arrays.hashCode((float[]) value);
if (type == int[].class)
return Arrays.hashCode((int[]) value);
if (type == long[].class)
return Arrays.hashCode((long[]) value);
if (type == short[].class)
return Arrays.hashCode((short[]) value);
if (type == boolean[].class)
return Arrays.hashCode((boolean[]) value);
return Arrays.hashCode((Object[]) value);
}
@java.io.Serial
private void readObject(java.io.ObjectInputStream s)
throws java.io.IOException, ClassNotFoundException {
ObjectInputStream.GetField fields = s.readFields();
@SuppressWarnings("unchecked")
Class<? extends Annotation> t = (Class<? extends Annotation>)fields.get("type", null);
@SuppressWarnings("unchecked")
Map<String, Object> streamVals = (Map<String, Object>)fields.get("memberValues", null);
AnnotationType annotationType = null;
try {
annotationType = AnnotationType.getInstance(t);
} catch(IllegalArgumentException e) {
throw new java.io.InvalidObjectException("Non-annotation type in annotation serial stream");
}
Map<String, Class<?>> memberTypes = annotationType.memberTypes();
Map<String, Object> mv = new LinkedHashMap<>();
for (Map.Entry<String, Object> memberValue : streamVals.entrySet()) {
String name = memberValue.getKey();
Object value = null;
Class<?> memberType = memberTypes.get(name);
if (memberType != null) {                  value = memberValue.getValue();
if (!(memberType.isInstance(value) ||
value instanceof ExceptionProxy)) {
value = new AnnotationTypeMismatchExceptionProxy(
Objects.toIdentityString(value))
.setMember(annotationType.members().get(name));
}
}
mv.put(name, value);
}
UnsafeAccessor.setType(this, t);
UnsafeAccessor.setMemberValues(this, mv);
}
private static class UnsafeAccessor {
private static final jdk.internal.misc.Unsafe unsafe
= jdk.internal.misc.Unsafe.getUnsafe();
private static final long typeOffset = unsafe.objectFieldOffset
(AnnotationInvocationHandler.class, "type");
private static final long memberValuesOffset = unsafe.objectFieldOffset
(AnnotationInvocationHandler.class, "memberValues");
static void setType(AnnotationInvocationHandler o,
Class<? extends Annotation> type) {
unsafe.putReference(o, typeOffset, type);
}
static void setMemberValues(AnnotationInvocationHandler o,
Map<String, Object> memberValues) {
unsafe.putReference(o, memberValuesOffset, memberValues);
}
}
}
package javax.lang.model.element;
import java.util.Map;
import javax.lang.model.type.DeclaredType;
public interface AnnotationMirror {
DeclaredType getAnnotationType();
Map<? extends ExecutableElement, ? extends AnnotationValue> getElementValues();
}
package jdk.internal.org.objectweb.asm.tree;
import java.util.ArrayList;
import java.util.List;
import jdk.internal.org.objectweb.asm.AnnotationVisitor;
import jdk.internal.org.objectweb.asm.Opcodes;
public class AnnotationNode extends AnnotationVisitor {
public String desc;
public List<Object> values;
public AnnotationNode(final String descriptor) {
this( Opcodes.ASM9, descriptor);
if (getClass() != AnnotationNode.class) {
throw new IllegalStateException();
}
}
public AnnotationNode(final int api, final String descriptor) {
super(api);
this.desc = descriptor;
}
AnnotationNode(final List<Object> values) {
super( Opcodes.ASM9);
this.values = values;
}
@Override
public void visit(final String name, final Object value) {
if (values == null) {
values = new ArrayList<>(this.desc != null ? 2 : 1);
}
if (this.desc != null) {
values.add(name);
}
if (value instanceof byte[]) {
values.add(Util.asArrayList((byte[]) value));
} else if (value instanceof boolean[]) {
values.add(Util.asArrayList((boolean[]) value));
} else if (value instanceof short[]) {
values.add(Util.asArrayList((short[]) value));
} else if (value instanceof char[]) {
values.add(Util.asArrayList((char[]) value));
} else if (value instanceof int[]) {
values.add(Util.asArrayList((int[]) value));
} else if (value instanceof long[]) {
values.add(Util.asArrayList((long[]) value));
} else if (value instanceof float[]) {
values.add(Util.asArrayList((float[]) value));
} else if (value instanceof double[]) {
values.add(Util.asArrayList((double[]) value));
} else {
values.add(value);
}
}
@Override
public void visitEnum(final String name, final String descriptor, final String value) {
if (values == null) {
values = new ArrayList<>(this.desc != null ? 2 : 1);
}
if (this.desc != null) {
values.add(name);
}
values.add(new String[] {descriptor, value});
}
@Override
public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {
if (values == null) {
values = new ArrayList<>(this.desc != null ? 2 : 1);
}
if (this.desc != null) {
values.add(name);
}
AnnotationNode annotation = new AnnotationNode(descriptor);
values.add(annotation);
return annotation;
}
@Override
public AnnotationVisitor visitArray(final String name) {
if (values == null) {
values = new ArrayList<>(this.desc != null ? 2 : 1);
}
if (this.desc != null) {
values.add(name);
}
List<Object> array = new ArrayList<>();
values.add(array);
return new AnnotationNode(array);
}
@Override
public void visitEnd() {
}
public void check(final int api) {
}
public void accept(final AnnotationVisitor annotationVisitor) {
if (annotationVisitor != null) {
if (values != null) {
for (int i = 0, n = values.size(); i < n; i += 2) {
String name = (String) values.get(i);
Object value = values.get(i + 1);
accept(annotationVisitor, name, value);
}
}
annotationVisitor.visitEnd();
}
}
static void accept(
final AnnotationVisitor annotationVisitor, final String name, final Object value) {
if (annotationVisitor != null) {
if (value instanceof String[]) {
String[] typeValue = (String[]) value;
annotationVisitor.visitEnum(name, typeValue[0], typeValue[1]);
} else if (value instanceof AnnotationNode) {
AnnotationNode annotationValue = (AnnotationNode) value;
annotationValue.accept(annotationVisitor.visitAnnotation(name, annotationValue.desc));
} else if (value instanceof List) {
AnnotationVisitor arrayAnnotationVisitor = annotationVisitor.visitArray(name);
if (arrayAnnotationVisitor != null) {
List<?> arrayValue = (List<?>) value;
for (int i = 0, n = arrayValue.size(); i < n; ++i) {
accept(arrayAnnotationVisitor, null, arrayValue.get(i));
}
arrayAnnotationVisitor.visitEnd();
}
} else {
annotationVisitor.visit(name, value);
}
}
}
}
package sun.reflect.annotation;
import java.lang.annotation.*;
import java.lang.reflect.*;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.util.*;
import java.util.function.Supplier;
import java.security.AccessController;
import java.security.PrivilegedAction;
import jdk.internal.reflect.ConstantPool;
import sun.reflect.generics.parser.SignatureParser;
import sun.reflect.generics.tree.TypeSignature;
import sun.reflect.generics.factory.GenericsFactory;
import sun.reflect.generics.factory.CoreReflectionFactory;
import sun.reflect.generics.visitor.Reifier;
import sun.reflect.generics.scope.ClassScope;
public class AnnotationParser {
public static Map<Class<? extends Annotation>, Annotation> parseAnnotations(
byte[] rawAnnotations,
ConstantPool constPool,
Class<?> container) {
if (rawAnnotations == null)
return Collections.emptyMap();
try {
return parseAnnotations2(rawAnnotations, constPool, container, null);
} catch(BufferUnderflowException e) {
throw new AnnotationFormatError("Unexpected end of annotations.");
} catch(IllegalArgumentException e) {
throw new AnnotationFormatError(e);
}
}
@SafeVarargs
@SuppressWarnings("varargs")     static Map<Class<? extends Annotation>, Annotation> parseSelectAnnotations(
byte[] rawAnnotations,
ConstantPool constPool,
Class<?> container,
Class<? extends Annotation> ... selectAnnotationClasses) {
if (rawAnnotations == null)
return Collections.emptyMap();
try {
return parseAnnotations2(rawAnnotations, constPool, container, selectAnnotationClasses);
} catch(BufferUnderflowException e) {
throw new AnnotationFormatError("Unexpected end of annotations.");
} catch(IllegalArgumentException e) {
throw new AnnotationFormatError(e);
}
}
private static Map<Class<? extends Annotation>, Annotation> parseAnnotations2(
byte[] rawAnnotations,
ConstantPool constPool,
Class<?> container,
Class<? extends Annotation>[] selectAnnotationClasses) {
Map<Class<? extends Annotation>, Annotation> result =
new LinkedHashMap<Class<? extends Annotation>, Annotation>();
ByteBuffer buf = ByteBuffer.wrap(rawAnnotations);
int numAnnotations = buf.getShort() & 0xFFFF;
for (int i = 0; i < numAnnotations; i++) {
Annotation a = parseAnnotation2(buf, constPool, container, false, selectAnnotationClasses);
if (a != null) {
Class<? extends Annotation> klass = a.annotationType();
if (AnnotationType.getInstance(klass).retention() == RetentionPolicy.RUNTIME &&
result.put(klass, a) != null) {
throw new AnnotationFormatError(
"Duplicate annotation for class: "+klass+": " + a);
}
}
}
return result;
}
public static Annotation[][] parseParameterAnnotations(
byte[] rawAnnotations,
ConstantPool constPool,
Class<?> container) {
try {
return parseParameterAnnotations2(rawAnnotations, constPool, container);
} catch(BufferUnderflowException e) {
throw new AnnotationFormatError(
"Unexpected end of parameter annotations.");
} catch(IllegalArgumentException e) {
throw new AnnotationFormatError(e);
}
}
private static Annotation[][] parseParameterAnnotations2(
byte[] rawAnnotations,
ConstantPool constPool,
Class<?> container) {
ByteBuffer buf = ByteBuffer.wrap(rawAnnotations);
int numParameters = buf.get() & 0xFF;
Annotation[][] result = new Annotation[numParameters][];
for (int i = 0; i < numParameters; i++) {
int numAnnotations = buf.getShort() & 0xFFFF;
List<Annotation> annotations =
new ArrayList<Annotation>(numAnnotations);
for (int j = 0; j < numAnnotations; j++) {
Annotation a = parseAnnotation(buf, constPool, container, false);
if (a != null) {
AnnotationType type = AnnotationType.getInstance(
a.annotationType());
if (type.retention() == RetentionPolicy.RUNTIME)
annotations.add(a);
}
}
result[i] = annotations.toArray(EMPTY_ANNOTATIONS_ARRAY);
}
return result;
}
private static final Annotation[] EMPTY_ANNOTATIONS_ARRAY =
new Annotation[0];
static Annotation parseAnnotation(ByteBuffer buf,
ConstantPool constPool,
Class<?> container,
boolean exceptionOnMissingAnnotationClass) {
return parseAnnotation2(buf, constPool, container, exceptionOnMissingAnnotationClass, null);
}
@SuppressWarnings("unchecked")
private static Annotation parseAnnotation2(ByteBuffer buf,
ConstantPool constPool,
Class<?> container,
boolean exceptionOnMissingAnnotationClass,
Class<? extends Annotation>[] selectAnnotationClasses) {
int typeIndex = buf.getShort() & 0xFFFF;
Class<? extends Annotation> annotationClass = null;
String sig = "[unknown]";
try {
sig = constPool.getUTF8At(typeIndex);
annotationClass = (Class<? extends Annotation>)parseSig(sig, container);
} catch (NoClassDefFoundError e) {
if (exceptionOnMissingAnnotationClass)
throw new TypeNotPresentException(sig, e);
skipAnnotation(buf, false);
return null;
}
catch (TypeNotPresentException e) {
if (exceptionOnMissingAnnotationClass)
throw e;
skipAnnotation(buf, false);
return null;
}
if (selectAnnotationClasses != null && !contains(selectAnnotationClasses, annotationClass)) {
skipAnnotation(buf, false);
return null;
}
AnnotationType type = null;
try {
type = AnnotationType.getInstance(annotationClass);
} catch (IllegalArgumentException e) {
skipAnnotation(buf, false);
return null;
}
Map<String, Class<?>> memberTypes = type.memberTypes();
Map<String, Object> memberValues =
new LinkedHashMap<String, Object>(type.memberDefaults());
int numMembers = buf.getShort() & 0xFFFF;
for (int i = 0; i < numMembers; i++) {
int memberNameIndex = buf.getShort() & 0xFFFF;
String memberName = constPool.getUTF8At(memberNameIndex);
Class<?> memberType = memberTypes.get(memberName);
if (memberType == null) {
skipMemberValue(buf);
} else {
Object value = parseMemberValue(memberType, buf, constPool, container);
if (value instanceof AnnotationTypeMismatchExceptionProxy exceptProxy)
exceptProxy.setMember(type.members().get(memberName));
memberValues.put(memberName, value);
}
}
return annotationForMap(annotationClass, memberValues);
}
@SuppressWarnings("removal")
public static Annotation annotationForMap(final Class<? extends Annotation> type,
final Map<String, Object> memberValues)
{
return AccessController.doPrivileged(new PrivilegedAction<Annotation>() {
public Annotation run() {
return (Annotation) Proxy.newProxyInstance(
type.getClassLoader(), new Class<?>[] { type },
new AnnotationInvocationHandler(type, memberValues));
}});
}
@SuppressWarnings("unchecked")
public static Object parseMemberValue(Class<?> memberType,
ByteBuffer buf,
ConstantPool constPool,
Class<?> container) {
Object result = null;
int tag = buf.get();
switch(tag) {
case 'e':
return parseEnumValue((Class<? extends Enum<?>>)memberType, buf, constPool, container);
case 'c':
result = parseClassValue(buf, constPool, container);
break;
case '@':
result = parseAnnotation(buf, constPool, container, true);
break;
case '[':
return parseArray(memberType, buf, constPool, container);
default:
result = parseConst(tag, buf, constPool);
}
if (result == null) {
result = new AnnotationTypeMismatchExceptionProxy(
Proxy.isProxyClass(memberType)
? memberType.getInterfaces()[0].getName()
: memberType.getName());
} else if (!(result instanceof ExceptionProxy) &&
!memberType.isInstance(result)) {
if (result instanceof Annotation) {
result = new AnnotationTypeMismatchExceptionProxy(
result.toString());
} else {
result = new AnnotationTypeMismatchExceptionProxy(
result.getClass().getName() + "[" + result + "]");
}
}
return result;
}
private static Object parseConst(int tag,
ByteBuffer buf, ConstantPool constPool) {
int constIndex = buf.getShort() & 0xFFFF;
switch(tag) {
case 'B':
return Byte.valueOf((byte) constPool.getIntAt(constIndex));
case 'C':
return Character.valueOf((char) constPool.getIntAt(constIndex));
case 'D':
return Double.valueOf(constPool.getDoubleAt(constIndex));
case 'F':
return Float.valueOf(constPool.getFloatAt(constIndex));
case 'I':
return Integer.valueOf(constPool.getIntAt(constIndex));
case 'J':
return Long.valueOf(constPool.getLongAt(constIndex));
case 'S':
return Short.valueOf((short) constPool.getIntAt(constIndex));
case 'Z':
return Boolean.valueOf(constPool.getIntAt(constIndex) != 0);
case 's':
return constPool.getUTF8At(constIndex);
default:
throw new AnnotationFormatError(
"Invalid member-value tag in annotation: " + tag);
}
}
private static Object parseClassValue(ByteBuffer buf,
ConstantPool constPool,
Class<?> container) {
int classIndex = buf.getShort() & 0xFFFF;
try {
String sig = constPool.getUTF8At(classIndex);
return parseSig(sig, container);
} catch (NoClassDefFoundError e) {
return new TypeNotPresentExceptionProxy("[unknown]", e);
} catch (TypeNotPresentException e) {
return new TypeNotPresentExceptionProxy(e.typeName(), e.getCause());
}
}
private static Class<?> parseSig(String sig, Class<?> container) {
if (sig.equals("V")) return void.class;
SignatureParser parser = SignatureParser.make();
TypeSignature typeSig = parser.parseTypeSig(sig);
GenericsFactory factory = CoreReflectionFactory.make(container, ClassScope.make(container));
Reifier reify = Reifier.make(factory);
typeSig.accept(reify);
Type result = reify.getResult();
return toClass(result);
}
static Class<?> toClass(Type o) {
if (o instanceof GenericArrayType gat)
return Array.newInstance(toClass(gat.getGenericComponentType()), 0)
.getClass();
return (Class)o;
}
@SuppressWarnings({"rawtypes", "unchecked"})
private static Object parseEnumValue(Class<? extends Enum> enumType, ByteBuffer buf,
ConstantPool constPool,
Class<?> container) {
int typeNameIndex = buf.getShort() & 0xFFFF;
String typeName  = constPool.getUTF8At(typeNameIndex);
int constNameIndex = buf.getShort() & 0xFFFF;
String constName = constPool.getUTF8At(constNameIndex);
if (!enumType.isEnum() || enumType != parseSig(typeName, container)) {
return new AnnotationTypeMismatchExceptionProxy(
typeName.substring(1, typeName.length() - 1).replace('/', '.') + "." + constName);
}
try {
return  Enum.valueOf(enumType, constName);
} catch(IllegalArgumentException e) {
return new EnumConstantNotPresentExceptionProxy(
(Class<? extends Enum<?>>)enumType, constName);
}
}
@SuppressWarnings("unchecked")
private static Object parseArray(Class<?> arrayType,
ByteBuffer buf,
ConstantPool constPool,
Class<?> container) {
int length = buf.getShort() & 0xFFFF;          if (!arrayType.isArray()) {
return parseUnknownArray(length, buf);
}
Class<?> componentType = arrayType.getComponentType();
if (componentType == byte.class) {
return parseByteArray(length, buf, constPool);
} else if (componentType == char.class) {
return parseCharArray(length, buf, constPool);
} else if (componentType == double.class) {
return parseDoubleArray(length, buf, constPool);
} else if (componentType == float.class) {
return parseFloatArray(length, buf, constPool);
} else if (componentType == int.class) {
return parseIntArray(length, buf, constPool);
} else if (componentType == long.class) {
return parseLongArray(length, buf, constPool);
} else if (componentType == short.class) {
return parseShortArray(length, buf, constPool);
} else if (componentType == boolean.class) {
return parseBooleanArray(length, buf, constPool);
} else if (componentType == String.class) {
return parseStringArray(length, buf, constPool);
} else if (componentType == Class.class) {
return parseClassArray(length, buf, constPool, container);
} else if (componentType.isEnum()) {
return parseEnumArray(length, (Class<? extends Enum<?>>)componentType, buf,
constPool, container);
} else if (componentType.isAnnotation()) {
return parseAnnotationArray(length, (Class <? extends Annotation>)componentType, buf,
constPool, container);
} else {
return parseUnknownArray(length, buf);
}
}
private static Object parseByteArray(int length,
ByteBuffer buf, ConstantPool constPool) {
byte[] result = new byte[length];
boolean typeMismatch = false;
int tag = 0;
for (int i = 0; i < length; i++) {
tag = buf.get();
if (tag == 'B') {
int index = buf.getShort() & 0xFFFF;
result[i] = (byte) constPool.getIntAt(index);
} else {
skipMemberValue(tag, buf);
typeMismatch = true;
}
}
return typeMismatch ? exceptionProxy(tag) : result;
}
private static Object parseCharArray(int length,
ByteBuffer buf, ConstantPool constPool) {
char[] result = new char[length];
boolean typeMismatch = false;
byte tag = 0;
for (int i = 0; i < length; i++) {
tag = buf.get();
if (tag == 'C') {
int index = buf.getShort() & 0xFFFF;
result[i] = (char) constPool.getIntAt(index);
} else {
skipMemberValue(tag, buf);
typeMismatch = true;
}
}
return typeMismatch ? exceptionProxy(tag) : result;
}
private static Object parseDoubleArray(int length,
ByteBuffer buf, ConstantPool constPool) {
double[] result = new  double[length];
boolean typeMismatch = false;
int tag = 0;
for (int i = 0; i < length; i++) {
tag = buf.get();
if (tag == 'D') {
int index = buf.getShort() & 0xFFFF;
result[i] = constPool.getDoubleAt(index);
} else {
skipMemberValue(tag, buf);
typeMismatch = true;
}
}
return typeMismatch ? exceptionProxy(tag) : result;
}
private static Object parseFloatArray(int length,
ByteBuffer buf, ConstantPool constPool) {
float[] result = new float[length];
boolean typeMismatch = false;
int tag = 0;
for (int i = 0; i < length; i++) {
tag = buf.get();
if (tag == 'F') {
int index = buf.getShort() & 0xFFFF;
result[i] = constPool.getFloatAt(index);
} else {
skipMemberValue(tag, buf);
typeMismatch = true;
}
}
return typeMismatch ? exceptionProxy(tag) : result;
}
private static Object parseIntArray(int length,
ByteBuffer buf, ConstantPool constPool) {
int[] result = new  int[length];
boolean typeMismatch = false;
int tag = 0;
for (int i = 0; i < length; i++) {
tag = buf.get();
if (tag == 'I') {
int index = buf.getShort() & 0xFFFF;
result[i] = constPool.getIntAt(index);
} else {
skipMemberValue(tag, buf);
typeMismatch = true;
}
}
return typeMismatch ? exceptionProxy(tag) : result;
}
private static Object parseLongArray(int length,
ByteBuffer buf, ConstantPool constPool) {
long[] result = new long[length];
boolean typeMismatch = false;
int tag = 0;
for (int i = 0; i < length; i++) {
tag = buf.get();
if (tag == 'J') {
int index = buf.getShort() & 0xFFFF;
result[i] = constPool.getLongAt(index);
} else {
skipMemberValue(tag, buf);
typeMismatch = true;
}
}
return typeMismatch ? exceptionProxy(tag) : result;
}
private static Object parseShortArray(int length,
ByteBuffer buf, ConstantPool constPool) {
short[] result = new short[length];
boolean typeMismatch = false;
int tag = 0;
for (int i = 0; i < length; i++) {
tag = buf.get();
if (tag == 'S') {
int index = buf.getShort() & 0xFFFF;
result[i] = (short) constPool.getIntAt(index);
} else {
skipMemberValue(tag, buf);
typeMismatch = true;
}
}
return typeMismatch ? exceptionProxy(tag) : result;
}
private static Object parseBooleanArray(int length,
ByteBuffer buf, ConstantPool constPool) {
boolean[] result = new boolean[length];
boolean typeMismatch = false;
int tag = 0;
for (int i = 0; i < length; i++) {
tag = buf.get();
if (tag == 'Z') {
int index = buf.getShort() & 0xFFFF;
result[i] = (constPool.getIntAt(index) != 0);
} else {
skipMemberValue(tag, buf);
typeMismatch = true;
}
}
return typeMismatch ? exceptionProxy(tag) : result;
}
private static Object parseStringArray(int length,
ByteBuffer buf,  ConstantPool constPool) {
String[] result = new String[length];
boolean typeMismatch = false;
int tag = 0;
for (int i = 0; i < length; i++) {
tag = buf.get();
if (tag == 's') {
int index = buf.getShort() & 0xFFFF;
result[i] = constPool.getUTF8At(index);
} else {
skipMemberValue(tag, buf);
typeMismatch = true;
}
}
return typeMismatch ? exceptionProxy(tag) : result;
}
private static Object parseClassArray(int length,
ByteBuffer buf,
ConstantPool constPool,
Class<?> container) {
return parseArrayElements(new Class<?>[length],
buf, 'c', () -> parseClassValue(buf, constPool, container));
}
private static Object parseEnumArray(int length, Class<? extends Enum<?>> enumType,
ByteBuffer buf,
ConstantPool constPool,
Class<?> container) {
return parseArrayElements((Object[]) Array.newInstance(enumType, length),
buf, 'e', () -> parseEnumValue(enumType, buf, constPool, container));
}
private static Object parseAnnotationArray(int length,
Class<? extends Annotation> annotationType,
ByteBuffer buf,
ConstantPool constPool,
Class<?> container) {
return parseArrayElements((Object[]) Array.newInstance(annotationType, length),
buf, '@', () -> parseAnnotation(buf, constPool, container, true));
}
private static Object parseArrayElements(Object[] result,
ByteBuffer buf,
int expectedTag,
Supplier<Object> parseElement) {
Object exceptionProxy = null;
for (int i = 0; i < result.length; i++) {
int tag = buf.get();
if (tag == expectedTag) {
Object value = parseElement.get();
if (value instanceof ExceptionProxy proxyValue) {
if (exceptionProxy == null)
exceptionProxy = proxyValue;
} else {
result[i] = value;
}
} else {
skipMemberValue(tag, buf);
if (exceptionProxy == null) exceptionProxy = exceptionProxy(tag);
}
}
return (exceptionProxy != null) ? exceptionProxy : result;
}
private static Object parseUnknownArray(int length,
ByteBuffer buf) {
int tag = 0;
for (int i = 0; i < length; i++) {
tag = buf.get();
skipMemberValue(tag, buf);
}
return exceptionProxy(tag);
}
private static ExceptionProxy exceptionProxy(int tag) {
return new AnnotationTypeMismatchExceptionProxy(
"Array with component tag: " + (tag == 0 ? "0" : (char) tag));
}
private static void skipAnnotation(ByteBuffer buf, boolean complete) {
if (complete)
buf.getShort();           int numMembers = buf.getShort() & 0xFFFF;
for (int i = 0; i < numMembers; i++) {
buf.getShort();               skipMemberValue(buf);
}
}
private static void skipMemberValue(ByteBuffer buf) {
int tag = buf.get();
skipMemberValue(tag, buf);
}
private static void skipMemberValue(int tag, ByteBuffer buf) {
switch(tag) {
case 'e':             buf.getInt();              break;
case '@':
skipAnnotation(buf, true);
break;
case '[':
skipArray(buf);
break;
default:
buf.getShort();
}
}
private static void skipArray(ByteBuffer buf) {
int length = buf.getShort() & 0xFFFF;
for (int i = 0; i < length; i++)
skipMemberValue(buf);
}
private static boolean contains(Object[] array, Object element) {
for (Object e : array)
if (e == element)
return true;
return false;
}
private static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];
public static Annotation[] toArray(Map<Class<? extends Annotation>, Annotation> annotations) {
return annotations.values().toArray(EMPTY_ANNOTATION_ARRAY);
}
static Annotation[] getEmptyAnnotationArray() { return EMPTY_ANNOTATION_ARRAY; }
}
package com.sun.tools.javac.processing;
public class AnnotationProcessingError extends Error {
static final long serialVersionUID = 305337707019230790L;
AnnotationProcessingError(Throwable cause) {
super(cause);
}
}
package com.sun.tools.javac.model;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.lang.annotation.*;
import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.stream.Collectors;
import sun.reflect.annotation.*;
import javax.lang.model.type.MirroredTypeException;
import javax.lang.model.type.MirroredTypesException;
import javax.lang.model.type.TypeMirror;
import com.sun.tools.javac.code.*;
import com.sun.tools.javac.code.Symbol.*;
import com.sun.tools.javac.code.Type.ArrayType;
import com.sun.tools.javac.util.*;
import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
import static com.sun.tools.javac.code.Kinds.Kind.*;
public class AnnotationProxyMaker {
private final Attribute.Compound anno;
private final Class<? extends Annotation> annoType;
private AnnotationProxyMaker(Attribute.Compound anno,
Class<? extends Annotation> annoType) {
this.anno = anno;
this.annoType = annoType;
}
public static <A extends Annotation> A generateAnnotation(
Attribute.Compound anno, Class<A> annoType) {
AnnotationProxyMaker apm = new AnnotationProxyMaker(anno, annoType);
return annoType.cast(apm.generateAnnotation());
}
private Annotation generateAnnotation() {
return AnnotationParser.annotationForMap(annoType,
getAllReflectedValues());
}
private Map<String, Object> getAllReflectedValues() {
Map<String, Object> res = new LinkedHashMap<>();
for (Map.Entry<MethodSymbol, Attribute> entry :
getAllValues().entrySet()) {
MethodSymbol meth = entry.getKey();
Object value = generateValue(meth, entry.getValue());
if (value != null) {
res.put(meth.name.toString(), value);
} else {
}
}
return res;
}
private Map<MethodSymbol, Attribute> getAllValues() {
Map<MethodSymbol, Attribute> res = new LinkedHashMap<>();
ClassSymbol sym = (ClassSymbol) anno.type.tsym;
for (Symbol s : sym.members().getSymbols(NON_RECURSIVE)) {
if (s.kind == MTH) {
MethodSymbol m = (MethodSymbol) s;
Attribute def = m.getDefaultValue();
if (def != null)
res.put(m, def);
}
}
for (Pair<MethodSymbol, Attribute> p : anno.values)
res.put(p.fst, p.snd);
return res;
}
private Object generateValue(MethodSymbol meth, Attribute attr) {
ValueVisitor vv = new ValueVisitor(meth);
return vv.getValue(attr);
}
private class ValueVisitor implements Attribute.Visitor {
private MethodSymbol meth;              private Class<?> returnClass;           private Object value;
ValueVisitor(MethodSymbol meth) {
this.meth = meth;
}
Object getValue(Attribute attr) {
Method method;                          try {
method = annoType.getMethod(meth.name.toString());
} catch (NoSuchMethodException e) {
return null;
}
returnClass = method.getReturnType();
attr.accept(this);
if (!(value instanceof ExceptionProxy) &&
!AnnotationType.invocationHandlerReturnType(returnClass)
.isInstance(value)) {
typeMismatch(method, attr);
}
return value;
}
public void visitConstant(Attribute.Constant c) {
value = c.getValue();
}
public void visitClass(Attribute.Class c) {
value = new MirroredTypeExceptionProxy(c.classType);
}
public void visitArray(Attribute.Array a) {
Name elemName = ((ArrayType) a.type).elemtype.tsym.getQualifiedName();
if (elemName.equals(elemName.table.names.java_lang_Class)) {                                   ListBuffer<TypeMirror> elems = new ListBuffer<>();
for (Attribute value : a.values) {
Type elem = ((Attribute.Class) value).classType;
elems.append(elem);
}
value = new MirroredTypesExceptionProxy(elems.toList());
} else {
int len = a.values.length;
Class<?> returnClassSaved = returnClass;
returnClass = returnClass.getComponentType();
try {
Object res = Array.newInstance(returnClass, len);
for (int i = 0; i < len; i++) {
a.values[i].accept(this);
if (value == null || value instanceof ExceptionProxy) {
return;
}
try {
Array.set(res, i, value);
} catch (IllegalArgumentException e) {
value = null;                                   return;
}
}
value = res;
} finally {
returnClass = returnClassSaved;
}
}
}
@SuppressWarnings({"unchecked", "rawtypes"})
public void visitEnum(Attribute.Enum e) {
if (returnClass.isEnum()) {
String constName = e.value.toString();
try {
value = Enum.valueOf((Class)returnClass, constName);
} catch (IllegalArgumentException ex) {
value = new EnumConstantNotPresentExceptionProxy(
(Class<Enum<?>>) returnClass, constName);
}
} else {
value = null;               }
}
public void visitCompound(Attribute.Compound c) {
try {
Class<? extends Annotation> nested =
returnClass.asSubclass(Annotation.class);
value = generateAnnotation(c, nested);
} catch (ClassCastException ex) {
value = null;               }
}
public void visitError(Attribute.Error e) {
if (e instanceof Attribute.UnresolvedClass unresolvedClass)
value = new MirroredTypeExceptionProxy(unresolvedClass.classType);
else
value = null;               }
private void typeMismatch(Method method, final Attribute attr) {
class AnnotationTypeMismatchExceptionProxy extends ExceptionProxy {
static final long serialVersionUID = 269;
final transient Method method;
AnnotationTypeMismatchExceptionProxy(Method method) {
this.method = method;
}
public String toString() {
return "<error>";                   }
protected RuntimeException generateException() {
return new AnnotationTypeMismatchException(method,
attr.type.toString());
}
}
value = new AnnotationTypeMismatchExceptionProxy(method);
}
}
private static final class MirroredTypeExceptionProxy extends ExceptionProxy {
static final long serialVersionUID = 269;
private transient TypeMirror type;
private final String typeString;
MirroredTypeExceptionProxy(TypeMirror t) {
type = t;
typeString = t.toString();
}
public String toString() {
return typeString + ".class";
}
public int hashCode() {
return (type != null ? type : typeString).hashCode();
}
public boolean equals(Object obj) {
return type != null &&
obj instanceof MirroredTypeExceptionProxy proxy &&
type.equals(proxy.type);
}
protected RuntimeException generateException() {
return new MirroredTypeException(type);
}
private void readObject(ObjectInputStream s)
throws IOException, ClassNotFoundException {
s.defaultReadObject();
type = null;
}
}
private static final class MirroredTypesExceptionProxy extends ExceptionProxy {
static final long serialVersionUID = 269;
private transient List<TypeMirror> types;
private final String typeStrings;
MirroredTypesExceptionProxy(List<TypeMirror> ts) {
types = ts;
typeStrings = ts.toString();
}
public String toString() {
return types.stream()
.map(t -> t.toString() + ".class")
.collect(Collectors.joining(", ", "{", "}"));
}
public int hashCode() {
return (types != null ? types : typeStrings).hashCode();
}
public boolean equals(Object obj) {
return types != null &&
obj instanceof MirroredTypesExceptionProxy proxy &&
types.equals(proxy.types);
}
protected RuntimeException generateException() {
return new MirroredTypesException(types);
}
private void readObject(ObjectInputStream s)
throws IOException, ClassNotFoundException {
s.defaultReadObject();
types = null;
}
}
}
package jdk.internal.org.objectweb.asm.commons;
import jdk.internal.org.objectweb.asm.AnnotationVisitor;
import jdk.internal.org.objectweb.asm.Opcodes;
public class AnnotationRemapper extends AnnotationVisitor {
protected final String descriptor;
protected final Remapper remapper;
@Deprecated
public AnnotationRemapper(final AnnotationVisitor annotationVisitor, final Remapper remapper) {
this( null, annotationVisitor, remapper);
}
public AnnotationRemapper(
final String descriptor, final AnnotationVisitor annotationVisitor, final Remapper remapper) {
this( Opcodes.ASM9, descriptor, annotationVisitor, remapper);
}
@Deprecated
protected AnnotationRemapper(
final int api, final AnnotationVisitor annotationVisitor, final Remapper remapper) {
this(api,  null, annotationVisitor, remapper);
}
protected AnnotationRemapper(
final int api,
final String descriptor,
final AnnotationVisitor annotationVisitor,
final Remapper remapper) {
super(api, annotationVisitor);
this.descriptor = descriptor;
this.remapper = remapper;
}
@Override
public void visit(final String name, final Object value) {
super.visit(mapAnnotationAttributeName(name), remapper.mapValue(value));
}
@Override
public void visitEnum(final String name, final String descriptor, final String value) {
super.visitEnum(mapAnnotationAttributeName(name), remapper.mapDesc(descriptor), value);
}
@Override
public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {
AnnotationVisitor annotationVisitor =
super.visitAnnotation(mapAnnotationAttributeName(name), remapper.mapDesc(descriptor));
if (annotationVisitor == null) {
return null;
} else {
return annotationVisitor == av
? this
: createAnnotationRemapper(descriptor, annotationVisitor);
}
}
@Override
public AnnotationVisitor visitArray(final String name) {
AnnotationVisitor annotationVisitor = super.visitArray(mapAnnotationAttributeName(name));
if (annotationVisitor == null) {
return null;
} else {
return annotationVisitor == av
? this
: createAnnotationRemapper( null, annotationVisitor);
}
}
@Deprecated
protected AnnotationVisitor createAnnotationRemapper(final AnnotationVisitor annotationVisitor) {
return new AnnotationRemapper(api,  null, annotationVisitor, remapper);
}
protected AnnotationVisitor createAnnotationRemapper(
final String descriptor, final AnnotationVisitor annotationVisitor) {
return new AnnotationRemapper(api, descriptor, annotationVisitor, remapper)
.orDeprecatedValue(createAnnotationRemapper(annotationVisitor));
}
final AnnotationVisitor orDeprecatedValue(final AnnotationVisitor deprecatedAnnotationVisitor) {
if (deprecatedAnnotationVisitor.getClass() == getClass()) {
AnnotationRemapper deprecatedAnnotationRemapper =
(AnnotationRemapper) deprecatedAnnotationVisitor;
if (deprecatedAnnotationRemapper.api == api
&& deprecatedAnnotationRemapper.av == av
&& deprecatedAnnotationRemapper.remapper == remapper) {
return this;
}
}
return deprecatedAnnotationVisitor;
}
private String mapAnnotationAttributeName(final String name) {
if (descriptor == null) {
return name;
}
return remapper.mapAnnotationAttributeName(descriptor, name);
}
}
package com.sun.org.apache.bcel.internal.classfile;
import java.io.DataInput;
import java.io.DataOutputStream;
import java.io.IOException;
public abstract class Annotations extends Attribute {
private AnnotationEntry[] annotationTable;
private final boolean isRuntimeVisible;
Annotations(final byte annotation_type, final int name_index, final int length, final DataInput input,
final ConstantPool constant_pool, final boolean isRuntimeVisible) throws IOException {
this(annotation_type, name_index, length, (AnnotationEntry[]) null, constant_pool, isRuntimeVisible);
final int annotation_table_length = input.readUnsignedShort();
annotationTable = new AnnotationEntry[annotation_table_length];
for (int i = 0; i < annotation_table_length; i++) {
annotationTable[i] = AnnotationEntry.read(input, constant_pool, isRuntimeVisible);
}
}
public Annotations(final byte annotationType, final int nameIndex, final int length, final AnnotationEntry[] annotationTable,
final ConstantPool constantPool, final boolean isRuntimeVisible) {
super(annotationType, nameIndex, length, constantPool);
this.annotationTable = annotationTable;
this.isRuntimeVisible = isRuntimeVisible;
}
@Override
public void accept(final Visitor v) {
v.visitAnnotation(this);
}
public final void setAnnotationTable(final AnnotationEntry[] annotationTable) {
this.annotationTable = annotationTable;
}
public AnnotationEntry[] getAnnotationEntries() {
return annotationTable;
}
public final int getNumAnnotations() {
if (annotationTable == null) {
return 0;
}
return annotationTable.length;
}
public boolean isRuntimeVisible() {
return isRuntimeVisible;
}
protected void writeAnnotations(final DataOutputStream dos) throws IOException {
if (annotationTable == null) {
return;
}
dos.writeShort(annotationTable.length);
for (final AnnotationEntry element : annotationTable) {
element.dump(dos);
}
}
}
package sun.reflect.annotation;
import java.lang.annotation.*;
import java.lang.reflect.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import jdk.internal.access.SharedSecrets;
import jdk.internal.access.JavaLangAccess;
import jdk.internal.reflect.ReflectionFactory;
public final class AnnotationSupport {
private static final JavaLangAccess LANG_ACCESS = SharedSecrets.getJavaLangAccess();
public static <A extends Annotation> A[] getDirectlyAndIndirectlyPresent(
Map<Class<? extends Annotation>, Annotation> annotations,
Class<A> annoClass) {
List<A> result = new ArrayList<>();
@SuppressWarnings("unchecked")
A direct = (A) annotations.get(annoClass);
if (direct != null)
result.add(direct);
A[] indirect = getIndirectlyPresent(annotations, annoClass);
if (indirect != null && indirect.length != 0) {
boolean indirectFirst = direct == null ||
containerBeforeContainee(annotations, annoClass);
result.addAll((indirectFirst ? 0 : 1), Arrays.asList(indirect));
}
@SuppressWarnings("unchecked")
A[] arr = (A[]) Array.newInstance(annoClass, result.size());
return result.toArray(arr);
}
private static <A extends Annotation> A[] getIndirectlyPresent(
Map<Class<? extends Annotation>, Annotation> annotations,
Class<A> annoClass) {
Repeatable repeatable = annoClass.getDeclaredAnnotation(Repeatable.class);
if (repeatable == null)
return null;
Class<? extends Annotation> containerClass = repeatable.value();
Annotation container = annotations.get(containerClass);
if (container == null)
return null;
A[] valueArray = getValueArray(container);
checkTypes(valueArray, container, annoClass);
return valueArray;
}
private static <A extends Annotation> boolean containerBeforeContainee(
Map<Class<? extends Annotation>, Annotation> annotations,
Class<A> annoClass) {
Class<? extends Annotation> containerClass =
annoClass.getDeclaredAnnotation(Repeatable.class).value();
for (Class<? extends Annotation> c : annotations.keySet()) {
if (c == containerClass) return true;
if (c == annoClass) return false;
}
return false;
}
public static <A extends Annotation> A[] getAssociatedAnnotations(
Map<Class<? extends Annotation>, Annotation> declaredAnnotations,
Class<?> decl,
Class<A> annoClass) {
Objects.requireNonNull(decl);
A[] result = getDirectlyAndIndirectlyPresent(declaredAnnotations, annoClass);
if(AnnotationType.getInstance(annoClass).isInherited()) {
Class<?> superDecl = decl.getSuperclass();
while (result.length == 0 && superDecl != null) {
result = getDirectlyAndIndirectlyPresent(LANG_ACCESS.getDeclaredAnnotationMap(superDecl), annoClass);
superDecl = superDecl.getSuperclass();
}
}
return result;
}
@SuppressWarnings("removal")
private static <A extends Annotation> A[] getValueArray(Annotation container) {
try {
Class<? extends Annotation> containerClass = container.annotationType();
AnnotationType annoType = AnnotationType.getInstance(containerClass);
if (annoType == null)
throw invalidContainerException(container, null);
Method m = annoType.members().get("value");
if (m == null)
throw invalidContainerException(container, null);
if (Proxy.isProxyClass(container.getClass())) {
InvocationHandler handler = Proxy.getInvocationHandler(container);
try {
@SuppressWarnings("unchecked")
A[] values = (A[]) handler.invoke(container, m, null);
return values;
} catch (Throwable t) {                     throw invalidContainerException(container, t);
}
} else {
Class<?> iface = m.getDeclaringClass();
if (!iface.isAnnotation())
throw new UnsupportedOperationException("Unsupported container annotation type.");
if (!Modifier.isPublic(m.getModifiers()))
throw new UnsupportedOperationException("Unsupported value member.");
final Method toInvoke;
if (!Modifier.isPublic(iface.getModifiers())) {
if (System.getSecurityManager() != null) {
toInvoke = AccessController.doPrivileged(new PrivilegedAction<Method>() {
@Override
public Method run() {
Method res = ReflectionFactory.getReflectionFactory().leafCopyMethod(m);
res.setAccessible(true);
return res;
}
});
} else {
toInvoke = ReflectionFactory.getReflectionFactory().leafCopyMethod(m);
toInvoke.setAccessible(true);
}
} else {
toInvoke = m;
}
@SuppressWarnings("unchecked")
A[] values = (A[]) toInvoke.invoke(container);
return values;
}
} catch (IllegalAccessException    |                  IllegalArgumentException  |                  InvocationTargetException |                  ClassCastException e) {
throw invalidContainerException(container, e);
}
}
private static AnnotationFormatError invalidContainerException(Annotation anno,
Throwable cause) {
return new AnnotationFormatError(
anno + " is an invalid container for repeating annotations",
cause);
}
private static <A extends Annotation> void checkTypes(A[] annotations,
Annotation container,
Class<A> annoClass) {
for (A a : annotations) {
if (!annoClass.isInstance(a)) {
throw new AnnotationFormatError(
String.format("%s is an invalid container for " +
"repeating annotations of type: %s",
container, annoClass));
}
}
}
}
package com.sun.source.tree;
import java.util.List;
public interface AnnotationTree extends ExpressionTree {
Tree getAnnotationType();
List<? extends ExpressionTree> getArguments();
}
package sun.reflect.annotation;
import java.lang.annotation.*;
import java.lang.reflect.*;
import java.util.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import jdk.internal.access.SharedSecrets;
import jdk.internal.access.JavaLangAccess;
public class AnnotationType {
private final Map<String, Class<?>> memberTypes;
private final Map<String, Object> memberDefaults;
private final Map<String, Method> members;
private final RetentionPolicy retention;
private final boolean inherited;
public static AnnotationType getInstance(
Class<? extends Annotation> annotationClass)
{
JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
AnnotationType result = jla.getAnnotationType(annotationClass);         if (result == null) {
result = new AnnotationType(annotationClass);
if (!jla.casAnnotationType(annotationClass, null, result)) {
result = jla.getAnnotationType(annotationClass);
assert result != null;
}
}
return result;
}
private AnnotationType(final Class<? extends Annotation> annotationClass) {
if (!annotationClass.isAnnotation())
throw new IllegalArgumentException("Not an annotation type");
@SuppressWarnings("removal")
Method[] methods =
AccessController.doPrivileged(new PrivilegedAction<>() {
public Method[] run() {
return annotationClass.getDeclaredMethods();
}
});
memberTypes = new HashMap<>(methods.length+1, 1.0f);
memberDefaults = new HashMap<>(0);
members = new HashMap<>(methods.length+1, 1.0f);
for (Method method : methods) {
if (Modifier.isPublic(method.getModifiers()) &&
Modifier.isAbstract(method.getModifiers()) &&
!method.isSynthetic()) {
if (method.getParameterCount() != 0) {
throw new IllegalArgumentException(method + " has params");
}
String name = method.getName();
Class<?> type = method.getReturnType();
memberTypes.put(name, invocationHandlerReturnType(type));
members.put(name, method);
Object defaultValue = method.getDefaultValue();
if (defaultValue != null) {
memberDefaults.put(name, defaultValue);
}
}
}
if (annotationClass != Retention.class &&
annotationClass != Inherited.class) {
JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
Map<Class<? extends Annotation>, Annotation> metaAnnotations =
AnnotationParser.parseSelectAnnotations(
jla.getRawClassAnnotations(annotationClass),
jla.getConstantPool(annotationClass),
annotationClass,
Retention.class, Inherited.class
);
Retention ret = (Retention) metaAnnotations.get(Retention.class);
retention = (ret == null ? RetentionPolicy.CLASS : ret.value());
inherited = metaAnnotations.containsKey(Inherited.class);
}
else {
retention = RetentionPolicy.RUNTIME;
inherited = false;
}
}
public static Class<?> invocationHandlerReturnType(Class<?> type) {
if (type == byte.class)
return Byte.class;
if (type == char.class)
return Character.class;
if (type == double.class)
return Double.class;
if (type == float.class)
return Float.class;
if (type == int.class)
return Integer.class;
if (type == long.class)
return Long.class;
if (type == short.class)
return Short.class;
if (type == boolean.class)
return Boolean.class;
return type;
}
public Map<String, Class<?>> memberTypes() {
return memberTypes;
}
public Map<String, Method> members() {
return members;
}
public Map<String, Object> memberDefaults() {
return memberDefaults;
}
public RetentionPolicy retention() {
return retention;
}
public boolean isInherited() {
return inherited;
}
public String toString() {
return "Annotation Type:\n" +
"   Member types: " + memberTypes + "\n" +
"   Member defaults: " + memberDefaults + "\n" +
"   Retention policy: " + retention + "\n" +
"   Inherited: " + inherited;
}
}
package jdk.javadoc.internal.doclets.toolkit.builders;
import java.util.*;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeMemberWriter;
import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
import jdk.javadoc.internal.doclets.toolkit.Content;
import jdk.javadoc.internal.doclets.toolkit.DocletException;
import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;
public class AnnotationTypeMemberBuilder extends AbstractMemberBuilder {
protected AnnotationTypeMemberWriter writer;
protected List<Element> members;
protected Element currentMember;
protected AnnotationTypeMemberBuilder(Context context,
TypeElement typeElement,
AnnotationTypeMemberWriter writer) {
super(context, typeElement);
this.writer = Objects.requireNonNull(writer);
this.members = getVisibleMembers(ANNOTATION_TYPE_MEMBER);
}
public static AnnotationTypeMemberBuilder getInstance(
Context context, TypeElement typeElement,
AnnotationTypeMemberWriter writer) {
return new AnnotationTypeMemberBuilder(context, typeElement,
writer);
}
@Override
public boolean hasMembersToDocument() {
return !members.isEmpty();
}
@Override
public void build(Content target) throws DocletException {
buildAnnotationTypeMember(target);
}
protected void buildAnnotationTypeMember(Content target)
throws DocletException {
if (hasMembersToDocument()) {
writer.addAnnotationDetailsMarker(target);
Content annotationDetailsHeader = writer.getAnnotationDetailsHeader();
Content memberList = writer.getMemberList();
for (Element member : members) {
currentMember = member;
Content annotationContent = writer.getAnnotationHeaderContent(currentMember);
buildAnnotationTypeMemberChildren(annotationContent);
memberList.add(writer.getMemberListItem(annotationContent));
}
Content annotationDetails = writer.getAnnotationDetails(annotationDetailsHeader, memberList);
target.add(annotationDetails);
}
}
protected void buildAnnotationTypeMemberChildren(Content annotationContent) {
buildSignature(annotationContent);
buildDeprecationInfo(annotationContent);
buildPreviewInfo(annotationContent);
buildMemberComments(annotationContent);
buildTagInfo(annotationContent);
buildDefaultValueInfo(annotationContent);
}
protected void buildSignature(Content target) {
target.add(writer.getSignature(currentMember));
}
protected void buildDeprecationInfo(Content annotationContent) {
writer.addDeprecated(currentMember, annotationContent);
}
protected void buildPreviewInfo(Content annotationContent) {
writer.addPreview(currentMember, annotationContent);
}
protected void buildMemberComments(Content annotationContent) {
if (!options.noComment()) {
writer.addComments(currentMember, annotationContent);
}
}
protected void buildTagInfo(Content annotationContent) {
writer.addTags(currentMember, annotationContent);
}
protected void buildDefaultValueInfo(Content annotationContent) {
writer.addDefaultValueInfo(currentMember, annotationContent);
}
public AnnotationTypeMemberWriter getWriter() {
return writer;
}
}
package jdk.javadoc.internal.doclets.toolkit;
import javax.lang.model.element.Element;
public interface AnnotationTypeMemberWriter extends MemberWriter {
Content getMemberHeader();
void addAnnotationDetailsMarker(Content memberDetails);
Content getAnnotationDetailsHeader();
Content getAnnotationHeaderContent(Element member);
Content getAnnotationDetails(Content annotationDetailsHeader, Content annotationDetails);
Content getSignature(Element member);
void addDeprecated(Element member, Content target);
void addPreview(Element member, Content content);
void addComments(Element member, Content annotationContent);
void addTags(Element member, Content annotationContent);
void addDefaultValueInfo(Element member, Content annotationContent);
}
package jdk.javadoc.internal.doclets.formats.html;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.AnnotationValue;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import jdk.javadoc.internal.doclets.formats.html.markup.Comment;
import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
import jdk.javadoc.internal.doclets.formats.html.markup.Text;
import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeMemberWriter;
import jdk.javadoc.internal.doclets.toolkit.Content;
import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;
public class AnnotationTypeMemberWriterImpl extends AbstractMemberWriter
implements AnnotationTypeMemberWriter, MemberSummaryWriter {
enum Kind {
OPTIONAL,
REQUIRED,
ANY
}
private final Kind kind;
public AnnotationTypeMemberWriterImpl(SubWriterHolderWriter writer) {
super(writer);
this.kind = Kind.ANY;
}
public AnnotationTypeMemberWriterImpl(SubWriterHolderWriter writer,
TypeElement annotationType,
Kind kind) {
super(writer, annotationType);
this.kind = kind;
}
@Override
public Content getMemberSummaryHeader(TypeElement typeElement,
Content content) {
switch (kind) {
case OPTIONAL -> content.add(selectComment(
MarkerComments.START_OF_ANNOTATION_TYPE_OPTIONAL_MEMBER_SUMMARY,
MarkerComments.START_OF_ANNOTATION_INTERFACE_OPTIONAL_MEMBER_SUMMARY));
case REQUIRED -> content.add(selectComment(
MarkerComments.START_OF_ANNOTATION_TYPE_REQUIRED_MEMBER_SUMMARY,
MarkerComments.START_OF_ANNOTATION_INTERFACE_REQUIRED_MEMBER_SUMMARY));
case ANY -> throw new UnsupportedOperationException("unsupported member kind");
}
Content c = new ContentBuilder();
writer.addSummaryHeader(this, c);
return c;
}
@Override
public Content getMemberHeader() {
return writer.getMemberHeader();
}
@Override
public void addSummary(Content summariesList, Content content) {
writer.addSummary(HtmlStyle.memberSummary,
switch (kind) {
case REQUIRED -> HtmlIds.ANNOTATION_TYPE_REQUIRED_ELEMENT_SUMMARY;
case OPTIONAL -> HtmlIds.ANNOTATION_TYPE_OPTIONAL_ELEMENT_SUMMARY;
case ANY -> throw new UnsupportedOperationException("unsupported member kind");
},
summariesList, content);
}
@Override
public void addAnnotationDetailsMarker(Content memberDetails) {
memberDetails.add(selectComment(
MarkerComments.START_OF_ANNOTATION_TYPE_DETAILS,
MarkerComments.START_OF_ANNOTATION_INTERFACE_DETAILS));
}
@Override
public Content getAnnotationDetailsHeader() {
Content memberDetails = new ContentBuilder();
var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,
contents.annotationTypeDetailsLabel);
memberDetails.add(heading);
return memberDetails;
}
@Override
public Content getAnnotationHeaderContent(Element member) {
Content content = new ContentBuilder();
var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,
Text.of(name(member)));
content.add(heading);
return HtmlTree.SECTION(HtmlStyle.detail, content)
.setId(htmlIds.forMember(typeElement, (ExecutableElement) member));
}
@Override
public Content getSignature(Element member) {
return new Signatures.MemberSignature(member, this)
.setType(getType(member))
.setAnnotations(writer.getAnnotationInfo(member, true))
.toContent();
}
@Override
public void addDeprecated(Element member, Content target) {
addDeprecatedInfo(member, target);
}
@Override
public void addPreview(Element member, Content content) {
addPreviewInfo(member, content);
}
@Override
public void addComments(Element member, Content annotationContent) {
addComment(member, annotationContent);
}
@Override
public void addTags(Element member, Content annotationContent) {
writer.addTagsInfo(member, annotationContent);
}
@Override
public Content getAnnotationDetails(Content annotationDetailsHeader, Content annotationDetails) {
Content c = new ContentBuilder(annotationDetailsHeader, annotationDetails);
return getMember(HtmlTree.SECTION(HtmlStyle.memberDetails, c));
}
@Override
public void addSummaryLabel(Content content) {
var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,
switch (kind) {
case REQUIRED -> contents.annotateTypeRequiredMemberSummaryLabel;
case OPTIONAL -> contents.annotateTypeOptionalMemberSummaryLabel;
case ANY -> throw new UnsupportedOperationException("unsupported member kind");
});
content.add(label);
}
protected Content getCaption() {
return contents.getContent(
switch (kind) {
case REQUIRED -> "doclet.Annotation_Type_Required_Members";
case OPTIONAL -> "doclet.Annotation_Type_Optional_Members";
case ANY -> throw new UnsupportedOperationException("unsupported member kind");
});
}
@Override
public TableHeader getSummaryTableHeader(Element member) {
return new TableHeader(contents.modifierAndTypeLabel,
switch (kind) {
case REQUIRED -> contents.annotationTypeRequiredMemberLabel;
case OPTIONAL -> contents.annotationTypeOptionalMemberLabel;
case ANY -> throw new UnsupportedOperationException("unsupported member kind");
},
contents.descriptionLabel);
}
@Override
protected Table createSummaryTable() {
return new Table(HtmlStyle.summaryTable)
.setCaption(getCaption())
.setHeader(getSummaryTableHeader(typeElement))
.setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);
}
@Override
public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {
}
@Override
protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,
Content content) {
Content memberLink = writer.getDocLink(context, utils.getEnclosingTypeElement(member), member,
name(member), HtmlStyle.memberNameLink);
var code = HtmlTree.CODE(memberLink);
content.add(code);
}
@Override
protected void addInheritedSummaryLink(TypeElement typeElement,
Element member, Content target) {
}
@Override
protected void addSummaryType(Element member, Content content) {
addModifiersAndType(member, getType(member), content);
}
@Override
protected Content getSummaryLink(Element member) {
String name = utils.getFullyQualifiedName(member) + "." + member.getSimpleName();
return writer.getDocLink(HtmlLinkInfo.Kind.MEMBER_DEPRECATED_PREVIEW, member, name);
}
protected Comment selectComment(Comment c1, Comment c2) {
HtmlConfiguration configuration = writer.configuration;
SourceVersion sv = configuration.docEnv.getSourceVersion();
return sv.compareTo(SourceVersion.RELEASE_16) < 0 ? c1 : c2;
}
private TypeMirror getType(Element member) {
return utils.isExecutableElement(member)
? utils.getReturnType(typeElement, (ExecutableElement) member)
: member.asType();
}
public void addDefaultValueInfo(Element member, Content annotationContent) {
if (utils.isAnnotationInterface(member.getEnclosingElement())) {
ExecutableElement ee = (ExecutableElement) member;
AnnotationValue value = ee.getDefaultValue();
if (value != null) {
var dl = HtmlTree.DL(HtmlStyle.notes);
dl.add(HtmlTree.DT(contents.default_));
dl.add(HtmlTree.DD(HtmlTree.CODE(Text.of(value.toString()))));
annotationContent.add(dl);
}
}
}
}
package java.lang.annotation;
import java.lang.reflect.Method;
public class AnnotationTypeMismatchException extends RuntimeException {
@java.io.Serial
private static final long serialVersionUID = 8125925355765570191L;
private final transient Method element;
private final String foundType;
public AnnotationTypeMismatchException(Method element, String foundType) {
super("Incorrectly typed data found for annotation element " + element
+ " (Found data of type " + foundType + ")");
this.element = element;
this.foundType = foundType;
}
public Method element() {
return this.element;
}
public String foundType() {
return this.foundType;
}
}
package sun.reflect.annotation;
import java.lang.annotation.*;
import java.lang.reflect.Method;
class AnnotationTypeMismatchExceptionProxy extends ExceptionProxy {
@java.io.Serial
private static final long serialVersionUID = 7844069490309503934L;
@SuppressWarnings("serial")     private Method member;     private final String foundType;
AnnotationTypeMismatchExceptionProxy(String foundType) {
this.foundType = foundType;
}
AnnotationTypeMismatchExceptionProxy setMember(Method member) {
this.member = member;
return this;
}
protected RuntimeException generateException() {
return new AnnotationTypeMismatchException(member, foundType);
}
@Override
public String toString() {
return "" ;
}
}
package javax.lang.model.element;
public interface AnnotationValue {
Object getValue();
String toString();
<R, P> R accept(AnnotationValueVisitor<R, P> v, P p);
}
package javax.lang.model.element;
import java.util.List;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.*;
public interface AnnotationValueVisitor<R, P> {
R visit(AnnotationValue av, P p);
default R visit(AnnotationValue av) {
return visit(av, null);
}
R visitBoolean(boolean b, P p);
R visitByte(byte b, P p);
R visitChar(char c, P p);
R visitDouble(double d, P p);
R visitFloat(float f, P p);
R visitInt(int i, P p);
R visitLong(long i, P p);
R visitShort(short s, P p);
R visitString(String s, P p);
R visitType(TypeMirror t, P p);
R visitEnumConstant(VariableElement c, P p);
R visitAnnotation(AnnotationMirror a, P p);
R visitArray(List<? extends AnnotationValue> vals, P p);
R visitUnknown(AnnotationValue av, P p);
}
package jdk.internal.org.objectweb.asm;
public abstract class AnnotationVisitor {
protected final int api;
protected AnnotationVisitor av;
protected AnnotationVisitor(final int api) {
this(api, null);
}
protected AnnotationVisitor(final int api, final AnnotationVisitor annotationVisitor) {
if (api != Opcodes.ASM9
&& api != Opcodes.ASM8
&& api != Opcodes.ASM7
&& api != Opcodes.ASM6
&& api != Opcodes.ASM5
&& api != Opcodes.ASM4) {
throw new IllegalArgumentException("Unsupported api " + api);
}
this.api = api;
this.av = annotationVisitor;
}
public void visit(final String name, final Object value) {
if (av != null) {
av.visit(name, value);
}
}
public void visitEnum(final String name, final String descriptor, final String value) {
if (av != null) {
av.visitEnum(name, descriptor, value);
}
}
public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {
if (av != null) {
return av.visitAnnotation(name, descriptor);
}
return null;
}
public AnnotationVisitor visitArray(final String name) {
if (av != null) {
return av.visitArray(name);
}
return null;
}
public void visitEnd() {
if (av != null) {
av.visitEnd();
}
}
}
package jdk.internal.org.objectweb.asm;
final class AnnotationWriter extends AnnotationVisitor {
private final SymbolTable symbolTable;
private final boolean useNamedValues;
private final ByteVector annotation;
private final int numElementValuePairsOffset;
private int numElementValuePairs;
private final AnnotationWriter previousAnnotation;
private AnnotationWriter nextAnnotation;
AnnotationWriter(
final SymbolTable symbolTable,
final boolean useNamedValues,
final ByteVector annotation,
final AnnotationWriter previousAnnotation) {
super( Opcodes.ASM9);
this.symbolTable = symbolTable;
this.useNamedValues = useNamedValues;
this.annotation = annotation;
this.numElementValuePairsOffset = annotation.length == 0 ? -1 : annotation.length - 2;
this.previousAnnotation = previousAnnotation;
if (previousAnnotation != null) {
previousAnnotation.nextAnnotation = this;
}
}
static AnnotationWriter create(
final SymbolTable symbolTable,
final String descriptor,
final AnnotationWriter previousAnnotation) {
ByteVector annotation = new ByteVector();
annotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);
return new AnnotationWriter(
symbolTable,  true, annotation, previousAnnotation);
}
static AnnotationWriter create(
final SymbolTable symbolTable,
final int typeRef,
final TypePath typePath,
final String descriptor,
final AnnotationWriter previousAnnotation) {
ByteVector typeAnnotation = new ByteVector();
TypeReference.putTarget(typeRef, typeAnnotation);
TypePath.put(typePath, typeAnnotation);
typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);
return new AnnotationWriter(
symbolTable,  true, typeAnnotation, previousAnnotation);
}
@Override
public void visit(final String name, final Object value) {
++numElementValuePairs;
if (useNamedValues) {
annotation.putShort(symbolTable.addConstantUtf8(name));
}
if (value instanceof String) {
annotation.put12('s', symbolTable.addConstantUtf8((String) value));
} else if (value instanceof Byte) {
annotation.put12('B', symbolTable.addConstantInteger(((Byte) value).byteValue()).index);
} else if (value instanceof Boolean) {
int booleanValue = ((Boolean) value).booleanValue() ? 1 : 0;
annotation.put12('Z', symbolTable.addConstantInteger(booleanValue).index);
} else if (value instanceof Character) {
annotation.put12('C', symbolTable.addConstantInteger(((Character) value).charValue()).index);
} else if (value instanceof Short) {
annotation.put12('S', symbolTable.addConstantInteger(((Short) value).shortValue()).index);
} else if (value instanceof Type) {
annotation.put12('c', symbolTable.addConstantUtf8(((Type) value).getDescriptor()));
} else if (value instanceof byte[]) {
byte[] byteArray = (byte[]) value;
annotation.put12('[', byteArray.length);
for (byte byteValue : byteArray) {
annotation.put12('B', symbolTable.addConstantInteger(byteValue).index);
}
} else if (value instanceof boolean[]) {
boolean[] booleanArray = (boolean[]) value;
annotation.put12('[', booleanArray.length);
for (boolean booleanValue : booleanArray) {
annotation.put12('Z', symbolTable.addConstantInteger(booleanValue ? 1 : 0).index);
}
} else if (value instanceof short[]) {
short[] shortArray = (short[]) value;
annotation.put12('[', shortArray.length);
for (short shortValue : shortArray) {
annotation.put12('S', symbolTable.addConstantInteger(shortValue).index);
}
} else if (value instanceof char[]) {
char[] charArray = (char[]) value;
annotation.put12('[', charArray.length);
for (char charValue : charArray) {
annotation.put12('C', symbolTable.addConstantInteger(charValue).index);
}
} else if (value instanceof int[]) {
int[] intArray = (int[]) value;
annotation.put12('[', intArray.length);
for (int intValue : intArray) {
annotation.put12('I', symbolTable.addConstantInteger(intValue).index);
}
} else if (value instanceof long[]) {
long[] longArray = (long[]) value;
annotation.put12('[', longArray.length);
for (long longValue : longArray) {
annotation.put12('J', symbolTable.addConstantLong(longValue).index);
}
} else if (value instanceof float[]) {
float[] floatArray = (float[]) value;
annotation.put12('[', floatArray.length);
for (float floatValue : floatArray) {
annotation.put12('F', symbolTable.addConstantFloat(floatValue).index);
}
} else if (value instanceof double[]) {
double[] doubleArray = (double[]) value;
annotation.put12('[', doubleArray.length);
for (double doubleValue : doubleArray) {
annotation.put12('D', symbolTable.addConstantDouble(doubleValue).index);
}
} else {
Symbol symbol = symbolTable.addConstant(value);
annotation.put12(".s.IFJDCS".charAt(symbol.tag), symbol.index);
}
}
@Override
public void visitEnum(final String name, final String descriptor, final String value) {
++numElementValuePairs;
if (useNamedValues) {
annotation.putShort(symbolTable.addConstantUtf8(name));
}
annotation
.put12('e', symbolTable.addConstantUtf8(descriptor))
.putShort(symbolTable.addConstantUtf8(value));
}
@Override
public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {
++numElementValuePairs;
if (useNamedValues) {
annotation.putShort(symbolTable.addConstantUtf8(name));
}
annotation.put12('@', symbolTable.addConstantUtf8(descriptor)).putShort(0);
return new AnnotationWriter(symbolTable,  true, annotation, null);
}
@Override
public AnnotationVisitor visitArray(final String name) {
++numElementValuePairs;
if (useNamedValues) {
annotation.putShort(symbolTable.addConstantUtf8(name));
}
annotation.put12('[', 0);
return new AnnotationWriter(symbolTable,  false, annotation, null);
}
@Override
public void visitEnd() {
if (numElementValuePairsOffset != -1) {
byte[] data = annotation.data;
data[numElementValuePairsOffset] = (byte) (numElementValuePairs >>> 8);
data[numElementValuePairsOffset + 1] = (byte) numElementValuePairs;
}
}
int computeAnnotationsSize(final String attributeName) {
if (attributeName != null) {
symbolTable.addConstantUtf8(attributeName);
}
int attributeSize = 8;
AnnotationWriter annotationWriter = this;
while (annotationWriter != null) {
attributeSize += annotationWriter.annotation.length;
annotationWriter = annotationWriter.previousAnnotation;
}
return attributeSize;
}
static int computeAnnotationsSize(
final AnnotationWriter lastRuntimeVisibleAnnotation,
final AnnotationWriter lastRuntimeInvisibleAnnotation,
final AnnotationWriter lastRuntimeVisibleTypeAnnotation,
final AnnotationWriter lastRuntimeInvisibleTypeAnnotation) {
int size = 0;
if (lastRuntimeVisibleAnnotation != null) {
size +=
lastRuntimeVisibleAnnotation.computeAnnotationsSize(
Constants.RUNTIME_VISIBLE_ANNOTATIONS);
}
if (lastRuntimeInvisibleAnnotation != null) {
size +=
lastRuntimeInvisibleAnnotation.computeAnnotationsSize(
Constants.RUNTIME_INVISIBLE_ANNOTATIONS);
}
if (lastRuntimeVisibleTypeAnnotation != null) {
size +=
lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(
Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);
}
if (lastRuntimeInvisibleTypeAnnotation != null) {
size +=
lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(
Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);
}
return size;
}
void putAnnotations(final int attributeNameIndex, final ByteVector output) {
int attributeLength = 2;         int numAnnotations = 0;
AnnotationWriter annotationWriter = this;
AnnotationWriter firstAnnotation = null;
while (annotationWriter != null) {
annotationWriter.visitEnd();
attributeLength += annotationWriter.annotation.length;
numAnnotations++;
firstAnnotation = annotationWriter;
annotationWriter = annotationWriter.previousAnnotation;
}
output.putShort(attributeNameIndex);
output.putInt(attributeLength);
output.putShort(numAnnotations);
annotationWriter = firstAnnotation;
while (annotationWriter != null) {
output.putByteArray(annotationWriter.annotation.data, 0, annotationWriter.annotation.length);
annotationWriter = annotationWriter.nextAnnotation;
}
}
static void putAnnotations(
final SymbolTable symbolTable,
final AnnotationWriter lastRuntimeVisibleAnnotation,
final AnnotationWriter lastRuntimeInvisibleAnnotation,
final AnnotationWriter lastRuntimeVisibleTypeAnnotation,
final AnnotationWriter lastRuntimeInvisibleTypeAnnotation,
final ByteVector output) {
if (lastRuntimeVisibleAnnotation != null) {
lastRuntimeVisibleAnnotation.putAnnotations(
symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_ANNOTATIONS), output);
}
if (lastRuntimeInvisibleAnnotation != null) {
lastRuntimeInvisibleAnnotation.putAnnotations(
symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_ANNOTATIONS), output);
}
if (lastRuntimeVisibleTypeAnnotation != null) {
lastRuntimeVisibleTypeAnnotation.putAnnotations(
symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output);
}
if (lastRuntimeInvisibleTypeAnnotation != null) {
lastRuntimeInvisibleTypeAnnotation.putAnnotations(
symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output);
}
}
static int computeParameterAnnotationsSize(
final String attributeName,
final AnnotationWriter[] annotationWriters,
final int annotableParameterCount) {
int attributeSize = 7 + 2 * annotableParameterCount;
for (int i = 0; i < annotableParameterCount; ++i) {
AnnotationWriter annotationWriter = annotationWriters[i];
attributeSize +=
annotationWriter == null ? 0 : annotationWriter.computeAnnotationsSize(attributeName) - 8;
}
return attributeSize;
}
static void putParameterAnnotations(
final int attributeNameIndex,
final AnnotationWriter[] annotationWriters,
final int annotableParameterCount,
final ByteVector output) {
int attributeLength = 1 + 2 * annotableParameterCount;
for (int i = 0; i < annotableParameterCount; ++i) {
AnnotationWriter annotationWriter = annotationWriters[i];
attributeLength +=
annotationWriter == null ? 0 : annotationWriter.computeAnnotationsSize(null) - 8;
}
output.putShort(attributeNameIndex);
output.putInt(attributeLength);
output.putByte(annotableParameterCount);
for (int i = 0; i < annotableParameterCount; ++i) {
AnnotationWriter annotationWriter = annotationWriters[i];
AnnotationWriter firstAnnotation = null;
int numAnnotations = 0;
while (annotationWriter != null) {
annotationWriter.visitEnd();
numAnnotations++;
firstAnnotation = annotationWriter;
annotationWriter = annotationWriter.previousAnnotation;
}
output.putShort(numAnnotations);
annotationWriter = firstAnnotation;
while (annotationWriter != null) {
output.putByteArray(
annotationWriter.annotation.data, 0, annotationWriter.annotation.length);
annotationWriter = annotationWriter.nextAnnotation;
}
}
}
}
import jdk.test.lib.helpers.ClassFileInstaller;
public class AnonVmClassesDuringDump {
public static String appClasses[] = {
Hello.class.getName(),
};
public static String agentClasses[] = {
AnonVmClassesDuringDumpTransformer.class.getName(),
};
public static String cdsDiagnosticOption = "-XX:+AllowArchivingWithJavaAgent";
public static final boolean dynamicMode =
Boolean.getBoolean(System.getProperty("test.dynamic.cds.archive", "false"));
public static void main(String[] args) throws Throwable {
String agentJar =
ClassFileInstaller.writeJar("AnonVmClassesDuringDumpTransformer.jar",
ClassFileInstaller.Manifest.fromSourceFile("AnonVmClassesDuringDumpTransformer.mf"),
agentClasses);
String appJar =
ClassFileInstaller.writeJar("AnonVmClassesDuringDumpApp.jar", appClasses);
TestCommon.testDump(appJar, TestCommon.list(Hello.class.getName()),
"-javaagent:" + agentJar,
"-XX:+UnlockDiagnosticVMOptions", cdsDiagnosticOption,
"-Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=true");
String prefix = ".class.load. ";
String class_pattern = ".*Lambda([a-z0-9$]+)/([0-9]+).*";
String suffix = ".*source: shared objects file.*";
String pattern = prefix + class_pattern + suffix;
TestCommon.run("-cp", appJar,
"-XX:+UnlockDiagnosticVMOptions", cdsDiagnosticOption, Hello.class.getName())
.assertNormalExit(dynamicMode ?
output -> output.shouldMatch(pattern) :
output -> output.shouldNotMatch(pattern));
TestCommon.run("-cp", appJar,
"-XX:+UnlockDiagnosticVMOptions", cdsDiagnosticOption,
"-XX:+PrintSharedArchiveAndExit", "-XX:+PrintSharedDictionary", Hello.class.getName())
.assertNormalExit(dynamicMode ?
output -> output.shouldMatch(pattern) :
output -> output.shouldNotMatch(pattern));
}
}
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.Instrumentation;
import java.lang.instrument.IllegalClassFormatException;
import java.security.ProtectionDomain;
public class AnonVmClassesDuringDumpTransformer implements ClassFileTransformer {
public byte[] transform(ClassLoader loader, String name, Class<?> classBeingRedefined,
ProtectionDomain pd, byte[] buffer) throws IllegalClassFormatException {
return null;
}
private static Instrumentation savedInstrumentation;
public static void premain(String agentArguments, Instrumentation instrumentation) {
System.out.println("ClassFileTransformer.premain() is called");
instrumentation.addTransformer(new AnonVmClassesDuringDumpTransformer(), true);
savedInstrumentation = instrumentation;
Runnable r = () -> {
System.out.println("Invoked inside a Lambda");
};
r.run();
}
public static Instrumentation getInstrumentation() {
return savedInstrumentation;
}
public static void agentmain(String args, Instrumentation inst) throws Exception {
premain(args, inst);
}
}
package compiler.jvmci.common.testcases;
public class AnotherSingleImplementer implements AnotherSingleImplementerInterface {
@Override
public void interfaceMethod() {
}
public void nonInterfaceMethod() {
}
@Override
public void finalize() throws Throwable {
super.finalize();
}
}
package compiler.jvmci.common.testcases;
public interface AnotherSingleImplementerInterface {
public static final long initTime = System.currentTimeMillis();
default void defaultMethod() {
}
void interfaceMethod();
void finalize() throws Throwable;
}
package jdk.internal.org.jline.utils;
import java.io.FilterWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Iterator;
public class AnsiWriter extends FilterWriter {
private static final char[] RESET_CODE = "\033[0m".toCharArray();
public AnsiWriter(Writer out) {
super(out);
}
private static final int MAX_ESCAPE_SEQUENCE_LENGTH = 100;
private final char[] buffer = new char[MAX_ESCAPE_SEQUENCE_LENGTH];
private int pos = 0;
private int startOfValue;
private final ArrayList<Object> options = new ArrayList<>();
private static final int LOOKING_FOR_FIRST_ESC_CHAR = 0;
private static final int LOOKING_FOR_SECOND_ESC_CHAR = 1;
private static final int LOOKING_FOR_NEXT_ARG = 2;
private static final int LOOKING_FOR_STR_ARG_END = 3;
private static final int LOOKING_FOR_INT_ARG_END = 4;
private static final int LOOKING_FOR_OSC_COMMAND = 5;
private static final int LOOKING_FOR_OSC_COMMAND_END = 6;
private static final int LOOKING_FOR_OSC_PARAM = 7;
private static final int LOOKING_FOR_ST = 8;
private static final int LOOKING_FOR_CHARSET = 9;
int state = LOOKING_FOR_FIRST_ESC_CHAR;
private static final int FIRST_ESC_CHAR = 27;
private static final int SECOND_ESC_CHAR = '[';
private static final int SECOND_OSC_CHAR = ']';
private static final int BEL = 7;
private static final int SECOND_ST_CHAR = '\\';
private static final int SECOND_CHARSET0_CHAR = '(';
private static final int SECOND_CHARSET1_CHAR = ')';
@Override
public synchronized void write(int data) throws IOException {
switch (state) {
case LOOKING_FOR_FIRST_ESC_CHAR:
if (data == FIRST_ESC_CHAR) {
buffer[pos++] = (char) data;
state = LOOKING_FOR_SECOND_ESC_CHAR;
} else {
out.write(data);
}
break;
case LOOKING_FOR_SECOND_ESC_CHAR:
buffer[pos++] = (char) data;
if (data == SECOND_ESC_CHAR) {
state = LOOKING_FOR_NEXT_ARG;
} else if (data == SECOND_OSC_CHAR) {
state = LOOKING_FOR_OSC_COMMAND;
} else if (data == SECOND_CHARSET0_CHAR) {
options.add((int) '0');
state = LOOKING_FOR_CHARSET;
} else if (data == SECOND_CHARSET1_CHAR) {
options.add((int) '1');
state = LOOKING_FOR_CHARSET;
} else {
reset(false);
}
break;
case LOOKING_FOR_NEXT_ARG:
buffer[pos++] = (char) data;
if ('"' == data) {
startOfValue = pos - 1;
state = LOOKING_FOR_STR_ARG_END;
} else if ('0' <= data && data <= '9') {
startOfValue = pos - 1;
state = LOOKING_FOR_INT_ARG_END;
} else if (';' == data) {
options.add(null);
} else if ('?' == data) {
options.add('?');
} else if ('=' == data) {
options.add('=');
} else {
boolean skip = true;
try {
skip = processEscapeCommand(options, data);
} finally {
reset(skip);
}
}
break;
default:
break;
case LOOKING_FOR_INT_ARG_END:
buffer[pos++] = (char) data;
if (!('0' <= data && data <= '9')) {
String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue);
Integer value = Integer.valueOf(strValue);
options.add(value);
if (data == ';') {
state = LOOKING_FOR_NEXT_ARG;
} else {
boolean skip = true;
try {
skip = processEscapeCommand(options, data);
} finally {
reset(skip);
}
}
}
break;
case LOOKING_FOR_STR_ARG_END:
buffer[pos++] = (char) data;
if ('"' != data) {
String value = new String(buffer, startOfValue, (pos - 1) - startOfValue);
options.add(value);
if (data == ';') {
state = LOOKING_FOR_NEXT_ARG;
} else {
reset(processEscapeCommand(options, data));
}
}
break;
case LOOKING_FOR_OSC_COMMAND:
buffer[pos++] = (char) data;
if ('0' <= data && data <= '9') {
startOfValue = pos - 1;
state = LOOKING_FOR_OSC_COMMAND_END;
} else {
reset(false);
}
break;
case LOOKING_FOR_OSC_COMMAND_END:
buffer[pos++] = (char) data;
if (';' == data) {
String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue);
Integer value = Integer.valueOf(strValue);
options.add(value);
startOfValue = pos;
state = LOOKING_FOR_OSC_PARAM;
} else if ('0' <= data && data <= '9') {
} else {
reset(false);
}
break;
case LOOKING_FOR_OSC_PARAM:
buffer[pos++] = (char) data;
if (BEL == data) {
String value = new String(buffer, startOfValue, (pos - 1) - startOfValue);
options.add(value);
boolean skip = true;
try {
skip = processOperatingSystemCommand(options);
} finally {
reset(skip);
}
} else if (FIRST_ESC_CHAR == data) {
state = LOOKING_FOR_ST;
} else {
}
break;
case LOOKING_FOR_ST:
buffer[pos++] = (char) data;
if (SECOND_ST_CHAR == data) {
String value = new String(buffer, startOfValue, (pos - 2) - startOfValue);
options.add(value);
boolean skip = true;
try {
skip = processOperatingSystemCommand(options);
} finally {
reset(skip);
}
} else {
state = LOOKING_FOR_OSC_PARAM;
}
break;
case LOOKING_FOR_CHARSET:
options.add((char) data);
reset(processCharsetSelect(options));
break;
}
if (pos >= buffer.length) {
reset(false);
}
}
private void reset(boolean skipBuffer) throws IOException {
if (!skipBuffer) {
out.write(buffer, 0, pos);
}
pos = 0;
startOfValue = 0;
options.clear();
state = LOOKING_FOR_FIRST_ESC_CHAR;
}
private int getNextOptionInt(Iterator<Object> optionsIterator) throws IOException {
for (;;) {
if (!optionsIterator.hasNext())
throw new IllegalArgumentException();
Object arg = optionsIterator.next();
if (arg != null)
return (Integer) arg;
}
}
private boolean processEscapeCommand(ArrayList<Object> options, int command) throws IOException {
try {
switch (command) {
case 'A':
processCursorUp(optionInt(options, 0, 1));
return true;
case 'B':
processCursorDown(optionInt(options, 0, 1));
return true;
case 'C':
processCursorRight(optionInt(options, 0, 1));
return true;
case 'D':
processCursorLeft(optionInt(options, 0, 1));
return true;
case 'E':
processCursorDownLine(optionInt(options, 0, 1));
return true;
case 'F':
processCursorUpLine(optionInt(options, 0, 1));
return true;
case 'G':
processCursorToColumn(optionInt(options, 0));
return true;
case 'H':
case 'f':
processCursorTo(optionInt(options, 0, 1), optionInt(options, 1, 1));
return true;
case 'J':
processEraseScreen(optionInt(options, 0, 0));
return true;
case 'K':
processEraseLine(optionInt(options, 0, 0));
return true;
case 'L':
processInsertLine(optionInt(options, 0, 1));
return true;
case 'M':
processDeleteLine(optionInt(options, 0, 1));
return true;
case 'S':
processScrollUp(optionInt(options, 0, 1));
return true;
case 'T':
processScrollDown(optionInt(options, 0, 1));
return true;
case 'm':
for (Object next : options) {
if (next != null && next.getClass() != Integer.class) {
throw new IllegalArgumentException();
}
}
int count = 0;
Iterator<Object> optionsIterator = options.iterator();
while (optionsIterator.hasNext()) {
Object next = optionsIterator.next();
if (next != null) {
count++;
int value = (Integer) next;
if (30 <= value && value <= 37) {
processSetForegroundColor(value - 30);
} else if (40 <= value && value <= 47) {
processSetBackgroundColor(value - 40);
} else if (90 <= value && value <= 97) {
processSetForegroundColor(value - 90, true);
} else if (100 <= value && value <= 107) {
processSetBackgroundColor(value - 100, true);
} else if (value == 38 || value == 48) {
int arg2or5 = getNextOptionInt(optionsIterator);
if (arg2or5 == 2) {
int r = getNextOptionInt(optionsIterator);
int g = getNextOptionInt(optionsIterator);
int b = getNextOptionInt(optionsIterator);
if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
if (value == 38)
processSetForegroundColorExt(r, g, b);
else
processSetBackgroundColorExt(r, g, b);
} else {
throw new IllegalArgumentException();
}
}
else if (arg2or5 == 5) {
int paletteIndex = getNextOptionInt(optionsIterator);
if (paletteIndex >= 0 && paletteIndex <= 255) {
if (value == 38)
processSetForegroundColorExt(paletteIndex);
else
processSetBackgroundColorExt(paletteIndex);
} else {
throw new IllegalArgumentException();
}
}
else {
throw new IllegalArgumentException();
}
} else {
switch (value) {
case 39:
processDefaultTextColor();
break;
case 49:
processDefaultBackgroundColor();
break;
case 0:
processAttributeRest();
break;
default:
processSetAttribute(value);
}
}
}
}
if (count == 0) {
processAttributeRest();
}
return true;
case 's':
processSaveCursorPosition();
return true;
case 'u':
processRestoreCursorPosition();
return true;
default:
if ('a' <= command && 'z' <= command) {
processUnknownExtension(options, command);
return true;
}
if ('A' <= command && 'Z' <= command) {
processUnknownExtension(options, command);
return true;
}
return false;
}
} catch (IllegalArgumentException ignore) {
}
return false;
}
private boolean processOperatingSystemCommand(ArrayList<Object> options) throws IOException {
int command = optionInt(options, 0);
String label = (String) options.get(1);
try {
switch (command) {
case 0:
processChangeIconNameAndWindowTitle(label);
return true;
case 1:
processChangeIconName(label);
return true;
case 2:
processChangeWindowTitle(label);
return true;
default:
processUnknownOperatingSystemCommand(command, label);
return true;
}
} catch (IllegalArgumentException ignore) {
}
return false;
}
protected void processRestoreCursorPosition() throws IOException {
}
protected void processSaveCursorPosition() throws IOException {
}
protected void processInsertLine(int optionInt) throws IOException {
}
protected void processDeleteLine(int optionInt) throws IOException {
}
protected void processScrollDown(int optionInt) throws IOException {
}
protected void processScrollUp(int optionInt) throws IOException {
}
protected static final int ERASE_SCREEN_TO_END = 0;
protected static final int ERASE_SCREEN_TO_BEGINING = 1;
protected static final int ERASE_SCREEN = 2;
protected void processEraseScreen(int eraseOption) throws IOException {
}
protected static final int ERASE_LINE_TO_END = 0;
protected static final int ERASE_LINE_TO_BEGINING = 1;
protected static final int ERASE_LINE = 2;
protected void processEraseLine(int eraseOption) throws IOException {
}
protected static final int ATTRIBUTE_INTENSITY_BOLD = 1;     protected static final int ATTRIBUTE_INTENSITY_FAINT = 2;     protected static final int ATTRIBUTE_ITALIC = 3;     protected static final int ATTRIBUTE_UNDERLINE = 4;     protected static final int ATTRIBUTE_BLINK_SLOW = 5;     protected static final int ATTRIBUTE_BLINK_FAST = 6;     protected static final int ATTRIBUTE_NEGATIVE_ON = 7;     protected static final int ATTRIBUTE_CONCEAL_ON = 8;     protected static final int ATTRIBUTE_UNDERLINE_DOUBLE = 21;     protected static final int ATTRIBUTE_INTENSITY_NORMAL = 22;     protected static final int ATTRIBUTE_UNDERLINE_OFF = 24;     protected static final int ATTRIBUTE_BLINK_OFF = 25;     @Deprecated
protected static final int ATTRIBUTE_NEGATIVE_Off = 27;     protected static final int ATTRIBUTE_NEGATIVE_OFF = 27;     protected static final int ATTRIBUTE_CONCEAL_OFF = 28;
protected void processSetAttribute(int attribute) throws IOException {
}
protected static final int BLACK = 0;
protected static final int RED = 1;
protected static final int GREEN = 2;
protected static final int YELLOW = 3;
protected static final int BLUE = 4;
protected static final int MAGENTA = 5;
protected static final int CYAN = 6;
protected static final int WHITE = 7;
protected void processSetForegroundColor(int color) throws IOException {
processSetForegroundColor(color, false);
}
protected void processSetForegroundColor(int color, boolean bright) throws IOException {
processSetForegroundColorExt(bright ? color + 8 : color);
}
protected void processSetForegroundColorExt(int paletteIndex) throws IOException {
}
protected void processSetForegroundColorExt(int r, int g, int b) throws IOException {
processSetForegroundColorExt(Colors.roundRgbColor(r, g, b, 16));
}
protected void processSetBackgroundColor(int color) throws IOException {
processSetBackgroundColor(color, false);
}
protected void processSetBackgroundColor(int color, boolean bright) throws IOException {
processSetBackgroundColorExt(bright ? color + 8 : color);
}
protected void processSetBackgroundColorExt(int paletteIndex) throws IOException {
}
protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException {
processSetBackgroundColorExt(Colors.roundRgbColor(r, g, b, 16));
}
protected void processDefaultTextColor() throws IOException {
}
protected void processDefaultBackgroundColor() throws IOException {
}
protected void processAttributeRest() throws IOException {
}
protected void processCursorTo(int row, int col) throws IOException {
}
protected void processCursorToColumn(int x) throws IOException {
}
protected void processCursorUpLine(int count) throws IOException {
}
protected void processCursorDownLine(int count) throws IOException {
for (int i = 0; i < count; i++) {
out.write('\n');
}
}
protected void processCursorLeft(int count) throws IOException {
}
protected void processCursorRight(int count) throws IOException {
for (int i = 0; i < count; i++) {
out.write(' ');
}
}
protected void processCursorDown(int count) throws IOException {
}
protected void processCursorUp(int count) throws IOException {
}
protected void processUnknownExtension(ArrayList<Object> options, int command) {
}
protected void processChangeIconNameAndWindowTitle(String label) {
processChangeIconName(label);
processChangeWindowTitle(label);
}
protected void processChangeIconName(String name) {
}
protected void processChangeWindowTitle(String title) {
}
protected void processUnknownOperatingSystemCommand(int command, String param) {
}
private boolean processCharsetSelect(ArrayList<Object> options) throws IOException {
int set = optionInt(options, 0);
char seq = (Character) options.get(1);
processCharsetSelect(set, seq);
return true;
}
protected void processCharsetSelect(int set, char seq) {
}
private int optionInt(ArrayList<Object> options, int index) {
if (options.size() <= index)
throw new IllegalArgumentException();
Object value = options.get(index);
if (value == null)
throw new IllegalArgumentException();
if (!value.getClass().equals(Integer.class))
throw new IllegalArgumentException();
return (Integer) value;
}
private int optionInt(ArrayList<Object> options, int index, int defaultValue) {
if (options.size() > index) {
Object value = options.get(index);
if (value == null) {
return defaultValue;
}
return (Integer) value;
}
return defaultValue;
}
@Override
public void write(char[] cbuf, int off, int len) throws IOException {
for (int i = 0; i < len; i++) {
write(cbuf[off + i]);
}
}
@Override
public void write(String str, int off, int len) throws IOException {
for (int i = 0; i < len; i++) {
write(str.charAt(off + i));
}
}
@Override
public void close() throws IOException {
write(RESET_CODE);
flush();
super.close();
}
}
public class AntiDependentLoadInOuterStripMinedLoop {
private static int field;
private static volatile int barrier;
public static void main(String[] args) {
int[] array = new int[1];
A a = new A();
for (int i = 0; i < 20_000; i++) {
test1(array);
test2(a, array);
test2_helper(array, 0, 0);
}
}
private static int test1(int[] array) {
int res = 1;
for (int i = 0; i < 10; i++) {
barrier = 1;
for (int j = 0; j < 2000; j++) {
array[0] = j;                  res *= j;
}
}
return field + res + field * 2;
}
private static int test2(A a, int[] array) {
int ignore = a.field;
int res = 1;
int k = 0;
for (k = 0; k < 2; k++) {
}
for (int i = 0; i < 10; i++) {
barrier = 1;
for (int j = 0; j < 2000; j++) {
test2_helper(array, k, j);
res *= j;
}
}
return a.field + res + a.field * 2;
}
private static void test2_helper(int[] array, int k, int j) {
if (k == 2) {
array[0] = j;
}
}
private static class A {
public int field;
}
}
package com.sun.org.apache.xerces.internal.impl.dv.xs;
import com.sun.org.apache.xerces.internal.impl.dv.InvalidDatatypeValueException;
import com.sun.org.apache.xerces.internal.impl.dv.ValidationContext;
class AnyAtomicDV extends TypeValidator {
public short getAllowedFacets() {
return 0;
}
public Object getActualValue(String content, ValidationContext context) throws InvalidDatatypeValueException {
return content;
}
}
package com.sun.org.apache.xalan.internal.xsltc.dom;
import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.Translet;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
public abstract class AnyNodeCounter extends NodeCounter {
public AnyNodeCounter(Translet translet,
DOM document, DTMAxisIterator iterator) {
super(translet, document, iterator);
}
public AnyNodeCounter(Translet translet,
DOM document,
DTMAxisIterator iterator,
boolean hasFrom) {
super(translet, document, iterator, hasFrom);
}
public NodeCounter setStartNode(int node) {
_node = node;
_nodeType = _document.getExpandedTypeID(node);
return this;
}
public String getCounter() {
int result;
if (_value != Integer.MIN_VALUE) {
if (_value == 0) return "0";
else if (Double.isNaN(_value)) return "NaN";
else if (_value < 0 && Double.isInfinite(_value)) return "-Infinity";
else if (Double.isInfinite(_value)) return "Infinity";
else return formatNumbers((int)_value);
}
else {
int next = _node;
final int root = _document.getDocument();
result = 0;
while (next >= root && !matchesFrom(next)) {
if (matchesCount(next)) {
++result;
}
next--;
}
}
return formatNumbers(result);
}
public static NodeCounter getDefaultNodeCounter(Translet translet,
DOM document,
DTMAxisIterator iterator) {
return new DefaultAnyNodeCounter(translet, document, iterator);
}
static class DefaultAnyNodeCounter extends AnyNodeCounter {
public DefaultAnyNodeCounter(Translet translet,
DOM document, DTMAxisIterator iterator) {
super(translet, document, iterator);
}
public String getCounter() {
int result;
if (_value != Integer.MIN_VALUE) {
if (_value == 0) return "0";
else if (Double.isNaN(_value)) return "NaN";
else if (_value < 0 && Double.isInfinite(_value)) return "-Infinity";
else if (Double.isInfinite(_value)) return "Infinity";
else result = (int) _value;
}
else {
int next = _node;
result = 0;
final int ntype = _document.getExpandedTypeID(_node);
final int root = _document.getDocument();
while (next >= 0) {
if (ntype == _document.getExpandedTypeID(next)) {
result++;
}
if (next == root) {
break;
}
else {
--next;
}
}
}
return formatNumbers(result);
}
}
}
package com.sun.hotspot.igv.graph;
import java.util.List;
import java.util.ArrayList;
public class AnySelector implements BlockSelector {
private final Selector selector;
public AnySelector(Selector s) {
this.selector = s;
}
@Override
public List<Block> selected(Diagram d) {
List<Block> l = new ArrayList<>();
for (Figure f : selector.selected(d)) {
l.add(d.getBlock(f.getBlock()));
}
return l;
}
}
package com.sun.org.apache.xerces.internal.impl.dv.xs;
import com.sun.org.apache.xerces.internal.impl.dv.InvalidDatatypeValueException;
import com.sun.org.apache.xerces.internal.impl.dv.ValidationContext;
public class AnySimpleDV extends TypeValidator {
public short getAllowedFacets() {
return 0;
}
public Object getActualValue(String content, ValidationContext context) throws InvalidDatatypeValueException {
return content;
}
}
package com.sun.org.apache.xerces.internal.impl.dv.xs;
import com.sun.org.apache.xerces.internal.impl.dv.InvalidDatatypeValueException;
import com.sun.org.apache.xerces.internal.util.URI;
import com.sun.org.apache.xerces.internal.impl.dv.ValidationContext;
public class AnyURIDV extends TypeValidator {
private static final URI BASE_URI;
static {
URI uri = null;
try {
uri = new URI("abc:        } catch (URI.MalformedURIException ex) {
}
BASE_URI = uri;
}
public short getAllowedFacets(){
return (XSSimpleTypeDecl.FACET_LENGTH | XSSimpleTypeDecl.FACET_MINLENGTH | XSSimpleTypeDecl.FACET_MAXLENGTH | XSSimpleTypeDecl.FACET_PATTERN | XSSimpleTypeDecl.FACET_ENUMERATION | XSSimpleTypeDecl.FACET_WHITESPACE );
}
public Object getActualValue(String content, ValidationContext context) throws InvalidDatatypeValueException {
try {
if( content.length() != 0 ) {
final String encoded = encode(content);
new URI(BASE_URI, encoded );
}
} catch (URI.MalformedURIException ex) {
throw new InvalidDatatypeValueException("cvc-datatype-valid.1.2.1", new Object[]{content, "anyURI"});
}
return content;
}
private static boolean gNeedEscaping[] = new boolean[128];
private static char gAfterEscaping1[] = new char[128];
private static char gAfterEscaping2[] = new char[128];
private static char[] gHexChs = {'0', '1', '2', '3', '4', '5', '6', '7',
'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
static {
for (int i = 0; i <= 0x1f; i++) {
gNeedEscaping[i] = true;
gAfterEscaping1[i] = gHexChs[i >> 4];
gAfterEscaping2[i] = gHexChs[i & 0xf];
}
gNeedEscaping[0x7f] = true;
gAfterEscaping1[0x7f] = '7';
gAfterEscaping2[0x7f] = 'F';
char[] escChs = {' ', '<', '>', '"', '{', '}',
'|', '\\', '^', '~', '`'};
int len = escChs.length;
char ch;
for (int i = 0; i < len; i++) {
ch = escChs[i];
gNeedEscaping[ch] = true;
gAfterEscaping1[ch] = gHexChs[ch >> 4];
gAfterEscaping2[ch] = gHexChs[ch & 0xf];
}
}
private static String encode(String anyURI){
int len = anyURI.length(), ch;
StringBuffer buffer = new StringBuffer(len*3);
int i = 0;
for (; i < len; i++) {
ch = anyURI.charAt(i);
if (ch >= 128)
break;
if (gNeedEscaping[ch]) {
buffer.append('%');
buffer.append(gAfterEscaping1[ch]);
buffer.append(gAfterEscaping2[ch]);
}
else {
buffer.append((char)ch);
}
}
if (i < len) {
byte[] bytes = null;
byte b;
try {
bytes = anyURI.substring(i).getBytes("UTF-8");
} catch (java.io.UnsupportedEncodingException e) {
return anyURI;
}
len = bytes.length;
for (i = 0; i < len; i++) {
b = bytes[i];
if (b < 0) {
ch = b + 256;
buffer.append('%');
buffer.append(gHexChs[ch >> 4]);
buffer.append(gHexChs[ch & 0xf]);
}
else if (gNeedEscaping[b]) {
buffer.append('%');
buffer.append(gAfterEscaping1[b]);
buffer.append(gAfterEscaping2[b]);
}
else {
buffer.append((char)b);
}
}
}
if (buffer.length() != len) {
return buffer.toString();
}
else {
return anyURI;
}
}
}
package org.jcp.xml.dsig.internal.dom;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.security.spec.AlgorithmParameterSpec;
import java.security.InvalidAlgorithmParameterException;
import java.util.Set;
import javax.xml.crypto.*;
import javax.xml.crypto.dom.DOMCryptoContext;
import javax.xml.crypto.dsig.TransformException;
import javax.xml.crypto.dsig.TransformService;
import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;
import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
import com.sun.org.apache.xml.internal.security.transforms.Transform;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
public abstract class ApacheCanonicalizer extends TransformService {
static {
com.sun.org.apache.xml.internal.security.Init.init();
}
private static final com.sun.org.slf4j.internal.Logger LOG =
com.sun.org.slf4j.internal.LoggerFactory.getLogger(ApacheCanonicalizer.class);
protected Canonicalizer canonicalizer;
private Transform apacheTransform;
protected String inclusiveNamespaces;
protected C14NMethodParameterSpec params;
protected Document ownerDoc;
protected Element transformElem;
public final AlgorithmParameterSpec getParameterSpec()
{
return params;
}
public void init(XMLStructure parent, XMLCryptoContext context)
throws InvalidAlgorithmParameterException
{
if (context != null && !(context instanceof DOMCryptoContext)) {
throw new ClassCastException
("context must be of type DOMCryptoContext");
}
if (parent == null) {
throw new NullPointerException();
}
if (!(parent instanceof javax.xml.crypto.dom.DOMStructure)) {
throw new ClassCastException("parent must be of type DOMStructure");
}
transformElem = (Element)
((javax.xml.crypto.dom.DOMStructure)parent).getNode();
ownerDoc = DOMUtils.getOwnerDocument(transformElem);
}
public void marshalParams(XMLStructure parent, XMLCryptoContext context)
throws MarshalException
{
if (context != null && !(context instanceof DOMCryptoContext)) {
throw new ClassCastException
("context must be of type DOMCryptoContext");
}
if (parent == null) {
throw new NullPointerException();
}
if (!(parent instanceof javax.xml.crypto.dom.DOMStructure)) {
throw new ClassCastException("parent must be of type DOMStructure");
}
transformElem = (Element)
((javax.xml.crypto.dom.DOMStructure)parent).getNode();
ownerDoc = DOMUtils.getOwnerDocument(transformElem);
}
public Data canonicalize(Data data, XMLCryptoContext xc)
throws TransformException
{
return canonicalize(data, xc, null);
}
public Data canonicalize(Data data, XMLCryptoContext xc, OutputStream os)
throws TransformException
{
if (canonicalizer == null) {
try {
canonicalizer = Canonicalizer.getInstance(getAlgorithm());
LOG.debug("Created canonicalizer for algorithm: {}", getAlgorithm());
} catch (InvalidCanonicalizerException ice) {
throw new TransformException
("Couldn't find Canonicalizer for: " + getAlgorithm() +
": " + ice.getMessage(), ice);
}
}
boolean isByteArrayOutputStream = os == null;
OutputStream writer = isByteArrayOutputStream ? new ByteArrayOutputStream() : os;
try {
boolean secVal = Utils.secureValidation(xc);
Set<Node> nodeSet = null;
if (data instanceof ApacheData) {
XMLSignatureInput in =
((ApacheData)data).getXMLSignatureInput();
if (in.isElement()) {
if (inclusiveNamespaces != null) {
canonicalizer.canonicalizeSubtree(in.getSubNode(), inclusiveNamespaces, writer);
return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));
} else {
canonicalizer.canonicalizeSubtree(in.getSubNode(), writer);
return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));
}
} else if (in.isNodeSet()) {
nodeSet = in.getNodeSet();
} else {
canonicalizer.canonicalize(Utils.readBytesFromStream(in.getOctetStream()), writer, secVal);
return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));
}
} else if (data instanceof DOMSubTreeData) {
DOMSubTreeData subTree = (DOMSubTreeData)data;
if (inclusiveNamespaces != null) {
canonicalizer.canonicalizeSubtree(subTree.getRoot(), inclusiveNamespaces, writer);
return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));
} else {
canonicalizer.canonicalizeSubtree(subTree.getRoot(), writer);
return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));
}
} else if (data instanceof NodeSetData) {
NodeSetData<?> nsd = (NodeSetData<?>)data;
nodeSet = Utils.toNodeSet(nsd.iterator());
LOG.debug("Canonicalizing {} nodes", nodeSet.size());
} else {
canonicalizer.canonicalize(Utils.readBytesFromStream(((OctetStreamData)data).getOctetStream()), writer, secVal);
return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));
}
if (inclusiveNamespaces != null) {
canonicalizer.canonicalizeXPathNodeSet(nodeSet, inclusiveNamespaces, writer);
return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));
} else {
canonicalizer.canonicalizeXPathNodeSet(nodeSet, writer);
return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));
}
} catch (Exception e) {
throw new TransformException(e);
}
}
private byte[] getC14nBytes(OutputStream outputStream, boolean isByteArrayOutputStream) {            if (isByteArrayOutputStream) {
return ((ByteArrayOutputStream)outputStream).toByteArray();
}
return null;
}
public Data transform(Data data, XMLCryptoContext xc, OutputStream os)
throws TransformException
{
if (data == null) {
throw new NullPointerException("data must not be null");
}
if (os == null) {
throw new NullPointerException("output stream must not be null");
}
if (ownerDoc == null) {
throw new TransformException("transform must be marshalled");
}
if (apacheTransform == null) {
try {
apacheTransform =
new Transform(ownerDoc, getAlgorithm(), transformElem.getChildNodes());
apacheTransform.setElement(transformElem, xc.getBaseURI());
LOG.debug("Created transform for algorithm: {}", getAlgorithm());
} catch (Exception ex) {
throw new TransformException
("Couldn't find Transform for: " + getAlgorithm(), ex);
}
}
XMLSignatureInput in;
if (data instanceof ApacheData) {
LOG.debug("ApacheData = true");
in = ((ApacheData)data).getXMLSignatureInput();
} else if (data instanceof NodeSetData) {
LOG.debug("isNodeSet() = true");
if (data instanceof DOMSubTreeData) {
DOMSubTreeData subTree = (DOMSubTreeData)data;
in = new XMLSignatureInput(subTree.getRoot());
in.setExcludeComments(subTree.excludeComments());
} else {
@SuppressWarnings("unchecked")
Set<Node> nodeSet =
Utils.toNodeSet(((NodeSetData)data).iterator());
in = new XMLSignatureInput(nodeSet);
}
} else {
LOG.debug("isNodeSet() = false");
try {
in = new XMLSignatureInput
(((OctetStreamData)data).getOctetStream());
} catch (Exception ex) {
throw new TransformException(ex);
}
}
boolean secVal = Utils.secureValidation(xc);
in.setSecureValidation(secVal);
try {
in = apacheTransform.performTransform(in, os, secVal);
if (in.isOctetStream()) {
return new ApacheOctetStreamData(in);
} else {
return new ApacheNodeSetData(in);
}
} catch (Exception ex) {
throw new TransformException(ex);
}
}
public final boolean isFeatureSupported(String feature) {
if (feature == null) {
throw new NullPointerException();
} else {
return false;
}
}
}
package org.jcp.xml.dsig.internal.dom;
import javax.xml.crypto.Data;
import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
public interface ApacheData extends Data {
XMLSignatureInput getXMLSignatureInput();
}
package org.jcp.xml.dsig.internal.dom;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import javax.xml.crypto.NodeSetData;
import org.w3c.dom.Node;
import com.sun.org.apache.xml.internal.security.signature.NodeFilter;
import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
public class ApacheNodeSetData implements ApacheData, NodeSetData<Node> {
private XMLSignatureInput xi;
public ApacheNodeSetData(XMLSignatureInput xi) {
this.xi = xi;
}
public Iterator<Node> iterator() {
if (xi.getNodeFilters() != null && !xi.getNodeFilters().isEmpty()) {
return Collections.unmodifiableSet
(getNodeSet(xi.getNodeFilters())).iterator();
}
try {
return Collections.unmodifiableSet(xi.getNodeSet()).iterator();
} catch (Exception e) {
throw new RuntimeException
("unrecoverable error retrieving nodeset", e);
}
}
public XMLSignatureInput getXMLSignatureInput() {
return xi;
}
private Set<Node> getNodeSet(List<NodeFilter> nodeFilters) {
if (xi.isNeedsToBeExpanded()) {
XMLUtils.circumventBug2650
(XMLUtils.getOwnerDocument(xi.getSubNode()));
}
Set<Node> inputSet = new LinkedHashSet<>();
XMLUtils.getSet(xi.getSubNode(), inputSet,
null, !xi.isExcludeComments());
Set<Node> nodeSet = new LinkedHashSet<>();
for (Node currentNode : inputSet) {
Iterator<NodeFilter> it = nodeFilters.iterator();
boolean skipNode = false;
while (it.hasNext() && !skipNode) {
NodeFilter nf = it.next();
if (nf.isNodeInclude(currentNode) != 1) {
skipNode = true;
}
}
if (!skipNode) {
nodeSet.add(currentNode);
}
}
return nodeSet;
}
}
package org.jcp.xml.dsig.internal.dom;
import java.io.IOException;
import javax.xml.crypto.OctetStreamData;
import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
public class ApacheOctetStreamData extends OctetStreamData
implements ApacheData {
private XMLSignatureInput xi;
public ApacheOctetStreamData(XMLSignatureInput xi)
throws IOException
{
super(xi.getOctetStream(), xi.getSourceURI(), xi.getMIMEType());
this.xi = xi;
}
public XMLSignatureInput getXMLSignatureInput() {
return xi;
}
}
package org.jcp.xml.dsig.internal.dom;
import java.io.OutputStream;
import java.security.InvalidAlgorithmParameterException;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Set;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
import com.sun.org.apache.xml.internal.security.transforms.Transform;
import javax.xml.crypto.*;
import javax.xml.crypto.dom.DOMCryptoContext;
import javax.xml.crypto.dsig.*;
import javax.xml.crypto.dsig.spec.TransformParameterSpec;
public abstract class ApacheTransform extends TransformService {
static {
com.sun.org.apache.xml.internal.security.Init.init();
}
private static final com.sun.org.slf4j.internal.Logger LOG =
com.sun.org.slf4j.internal.LoggerFactory.getLogger(ApacheTransform.class);
private Transform transform;
protected Document ownerDoc;
protected Element transformElem;
protected TransformParameterSpec params;
@Override
public final AlgorithmParameterSpec getParameterSpec() {
return params;
}
public void init(XMLStructure parent, XMLCryptoContext context)
throws InvalidAlgorithmParameterException
{
if (context != null && !(context instanceof DOMCryptoContext)) {
throw new ClassCastException
("context must be of type DOMCryptoContext");
}
if (parent == null) {
throw new NullPointerException();
}
if (!(parent instanceof javax.xml.crypto.dom.DOMStructure)) {
throw new ClassCastException("parent must be of type DOMStructure");
}
transformElem = (Element)
((javax.xml.crypto.dom.DOMStructure) parent).getNode();
ownerDoc = DOMUtils.getOwnerDocument(transformElem);
}
public void marshalParams(XMLStructure parent, XMLCryptoContext context)
throws MarshalException
{
if (context != null && !(context instanceof DOMCryptoContext)) {
throw new ClassCastException
("context must be of type DOMCryptoContext");
}
if (parent == null) {
throw new NullPointerException();
}
if (!(parent instanceof javax.xml.crypto.dom.DOMStructure)) {
throw new ClassCastException("parent must be of type DOMStructure");
}
transformElem = (Element)
((javax.xml.crypto.dom.DOMStructure) parent).getNode();
ownerDoc = DOMUtils.getOwnerDocument(transformElem);
}
public Data transform(Data data, XMLCryptoContext xc)
throws TransformException
{
if (data == null) {
throw new NullPointerException("data must not be null");
}
return transformIt(data, xc, null);
}
public Data transform(Data data, XMLCryptoContext xc, OutputStream os)
throws TransformException
{
if (data == null) {
throw new NullPointerException("data must not be null");
}
if (os == null) {
throw new NullPointerException("output stream must not be null");
}
return transformIt(data, xc, os);
}
private Data transformIt(Data data, XMLCryptoContext xc, OutputStream os)
throws TransformException
{
if (ownerDoc == null) {
throw new TransformException("transform must be marshalled");
}
if (transform == null) {
try {
transform =
new Transform(ownerDoc, getAlgorithm(), transformElem.getChildNodes());
transform.setElement(transformElem, xc.getBaseURI());
LOG.debug("Created transform for algorithm: {}", getAlgorithm());
} catch (Exception ex) {
throw new TransformException("Couldn't find Transform for: " +
getAlgorithm(), ex);
}
}
if (Utils.secureValidation(xc)) {
String algorithm = getAlgorithm();
if (Policy.restrictAlg(algorithm)) {
throw new TransformException(
"Transform " + algorithm + " is forbidden when secure validation is enabled"
);
}
}
XMLSignatureInput in;
if (data instanceof ApacheData) {
LOG.debug("ApacheData = true");
in = ((ApacheData)data).getXMLSignatureInput();
} else if (data instanceof NodeSetData) {
LOG.debug("isNodeSet() = true");
if (data instanceof DOMSubTreeData) {
LOG.debug("DOMSubTreeData = true");
DOMSubTreeData subTree = (DOMSubTreeData)data;
in = new XMLSignatureInput(subTree.getRoot());
in.setExcludeComments(subTree.excludeComments());
} else {
@SuppressWarnings("unchecked")
Set<Node> nodeSet =
Utils.toNodeSet(((NodeSetData)data).iterator());
in = new XMLSignatureInput(nodeSet);
}
} else {
LOG.debug("isNodeSet() = false");
try {
in = new XMLSignatureInput
(((OctetStreamData)data).getOctetStream());
} catch (Exception ex) {
throw new TransformException(ex);
}
}
boolean secVal = Utils.secureValidation(xc);
in.setSecureValidation(secVal);
try {
if (os != null) {
in = transform.performTransform(in, os, secVal);
if (!in.isNodeSet() && !in.isElement()) {
return null;
}
} else {
in = transform.performTransform(in, secVal);
}
if (in.isOctetStream()) {
return new ApacheOctetStreamData(in);
} else {
return new ApacheNodeSetData(in);
}
} catch (Exception ex) {
throw new TransformException(ex);
}
}
public final boolean isFeatureSupported(String feature) {
if (feature == null) {
throw new NullPointerException();
} else {
return false;
}
}
}
package sun.security.krb5.internal;
import sun.security.krb5.Asn1Exception;
import sun.security.krb5.internal.util.KerberosFlags;
import sun.security.util.*;
import java.io.IOException;
public class APOptions extends KerberosFlags {
public APOptions() {
super(Krb5.AP_OPTS_MAX + 1);
}
public APOptions(int oneBit) throws Asn1Exception {
super(Krb5.AP_OPTS_MAX + 1);
set(oneBit, true);
}
public APOptions(int size, byte[] data) throws Asn1Exception {
super(size, data);
if ((size > data.length * BITS_PER_UNIT) || (size > Krb5.AP_OPTS_MAX + 1)) {
throw new Asn1Exception(Krb5.BITSTRING_BAD_LENGTH);
}
}
public APOptions(boolean[] data) throws Asn1Exception {
super(data);
if (data.length > Krb5.AP_OPTS_MAX + 1) {
throw new Asn1Exception(Krb5.BITSTRING_BAD_LENGTH);
}
}
public APOptions(DerValue encoding) throws IOException, Asn1Exception {
this(encoding.getUnalignedBitString(true).toBooleanArray());
}
public static APOptions parse(DerInputStream data, byte explicitTag, boolean optional) throws Asn1Exception, IOException {
if ((optional) && (((byte)data.peekByte() & (byte)0x1F) != explicitTag))
return null;
DerValue der = data.getDerValue();
if (explicitTag != (der.getTag() & (byte)0x1F))  {
throw new Asn1Exception(Krb5.ASN1_BAD_ID);
} else {
DerValue subDer = der.getData().getDerValue();
return new APOptions(subDer);
}
}
}
import jdk.test.lib.cds.CDSOptions;
public class AppCDSOptions extends CDSOptions {
public String appJar;
public String appJarDir;
public AppCDSOptions setAppJar(String appJar) {
this.appJar = appJar;
return this;
}
public AppCDSOptions setAppJarDir(String appJarDir) {
this.appJarDir = appJarDir;
return this;
}
}
package javax.security.auth.login;
import java.util.Map;
import java.util.Collections;
public class AppConfigurationEntry {
private String loginModuleName;
private LoginModuleControlFlag controlFlag;
private Map<String,?> options;
public AppConfigurationEntry(String loginModuleName,
LoginModuleControlFlag controlFlag,
Map<String,?> options)
{
if (loginModuleName == null || loginModuleName.isEmpty() ||
(controlFlag != LoginModuleControlFlag.REQUIRED &&
controlFlag != LoginModuleControlFlag.REQUISITE &&
controlFlag != LoginModuleControlFlag.SUFFICIENT &&
controlFlag != LoginModuleControlFlag.OPTIONAL) ||
options == null)
throw new IllegalArgumentException();
this.loginModuleName = loginModuleName;
this.controlFlag = controlFlag;
this.options = Collections.unmodifiableMap(options);
}
public String getLoginModuleName() {
return loginModuleName;
}
public LoginModuleControlFlag getControlFlag() {
return controlFlag;
}
public Map<String,?> getOptions() {
return options;
}
public static class LoginModuleControlFlag {
private String controlFlag;
public static final LoginModuleControlFlag REQUIRED =
new LoginModuleControlFlag("required");
public static final LoginModuleControlFlag REQUISITE =
new LoginModuleControlFlag("requisite");
public static final LoginModuleControlFlag SUFFICIENT =
new LoginModuleControlFlag("sufficient");
public static final LoginModuleControlFlag OPTIONAL =
new LoginModuleControlFlag("optional");
private LoginModuleControlFlag(String controlFlag) {
this.controlFlag = controlFlag;
}
public String toString() {
return (sun.security.util.ResourcesMgr.getString
("LoginModuleControlFlag.") + controlFlag);
}
}
}
package sun.awt;
import java.awt.EventQueue;
import java.awt.Window;
import java.awt.SystemTray;
import java.awt.TrayIcon;
import java.awt.Toolkit;
import java.awt.GraphicsEnvironment;
import java.awt.event.InvocationEvent;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Collections;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.beans.PropertyChangeSupport;
import java.beans.PropertyChangeListener;
import java.lang.ref.SoftReference;
import jdk.internal.access.JavaAWTAccess;
import jdk.internal.access.SharedSecrets;
import sun.util.logging.PlatformLogger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;
public final class AppContext {
private static final PlatformLogger log = PlatformLogger.getLogger("sun.awt.AppContext");
public static final Object EVENT_QUEUE_KEY = new StringBuffer("EventQueue");
public static final Object EVENT_QUEUE_LOCK_KEY = new StringBuilder("EventQueue.Lock");
public static final Object EVENT_QUEUE_COND_KEY = new StringBuilder("EventQueue.Condition");
private static final Map<ThreadGroup, AppContext> threadGroup2appContext =
Collections.synchronizedMap(new IdentityHashMap<ThreadGroup, AppContext>());
public static Set<AppContext> getAppContexts() {
synchronized (threadGroup2appContext) {
return new HashSet<AppContext>(threadGroup2appContext.values());
}
}
private static volatile AppContext mainAppContext;
private static class GetAppContextLock {};
private static final Object getAppContextLock = new GetAppContextLock();
private final Map<Object, Object> table = new HashMap<>();
private final ThreadGroup threadGroup;
private PropertyChangeSupport changeSupport = null;
public static final String DISPOSED_PROPERTY_NAME = "disposed";
public static final String GUI_DISPOSED = "guidisposed";
private enum State {
VALID,
BEING_DISPOSED,
DISPOSED
};
private volatile State state = State.VALID;
public boolean isDisposed() {
return state == State.DISPOSED;
}
private static final AtomicInteger numAppContexts = new AtomicInteger();
private final ClassLoader contextClassLoader;
@SuppressWarnings("removal")
AppContext(ThreadGroup threadGroup) {
numAppContexts.incrementAndGet();
this.threadGroup = threadGroup;
threadGroup2appContext.put(threadGroup, this);
this.contextClassLoader =
AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
public ClassLoader run() {
return Thread.currentThread().getContextClassLoader();
}
});
Lock eventQueuePushPopLock = new ReentrantLock();
put(EVENT_QUEUE_LOCK_KEY, eventQueuePushPopLock);
Condition eventQueuePushPopCond = eventQueuePushPopLock.newCondition();
put(EVENT_QUEUE_COND_KEY, eventQueuePushPopCond);
}
private static final ThreadLocal<AppContext> threadAppContext =
new ThreadLocal<AppContext>();
@SuppressWarnings("removal")
private static void initMainAppContext() {
AccessController.doPrivileged(new PrivilegedAction<Void>() {
public Void run() {
ThreadGroup currentThreadGroup =
Thread.currentThread().getThreadGroup();
ThreadGroup parentThreadGroup = currentThreadGroup.getParent();
while (parentThreadGroup != null) {
currentThreadGroup = parentThreadGroup;
parentThreadGroup = currentThreadGroup.getParent();
}
mainAppContext = SunToolkit.createNewAppContext(currentThreadGroup);
return null;
}
});
}
@SuppressWarnings("removal")
public static AppContext getAppContext() {
if (numAppContexts.get() == 1 && mainAppContext != null) {
return mainAppContext;
}
AppContext appContext = threadAppContext.get();
if (null == appContext) {
appContext = AccessController.doPrivileged(new PrivilegedAction<AppContext>()
{
public AppContext run() {
ThreadGroup currentThreadGroup = Thread.currentThread().getThreadGroup();
ThreadGroup threadGroup = currentThreadGroup;
synchronized (getAppContextLock) {
if (numAppContexts.get() == 0) {
if (System.getProperty("javaplugin.version") == null &&
System.getProperty("javawebstart.version") == null) {
initMainAppContext();
} else if (System.getProperty("javafx.version") != null &&
threadGroup.getParent() != null) {
SunToolkit.createNewAppContext();
}
}
}
AppContext context = threadGroup2appContext.get(threadGroup);
while (context == null) {
threadGroup = threadGroup.getParent();
if (threadGroup == null) {
SecurityManager securityManager = System.getSecurityManager();
if (securityManager != null) {
ThreadGroup smThreadGroup = securityManager.getThreadGroup();
if (smThreadGroup != null) {
return threadGroup2appContext.get(smThreadGroup);
}
}
return null;
}
context = threadGroup2appContext.get(threadGroup);
}
for (ThreadGroup tg = currentThreadGroup; tg != threadGroup; tg = tg.getParent()) {
threadGroup2appContext.put(tg, context);
}
threadAppContext.set(context);
return context;
}
});
}
return appContext;
}
public static boolean isMainContext(AppContext ctx) {
return (ctx != null && ctx == mainAppContext);
}
private long DISPOSAL_TIMEOUT = 5000;
private long THREAD_INTERRUPT_TIMEOUT = 1000;
@SuppressWarnings({"deprecation", "removal"})
public void dispose() throws IllegalThreadStateException {
if (this.threadGroup.parentOf(Thread.currentThread().getThreadGroup())) {
throw new IllegalThreadStateException(
"Current Thread is contained within AppContext to be disposed."
);
}
synchronized(this) {
if (this.state != State.VALID) {
return;             }
this.state = State.BEING_DISPOSED;
}
final PropertyChangeSupport changeSupport = this.changeSupport;
if (changeSupport != null) {
changeSupport.firePropertyChange(DISPOSED_PROPERTY_NAME, false, true);
}
final Object notificationLock = new Object();
Runnable runnable = new Runnable() {
public void run() {
Window[] windowsToDispose = Window.getOwnerlessWindows();
for (Window w : windowsToDispose) {
try {
w.dispose();
} catch (Throwable t) {
log.finer("exception occurred while disposing app context", t);
}
}
AccessController.doPrivileged(new PrivilegedAction<Void>() {
public Void run() {
if (!GraphicsEnvironment.isHeadless() && SystemTray.isSupported())
{
SystemTray systemTray = SystemTray.getSystemTray();
TrayIcon[] trayIconsToDispose = systemTray.getTrayIcons();
for (TrayIcon ti : trayIconsToDispose) {
systemTray.remove(ti);
}
}
return null;
}
});
if (changeSupport != null) {
changeSupport.firePropertyChange(GUI_DISPOSED, false, true);
}
synchronized(notificationLock) {
notificationLock.notifyAll();                 }
}
};
synchronized(notificationLock) {
SunToolkit.postEvent(this,
new InvocationEvent(Toolkit.getDefaultToolkit(), runnable));
try {
notificationLock.wait(DISPOSAL_TIMEOUT);
} catch (InterruptedException e) { }
}
runnable = new Runnable() { public void run() {
synchronized(notificationLock) {
notificationLock.notifyAll();             }
} };
synchronized(notificationLock) {
SunToolkit.postEvent(this,
new InvocationEvent(Toolkit.getDefaultToolkit(), runnable));
try {
notificationLock.wait(DISPOSAL_TIMEOUT);
} catch (InterruptedException e) { }
}
synchronized(this) {
this.state = State.DISPOSED;
}
this.threadGroup.interrupt();
long startTime = System.currentTimeMillis();
long endTime = startTime + THREAD_INTERRUPT_TIMEOUT;
while ((this.threadGroup.activeCount() > 0) &&
(System.currentTimeMillis() < endTime)) {
try {
Thread.sleep(10);
} catch (InterruptedException e) { }
}
AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
Thread[] threads;
int len, threadCount;
do {
len = threadGroup.activeCount() + 4;
threads = new Thread[len];
threadCount = threadGroup.enumerate(threads);
} while (threadCount == len);
for (int i = 0; i < threadCount; i++) {
threads[i].stop();
}
return null;
});
startTime = System.currentTimeMillis();
endTime = startTime + THREAD_INTERRUPT_TIMEOUT;
while ((this.threadGroup.activeCount() > 0) &&
(System.currentTimeMillis() < endTime)) {
try {
Thread.sleep(10);
} catch (InterruptedException e) { }
}
int numSubGroups = this.threadGroup.activeGroupCount();
if (numSubGroups > 0) {
ThreadGroup [] subGroups = new ThreadGroup[numSubGroups];
numSubGroups = this.threadGroup.enumerate(subGroups);
for (int subGroup = 0; subGroup < numSubGroups; subGroup++) {
threadGroup2appContext.remove(subGroups[subGroup]);
}
}
threadGroup2appContext.remove(this.threadGroup);
threadAppContext.set(null);
try {
this.threadGroup.destroy();
} catch (IllegalThreadStateException e) {
}
synchronized (table) {
this.table.clear();         }
numAppContexts.decrementAndGet();
mostRecentKeyValue = null;
}
static final class PostShutdownEventRunnable implements Runnable {
private final AppContext appContext;
PostShutdownEventRunnable(AppContext ac) {
appContext = ac;
}
public void run() {
final EventQueue eq = (EventQueue)appContext.get(EVENT_QUEUE_KEY);
if (eq != null) {
eq.postEvent(AWTAutoShutdown.getShutdownEvent());
}
}
}
static final class CreateThreadAction implements PrivilegedAction<Thread> {
private final AppContext appContext;
private final Runnable runnable;
CreateThreadAction(AppContext ac, Runnable r) {
appContext = ac;
runnable = r;
}
public Thread run() {
Thread t = new Thread(appContext.getThreadGroup(),
runnable, "AppContext Disposer", 0, false);
t.setContextClassLoader(appContext.getContextClassLoader());
t.setPriority(Thread.NORM_PRIORITY + 1);
t.setDaemon(true);
return t;
}
}
static void stopEventDispatchThreads() {
for (AppContext appContext: getAppContexts()) {
if (appContext.isDisposed()) {
continue;
}
Runnable r = new PostShutdownEventRunnable(appContext);
if (appContext != AppContext.getAppContext()) {
PrivilegedAction<Thread> action = new CreateThreadAction(appContext, r);
@SuppressWarnings("removal")
Thread thread = AccessController.doPrivileged(action);
thread.start();
} else {
r.run();
}
}
}
private MostRecentKeyValue mostRecentKeyValue = null;
private MostRecentKeyValue shadowMostRecentKeyValue = null;
public Object get(Object key) {
synchronized (table) {
MostRecentKeyValue recent = mostRecentKeyValue;
if ((recent != null) && (recent.key == key)) {
return recent.value;
}
Object value = table.get(key);
if(mostRecentKeyValue == null) {
mostRecentKeyValue = new MostRecentKeyValue(key, value);
shadowMostRecentKeyValue = new MostRecentKeyValue(key, value);
} else {
MostRecentKeyValue auxKeyValue = mostRecentKeyValue;
shadowMostRecentKeyValue.setPair(key, value);
mostRecentKeyValue = shadowMostRecentKeyValue;
shadowMostRecentKeyValue = auxKeyValue;
}
return value;
}
}
public Object put(Object key, Object value) {
synchronized (table) {
MostRecentKeyValue recent = mostRecentKeyValue;
if ((recent != null) && (recent.key == key))
recent.value = value;
return table.put(key, value);
}
}
public Object remove(Object key) {
synchronized (table) {
MostRecentKeyValue recent = mostRecentKeyValue;
if ((recent != null) && (recent.key == key))
recent.value = null;
return table.remove(key);
}
}
public ThreadGroup getThreadGroup() {
return threadGroup;
}
public ClassLoader getContextClassLoader() {
return contextClassLoader;
}
@Override
public String toString() {
return getClass().getName() + "[threadGroup=" + threadGroup.getName() + "]";
}
public synchronized PropertyChangeListener[] getPropertyChangeListeners() {
if (changeSupport == null) {
return new PropertyChangeListener[0];
}
return changeSupport.getPropertyChangeListeners();
}
public synchronized void addPropertyChangeListener(
String propertyName,
PropertyChangeListener listener) {
if (listener == null) {
return;
}
if (changeSupport == null) {
changeSupport = new PropertyChangeSupport(this);
}
changeSupport.addPropertyChangeListener(propertyName, listener);
}
public synchronized void removePropertyChangeListener(
String propertyName,
PropertyChangeListener listener) {
if (listener == null || changeSupport == null) {
return;
}
changeSupport.removePropertyChangeListener(propertyName, listener);
}
public synchronized PropertyChangeListener[] getPropertyChangeListeners(
String propertyName) {
if (changeSupport == null) {
return new PropertyChangeListener[0];
}
return changeSupport.getPropertyChangeListeners(propertyName);
}
static {
SharedSecrets.setJavaAWTAccess(new JavaAWTAccess() {
@SuppressWarnings("removal")
private boolean hasRootThreadGroup(final AppContext ecx) {
return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
@Override
public Boolean run() {
return ecx.threadGroup.getParent() == null;
}
});
}
public Object getAppletContext() {
if (numAppContexts.get() == 0) return null;
AppContext ecx = null;
if (numAppContexts.get() > 0) {
ecx = ecx != null ? ecx : getAppContext();
}
final boolean isMainAppContext = ecx == null
|| mainAppContext == ecx
|| mainAppContext == null && hasRootThreadGroup(ecx);
return isMainAppContext ? null : ecx;
}
});
}
public static <T> T getSoftReferenceValue(Object key,
Supplier<T> supplier) {
final AppContext appContext = AppContext.getAppContext();
@SuppressWarnings("unchecked")
SoftReference<T> ref = (SoftReference<T>) appContext.get(key);
if (ref != null) {
final T object = ref.get();
if (object != null) {
return object;
}
}
final T object = supplier.get();
ref = new SoftReference<>(object);
appContext.put(key, ref);
return object;
}
}
final class MostRecentKeyValue {
Object key;
Object value;
MostRecentKeyValue(Object k, Object v) {
key = k;
value = v;
}
void setPair(Object k, Object v) {
key = k;
value = v;
}
}
package java2d.demos.Paths;
import static java.awt.Color.BLACK;
import static java.awt.Color.GRAY;
import static java.awt.Color.WHITE;
import java.awt.Graphics2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Path2D;
import java.awt.geom.Rectangle2D;
import java2d.Surface;
@SuppressWarnings("serial")
public class Append extends Surface {
public Append() {
setBackground(WHITE);
}
@Override
public void render(int w, int h, Graphics2D g2) {
GeneralPath p = new GeneralPath(Path2D.WIND_NON_ZERO);
p.moveTo(w * 0.25f, h * 0.2f);
p.lineTo(w * 0.75f, h * 0.2f);
p.closePath();
p.append(new Rectangle2D.Double(w * .4, h * .3, w * .2, h * .1), false);
g2.setColor(GRAY);
g2.fill(p);
g2.setColor(BLACK);
g2.draw(p);
g2.drawString("Append rect to path", (int) (w * .25), (int) (h * .2) - 5);
p.reset();
p.moveTo(w * 0.25f, h * 0.6f);
p.lineTo(w * 0.75f, h * 0.6f);
p.closePath();
p.append(new Rectangle2D.Double(w * .4, h * .7, w * .2, h * .1), true);
g2.setColor(GRAY);
g2.fill(p);
g2.setColor(BLACK);
g2.draw(p);
g2.drawString("Append, connect", (int) (w * .25), (int) (h * .6) - 5);
}
public static void main(String[] s) {
createDemoFrame(new Append());
}
}
package java.lang;
import java.io.IOException;
public interface Appendable {
Appendable append(CharSequence csq) throws IOException;
Appendable append(CharSequence csq, int start, int end) throws IOException;
Appendable append(char c) throws IOException;
}
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import jdk.test.lib.cds.CDSTestUtils;
import jdk.test.lib.process.OutputAnalyzer;
public class AppendClasspath {
public static void main(String[] args) throws Exception {
String appJar = JarBuilder.getOrCreateHelloJar();
String appJar2 = JarBuilder.build("AppendClasspath_HelloMore", "HelloMore");
TestCommon.testDump(appJar, TestCommon.list("Hello"));
TestCommon.run(
"-cp", appJar + File.pathSeparator + appJar2,
"HelloMore")
.assertNormalExit();
String outDir = CDSTestUtils.getOutputDir();
String newFile = "non-exist.jar";
String nonExistPath = outDir + File.separator + newFile;
String classPath = appJar + File.pathSeparator + nonExistPath;
File nonExistJar = new File(outDir, newFile);
if (nonExistJar.exists()) {
nonExistJar.delete();
}
TestCommon.run(
"-cp", classPath,
"-Xlog:class+path=trace",
"Hello")
.assertNormalExit();
final String errorMessage1 = "Unable to use shared archive";
final String errorMessage2 = "shared class paths mismatch";
TestCommon.run(
"-Xlog:cds",
"-cp", appJar2 + File.pathSeparator + appJar,
"HelloMore")
.assertAbnormalExit(errorMessage1, errorMessage2);
TestCommon.testDump(appJar + File.pathSeparator + appJar2,
TestCommon.list("Hello"));
TestCommon.run(
"-Xlog:cds",
"-cp", appJar2,
"Hello")
.assertAbnormalExit(errorMessage1, errorMessage2);
TestCommon.run(
"-Xlog:cds",
"-cp", appJar2 + File.pathSeparator + appJar,
"HelloMore")
.assertAbnormalExit(errorMessage1, errorMessage2);
}
}
package java.awt.desktop;
import java.awt.Desktop;
import java.awt.GraphicsEnvironment;
import java.awt.HeadlessException;
import java.io.Serial;
import java.util.EventObject;
public sealed class AppEvent extends EventObject
permits AboutEvent,
AppForegroundEvent,
AppHiddenEvent,
AppReopenedEvent,
FilesEvent,
OpenURIEvent,
PreferencesEvent,
QuitEvent,
ScreenSleepEvent,
SystemSleepEvent,
UserSessionEvent {
@Serial
private static final long serialVersionUID = -5958503993556009432L;
AppEvent() {
super(Desktop.getDesktop());
}
}
package java.awt.desktop;
import java.awt.Desktop;
import java.awt.GraphicsEnvironment;
import java.awt.HeadlessException;
import java.io.Serial;
public final class AppForegroundEvent extends AppEvent {
@Serial
private static final long serialVersionUID = -5513582555740533911L;
public AppForegroundEvent() {
}
}
package java.awt.desktop;
public interface AppForegroundListener extends SystemEventListener {
public void appRaisedToForeground(AppForegroundEvent e);
public void appMovedToBackground(AppForegroundEvent e);
}
package java.awt.desktop;
import java.awt.Desktop;
import java.awt.GraphicsEnvironment;
import java.awt.HeadlessException;
import java.io.Serial;
public final class AppHiddenEvent extends AppEvent {
@Serial
private static final long serialVersionUID = 2637465279476429224L;
public AppHiddenEvent() {
}
}
package java.awt.desktop;
public interface AppHiddenListener extends SystemEventListener {
public void appHidden(AppHiddenEvent e);
public void appUnhidden(AppHiddenEvent e);
}
package jdk.jpackage.internal;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.MessageFormat;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;
import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;
import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;
import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_DATA;
import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;
class AppImageBundler extends AbstractBundler {
@Override
public final String getName() {
return I18N.getString("app.bundler.name");
}
@Override
public final String getID() {
return "app";
}
@Override
public final String getBundleType() {
return "IMAGE";
}
@Override
public final boolean validate(Map<String, ? super Object> params)
throws ConfigException {
try {
Objects.requireNonNull(params);
if (!params.containsKey(PREDEFINED_APP_IMAGE.getID())
&& !StandardBundlerParam.isRuntimeInstaller(params)) {
LAUNCHER_DATA.fetchFrom(params);
}
if (paramsValidator != null) {
paramsValidator.validate(params);
}
} catch (RuntimeException re) {
if (re.getCause() instanceof ConfigException) {
throw (ConfigException) re.getCause();
} else {
throw new ConfigException(re);
}
}
return true;
}
@Override
public final Path execute(Map<String, ? super Object> params,
Path outputParentDir) throws PackagerException {
if (StandardBundlerParam.isRuntimeInstaller(params)) {
return PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);
}
try {
return createAppBundle(params, outputParentDir);
} catch (PackagerException pe) {
throw pe;
} catch (RuntimeException|IOException|ConfigException ex) {
Log.verbose(ex);
throw new PackagerException(ex);
}
}
@Override
public final boolean supported(boolean runtimeInstaller) {
return true;
}
@Override
public final boolean isDefault() {
return false;
}
final AppImageBundler setDependentTask(boolean v) {
dependentTask = v;
return this;
}
final boolean isDependentTask() {
return dependentTask;
}
final AppImageBundler setAppImageSupplier(
Function<Path, AbstractAppImageBuilder> v) {
appImageSupplier = v;
return this;
}
final AppImageBundler setParamsValidator(ParamsValidator v) {
paramsValidator = v;
return this;
}
@FunctionalInterface
interface ParamsValidator {
void validate(Map<String, ? super Object> params) throws ConfigException;
}
private Path createRoot(Map<String, ? super Object> params,
Path outputDirectory) throws PackagerException, IOException {
IOUtils.writableOutputDir(outputDirectory);
String imageName = APP_NAME.fetchFrom(params);
if (Platform.isMac()) {
imageName = imageName + ".app";
}
if (!dependentTask) {
Log.verbose(MessageFormat.format(
I18N.getString("message.creating-app-bundle"),
imageName, outputDirectory.toAbsolutePath()));
}
Path rootDirectory = outputDirectory.resolve(imageName);
if (Files.exists(rootDirectory)) {
throw new PackagerException("error.root-exists",
rootDirectory.toAbsolutePath().toString());
}
Files.createDirectories(rootDirectory);
return rootDirectory;
}
private Path createAppBundle(Map<String, ? super Object> params,
Path outputDirectory) throws PackagerException, IOException,
ConfigException {
boolean hasAppImage =
PREDEFINED_APP_IMAGE.fetchFrom(params) != null;
boolean hasRuntimeImage =
PREDEFINED_RUNTIME_IMAGE.fetchFrom(params) != null;
Path rootDirectory = hasAppImage ?
PREDEFINED_APP_IMAGE.fetchFrom(params) :
createRoot(params, outputDirectory);
AbstractAppImageBuilder appBuilder = appImageSupplier.apply(rootDirectory);
if (!hasAppImage) {
if (!hasRuntimeImage) {
JLinkBundlerHelper.execute(params,
appBuilder.getAppLayout().runtimeHomeDirectory());
} else {
StandardBundlerParam.copyPredefinedRuntimeImage(
params, appBuilder.getAppLayout());
}
}
appBuilder.prepareApplicationFiles(params);
return rootDirectory;
}
private boolean dependentTask;
private ParamsValidator paramsValidator;
private Function<Path, AbstractAppImageBuilder> appImageSupplier;
}
package jdk.jpackage.internal;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.NoSuchFileException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.NamedNodeMap;
import org.xml.sax.SAXException;
import static jdk.jpackage.internal.StandardBundlerParam.VERSION;
import static jdk.jpackage.internal.StandardBundlerParam.ADD_LAUNCHERS;
import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;
import static jdk.jpackage.internal.StandardBundlerParam.MAIN_CLASS;
import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_AS_SERVICE;
import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;
import static jdk.jpackage.internal.StandardBundlerParam.MENU_HINT;
import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;
import static jdk.jpackage.internal.StandardBundlerParam.APP_STORE;
public final class AppImageFile {
private final String creatorVersion;
private final String creatorPlatform;
private final String launcherName;
private final String mainClass;
private final List<LauncherInfo> addLauncherInfos;
private final boolean signed;
private final boolean appStore;
private static final String FILENAME = ".jpackage.xml";
private static final Map<Platform, String> PLATFORM_LABELS = Map.of(
Platform.LINUX, "linux", Platform.WINDOWS, "windows", Platform.MAC,
"macOS");
private AppImageFile(Path appImageDir, String launcherName, String mainClass,
List<LauncherInfo> launcherInfos, String creatorVersion,
String creatorPlatform, String signedStr, String appStoreStr) {
boolean isValid = true;
if (!Objects.equals(getVersion(), creatorVersion)) {
isValid = false;
}
if (!Objects.equals(getPlatform(), creatorPlatform)) {
isValid = false;
}
if (launcherName == null || launcherName.length() == 0) {
isValid = false;
}
if (mainClass == null || mainClass.length() == 0) {
isValid = false;
}
for (var launcher : launcherInfos) {
if ("".equals(launcher.getName())) {
isValid = false;
}
}
if (signedStr == null ||
!("true".equals(signedStr) || "false".equals(signedStr))) {
isValid = false;
}
if (appStoreStr == null ||
!("true".equals(appStoreStr) || "false".equals(appStoreStr))) {
isValid = false;
}
if (!isValid) {
throw new RuntimeException(MessageFormat.format(I18N.getString(
"error.invalid-app-image"), appImageDir));
}
this.launcherName = launcherName;
this.mainClass = mainClass;
this.addLauncherInfos = launcherInfos;
this.creatorVersion = creatorVersion;
this.creatorPlatform = creatorPlatform;
this.signed = "true".equals(signedStr);
this.appStore = "true".equals(appStoreStr);
}
List<LauncherInfo> getAddLaunchers() {
return addLauncherInfos;
}
String getLauncherName() {
return launcherName;
}
String getMainClass() {
return mainClass;
}
public boolean isSigned() {
return signed;
}
boolean isAppStore() {
return appStore;
}
public static Path getPathInAppImage(Path appImageDir) {
return ApplicationLayout.platformAppImage()
.resolveAt(appImageDir)
.appDirectory()
.resolve(FILENAME);
}
static void save(Path appImageDir, Map<String, Object> params)
throws IOException {
IOUtils.createXml(getPathInAppImage(appImageDir), xml -> {
xml.writeStartElement("jpackage-state");
xml.writeAttribute("version", getVersion());
xml.writeAttribute("platform", getPlatform());
xml.writeStartElement("app-version");
xml.writeCharacters(VERSION.fetchFrom(params));
xml.writeEndElement();
xml.writeStartElement("main-launcher");
xml.writeCharacters(APP_NAME.fetchFrom(params));
xml.writeEndElement();
xml.writeStartElement("main-class");
xml.writeCharacters(MAIN_CLASS.fetchFrom(params));
xml.writeEndElement();
xml.writeStartElement("signed");
xml.writeCharacters(SIGN_BUNDLE.fetchFrom(params).toString());
xml.writeEndElement();
xml.writeStartElement("app-store");
xml.writeCharacters(APP_STORE.fetchFrom(params).toString());
xml.writeEndElement();
List<Map<String, ? super Object>> addLaunchers =
ADD_LAUNCHERS.fetchFrom(params);
for (var launcherParams : addLaunchers) {
var li = new LauncherInfo(launcherParams);
xml.writeStartElement("add-launcher");
xml.writeAttribute("name", li.getName());
xml.writeAttribute("shortcut", Boolean.toString(li.isShortcut()));
xml.writeAttribute("menu", Boolean.toString(li.isMenu()));
xml.writeAttribute("service", Boolean.toString(li.isService()));
xml.writeEndElement();
}
});
}
public static AppImageFile load(Path appImageDir) {
try {
Document doc = readXml(appImageDir);
XPath xPath = XPathFactory.newInstance().newXPath();
String mainLauncher = xpathQueryNullable(xPath,
"/jpackage-state/main-launcher/text()", doc);
String mainClass = xpathQueryNullable(xPath,
"/jpackage-state/main-class/text()", doc);
List<LauncherInfo> launcherInfos = new ArrayList<>();
String platform = xpathQueryNullable(xPath,
"/jpackage-state/@platform", doc);
String version = xpathQueryNullable(xPath,
"/jpackage-state/@version", doc);
String signedStr = xpathQueryNullable(xPath,
"/jpackage-state/signed/text()", doc);
String appStoreStr = xpathQueryNullable(xPath,
"/jpackage-state/app-store/text()", doc);
NodeList launcherNodes = (NodeList) xPath.evaluate(
"/jpackage-state/add-launcher", doc,
XPathConstants.NODESET);
for (int i = 0; i != launcherNodes.getLength(); i++) {
launcherInfos.add(new LauncherInfo(launcherNodes.item(i)));
}
return new AppImageFile(appImageDir, mainLauncher, mainClass,
launcherInfos, version, platform, signedStr, appStoreStr);
} catch (XPathExpressionException ex) {
throw new RuntimeException(ex);
} catch (NoSuchFileException nsfe) {
throw new RuntimeException(MessageFormat.format(I18N.getString(
"error.foreign-app-image"), appImageDir));
} catch (IOException ioe) {
throw new RuntimeException(ioe);
}
}
private static String getAttribute(Node item, String attr) {
NamedNodeMap attrs = item.getAttributes();
Node attrNode = attrs.getNamedItem(attr);
return ((attrNode == null) ? null : attrNode.getNodeValue());
}
public static Document readXml(Path appImageDir) throws IOException {
try {
Path path = getPathInAppImage(appImageDir);
DocumentBuilderFactory dbf =
DocumentBuilderFactory.newDefaultInstance();
